var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};

// shared/schema.ts
var schema_exports = {};
__export(schema_exports, {
  archivedMatches: () => archivedMatches,
  archivedMessages: () => archivedMessages,
  archivedUsers: () => archivedUsers,
  blockedPhoneNumbers: () => blockedPhoneNumbers,
  compatibilityAnalysis: () => compatibilityAnalysis,
  connectionsPreferences: () => connectionsPreferences,
  conversationThreads: () => conversationThreads,
  globalDealBreakers: () => globalDealBreakers,
  globalInterests: () => globalInterests,
  globalReligions: () => globalReligions,
  globalTribes: () => globalTribes,
  insertArchivedMatchSchema: () => insertArchivedMatchSchema,
  insertArchivedMessageSchema: () => insertArchivedMessageSchema,
  insertArchivedUserSchema: () => insertArchivedUserSchema,
  insertBlockedPhoneNumberSchema: () => insertBlockedPhoneNumberSchema,
  insertCompatibilityAnalysisSchema: () => insertCompatibilityAnalysisSchema,
  insertConnectionsPreferencesSchema: () => insertConnectionsPreferencesSchema,
  insertGlobalDealBreakerSchema: () => insertGlobalDealBreakerSchema,
  insertGlobalInterestSchema: () => insertGlobalInterestSchema,
  insertGlobalReligionSchema: () => insertGlobalReligionSchema,
  insertGlobalTribeSchema: () => insertGlobalTribeSchema,
  insertMatchSchema: () => insertMatchSchema,
  insertMessageReactionSchema: () => insertMessageReactionSchema,
  insertMessageSchema: () => insertMessageSchema,
  insertPaymentHistorySchema: () => insertPaymentHistorySchema,
  insertPaymentMethodSchema: () => insertPaymentMethodSchema,
  insertProfessionalReviewSchema: () => insertProfessionalReviewSchema,
  insertPromotionalCodeSchema: () => insertPromotionalCodeSchema,
  insertPromotionalCodeUsageSchema: () => insertPromotionalCodeUsageSchema,
  insertRegionalPricingSchema: () => insertRegionalPricingSchema,
  insertSubscriptionEventSchema: () => insertSubscriptionEventSchema,
  insertSubscriptionSchema: () => insertSubscriptionSchema,
  insertSuiteCompatibilityScoreSchema: () => insertSuiteCompatibilityScoreSchema,
  insertSuiteFieldVisibilitySchema: () => insertSuiteFieldVisibilitySchema,
  insertSuiteJobApplicationSchema: () => insertSuiteJobApplicationSchema,
  insertSuiteJobProfileSchema: () => insertSuiteJobProfileSchema,
  insertSuiteMentorshipCompatibilityScoreSchema: () => insertSuiteMentorshipCompatibilityScoreSchema,
  insertSuiteMentorshipConnectionSchema: () => insertSuiteMentorshipConnectionSchema,
  insertSuiteMentorshipProfileSchema: () => insertSuiteMentorshipProfileSchema,
  insertSuiteNetworkingConnectionSchema: () => insertSuiteNetworkingConnectionSchema,
  insertSuiteNetworkingProfileSchema: () => insertSuiteNetworkingProfileSchema,
  insertSuiteProfileSettingsSchema: () => insertSuiteProfileSettingsSchema,
  insertSwipeHistorySchema: () => insertSwipeHistorySchema,
  insertTypingStatusSchema: () => insertTypingStatusSchema,
  insertUserBlockSchema: () => insertUserBlockSchema,
  insertUserInterestSchema: () => insertUserInterestSchema,
  insertUserMatchSettingsSchema: () => insertUserMatchSettingsSchema,
  insertUserPhotoSchema: () => insertUserPhotoSchema,
  insertUserReportStrikeSchema: () => insertUserReportStrikeSchema,
  insertUserSchema: () => insertUserSchema,
  insertVerificationCodeSchema: () => insertVerificationCodeSchema,
  insertVideoCallSchema: () => insertVideoCallSchema,
  matches: () => matches,
  messageEngagementMetrics: () => messageEngagementMetrics,
  messageReactions: () => messageReactions,
  messages: () => messages,
  passwordResetCodes: () => passwordResetCodes,
  paymentHistory: () => paymentHistory,
  paymentMethods: () => paymentMethods,
  professionalReviews: () => professionalReviews,
  profileViews: () => profileViews,
  promotionalCodeUsage: () => promotionalCodeUsage,
  promotionalCodes: () => promotionalCodes,
  regionalPricing: () => regionalPricing,
  subscriptionEvents: () => subscriptionEvents2,
  subscriptions: () => subscriptions,
  suiteCompatibilityScores: () => suiteCompatibilityScores,
  suiteFieldVisibility: () => suiteFieldVisibility,
  suiteJobApplications: () => suiteJobApplications,
  suiteJobProfiles: () => suiteJobProfiles,
  suiteMentorshipCompatibilityScores: () => suiteMentorshipCompatibilityScores,
  suiteMentorshipConnections: () => suiteMentorshipConnections,
  suiteMentorshipProfiles: () => suiteMentorshipProfiles,
  suiteNetworkingConnections: () => suiteNetworkingConnections,
  suiteNetworkingProfiles: () => suiteNetworkingProfiles,
  suiteProfileSettings: () => suiteProfileSettings,
  swipeHistory: () => swipeHistory,
  typingStatus: () => typingStatus,
  updateUserPhotoPrimarySchema: () => updateUserPhotoPrimarySchema,
  userBlocks: () => userBlocks,
  userInterests: () => userInterests,
  userMatchSettings: () => userMatchSettings,
  userPhotos: () => userPhotos,
  userPreferences: () => userPreferences,
  userPreferencesSchema: () => userPreferencesSchema,
  userProfileSchema: () => userProfileSchema,
  userReportStrikes: () => userReportStrikes,
  users: () => users,
  verificationCodes: () => verificationCodes,
  videoCalls: () => videoCalls
});
import {
  pgTable,
  text,
  serial,
  integer,
  boolean,
  timestamp,
  unique
} from "drizzle-orm/pg-core";
import { createInsertSchema } from "drizzle-zod";
import { z } from "zod";
var blockedPhoneNumbers, userReportStrikes, userBlocks, passwordResetCodes, users, userPreferences, matches, messages, userInterests, globalInterests, globalDealBreakers, globalTribes, globalReligions, profileViews, messageEngagementMetrics, conversationThreads, typingStatus, videoCalls, compatibilityAnalysis, suiteCompatibilityScores, verificationCodes, userPhotos, messageReactions, userMatchSettings, suiteJobProfiles, suiteMentorshipProfiles, suiteNetworkingProfiles, suiteProfileSettings, suiteFieldVisibility, connectionsPreferences, insertUserSchema, userProfileSchema, insertBlockedPhoneNumberSchema, insertUserReportStrikeSchema, userPreferencesSchema, insertMatchSchema, insertMessageSchema, insertUserInterestSchema, insertGlobalInterestSchema, insertGlobalDealBreakerSchema, insertGlobalTribeSchema, insertGlobalReligionSchema, insertTypingStatusSchema, insertVideoCallSchema, insertVerificationCodeSchema, insertUserPhotoSchema, updateUserPhotoPrimarySchema, insertMessageReactionSchema, insertUserMatchSettingsSchema, insertCompatibilityAnalysisSchema, insertSuiteCompatibilityScoreSchema, insertUserBlockSchema, insertArchivedMatchSchema, insertArchivedMessageSchema, insertArchivedUserSchema, insertSuiteJobProfileSchema, insertSuiteMentorshipProfileSchema, insertSuiteNetworkingProfileSchema, insertSuiteProfileSettingsSchema, insertSuiteFieldVisibilitySchema, swipeHistory, insertSwipeHistorySchema, archivedMatches, archivedMessages, archivedUsers, suiteNetworkingConnections, suiteMentorshipConnections, suiteJobApplications, professionalReviews, insertSuiteNetworkingConnectionSchema, insertSuiteMentorshipConnectionSchema, insertSuiteJobApplicationSchema, insertProfessionalReviewSchema, subscriptions, paymentMethods, paymentHistory, subscriptionEvents2, regionalPricing, promotionalCodes, promotionalCodeUsage, insertSubscriptionSchema, insertPaymentMethodSchema, insertPaymentHistorySchema, insertSubscriptionEventSchema, insertRegionalPricingSchema, insertPromotionalCodeSchema, insertPromotionalCodeUsageSchema, suiteMentorshipCompatibilityScores, insertSuiteMentorshipCompatibilityScoreSchema, insertConnectionsPreferencesSchema;
var init_schema = __esm({
  "shared/schema.ts"() {
    "use strict";
    blockedPhoneNumbers = pgTable("blocked_phone_numbers", {
      id: serial("id").primaryKey(),
      phoneNumber: text("phone_number").notNull().unique(),
      fullName: text("full_name"),
      // User's full name when blocked
      email: text("email"),
      // User's email when blocked
      reason: text("reason").notNull(),
      // e.g., "under_14_age_restriction", "user_reports"
      blockedAt: timestamp("blocked_at").defaultNow(),
      metadata: text("metadata")
      // Additional info as JSON string
    });
    userReportStrikes = pgTable("user_report_strikes", {
      id: serial("id").primaryKey(),
      reportedUserId: integer("reported_user_id").notNull(),
      // User being reported
      reporterUserId: integer("reporter_user_id").notNull(),
      // User making the report
      reason: text("reason").notNull(),
      // Reason for report
      description: text("description"),
      // Additional details
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow(),
      matchId: integer("match_id")
      // Associated match that was unmatched
    });
    userBlocks = pgTable("user_blocks", {
      id: serial("id").primaryKey(),
      blockerUserId: integer("blocker_user_id").notNull().references(() => users.id),
      // User who is blocking
      blockedUserId: integer("blocked_user_id").notNull().references(() => users.id),
      // User being blocked
      reason: text("reason"),
      // Optional reason for blocking
      createdAt: timestamp("created_at").defaultNow()
      // Prevent duplicate blocks and self-blocking
    }, (table) => ({
      uniqueBlock: unique().on(table.blockerUserId, table.blockedUserId)
    }));
    passwordResetCodes = pgTable("password_reset_codes", {
      id: serial("id").primaryKey(),
      email: text("email").notNull(),
      resetCode: text("reset_code").notNull(),
      // 7-digit code
      isUsed: boolean("is_used").default(false),
      createdAt: timestamp("created_at").defaultNow(),
      expiresAt: timestamp("expires_at").notNull()
      // 10 minutes expiry
    });
    users = pgTable("users", {
      id: serial("id").primaryKey(),
      username: text("username").notNull().unique(),
      password: text("password").notNull(),
      fullName: text("full_name").notNull(),
      email: text("email").notNull().unique(),
      phoneNumber: text("phone_number").unique(),
      gender: text("gender").notNull(),
      location: text("location").notNull(),
      // 'Ghana' or 'Diaspora'
      countryOfOrigin: text("country_of_origin"),
      // User's primary country of origin
      secondaryCountryOfOrigin: text("secondary_country_of_origin"),
      // User's secondary country of origin (dual citizenship)
      bio: text("bio"),
      profession: text("profession"),
      ethnicity: text("ethnicity"),
      // Primary tribe
      secondaryTribe: text("secondary_tribe"),
      // Secondary tribe
      religion: text("religion"),
      photoUrl: text("photo_url"),
      showProfilePhoto: boolean("show_profile_photo").default(true),
      // Toggle to show/hide profile picture
      dateOfBirth: timestamp("date_of_birth"),
      relationshipStatus: text("relationship_status"),
      // User's current relationship status
      relationshipGoal: text("relationship_goal"),
      // What they're looking for
      highSchool: text("high_school"),
      // User's high school name
      collegeUniversity: text("college_university"),
      // User's college/university name
      interests: text("interests"),
      // Stored as JSON string of user's interests
      visibilityPreferences: text("visibility_preferences"),
      // Stored as JSON string of field visibility preferences
      // New fields for matching algorithm
      bodyType: text("body_type"),
      // User's actual body type
      height: integer("height"),
      // User's height in centimeters
      smoking: text("smoking"),
      // User's smoking habits: "yes", "no", "occasionally"
      drinking: text("drinking"),
      // User's drinking habits: "yes", "no", "occasionally", "socially"
      hasChildren: text("has_children"),
      // "yes", "no", or null
      wantsChildren: text("wants_children"),
      // "yes", "no", or null
      educationLevel: text("education_level"),
      // User's actual education level
      matchingPriorities: text("matching_priorities"),
      // JSON array of user's matching priorities
      verifiedByPhone: boolean("verified_by_phone").default(false),
      twoFactorEnabled: boolean("two_factor_enabled").default(true),
      // Default to true for security
      profileHidden: boolean("profile_hidden").default(true),
      // Hide profile from discovery (default true for new users)
      hasActivatedProfile: boolean("has_activated_profile").default(false),
      // Tracks if user has ever activated their profile
      ghostMode: boolean("ghost_mode").default(false),
      // Hide online status and typing indicators
      hideAge: boolean("hide_age").default(false),
      // Hide age from swipecard display
      isOnline: boolean("is_online").default(false),
      lastActive: timestamp("last_active"),
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow(),
      showAppModeSelection: boolean("show_app_mode_selection").default(true),
      // Show app selection screen after login
      showNationalitySelection: boolean("show_nationality_selection").default(true),
      // Show nationality selection screen
      lastUsedApp: text("last_used_app"),
      premiumAccess: boolean("premium_access").default(false),
      // Premium subscription status
      stripeCustomerId: text("stripe_customer_id").unique(),
      // Stripe customer ID for payment processing
      stripeSubscriptionId: text("stripe_subscription_id").unique(),
      // Active Stripe subscription ID
      subscriptionStatus: text("subscription_status"),
      // 'active', 'canceled', 'past_due', 'unpaid'
      subscriptionExpiresAt: timestamp("subscription_expires_at"),
      // When current subscription period ends
      subscriptionCanceledAt: timestamp("subscription_canceled_at"),
      // When user requested cancellation
      idVerificationPhoto: text("id_verification_photo"),
      // Government ID photo for verification
      liveVerificationPhoto: text("live_verification_photo"),
      // Live selfie photo for verification
      isVerified: boolean("is_verified").default(false),
      // Manual verification status - shows verification badge
      isSuspended: boolean("is_suspended").default(false),
      // Account suspension status
      suspendedAt: timestamp("suspended_at"),
      // When account was suspended
      suspensionExpiresAt: timestamp("suspension_expires_at")
      // When suspension expires
    });
    userPreferences = pgTable("user_preferences", {
      id: serial("id").primaryKey(),
      userId: integer("user_id").notNull().references(() => users.id),
      minAge: integer("min_age"),
      maxAge: integer("max_age"),
      locationPreference: text("location_preference"),
      // 'Ghana', 'Diaspora', or 'Both'
      poolCountry: text("pool_country"),
      // Legacy single pool country field (for migration compatibility)
      meetPoolCountry: text("meet_pool_country"),
      // MEET app specific: "WHERE SHOULD LOVE COME FROM?"
      suitePoolCountry: text("suite_pool_country"),
      // SUITE app specific: "WHERE SHOULD CONNECTION COME FROM?"
      ethnicityPreference: text("ethnicity_preference"),
      // Can be JSON array of preferred tribes
      religionPreference: text("religion_preference"),
      // Can be JSON array of preferred religions
      relationshipGoalPreference: text("relationship_goal_preference"),
      distancePreference: integer("distance_preference"),
      // Maximum distance in kilometers
      educationLevelPreference: text("education_level_preference"),
      // Can be JSON array of education levels
      hasChildrenPreference: text("has_children_preference"),
      // 'yes', 'no', 'any'
      wantsChildrenPreference: text("wants_children_preference"),
      // 'yes', 'no', 'any'
      minHeightPreference: integer("min_height_preference"),
      // in cm
      maxHeightPreference: integer("max_height_preference"),
      // in cm
      bodyTypePreference: text("body_type_preference"),
      // Can be JSON array of body types
      dealBreakers: text("deal_breakers"),
      // Can be JSON array of deal breakers
      interestPreferences: text("interest_preferences"),
      // Can be JSON array of preferred interests
      matchingPriorities: text("matching_priorities"),
      // JSON array of matching priorities in order of importance
      smokingPreference: text("smoking_preference"),
      // 'no', 'occasionally', 'yes', 'any'
      drinkingPreference: text("drinking_preference"),
      // 'no', 'socially', 'occasionally', 'yes', 'any'
      updatedAt: timestamp("updated_at").defaultNow()
    });
    matches = pgTable("matches", {
      id: serial("id").primaryKey(),
      userId1: integer("user_id_1").notNull().references(() => users.id),
      userId2: integer("user_id_2").notNull().references(() => users.id),
      matched: boolean("matched").notNull().default(false),
      isDislike: boolean("is_dislike").notNull().default(false),
      // True if this is a dislike (userId1 dislikes userId2)
      hasUnreadMessages1: boolean("has_unread_messages_1").notNull().default(false),
      // User 1 has unread messages
      hasUnreadMessages2: boolean("has_unread_messages_2").notNull().default(false),
      // User 2 has unread messages
      notifiedUser1: boolean("notified_user_1").notNull().default(false),
      // User 1 has been notified of match
      notifiedUser2: boolean("notified_user_2").notNull().default(false),
      // User 2 has been notified of match
      lastMessageAt: timestamp("last_message_at"),
      metadata: text("metadata"),
      // JSON string for additional match data like suiteType
      createdAt: timestamp("created_at").defaultNow()
    });
    messages = pgTable("messages", {
      id: serial("id").primaryKey(),
      matchId: integer("match_id").notNull().references(() => matches.id),
      senderId: integer("sender_id").notNull().references(() => users.id),
      receiverId: integer("receiver_id").notNull().references(() => users.id),
      content: text("content").notNull(),
      encryptedContent: text("encrypted_content"),
      iv: text("initialization_vector"),
      messageType: text("message_type").default("text"),
      // "text", "audio", "image", etc.
      audioUrl: text("audio_url"),
      audioDuration: integer("audio_duration"),
      // Duration in seconds
      read: boolean("read").notNull().default(false),
      readAt: timestamp("read_at"),
      createdAt: timestamp("created_at").defaultNow(),
      // Reply functionality
      replyToMessageId: integer("reply_to_message_id"),
      replyToContent: text("reply_to_content"),
      replyToSenderName: text("reply_to_sender_name"),
      replyToIsCurrentUser: boolean("reply_to_is_current_user"),
      // Auto-delete functionality
      autoDeleteScheduledAt: timestamp("auto_delete_scheduled_at"),
      autoDeleteModeWhenSent: text("auto_delete_mode_when_sent").default("never"),
      deletedForUserId: integer("deleted_for_user_id").references(() => users.id)
    });
    userInterests = pgTable("user_interests", {
      id: serial("id").primaryKey(),
      userId: integer("user_id").notNull().references(() => users.id),
      interest: text("interest").notNull(),
      showOnProfile: boolean("show_on_profile").default(true)
    });
    globalInterests = pgTable("global_interests", {
      id: serial("id").primaryKey(),
      interest: text("interest").notNull().unique(),
      category: text("category"),
      createdAt: timestamp("created_at").defaultNow(),
      createdBy: integer("created_by").references(() => users.id)
    });
    globalDealBreakers = pgTable("global_deal_breakers", {
      id: serial("id").primaryKey(),
      dealBreaker: text("deal_breaker").notNull().unique(),
      createdBy: integer("created_by").references(() => users.id),
      createdAt: timestamp("created_at").defaultNow()
    });
    globalTribes = pgTable("global_tribes", {
      id: serial("id").primaryKey(),
      tribe: text("tribe").notNull().unique(),
      category: text("category"),
      // For grouping tribes by ethnicity (e.g., "Akan", "Ga-Adangbe", etc.)
      createdBy: integer("created_by").references(() => users.id),
      createdAt: timestamp("created_at").defaultNow()
    });
    globalReligions = pgTable("global_religions", {
      id: serial("id").primaryKey(),
      religion: text("religion").notNull().unique(),
      category: text("category"),
      // For grouping religions (e.g., "Christianity", "Islam", etc.)
      createdBy: integer("created_by").references(() => users.id),
      createdAt: timestamp("created_at").defaultNow()
    });
    profileViews = pgTable("profile_views", {
      id: serial("id").primaryKey(),
      viewerId: integer("viewer_id").notNull().references(() => users.id),
      viewedId: integer("viewed_id").notNull().references(() => users.id),
      viewCount: integer("view_count").notNull().default(1),
      firstViewedAt: timestamp("first_viewed_at").defaultNow(),
      lastViewedAt: timestamp("last_viewed_at").defaultNow(),
      totalViewDuration: integer("total_view_duration").default(0),
      // Total seconds spent viewing
      appMode: text("app_mode").notNull().default("MEET"),
      // "MEET", "HEAT", "SUITE_NETWORKING", etc.
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow()
    });
    messageEngagementMetrics = pgTable("message_engagement_metrics", {
      id: serial("id").primaryKey(),
      messageId: integer("message_id").notNull().references(() => messages.id),
      senderId: integer("sender_id").notNull().references(() => users.id),
      receiverId: integer("receiver_id").notNull().references(() => users.id),
      messageLength: integer("message_length").notNull(),
      hasQuestion: boolean("has_question").notNull().default(false),
      hasExclamation: boolean("has_exclamation").notNull().default(false),
      wordCount: integer("word_count").notNull(),
      sentimentScore: integer("sentiment_score").default(0),
      // -100 to 100 sentiment analysis (scaled)
      readTime: integer("read_time"),
      // Seconds to read message
      responseTime: integer("response_time"),
      // Seconds until response
      engagementScore: integer("engagement_score").default(50),
      // 0-100 calculated engagement score
      createdAt: timestamp("created_at").defaultNow()
    });
    conversationThreads = pgTable("conversation_threads", {
      id: serial("id").primaryKey(),
      participantOneId: integer("participant_one_id").notNull().references(() => users.id),
      participantTwoId: integer("participant_two_id").notNull().references(() => users.id),
      threadId: text("thread_id").notNull().unique(),
      // Format: "userId1-userId2" (lower ID first)
      totalMessages: integer("total_messages").notNull().default(0),
      messagesFromOne: integer("messages_from_one").notNull().default(0),
      messagesFromTwo: integer("messages_from_two").notNull().default(0),
      averageResponseTime: integer("average_response_time").default(0),
      // Minutes (scaled from hours)
      conversationDepth: integer("conversation_depth").default(0),
      // Number of back-and-forth exchanges
      lastActivityAt: timestamp("last_activity_at").defaultNow(),
      isActive: boolean("is_active").notNull().default(true),
      appMode: text("app_mode").notNull().default("MEET"),
      // "MEET", "HEAT", "SUITE"
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow()
    });
    typingStatus = pgTable("typing_status", {
      id: serial("id").primaryKey(),
      userId: integer("user_id").notNull().references(() => users.id),
      matchId: integer("match_id").notNull().references(() => matches.id),
      isTyping: boolean("is_typing").notNull().default(false),
      updatedAt: timestamp("updated_at").defaultNow()
    });
    videoCalls = pgTable("video_calls", {
      id: serial("id").primaryKey(),
      matchId: integer("match_id").notNull().references(() => matches.id),
      initiatorId: integer("initiator_id").notNull().references(() => users.id),
      receiverId: integer("receiver_id").notNull().references(() => users.id),
      roomName: text("room_name").notNull().unique(),
      status: text("status").notNull().default("pending"),
      // pending, active, completed, declined
      startedAt: timestamp("started_at"),
      endedAt: timestamp("ended_at"),
      createdAt: timestamp("created_at").defaultNow()
    });
    compatibilityAnalysis = pgTable("compatibility_analysis", {
      id: serial("id").primaryKey(),
      user1Id: integer("user1_id").notNull().references(() => users.id),
      user2Id: integer("user2_id").notNull().references(() => users.id),
      compatibilityData: text("compatibility_data").notNull(),
      // JSON string containing all compatibility analysis
      overallScore: integer("overall_score").notNull(),
      // Overall compatibility percentage (0-100)
      version: text("version").notNull().default("1.0"),
      // Version for future compatibility data format changes
      computedAt: timestamp("computed_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow(),
      isActive: boolean("is_active").notNull().default(true)
      // For soft deletion when user dislikes
    });
    suiteCompatibilityScores = pgTable("suite_compatibility_scores", {
      id: serial("id").primaryKey(),
      userId: integer("user_id").notNull().references(() => users.id),
      // User viewing the profile
      targetUserId: integer("target_user_id").notNull().references(() => users.id),
      // Profile being viewed
      targetProfileId: integer("target_profile_id").notNull().references(() => suiteNetworkingProfiles.id),
      // Specific networking profile
      // Multi-dimensional scoring system
      synergyScore: integer("synergy_score").notNull(),
      // Industry/goals alignment (1-10)
      networkValueScore: integer("network_value_score").notNull(),
      // Professional influence potential (1-10)
      collaborationScore: integer("collaboration_score").notNull(),
      // Project partnership likelihood (1-10)
      exchangeScore: integer("exchange_score").notNull(),
      // Mutual benefit potential (1-10)
      overallStarRating: integer("overall_star_rating").notNull(),
      // Final star rating (1-10)
      // Detailed analysis data
      analysisData: text("analysis_data").notNull(),
      // JSON with breakdown details
      insights: text("insights").notNull(),
      // JSON array of key insights
      suggestedActions: text("suggested_actions").notNull(),
      // JSON array of conversation starters
      // Geographic and cultural intelligence
      geographicFit: integer("geographic_fit").notNull(),
      // Location/timezone compatibility (1-10)
      culturalAlignment: integer("cultural_alignment").notNull(),
      // Cross-cultural networking potential (1-10)
      // Metadata
      computedAt: timestamp("computed_at").defaultNow(),
      lastUpdated: timestamp("last_updated").defaultNow(),
      isActive: boolean("is_active").notNull().default(true)
    }, (table) => {
      return {
        // Ensure one score per user-profile combination
        uniqueUserProfile: unique().on(table.userId, table.targetProfileId)
      };
    });
    verificationCodes = pgTable("verification_codes", {
      id: serial("id").primaryKey(),
      phoneNumber: text("phone_number").notNull(),
      code: text("code").notNull(),
      expiresAt: timestamp("expires_at").notNull(),
      createdAt: timestamp("created_at").defaultNow()
    });
    userPhotos = pgTable("user_photos", {
      id: serial("id").primaryKey(),
      userId: integer("user_id").notNull().references(() => users.id),
      photoUrl: text("photo_url").notNull(),
      isPrimary: boolean("is_primary").default(false),
      // Legacy primary photo (for backwards compatibility)
      // Section-specific primary photo flags
      isPrimaryForMeet: boolean("is_primary_for_meet").default(false),
      isPrimaryForJob: boolean("is_primary_for_job").default(false),
      isPrimaryForMentorship: boolean("is_primary_for_mentorship").default(false),
      isPrimaryForNetworking: boolean("is_primary_for_networking").default(false),
      createdAt: timestamp("created_at").defaultNow()
    });
    messageReactions = pgTable("message_reactions", {
      id: serial("id").primaryKey(),
      messageId: integer("message_id").notNull().references(() => messages.id),
      userId: integer("user_id").notNull().references(() => users.id),
      emoji: text("emoji").notNull(),
      createdAt: timestamp("created_at").defaultNow()
    });
    userMatchSettings = pgTable(
      "user_match_settings",
      {
        id: serial("id").primaryKey(),
        userId: integer("user_id").notNull().references(() => users.id),
        matchId: integer("match_id").notNull().references(() => matches.id),
        autoDeleteMode: text("auto_delete_mode").default("never"),
        // 'never', 'always', 'custom'
        autoDeleteValue: integer("auto_delete_value").default(5),
        autoDeleteUnit: text("auto_delete_unit").default("minutes"),
        // 'minutes', 'hours', 'days'
        createdAt: timestamp("created_at").defaultNow()
      },
      (table) => ({
        userMatchUnique: unique().on(table.userId, table.matchId)
      })
    );
    suiteJobProfiles = pgTable("suite_job_profiles", {
      id: serial("id").primaryKey(),
      userId: integer("user_id").notNull().references(() => users.id),
      // User role
      role: text("role"),
      // 'job-seeker', 'recruiter'
      // Basic job information
      jobTitle: text("job_title").notNull(),
      company: text("company"),
      description: text("description").notNull(),
      compensation: text("compensation"),
      compensationCurrency: text("compensation_currency"),
      compensationPeriod: text("compensation_period"),
      salary: text("salary"),
      salaryCurrency: text("salary_currency"),
      salaryPeriod: text("salary_period"),
      requirements: text("requirements"),
      // JSON array of requirements
      location: text("location"),
      workType: text("work_type").notNull(),
      // 'Remote', 'In-person', 'Hybrid'
      jobType: text("job_type").notNull(),
      // 'Full-time', 'Part-time', 'Contract', 'Internship'
      experienceLevel: text("experience_level"),
      // 'Entry', 'Mid', 'Senior', 'Executive'
      // Emotional and cultural context
      whyItMatters: text("why_it_matters"),
      whoShouldApply: text("who_should_apply"),
      culturalFit: text("cultural_fit"),
      areasOfExpertise: text("areas_of_expertise"),
      industryTags: text("industry_tags"),
      // JSON array of industry tags
      skillTags: text("skill_tags"),
      // JSON array of required skills
      // Application settings
      applicationUrl: text("application_url"),
      applicationEmail: text("application_email"),
      applicationInstructions: text("application_instructions"),
      isActive: boolean("is_active").default(true),
      expiresAt: timestamp("expires_at"),
      // Field visibility preferences (JSON string)
      visibilityPreferences: text("visibility_preferences"),
      // Metadata
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow()
    });
    suiteMentorshipProfiles = pgTable("suite_mentorship_profiles", {
      id: serial("id").primaryKey(),
      userId: integer("user_id").notNull().references(() => users.id),
      // Role and basic info
      role: text("role").notNull(),
      // 'mentor' or 'mentee'
      areasOfExpertise: text("areas_of_expertise").array(),
      // Array for mentors
      learningGoals: text("learning_goals").array(),
      // Array for mentees
      languagesSpoken: text("languages_spoken").array(),
      // Array of languages
      industriesOrDomains: text("industries_or_domains").array(),
      // Array of industries
      // Mentorship details
      mentorshipStyle: text("mentorship_style"),
      preferredFormat: text("preferred_format"),
      // JSON array: ['1-on-1', 'Group', 'Workshop', 'Peer']
      communicationStyle: text("communication_style"),
      // JSON array: ['Chat', 'Video', 'In-person', 'Async']
      // Availability
      availability: text("availability"),
      // JSON object with schedule
      timeCommitment: text("time_commitment"),
      // 'Light (1-2 hrs/month)', 'Regular (3-5 hrs/month)', 'Intensive (5+ hrs/month)'
      location: text("location"),
      // User's location, defaults from registration
      // Goals and experience
      successStories: text("success_stories"),
      whyMentor: text("why_mentor"),
      // For mentors: why they want to mentor
      whySeekMentorship: text("why_seek_mentorship"),
      // For mentees: what they hope to gain
      // Mentee-specific fields
      preferredMentorshipStyle: text("preferred_mentorship_style"),
      // For mentees: preferred mentorship style
      industryAspiration: text("industry_aspiration"),
      // For mentees: industry they want to work in
      // Matching preferences
      preferredMenteeLevel: text("preferred_mentee_level"),
      // For mentors
      preferredMentorExperience: text("preferred_mentor_experience"),
      // For mentees
      preferredIndustries: text("preferred_industries"),
      // JSON array
      // Education fields
      highSchool: text("high_school"),
      // User's high school name
      collegeUniversity: text("college_university"),
      // User's college/university name
      // Status
      isActive: boolean("is_active").default(true),
      maxMentees: integer("max_mentees"),
      // For mentors
      currentMentees: integer("current_mentees").default(0),
      // For mentors
      // Field visibility preferences (JSON string)
      visibilityPreferences: text("visibility_preferences"),
      // Metadata
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow()
    });
    suiteNetworkingProfiles = pgTable("suite_networking_profiles", {
      id: serial("id").primaryKey(),
      userId: integer("user_id").notNull().references(() => users.id),
      // Professional identity
      professionalTagline: text("professional_tagline"),
      currentRole: text("current_role"),
      currentCompany: text("current_company"),
      industry: text("industry"),
      experienceYears: integer("experience_years"),
      // Networking goals
      networkingGoals: text("networking_goals"),
      // JSON array of goals
      lookingFor: text("looking_for"),
      // What they're seeking: collaboration, advice, partnerships, etc.
      canOffer: text("can_offer"),
      // What they can provide to others
      // Interests and causes
      professionalInterests: text("professional_interests"),
      // JSON array
      causesIPassionate: text("causes_passionate"),
      // JSON array of causes they care about
      // Collaboration preferences
      collaborationTypes: text("collaboration_types"),
      // JSON array: ['Projects', 'Startups', 'Research', 'Volunteering']
      workingStyle: text("working_style"),
      // 'Remote-first', 'In-person', 'Flexible'
      timeCommitment: text("time_commitment"),
      // How much time they can dedicate
      // Fun and personal
      lightUpWhenTalking: text("light_up_when_talking"),
      // Fun prompt response
      wantToMeetSomeone: text("want_to_meet_someone"),
      // "I'd love to meet someone who..."
      currentProjects: text("current_projects"),
      // JSON array of current projects
      dreamCollaboration: text("dream_collaboration"),
      // Availability and contact
      preferredMeetingStyle: text("preferred_meeting_style"),
      // JSON array: ['Coffee chat', 'Virtual call', 'Coworking', 'Events']
      availability: text("availability"),
      // General availability
      // Geographic preferences
      location: text("location"),
      openToRemote: boolean("open_to_remote").default(true),
      preferredLocations: text("preferred_locations"),
      // JSON array for in-person meetups
      // Education fields
      highSchool: text("high_school"),
      // User's high school name
      collegeUniversity: text("college_university"),
      // User's college/university name
      // Status and visibility
      isActive: boolean("is_active").default(true),
      lookingForOpportunities: boolean("looking_for_opportunities").default(true),
      // Field visibility preferences (JSON string)
      visibilityPreferences: text("visibility_preferences"),
      // Metadata
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow()
    });
    suiteProfileSettings = pgTable("suite_profile_settings", {
      id: serial("id").primaryKey(),
      userId: integer("user_id").notNull().references(() => users.id).unique(),
      // Profile activation status
      jobProfileActive: boolean("job_profile_active").default(false),
      mentorshipProfileActive: boolean("mentorship_profile_active").default(false),
      networkingProfileActive: boolean("networking_profile_active").default(false),
      // Discovery preferences (consistent with profile_hidden logic: false = visible, true = hidden)
      // NEW USERS START HIDDEN: All discovery toggles default to true (hidden) for new users
      hiddenInJobDiscovery: boolean("hidden_in_job_discovery").default(true),
      hiddenInMentorshipDiscovery: boolean(
        "hidden_in_mentorship_discovery"
      ).default(true),
      hiddenInNetworkingDiscovery: boolean(
        "hidden_in_networking_discovery"
      ).default(true),
      // Primary profile preference
      primaryProfileType: text("primary_profile_type"),
      // 'job', 'mentorship', 'networking'
      // Metadata
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow()
    });
    suiteFieldVisibility = pgTable(
      "suite_field_visibility",
      {
        id: serial("id").primaryKey(),
        userId: integer("user_id").notNull().references(() => users.id),
        profileType: text("profile_type").notNull().$type(),
        fieldName: text("field_name").notNull(),
        isVisible: boolean("is_visible").notNull().default(true),
        createdAt: timestamp("created_at").defaultNow(),
        updatedAt: timestamp("updated_at").defaultNow()
      },
      (table) => ({
        uniqueUserProfileField: unique().on(
          table.userId,
          table.profileType,
          table.fieldName
        )
      })
    );
    connectionsPreferences = pgTable("connections_preferences", {
      id: serial("id").primaryKey(),
      userId: integer("user_id").notNull().references(() => users.id).unique(),
      // Mentorship Preferences
      mentorshipLookingFor: text("mentorship_looking_for").array(),
      // ['mentors', 'mentees', 'both']
      mentorshipExperienceLevel: text("mentorship_experience_level").array(),
      // ['junior', 'mid', 'senior', 'executive']
      mentorshipIndustries: text("mentorship_industries").array(),
      mentorshipAreasOfExpertise: text("mentorship_areas_of_expertise").array(),
      // ['software-development', 'data-science', 'marketing', etc.]
      mentorshipEducationLevel: text("mentorship_education_level").array(),
      // ['high-school', 'bachelor', 'master', 'phd', 'other']
      mentorshipSkills: text("mentorship_skills").array(),
      // ['python', 'javascript', 'leadership', etc.]
      mentorshipTopics: text("mentorship_topics").array(),
      // Learning/teaching topics
      mentorshipFormat: text("mentorship_format").array(),
      // ['one-on-one', 'group', 'virtual', 'in-person']
      mentorshipTimeCommitment: text("mentorship_time_commitment"),
      // ['flexible', 'weekly', 'monthly', 'project-based']
      mentorshipLocationPreference: text("mentorship_location_preference"),
      // ['local', 'regional', 'national', 'international']
      mentorshipWeights: text("mentorship_weights"),
      // JSON string of preference weights
      // Networking Preferences  
      networkingPurpose: text("networking_purpose").array(),
      // ['partnerships', 'opportunities', 'knowledge', 'insights']
      networkingCompanySize: text("networking_company_size").array(),
      // ['startup', 'sme', 'enterprise', 'nonprofit']
      networkingSeniority: text("networking_seniority").array(),
      // ['individual', 'manager', 'director', 'executive']
      networkingIndustries: text("networking_industries").array(),
      networkingAreasOfExpertise: text("networking_areas_of_expertise").array(),
      // ['software-development', 'data-science', 'marketing', etc.]
      networkingEducationLevel: text("networking_education_level").array(),
      // ['high-school', 'bachelor', 'master', 'phd', 'other']
      networkingSkills: text("networking_skills").array(),
      // ['python', 'javascript', 'leadership', etc.]
      networkingFunctionalAreas: text("networking_functional_areas").array(),
      // ['sales', 'marketing', 'engineering', etc.]
      networkingLocationPreference: text("networking_location_preference"),
      // 'local', 'regional', 'national', 'international'
      networkingEventPreference: text("networking_event_preference").array(),
      // ['virtual', 'in-person', 'conferences', 'casual']
      networkingWeights: text("networking_weights"),
      // JSON string of preference weights
      // Jobs Preferences
      jobsTypes: text("jobs_types").array(),
      // ['full-time', 'part-time', 'contract', 'freelance']
      jobsSalaryRange: text("jobs_salary_range").array(),
      // ['0-30k', '30k-50k', '50k-75k', etc.]
      jobsSalaryCurrency: text("jobs_salary_currency"),
      // 'USD', 'EUR', 'GHS', etc.
      jobsSalaryMin: integer("jobs_salary_min"),
      // Minimum salary amount
      jobsSalaryMax: integer("jobs_salary_max"),
      // Maximum salary amount  
      jobsSalaryPeriod: text("jobs_salary_period"),
      // '/hour', '/day', '/month', '/year'
      jobsWorkArrangement: text("jobs_work_arrangement").array(),
      // ['remote', 'hybrid', 'on-site']
      jobsCompanySize: text("jobs_company_size").array(),
      // ['startup', 'sme', 'enterprise']
      jobsIndustries: text("jobs_industries").array(),
      jobsEducationLevel: text("jobs_education_level").array(),
      // ['high-school', 'bachelor', 'master', 'phd', 'other']
      jobsSkills: text("jobs_skills").array(),
      // ['python', 'javascript', 'leadership', etc.]
      jobsExperienceLevel: text("jobs_experience_level").array(),
      // ['entry', 'mid', 'senior', 'lead', 'executive']
      jobsFunctionalAreas: text("jobs_functional_areas").array(),
      jobsWorkLocation: text("jobs_work_location"),
      // ['local', 'regional', 'national', 'international']
      jobsWeights: text("jobs_weights"),
      // JSON string of preference weights
      // Global Settings
      dealBreakers: text("deal_breakers").array(),
      // Global deal breakers across all types
      preferenceProfiles: text("preference_profiles"),
      // JSON string of saved preference sets
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow()
    });
    insertUserSchema = createInsertSchema(users).pick({
      username: true,
      password: true,
      fullName: true,
      email: true,
      phoneNumber: true,
      gender: true,
      location: true,
      dateOfBirth: true,
      ethnicity: true,
      secondaryTribe: true,
      photoUrl: true,
      verifiedByPhone: true
    });
    userProfileSchema = createInsertSchema(users).pick({
      email: true,
      ethnicity: true,
      secondaryTribe: true,
      photoUrl: true,
      showProfilePhoto: true,
      dateOfBirth: true,
      phoneNumber: true,
      twoFactorEnabled: true,
      profileHidden: true,
      ghostMode: true,
      interests: true,
      showAppModeSelection: true,
      showNationalitySelection: true,
      lastUsedApp: true,
      isSuspended: true,
      suspendedAt: true,
      suspensionExpiresAt: true
    }).extend({
      // Override fields to make them nullable during updates (the fields we want to be able to clear)
      location: z.string().nullable(),
      bio: z.string().nullable(),
      profession: z.string().nullable(),
      religion: z.string().nullable(),
      relationshipGoal: z.string().nullable(),
      // New fields added to the schema
      countryOfOrigin: z.string().nullable(),
      secondaryCountryOfOrigin: z.string().nullable(),
      relationshipStatus: z.string().nullable(),
      // Education fields
      highSchool: z.string().nullable(),
      collegeUniversity: z.string().nullable(),
      // New matching algorithm fields
      bodyType: z.string().nullable(),
      height: z.number().nullable(),
      hasChildren: z.string().nullable(),
      wantsChildren: z.string().nullable(),
      educationLevel: z.string().nullable(),
      matchingPriorities: z.string().nullable(),
      // Smoking and drinking preferences
      smoking: z.string().nullable(),
      drinking: z.string().nullable(),
      // Special flags for update operations (not stored in database)
      clearingFields: z.boolean().optional(),
      visibilityPreferences: z.string().optional(),
      // App flow control toggles
      showAppModeSelection: z.boolean().optional(),
      showNationalitySelection: z.boolean().optional(),
      lastUsedApp: z.string().optional()
    });
    insertBlockedPhoneNumberSchema = createInsertSchema(blockedPhoneNumbers).pick({
      phoneNumber: true,
      reason: true,
      metadata: true
    });
    insertUserReportStrikeSchema = createInsertSchema(userReportStrikes).pick({
      reportedUserId: true,
      reporterUserId: true,
      reason: true,
      description: true,
      matchId: true
    });
    userPreferencesSchema = createInsertSchema(userPreferences).pick({
      minAge: true,
      maxAge: true,
      locationPreference: true,
      poolCountry: true,
      // Legacy field maintained for compatibility
      meetPoolCountry: true,
      // MEET app specific pool country
      suitePoolCountry: true,
      // SUITE app specific pool country
      ethnicityPreference: true,
      religionPreference: true,
      relationshipGoalPreference: true,
      distancePreference: true,
      educationLevelPreference: true,
      hasChildrenPreference: true,
      wantsChildrenPreference: true,
      minHeightPreference: true,
      maxHeightPreference: true,
      bodyTypePreference: true,
      dealBreakers: true,
      interestPreferences: true,
      matchingPriorities: true,
      smokingPreference: true,
      drinkingPreference: true
    });
    insertMatchSchema = createInsertSchema(matches).pick({
      userId1: true,
      userId2: true,
      matched: true,
      isDislike: true
    });
    insertMessageSchema = createInsertSchema(messages).pick({
      matchId: true,
      senderId: true,
      receiverId: true,
      content: true,
      messageType: true,
      audioUrl: true,
      audioDuration: true,
      replyToMessageId: true,
      replyToContent: true,
      replyToSenderName: true,
      replyToIsCurrentUser: true
    });
    insertUserInterestSchema = createInsertSchema(userInterests).pick({
      userId: true,
      interest: true,
      showOnProfile: true
    });
    insertGlobalInterestSchema = createInsertSchema(
      globalInterests
    ).pick({
      interest: true,
      category: true,
      createdBy: true
    });
    insertGlobalDealBreakerSchema = createInsertSchema(
      globalDealBreakers
    ).pick({
      dealBreaker: true,
      createdBy: true
    });
    insertGlobalTribeSchema = createInsertSchema(globalTribes).pick({
      tribe: true,
      category: true,
      createdBy: true
    });
    insertGlobalReligionSchema = createInsertSchema(
      globalReligions
    ).pick({
      religion: true,
      category: true,
      createdBy: true
    });
    insertTypingStatusSchema = createInsertSchema(typingStatus).pick({
      userId: true,
      matchId: true,
      isTyping: true
    });
    insertVideoCallSchema = createInsertSchema(videoCalls).pick({
      matchId: true,
      initiatorId: true,
      receiverId: true,
      roomName: true,
      status: true
    });
    insertVerificationCodeSchema = createInsertSchema(
      verificationCodes
    ).pick({
      phoneNumber: true,
      code: true,
      expiresAt: true
    });
    insertUserPhotoSchema = createInsertSchema(userPhotos).omit({
      id: true,
      createdAt: true
    });
    updateUserPhotoPrimarySchema = createInsertSchema(userPhotos).pick(
      {
        isPrimary: true,
        isPrimaryForMeet: true,
        isPrimaryForJob: true,
        isPrimaryForMentorship: true,
        isPrimaryForNetworking: true
      }
    );
    insertMessageReactionSchema = createInsertSchema(
      messageReactions
    ).pick({
      messageId: true,
      userId: true,
      emoji: true
    });
    insertUserMatchSettingsSchema = createInsertSchema(
      userMatchSettings
    ).pick({
      userId: true,
      matchId: true,
      autoDeleteMode: true,
      autoDeleteValue: true,
      autoDeleteUnit: true
    });
    insertCompatibilityAnalysisSchema = createInsertSchema(
      compatibilityAnalysis
    ).pick({
      user1Id: true,
      user2Id: true,
      compatibilityData: true,
      overallScore: true,
      version: true,
      isActive: true
    });
    insertSuiteCompatibilityScoreSchema = createInsertSchema(
      suiteCompatibilityScores
    ).pick({
      userId: true,
      targetUserId: true,
      targetProfileId: true,
      synergyScore: true,
      networkValueScore: true,
      collaborationScore: true,
      exchangeScore: true,
      overallStarRating: true,
      analysisData: true,
      insights: true,
      suggestedActions: true,
      geographicFit: true,
      culturalAlignment: true,
      isActive: true
    });
    insertUserBlockSchema = createInsertSchema(userBlocks).pick({
      blockerUserId: true,
      blockedUserId: true,
      reason: true
    });
    insertArchivedMatchSchema = insertMatchSchema;
    insertArchivedMessageSchema = insertMessageSchema;
    insertArchivedUserSchema = insertUserSchema;
    insertSuiteJobProfileSchema = createInsertSchema(
      suiteJobProfiles
    ).pick({
      userId: true,
      jobTitle: true,
      company: true,
      description: true,
      compensation: true,
      requirements: true,
      location: true,
      workType: true,
      jobType: true,
      experienceLevel: true,
      whyItMatters: true,
      whoShouldApply: true,
      culturalFit: true,
      industryTags: true,
      skillTags: true,
      applicationUrl: true,
      applicationEmail: true,
      applicationInstructions: true,
      isActive: true,
      expiresAt: true
    });
    insertSuiteMentorshipProfileSchema = createInsertSchema(
      suiteMentorshipProfiles
    ).pick({
      userId: true,
      role: true,
      areasOfExpertise: true,
      learningGoals: true,
      mentorshipStyle: true,
      preferredFormat: true,
      communicationStyle: true,
      availability: true,
      timeCommitment: true,
      location: true,
      successStories: true,
      whyMentor: true,
      whySeekMentorship: true,
      preferredMentorshipStyle: true,
      industryAspiration: true,
      preferredMenteeLevel: true,
      preferredMentorExperience: true,
      preferredIndustries: true,
      highSchool: true,
      collegeUniversity: true,
      isActive: true,
      maxMentees: true,
      currentMentees: true
    });
    insertSuiteNetworkingProfileSchema = createInsertSchema(
      suiteNetworkingProfiles
    ).pick({
      userId: true,
      professionalTagline: true,
      currentRole: true,
      currentCompany: true,
      industry: true,
      experienceYears: true,
      networkingGoals: true,
      lookingFor: true,
      canOffer: true,
      professionalInterests: true,
      causesIPassionate: true,
      collaborationTypes: true,
      workingStyle: true,
      timeCommitment: true,
      lightUpWhenTalking: true,
      wantToMeetSomeone: true,
      currentProjects: true,
      dreamCollaboration: true,
      preferredMeetingStyle: true,
      availability: true,
      location: true,
      openToRemote: true,
      preferredLocations: true,
      highSchool: true,
      collegeUniversity: true,
      isActive: true,
      lookingForOpportunities: true,
      visibilityPreferences: true
    });
    insertSuiteProfileSettingsSchema = createInsertSchema(
      suiteProfileSettings
    ).pick({
      userId: true,
      jobProfileActive: true,
      mentorshipProfileActive: true,
      networkingProfileActive: true,
      hiddenInJobDiscovery: true,
      hiddenInMentorshipDiscovery: true,
      hiddenInNetworkingDiscovery: true,
      primaryProfileType: true
    });
    insertSuiteFieldVisibilitySchema = createInsertSchema(
      suiteFieldVisibility
    ).pick({
      userId: true,
      profileType: true,
      fieldName: true,
      isVisible: true
    });
    swipeHistory = pgTable("swipe_history", {
      id: serial("id").primaryKey(),
      userId: integer("user_id").notNull(),
      targetUserId: integer("target_user_id").notNull(),
      action: text("action").notNull(),
      // 'like', 'dislike', 'message'
      appMode: text("app_mode").notNull(),
      // 'MEET', 'SUITE'
      timestamp: timestamp("timestamp").defaultNow()
    });
    insertSwipeHistorySchema = createInsertSchema(swipeHistory).pick({
      userId: true,
      targetUserId: true,
      action: true,
      appMode: true
    });
    archivedMatches = pgTable("archived_matches", {
      id: serial("id").primaryKey(),
      originalMatchId: integer("original_match_id").notNull(),
      // Original match ID before deletion
      userId1: integer("user_id_1").notNull(),
      // User IDs (not FK since users might be deleted)
      userId2: integer("user_id_2").notNull(),
      matched: boolean("matched").notNull(),
      isDislike: boolean("is_dislike").notNull(),
      hasUnreadMessages1: boolean("has_unread_messages_1").notNull(),
      hasUnreadMessages2: boolean("has_unread_messages_2").notNull(),
      notifiedUser1: boolean("notified_user_1").notNull(),
      notifiedUser2: boolean("notified_user_2").notNull(),
      lastMessageAt: timestamp("last_message_at"),
      matchCreatedAt: timestamp("match_created_at").notNull(),
      // Original match creation time
      archivedAt: timestamp("archived_at").defaultNow(),
      // When archived
      archivedReason: text("archived_reason").notNull(),
      // 'unmatch', 'user_deletion', 'admin_action'
      archivedByUserId: integer("archived_by_user_id"),
      // Who triggered the archival
      messageCount: integer("message_count").default(0)
      // Total messages in this match
    });
    archivedMessages = pgTable("archived_messages", {
      id: serial("id").primaryKey(),
      originalMessageId: integer("original_message_id").notNull(),
      // Original message ID before deletion
      originalMatchId: integer("original_match_id").notNull(),
      // Original match ID
      archivedMatchId: integer("archived_match_id").notNull().references(() => archivedMatches.id),
      // Reference to archived match
      senderId: integer("sender_id").notNull(),
      // User IDs (not FK since users might be deleted)
      receiverId: integer("receiver_id").notNull(),
      content: text("content").notNull(),
      encryptedContent: text("encrypted_content"),
      iv: text("initialization_vector"),
      messageType: text("message_type").default("text"),
      audioUrl: text("audio_url"),
      audioDuration: integer("audio_duration"),
      read: boolean("read").notNull(),
      readAt: timestamp("read_at"),
      messageCreatedAt: timestamp("message_created_at").notNull(),
      // Original message creation time
      archivedAt: timestamp("archived_at").defaultNow(),
      // When archived
      archivedReason: text("archived_reason").notNull(),
      // 'unmatch', 'user_deletion', 'admin_action'
      // Reply functionality preserved
      replyToMessageId: integer("reply_to_message_id"),
      replyToContent: text("reply_to_content"),
      replyToSenderName: text("reply_to_sender_name"),
      replyToIsCurrentUser: boolean("reply_to_is_current_user"),
      // Auto-delete functionality preserved
      autoDeleteScheduledAt: timestamp("auto_delete_scheduled_at"),
      autoDeleteModeWhenSent: text("auto_delete_mode_when_sent"),
      deletedForUserId: integer("deleted_for_user_id")
    });
    archivedUsers = pgTable("archived_users", {
      id: serial("id").primaryKey(),
      originalUserId: integer("original_user_id").notNull(),
      // Original user ID before deletion
      username: text("username").notNull(),
      fullName: text("full_name").notNull(),
      email: text("email").notNull(),
      phoneNumber: text("phone_number"),
      gender: text("gender").notNull(),
      location: text("location").notNull(),
      countryOfOrigin: text("country_of_origin"),
      bio: text("bio"),
      profession: text("profession"),
      ethnicity: text("ethnicity"),
      secondaryTribe: text("secondary_tribe"),
      religion: text("religion"),
      photoUrl: text("photo_url"),
      showProfilePhoto: boolean("show_profile_photo"),
      dateOfBirth: timestamp("date_of_birth"),
      relationshipStatus: text("relationship_status"),
      relationshipGoal: text("relationship_goal"),
      interests: text("interests"),
      visibilityPreferences: text("visibility_preferences"),
      verifiedByPhone: boolean("verified_by_phone"),
      twoFactorEnabled: boolean("two_factor_enabled"),
      profileHidden: boolean("profile_hidden"),
      ghostMode: boolean("ghost_mode"),
      isOnline: boolean("is_online"),
      lastActive: timestamp("last_active"),
      userCreatedAt: timestamp("user_created_at").notNull(),
      // Original user creation time
      archivedAt: timestamp("archived_at").defaultNow(),
      // When archived
      archivedReason: text("archived_reason").notNull(),
      // 'account_deletion', 'admin_action', 'policy_violation'
      archivedByUserId: integer("archived_by_user_id"),
      // Who triggered the archival (admin or self)
      totalMatches: integer("total_matches").default(0),
      // Historical match count
      totalMessages: integer("total_messages").default(0),
      // Historical message count
      ipAddress: text("ip_address"),
      // Last known IP for security
      userAgent: text("user_agent")
      // Last known user agent for security
    });
    suiteNetworkingConnections = pgTable(
      "suite_networking_connections",
      {
        id: serial("id").primaryKey(),
        userId: integer("user_id").notNull().references(() => users.id),
        // User who performed the action
        targetProfileId: integer("target_profile_id").notNull().references(() => suiteNetworkingProfiles.id),
        // Target networking profile
        targetUserId: integer("target_user_id").notNull().references(() => users.id),
        // Owner of the target profile
        action: text("action").notNull(),
        // 'like' or 'pass'
        matched: boolean("matched").notNull().default(false),
        // True if mutual like
        isDislike: boolean("is_dislike").notNull().default(false),
        // True if this is a dislike (pass action)
        createdAt: timestamp("created_at").defaultNow()
      },
      (table) => {
        return {
          // Ensure one action per user-profile combination
          uniqueUserProfile: unique().on(table.userId, table.targetProfileId)
        };
      }
    );
    suiteMentorshipConnections = pgTable(
      "suite_mentorship_connections",
      {
        id: serial("id").primaryKey(),
        userId: integer("user_id").notNull().references(() => users.id),
        // User who performed the action
        targetProfileId: integer("target_profile_id").notNull().references(() => suiteMentorshipProfiles.id),
        // Target mentorship profile
        targetUserId: integer("target_user_id").notNull().references(() => users.id),
        // Owner of the target profile
        action: text("action").notNull(),
        // 'like' or 'pass'
        matched: boolean("matched").notNull().default(false),
        // True if mutual like
        isDislike: boolean("is_dislike").notNull().default(false),
        // True if this is a dislike (pass action)
        createdAt: timestamp("created_at").defaultNow()
      },
      (table) => {
        return {
          // Ensure one action per user-profile combination
          uniqueUserProfile: unique().on(table.userId, table.targetProfileId)
        };
      }
    );
    suiteJobApplications = pgTable(
      "suite_job_applications",
      {
        id: serial("id").primaryKey(),
        userId: integer("user_id").notNull().references(() => users.id),
        // User who applied
        targetProfileId: integer("target_profile_id").notNull().references(() => suiteJobProfiles.id),
        // Target job profile
        targetUserId: integer("target_user_id").notNull().references(() => users.id),
        // Job poster
        action: text("action").notNull(),
        // 'like' or 'pass'
        applicationStatus: text("application_status").default("pending"),
        // 'pending', 'accepted', 'rejected', 'matched'
        matched: boolean("matched").default(false).notNull(),
        createdAt: timestamp("created_at").defaultNow()
      },
      (table) => {
        return {
          // Ensure one application per user-job combination
          uniqueUserJob: unique().on(table.userId, table.targetProfileId)
        };
      }
    );
    professionalReviews = pgTable("professional_reviews", {
      id: serial("id").primaryKey(),
      reviewedUserId: integer("reviewed_user_id").notNull().references(() => users.id),
      // User being reviewed
      reviewerUserId: integer("reviewer_user_id").notNull().references(() => users.id),
      // User writing the review
      rating: integer("rating").notNull(),
      // 1-5 star rating
      reviewText: text("review_text").notNull(),
      // Review comment
      isAnonymous: boolean("is_anonymous").default(false),
      // Whether reviewer wants to stay anonymous
      category: text("category").notNull().default("general"),
      // 'general', 'reliability', 'communication', 'skills'
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow()
    }, (table) => ({
      // Ensure one review per user pair per category
      uniqueReview: unique().on(table.reviewedUserId, table.reviewerUserId, table.category)
    }));
    insertSuiteNetworkingConnectionSchema = createInsertSchema(
      suiteNetworkingConnections
    ).pick({
      userId: true,
      targetProfileId: true,
      targetUserId: true,
      action: true,
      matched: true,
      isDislike: true
    });
    insertSuiteMentorshipConnectionSchema = createInsertSchema(
      suiteMentorshipConnections
    ).pick({
      userId: true,
      targetProfileId: true,
      targetUserId: true,
      action: true,
      matched: true,
      isDislike: true
    });
    insertSuiteJobApplicationSchema = createInsertSchema(
      suiteJobApplications
    ).pick({
      userId: true,
      targetProfileId: true,
      targetUserId: true,
      action: true,
      applicationStatus: true,
      matched: true
    });
    insertProfessionalReviewSchema = createInsertSchema(
      professionalReviews
    ).pick({
      reviewedUserId: true,
      reviewerUserId: true,
      rating: true,
      reviewText: true,
      isAnonymous: true,
      category: true
    });
    subscriptions = pgTable("subscriptions", {
      id: serial("id").primaryKey(),
      userId: integer("user_id").notNull().references(() => users.id),
      provider: text("provider").notNull(),
      // 'stripe', 'flutterwave', 'paystack'
      subscriptionId: text("subscription_id").notNull(),
      // External subscription ID from provider
      planType: text("plan_type").notNull(),
      // 'premium_monthly', 'premium_yearly', 'premium_quarterly'
      status: text("status").notNull(),
      // 'active', 'cancelled', 'past_due', 'incomplete', 'incomplete_expired', 'trialing', 'unpaid'
      currentPeriodStart: timestamp("current_period_start").notNull(),
      currentPeriodEnd: timestamp("current_period_end").notNull(),
      cancelAtPeriodEnd: boolean("cancel_at_period_end").default(false),
      cancelledAt: timestamp("cancelled_at"),
      currency: text("currency").notNull().default("USD"),
      // 'USD', 'GHS', 'EUR', 'GBP'
      amount: integer("amount").notNull(),
      // Amount in cents (e.g., $9.99 = 999)
      paymentMethod: text("payment_method").notNull(),
      // 'card', 'mobile_money', 'bank_transfer', 'digital_wallet'
      region: text("region").notNull(),
      // 'ghana', 'diaspora', 'africa', 'global'
      trialEnd: timestamp("trial_end"),
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow()
    });
    paymentMethods = pgTable("payment_methods", {
      id: serial("id").primaryKey(),
      userId: integer("user_id").notNull().references(() => users.id),
      provider: text("provider").notNull(),
      // 'stripe', 'flutterwave', 'paystack'
      externalId: text("external_id").notNull(),
      // Provider's payment method ID
      type: text("type").notNull(),
      // 'card', 'mobile_money', 'bank_transfer', 'digital_wallet'
      isDefault: boolean("is_default").default(false),
      metadata: text("metadata"),
      // JSON string containing payment method details (last4, mobile number, bank name, etc.)
      // Billing Address Information
      billingName: text("billing_name"),
      // Full name for billing
      billingEmail: text("billing_email"),
      // Email address for billing
      billingPhone: text("billing_phone"),
      // Phone number for billing
      billingAddress: text("billing_address"),
      // Street address
      billingCity: text("billing_city"),
      // City
      billingState: text("billing_state"),
      // State/Province
      billingPostalCode: text("billing_postal_code"),
      // Postal/ZIP code
      billingCountry: text("billing_country"),
      // Country
      nickname: text("nickname"),
      // User-friendly name for the payment method
      isActive: boolean("is_active").default(true),
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow()
    });
    paymentHistory = pgTable("payment_history", {
      id: serial("id").primaryKey(),
      subscriptionId: integer("subscription_id").notNull().references(() => subscriptions.id),
      userId: integer("user_id").notNull().references(() => users.id),
      provider: text("provider").notNull(),
      // 'stripe', 'flutterwave', 'paystack'
      providerTransactionId: text("provider_transaction_id").notNull(),
      // External transaction ID
      amount: integer("amount").notNull(),
      // Amount in cents
      currency: text("currency").notNull(),
      // 'USD', 'GHS', 'EUR', 'GBP'
      status: text("status").notNull(),
      // 'succeeded', 'pending', 'failed', 'cancelled', 'refunded'
      paymentMethod: text("payment_method").notNull(),
      // 'card', 'mobile_money', 'bank_transfer'
      paymentMethodId: integer("payment_method_id").references(() => paymentMethods.id),
      failureReason: text("failure_reason"),
      // Reason if payment failed
      refundAmount: integer("refund_amount"),
      // Refund amount in cents if applicable
      metadata: text("metadata"),
      // JSON string for additional transaction details
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow()
    });
    subscriptionEvents2 = pgTable("subscription_events", {
      id: serial("id").primaryKey(),
      subscriptionId: integer("subscription_id").notNull().references(() => subscriptions.id),
      userId: integer("user_id").notNull().references(() => users.id),
      eventType: text("event_type").notNull(),
      // 'created', 'updated', 'cancelled', 'reactivated', 'payment_failed', 'payment_succeeded'
      provider: text("provider").notNull(),
      // 'stripe', 'flutterwave', 'paystack'
      providerEventId: text("provider_event_id"),
      // External event ID from webhook
      oldStatus: text("old_status"),
      // Previous subscription status
      newStatus: text("new_status"),
      // New subscription status
      metadata: text("metadata"),
      // JSON string for event details
      createdAt: timestamp("created_at").defaultNow()
    });
    regionalPricing = pgTable("regional_pricing", {
      id: serial("id").primaryKey(),
      planType: text("plan_type").notNull(),
      // 'premium_monthly', 'premium_yearly', 'premium_quarterly'
      region: text("region").notNull(),
      // 'ghana', 'diaspora', 'nigeria', 'kenya', 'south_africa', 'global'
      currency: text("currency").notNull(),
      // 'USD', 'GHS', 'NGN', 'KES', 'ZAR', 'EUR', 'GBP'
      amount: integer("amount").notNull(),
      // Amount in cents
      discountPercentage: integer("discount_percentage").default(0),
      // Discount from base price
      isActive: boolean("is_active").default(true),
      validFrom: timestamp("valid_from").defaultNow(),
      validUntil: timestamp("valid_until"),
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow()
    });
    promotionalCodes = pgTable("promotional_codes", {
      id: serial("id").primaryKey(),
      code: text("code").notNull().unique(),
      // Promo code (e.g., 'WELCOME20', 'STUDENT50')
      type: text("type").notNull(),
      // 'percentage', 'fixed_amount', 'free_trial'
      value: integer("value").notNull(),
      // Discount value (percentage or amount in cents)
      currency: text("currency"),
      // Currency for fixed amount discounts
      planTypes: text("plan_types"),
      // JSON array of applicable plan types
      regions: text("regions"),
      // JSON array of applicable regions
      maxUses: integer("max_uses"),
      // Maximum number of uses (null = unlimited)
      currentUses: integer("current_uses").default(0),
      validFrom: timestamp("valid_from").defaultNow(),
      validUntil: timestamp("valid_until"),
      isActive: boolean("is_active").default(true),
      createdByUserId: integer("created_by_user_id").references(() => users.id),
      metadata: text("metadata"),
      // JSON string for additional promo details
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow()
    });
    promotionalCodeUsage = pgTable("promotional_code_usage", {
      id: serial("id").primaryKey(),
      promoCodeId: integer("promo_code_id").notNull().references(() => promotionalCodes.id),
      userId: integer("user_id").notNull().references(() => users.id),
      subscriptionId: integer("subscription_id").references(() => subscriptions.id),
      discountAmount: integer("discount_amount").notNull(),
      // Actual discount applied in cents
      currency: text("currency").notNull(),
      usedAt: timestamp("used_at").defaultNow()
    });
    insertSubscriptionSchema = createInsertSchema(subscriptions).pick({
      userId: true,
      provider: true,
      subscriptionId: true,
      planType: true,
      status: true,
      currentPeriodStart: true,
      currentPeriodEnd: true,
      cancelAtPeriodEnd: true,
      cancelledAt: true,
      currency: true,
      amount: true,
      paymentMethod: true,
      region: true,
      trialEnd: true
    });
    insertPaymentMethodSchema = createInsertSchema(paymentMethods).pick({
      userId: true,
      provider: true,
      externalId: true,
      type: true,
      isDefault: true,
      metadata: true,
      billingName: true,
      billingEmail: true,
      billingPhone: true,
      billingAddress: true,
      billingCity: true,
      billingState: true,
      billingPostalCode: true,
      billingCountry: true,
      nickname: true,
      isActive: true
    });
    insertPaymentHistorySchema = createInsertSchema(paymentHistory).pick({
      subscriptionId: true,
      userId: true,
      provider: true,
      providerTransactionId: true,
      amount: true,
      currency: true,
      status: true,
      paymentMethod: true,
      paymentMethodId: true,
      failureReason: true,
      refundAmount: true,
      metadata: true
    });
    insertSubscriptionEventSchema = createInsertSchema(subscriptionEvents2).pick({
      subscriptionId: true,
      userId: true,
      eventType: true,
      provider: true,
      providerEventId: true,
      oldStatus: true,
      newStatus: true,
      metadata: true
    });
    insertRegionalPricingSchema = createInsertSchema(regionalPricing).pick({
      planType: true,
      region: true,
      currency: true,
      amount: true,
      discountPercentage: true,
      isActive: true,
      validFrom: true,
      validUntil: true
    });
    insertPromotionalCodeSchema = createInsertSchema(promotionalCodes).pick({
      code: true,
      type: true,
      value: true,
      currency: true,
      planTypes: true,
      regions: true,
      maxUses: true,
      currentUses: true,
      validFrom: true,
      validUntil: true,
      isActive: true,
      createdByUserId: true,
      metadata: true
    });
    insertPromotionalCodeUsageSchema = createInsertSchema(promotionalCodeUsage).pick({
      promoCodeId: true,
      userId: true,
      subscriptionId: true,
      discountAmount: true,
      currency: true
    });
    suiteMentorshipCompatibilityScores = pgTable("suite_mentorship_compatibility_scores", {
      id: serial("id").primaryKey(),
      userId: integer("user_id").notNull().references(() => users.id),
      // User viewing the profile
      targetUserId: integer("target_user_id").notNull().references(() => users.id),
      // Profile being viewed
      targetProfileId: integer("target_profile_id").notNull().references(() => suiteMentorshipProfiles.id),
      // Specific mentorship profile
      // 6D Mentorship Compatibility Model
      expertiseRelevance: integer("expertise_relevance").notNull(),
      // Mentor expertise to mentee goals match (1-10)
      mentorshipStyleFit: integer("mentorship_style_fit").notNull(),
      // Teaching/learning style compatibility (1-10)
      timeSynergy: integer("time_synergy").notNull(),
      // Time commitment and availability alignment (1-10)
      communicationFit: integer("communication_fit").notNull(),
      // Communication style and channel match (1-10)
      contextualAlignment: integer("contextual_alignment").notNull(),
      // Geographic, linguistic, cultural fit (1-10)
      growthGapPotential: integer("growth_gap_potential").notNull(),
      // Optimal experience delta (1-10)
      overallCompatibilityScore: integer("overall_compatibility_score").notNull(),
      // Final percentage score (1-100)
      // Success prediction metrics
      successProbability: integer("success_probability").notNull(),
      // 90-day success likelihood (1-100)
      breakthroughMomentPrediction: integer("breakthrough_moment_prediction").notNull(),
      // When insights typically occur (weeks)
      plateauRiskAssessment: integer("plateau_risk_assessment").notNull(),
      // Stagnation risk level (1-10)
      // Detailed analysis data
      analysisData: text("analysis_data").notNull(),
      // JSON with comprehensive breakdown
      insights: text("insights").notNull(),
      // JSON array of key insights
      conversationStarters: text("conversation_starters").notNull(),
      // JSON array of AI-generated talking points
      mentorshipRoadmap: text("mentorship_roadmap").notNull(),
      // JSON with projected learning journey
      milestonePathway: text("milestone_pathway").notNull(),
      // JSON with predicted progress markers
      skillGapForecast: text("skill_gap_forecast").notNull(),
      // JSON with what mentee can learn
      // Metadata
      computedAt: timestamp("computed_at").defaultNow().notNull(),
      lastUpdated: timestamp("last_updated").defaultNow().notNull(),
      isActive: boolean("is_active").default(true).notNull()
    });
    insertSuiteMentorshipCompatibilityScoreSchema = createInsertSchema(
      suiteMentorshipCompatibilityScores
    ).pick({
      userId: true,
      targetUserId: true,
      targetProfileId: true,
      expertiseRelevance: true,
      mentorshipStyleFit: true,
      timeSynergy: true,
      communicationFit: true,
      contextualAlignment: true,
      growthGapPotential: true,
      overallCompatibilityScore: true,
      successProbability: true,
      breakthroughMomentPrediction: true,
      plateauRiskAssessment: true,
      analysisData: true,
      insights: true,
      conversationStarters: true,
      mentorshipRoadmap: true,
      milestonePathway: true,
      skillGapForecast: true,
      isActive: true
    });
    insertConnectionsPreferencesSchema = createInsertSchema(connectionsPreferences).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
  }
});

// server/db.ts
var db_exports = {};
__export(db_exports, {
  db: () => db,
  pool: () => pool
});
import { drizzle } from "drizzle-orm/neon-serverless";
import { neonConfig, Pool } from "@neondatabase/serverless";
import ws from "ws";
var pool, db;
var init_db = __esm({
  "server/db.ts"() {
    "use strict";
    init_schema();
    if (typeof process !== "undefined" && process.versions?.node) {
      neonConfig.fetchConnectionCache = true;
      neonConfig.webSocketConstructor = ws;
    }
    pool = new Pool({ connectionString: process.env.DATABASE_URL });
    db = drizzle(pool, {
      schema: {
        users,
        userPreferences,
        matches,
        messages,
        userInterests,
        typingStatus,
        videoCalls,
        globalInterests,
        globalDealBreakers,
        globalTribes,
        globalReligions,
        verificationCodes,
        userPhotos,
        messageReactions,
        userMatchSettings,
        suiteJobProfiles,
        suiteMentorshipProfiles,
        suiteNetworkingProfiles,
        suiteProfileSettings,
        compatibilityAnalysis
      }
    });
  }
});

// server/storage.ts
import session from "express-session";
import {
  eq,
  and,
  or,
  ne,
  desc,
  asc,
  sql,
  count,
  notInArray,
  inArray,
  isNull,
  notExists
} from "drizzle-orm";
import connectPg from "connect-pg-simple";
import createMemoryStore from "memorystore";
var PostgresSessionStore, MemoryStore, DatabaseStorage, storage;
var init_storage = __esm({
  "server/storage.ts"() {
    "use strict";
    init_schema();
    init_db();
    PostgresSessionStore = connectPg(session);
    MemoryStore = createMemoryStore(session);
    DatabaseStorage = class {
      sessionStore;
      constructor() {
        this.sessionStore = new PostgresSessionStore({
          pool,
          createTableIfMissing: true,
          tableName: "user_sessions",
          // Increased prune interval to keep more inactive sessions available
          pruneSessionInterval: 24 * 60 * 60
          // 24 hours in seconds
        });
      }
      // User operations
      async getUser(id) {
        const [user] = await db.select().from(users).where(eq(users.id, id));
        return user;
      }
      async getUserByUsername(username) {
        const allUsers = await this.getAllUsers();
        return allUsers.find(
          (user) => user.username.toLowerCase() === username.toLowerCase()
        );
      }
      async getUserByEmail(email) {
        const allUsers = await this.getAllUsers();
        return allUsers.find(
          (user) => user.email.toLowerCase() === email.toLowerCase()
        );
      }
      async getUserByPhoneNumber(phoneNumber) {
        if (!phoneNumber) {
          return void 0;
        }
        const allUsers = await this.getAllUsers();
        const matchingUsers = allUsers.filter(
          (user) => user.phoneNumber === phoneNumber
        );
        if (matchingUsers.length > 1) {
          console.warn(
            `WARNING: Found ${matchingUsers.length} users with the same phone number: ${phoneNumber}`
          );
          console.warn(
            `Matching user IDs: ${matchingUsers.map((u) => u.id).join(", ")}`
          );
          matchingUsers.sort((a, b) => {
            const dateA = a.createdAt ? new Date(a.createdAt).getTime() : 0;
            const dateB = b.createdAt ? new Date(b.createdAt).getTime() : 0;
            return dateB - dateA;
          });
          return matchingUsers[0];
        }
        return matchingUsers[0];
      }
      async getAllUsers() {
        return await db.select().from(users);
      }
      // Phone verification methods
      async createVerificationCode(verificationData) {
        const [code] = await db.insert(verificationCodes).values(verificationData).returning();
        return code;
      }
      async getVerificationCode(phoneNumber, code) {
        const [verificationCode] = await db.select().from(verificationCodes).where(
          and(
            eq(verificationCodes.phoneNumber, phoneNumber),
            eq(verificationCodes.code, code)
          )
        );
        return verificationCode;
      }
      async deleteVerificationCode(id) {
        await db.delete(verificationCodes).where(eq(verificationCodes.id, id));
      }
      async deleteExpiredVerificationCodes() {
        const now = /* @__PURE__ */ new Date();
        await db.delete(verificationCodes).where(
          // Using raw SQL to compare dates
          sql`${verificationCodes.expiresAt} < ${now}`
        );
      }
      // Blocked phone numbers for age compliance
      async addBlockedPhoneNumber(phoneNumber, reason, fullName, email, metadata) {
        const [blocked] = await db.insert(blockedPhoneNumbers).values({ phoneNumber, reason, fullName, email, metadata }).returning();
        return blocked;
      }
      async isPhoneNumberBlocked(phoneNumber) {
        const blocked = await db.select().from(blockedPhoneNumbers).where(eq(blockedPhoneNumbers.phoneNumber, phoneNumber)).limit(1);
        return blocked.length > 0;
      }
      async getBlockedPhoneNumber(phoneNumber) {
        const blocked = await db.select().from(blockedPhoneNumbers).where(eq(blockedPhoneNumbers.phoneNumber, phoneNumber)).limit(1);
        return blocked[0];
      }
      async createUser(insertUser) {
        let userData = {
          ...insertUser,
          createdAt: /* @__PURE__ */ new Date()
        };
        if (userData.dateOfBirth) {
          try {
            if (userData.dateOfBirth instanceof Date) {
              console.log("Date object already provided");
            } else if (typeof userData.dateOfBirth === "string") {
              userData.dateOfBirth = new Date(userData.dateOfBirth);
              console.log("Converted string to Date:", userData.dateOfBirth);
            } else {
              console.log(
                "Invalid date type, removing:",
                typeof userData.dateOfBirth
              );
              delete userData.dateOfBirth;
            }
            if (userData.dateOfBirth && isNaN(userData.dateOfBirth.getTime())) {
              console.log("Invalid date, removing field");
              delete userData.dateOfBirth;
            }
          } catch (err) {
            console.error("Error parsing date:", err);
            delete userData.dateOfBirth;
          }
        }
        console.log("Final user data for DB:", userData);
        userData.profileHidden = true;
        userData.premiumAccess = false;
        const [user] = await db.insert(users).values(userData).returning();
        return user;
      }
      async updateUserProfile(id, profile) {
        try {
          const existingUser = await this.getUser(id);
          if (!existingUser) {
            throw new Error(`User with ID ${id} not found`);
          }
          if (Object.keys(profile).length === 0) {
            throw new Error("No values to set");
          }
          const isVisibilityPreferencesOnlyUpdate = Object.keys(profile).length === 1 && "visibilityPreferences" in profile;
          if (isVisibilityPreferencesOnlyUpdate && profile.visibilityPreferences) {
            console.log("Special handling for visibilityPreferences-only update");
            try {
              await db.execute(sql`
            UPDATE users 
            SET visibility_preferences = ${profile.visibilityPreferences}
            WHERE id = ${id}
          `);
              return await this.getUser(id);
            } catch (directUpdateError) {
              console.error(
                "Error in direct visibility preferences update:",
                directUpdateError
              );
              throw new Error(
                `Database error: ${directUpdateError?.message || "Unknown database error"}`
              );
            }
          }
          const isClearingFields = profile.clearingFields === true;
          console.log("Profile update with clearingFields flag:", isClearingFields);
          delete profile.clearingFields;
          let visibilityPreferences;
          if ("visibilityPreferences" in profile) {
            visibilityPreferences = profile.visibilityPreferences;
            delete profile.visibilityPreferences;
          }
          const cleanProfile = {};
          for (const [key, value] of Object.entries(profile)) {
            if (value === null) {
              cleanProfile[key] = null;
              continue;
            }
            if (value === "") {
              if (isClearingFields) {
                cleanProfile[key] = null;
              }
              continue;
            }
            if (value !== void 0) {
              cleanProfile[key] = value;
            }
          }
          if (visibilityPreferences) {
            cleanProfile.visibilityPreferences = visibilityPreferences;
          }
          console.log("Clean profile data for update:", cleanProfile);
          if (Object.keys(cleanProfile).length === 0) {
            if (isClearingFields) {
              const originalKeys = Object.keys(profile);
              if (originalKeys.length > 0) {
                const fieldToClear = originalKeys[0];
                cleanProfile[fieldToClear] = null;
                console.log(
                  `Explicitly clearing field "${fieldToClear}" with null value`
                );
              } else {
                throw new Error("No fields specified for clearing operation");
              }
            } else {
              throw new Error("No valid values to set after filtering");
            }
          }
          console.log("Updating user profile with clean data:", cleanProfile);
          try {
            const [updatedUser] = await db.update(users).set(cleanProfile).where(eq(users.id, id)).returning();
            return updatedUser;
          } catch (dbError) {
            console.error(`Database error updating user ${id}:`, dbError);
            throw new Error(
              `Database error: ${dbError?.message || "Unknown database error"}`
            );
          }
        } catch (error) {
          console.error(`Error updating user profile for user ${id}:`, error);
          throw error;
        }
      }
      async updateUser(id, updates) {
        try {
          const [updatedUser] = await db.update(users).set(updates).where(eq(users.id, id)).returning();
          console.log(`User ${id} updated successfully`);
          return updatedUser;
        } catch (error) {
          console.error(`Error updating user ${id}:`, error);
          if (error instanceof Error) {
            throw new Error(`Database error: ${error.message}`);
          } else {
            throw new Error("Unknown database error");
          }
        }
      }
      async updateUserPassword(userId, hashedPassword) {
        await db.update(users).set({ password: hashedPassword }).where(eq(users.id, userId));
      }
      async deleteUser(userId) {
        console.log(`Starting complete user deletion for user ${userId}...`);
        try {
          await db.transaction(async (tx) => {
            const userResult = await tx.execute(sql`SELECT phone_number FROM users WHERE id = ${userId}`);
            const userPhone = userResult.rows[0]?.phone_number;
            console.log(`Deleting all dependent records for user ${userId}...`);
            await tx.execute(sql`DELETE FROM payment_history WHERE user_id = ${userId}`);
            await tx.execute(sql`DELETE FROM payment_methods WHERE user_id = ${userId}`);
            await tx.execute(sql`DELETE FROM subscriptions WHERE user_id = ${userId}`);
            await tx.execute(sql`DELETE FROM promotional_code_usage WHERE user_id = ${userId}`);
            await tx.execute(sql`DELETE FROM message_reactions WHERE user_id = ${userId}`);
            await tx.execute(sql`DELETE FROM messages WHERE sender_id = ${userId} OR receiver_id = ${userId} OR deleted_for_user_id = ${userId}`);
            await tx.execute(sql`DELETE FROM typing_status WHERE user_id = ${userId}`);
            await tx.execute(sql`DELETE FROM video_calls WHERE initiator_id = ${userId} OR receiver_id = ${userId}`);
            await tx.execute(sql`DELETE FROM matches WHERE user_id_1 = ${userId} OR user_id_2 = ${userId}`);
            await tx.execute(sql`DELETE FROM swipe_history WHERE user_id = ${userId} OR target_user_id = ${userId}`);
            await tx.execute(sql`DELETE FROM compatibility_analysis WHERE user1_id = ${userId} OR user2_id = ${userId}`);
            await tx.execute(sql`DELETE FROM suite_compatibility_scores WHERE user_id = ${userId} OR target_user_id = ${userId}`);
            await tx.execute(sql`DELETE FROM suite_mentorship_compatibility_scores WHERE user_id = ${userId} OR target_user_id = ${userId}`);
            await tx.execute(sql`DELETE FROM suite_networking_connections WHERE user_id = ${userId} OR target_user_id = ${userId}`);
            await tx.execute(sql`DELETE FROM suite_mentorship_connections WHERE user_id = ${userId} OR target_user_id = ${userId}`);
            await tx.execute(sql`DELETE FROM suite_job_applications WHERE user_id = ${userId} OR target_user_id = ${userId}`);
            await tx.execute(sql`DELETE FROM suite_message_reactions WHERE user_id = ${userId}`);
            await tx.execute(sql`DELETE FROM suite_messages WHERE sender_id = ${userId} OR receiver_id = ${userId}`);
            await tx.execute(sql`DELETE FROM professional_reviews WHERE user_id = ${userId} OR target_user_id = ${userId}`);
            await tx.execute(sql`DELETE FROM user_report_strikes WHERE reporter_user_id = ${userId} OR reported_user_id = ${userId}`);
            await tx.execute(sql`DELETE FROM user_photos WHERE user_id = ${userId}`);
            await tx.execute(sql`DELETE FROM user_preferences WHERE user_id = ${userId}`);
            await tx.execute(sql`DELETE FROM user_interests WHERE user_id = ${userId}`);
            await tx.execute(sql`DELETE FROM user_match_settings WHERE user_id = ${userId}`);
            await tx.execute(sql`DELETE FROM user_auto_delete_settings WHERE user_id = ${userId}`);
            await tx.execute(sql`DELETE FROM connections_preferences WHERE user_id = ${userId}`);
            await tx.execute(sql`DELETE FROM suite_job_profiles WHERE user_id = ${userId}`);
            await tx.execute(sql`DELETE FROM suite_mentorship_profiles WHERE user_id = ${userId}`);
            await tx.execute(sql`DELETE FROM suite_networking_profiles WHERE user_id = ${userId}`);
            await tx.execute(sql`DELETE FROM suite_profile_settings WHERE user_id = ${userId}`);
            await tx.execute(sql`DELETE FROM suite_field_visibility WHERE user_id = ${userId}`);
            await tx.execute(sql`DELETE FROM global_interests WHERE created_by = ${userId}`);
            await tx.execute(sql`DELETE FROM global_deal_breakers WHERE created_by = ${userId}`);
            if (userPhone) {
              await tx.execute(sql`DELETE FROM verification_codes WHERE phone_number = ${userPhone}`);
            }
            await tx.execute(sql`DELETE FROM users WHERE id = ${userId}`);
            console.log(`Successfully deleted user ${userId} and all related data using comprehensive SQL approach`);
          });
        } catch (error) {
          console.error(`Failed to delete user ${userId}:`, error);
          try {
            console.log(`Attempting simplified deletion for user ${userId}...`);
            await db.delete(users).where(eq(users.id, userId));
            console.log(`Successfully deleted user ${userId} with cascade`);
          } catch (simpleError) {
            console.error(`Both deletion methods failed for user ${userId}:`, simpleError);
            throw new Error(`Cannot delete user: Database constraints prevent deletion`);
          }
        }
      }
      async cleanAllUsers() {
        await db.delete(messages);
        await db.delete(matches);
        await db.delete(userPreferences);
        await db.delete(userInterests);
        await db.delete(typingStatus);
        await db.delete(videoCalls);
        await db.delete(verificationCodes);
        await db.delete(userPhotos);
        await db.delete(globalInterests);
        await db.delete(users);
        console.log(
          "All users and related data have been deleted from the database"
        );
      }
      // Preferences operations
      async getUserPreferences(userId) {
        try {
          const [preference] = await db.select().from(userPreferences).where(eq(userPreferences.userId, userId));
          return preference;
        } catch (error) {
          console.error(`Error getting preferences for user ${userId}:`, error);
          return void 0;
        }
      }
      //  PERFORMANCE OPTIMIZATION: Batch load user preferences
      async batchGetUserPreferences(userIds) {
        try {
          if (userIds.length === 0) return [];
          const startTime = Date.now();
          const preferences = await db.select().from(userPreferences).where(inArray(userPreferences.userId, userIds));
          const duration = Date.now() - startTime;
          console.log(`[BATCH-PERFORMANCE] Loaded ${preferences.length} preferences for ${userIds.length} users in ${duration}ms`);
          return preferences;
        } catch (error) {
          console.error(`Error batch getting preferences for users ${userIds}:`, error);
          return [];
        }
      }
      async createUserPreferences(preferences) {
        const [userPreference] = await db.insert(userPreferences).values(preferences).returning();
        return userPreference;
      }
      async updateUserPreferences(id, preferences) {
        const [updatedPreference] = await db.update(userPreferences).set(preferences).where(eq(userPreferences.id, id)).returning();
        return updatedPreference;
      }
      async updateUserLocationPreference(userId, location) {
        let userPrefs = await this.getUserPreferences(userId);
        if (userPrefs) {
          await this.updateUserPreferences(userPrefs.id, {
            locationPreference: location
          });
        } else {
          await this.createUserPreferences({
            userId,
            locationPreference: location,
            minAge: 18,
            maxAge: 35,
            distancePreference: 50
          });
        }
      }
      async updateUserPoolCountry(userId, poolCountry) {
        let userPrefs = await this.getUserPreferences(userId);
        if (userPrefs) {
          return await this.updateUserPreferences(userPrefs.id, {
            poolCountry
          });
        } else {
          return await this.createUserPreferences({
            userId,
            poolCountry,
            minAge: 18,
            maxAge: 35,
            distancePreference: 50
          });
        }
      }
      async updateUserAppSpecificPoolCountry(userId, poolCountry, appMode) {
        let userPrefs = await this.getUserPreferences(userId);
        const updateData = {};
        if (appMode === "MEET") {
          updateData.meetPoolCountry = poolCountry;
        } else {
          updateData.suitePoolCountry = poolCountry;
        }
        if (userPrefs) {
          return await this.updateUserPreferences(userPrefs.id, updateData);
        } else {
          const newPreferences = {
            userId,
            minAge: 18,
            maxAge: 35,
            distancePreference: 50,
            meetPoolCountry: appMode === "MEET" ? poolCountry : "ANYWHERE",
            suitePoolCountry: appMode === "SUITE" ? poolCountry : "ANYWHERE",
            poolCountry
            // Also set legacy field for compatibility
          };
          return await this.createUserPreferences(newPreferences);
        }
      }
      // Match operations
      async createMatch(match) {
        const existingMatch = await this.getMatchBetweenUsers(
          match.userId1,
          match.userId2
        );
        if (existingMatch) {
          return existingMatch;
        }
        const [newMatch2] = await db.insert(matches).values({
          ...match,
          matched: match.matched ?? false,
          hasUnreadMessages1: false,
          hasUnreadMessages2: false,
          notifiedUser1: false,
          notifiedUser2: false,
          metadata: match.metadata || null,
          createdAt: /* @__PURE__ */ new Date()
        }).returning();
        if (newMatch2.matched) {
          console.log(`[SWIPE-CLEANUP] Starting cleanup for CREATED match between users ${newMatch2.userId1} and ${newMatch2.userId2}`);
          try {
            await this.removeMatchedUsersFromSwipeHistory(newMatch2.userId1, newMatch2.userId2);
          } catch (cleanupError) {
            console.error(`[SWIPE-CLEANUP] Failed for CREATED match ${newMatch2.id}:`, cleanupError);
          }
        }
        return newMatch2;
      }
      async getMatchById(id) {
        const [match] = await db.select().from(matches).where(eq(matches.id, id));
        return match;
      }
      async getMatchesByUserId(userId) {
        return await db.select().from(matches).where(
          and(
            // User is in the match
            or(eq(matches.userId1, userId), eq(matches.userId2, userId)),
            // No blocking exists between users (bidirectional check)
            notExists(
              db.select().from(userBlocks).where(
                or(
                  // Current user hasn't blocked the other user
                  and(
                    eq(userBlocks.blockerUserId, userId),
                    or(
                      eq(userBlocks.blockedUserId, matches.userId1),
                      eq(userBlocks.blockedUserId, matches.userId2)
                    )
                  ),
                  // Other user hasn't blocked current user
                  and(
                    or(
                      eq(userBlocks.blockerUserId, matches.userId1),
                      eq(userBlocks.blockerUserId, matches.userId2)
                    ),
                    eq(userBlocks.blockedUserId, userId)
                  )
                )
              )
            )
          )
        );
      }
      // Get only MEET-originated matches (excludes SUITE matches) and blocked users
      async getMeetMatchesByUserId(userId) {
        return await db.select().from(matches).where(
          and(
            or(eq(matches.userId1, userId), eq(matches.userId2, userId)),
            or(
              isNull(matches.metadata),
              // Legacy MEET matches without metadata
              sql`${matches.metadata}::jsonb->>'suiteType' IS NULL`
              // Explicit MEET matches
            ),
            // No blocking exists between users (bidirectional check)
            notExists(
              db.select().from(userBlocks).where(
                or(
                  // Current user hasn't blocked the other user
                  and(
                    eq(userBlocks.blockerUserId, userId),
                    or(
                      eq(userBlocks.blockedUserId, matches.userId1),
                      eq(userBlocks.blockedUserId, matches.userId2)
                    )
                  ),
                  // Other user hasn't blocked current user
                  and(
                    or(
                      eq(userBlocks.blockerUserId, matches.userId1),
                      eq(userBlocks.blockerUserId, matches.userId2)
                    ),
                    eq(userBlocks.blockedUserId, userId)
                  )
                )
              )
            )
          )
        );
      }
      async getMatchBetweenUsers(userId1, userId2) {
        const [match] = await db.select().from(matches).where(
          or(
            and(eq(matches.userId1, userId1), eq(matches.userId2, userId2)),
            and(eq(matches.userId1, userId2), eq(matches.userId2, userId1))
          )
        );
        return match;
      }
      async getAllMatchesBetweenUsers(userId1, userId2) {
        const allMatches = await db.select().from(matches).where(
          or(
            and(eq(matches.userId1, userId1), eq(matches.userId2, userId2)),
            and(eq(matches.userId1, userId2), eq(matches.userId2, userId1))
          )
        ).orderBy(desc(matches.id));
        return allMatches;
      }
      async updateMatchStatus(matchId, matched) {
        const [updatedMatch] = await db.update(matches).set({
          matched,
          // Reset notification flags when updating match status
          notifiedUser1: false,
          notifiedUser2: false
        }).where(eq(matches.id, matchId)).returning();
        return updatedMatch;
      }
      async removeLikeOrDislike(userId, targetUserId) {
        const match = await this.getMatchBetweenUsers(userId, targetUserId);
        if (match) {
          await db.delete(matches).where(eq(matches.id, match.id));
          console.log(
            `Removed match ${match.id} between users ${userId} and ${targetUserId}`
          );
        } else {
          console.log(
            `No match found between users ${userId} and ${targetUserId} to remove`
          );
        }
      }
      // Get matches created after a specific timestamp for a user
      async getMatchesSince(userId, since) {
        return await db.select().from(matches).where(
          and(
            or(eq(matches.userId1, userId), eq(matches.userId2, userId)),
            sql`${matches.createdAt} > ${since}`
          )
        ).orderBy(desc(matches.createdAt));
      }
      // Get count of unread message notifications for a user (total unread messages)
      async getUnreadMessageCount(userId) {
        try {
          console.log(`[UNREAD-OPTIMIZED] User ${userId}: Starting optimized unread count query`);
          const startTime = Date.now();
          const [result] = await db.select({
            unreadCount: sql`COUNT(*)`
          }).from(messages).innerJoin(matches, eq(messages.matchId, matches.id)).where(
            and(
              eq(messages.receiverId, userId),
              eq(messages.read, false),
              or(
                and(eq(matches.userId1, userId), eq(matches.hasUnreadMessages1, true)),
                and(eq(matches.userId2, userId), eq(matches.hasUnreadMessages2, true))
              )
            )
          );
          const duration = Date.now() - startTime;
          const unreadCount = Number(result?.unreadCount) || 0;
          console.log(`[UNREAD-OPTIMIZED] User ${userId}: Query completed in ${duration}ms, found ${unreadCount} unread messages`);
          return unreadCount;
        } catch (error) {
          console.error("Error getting unread message count:", error);
          return 0;
        }
      }
      // Get count of conversations with unread messages for navigation badge - OPTIMIZED VERSION
      async getUnreadConversationsCount(userId) {
        try {
          const result = await db.execute(sql`
        SELECT COUNT(DISTINCT msg.match_id) AS unread_conversation_count
        FROM messages msg
        JOIN matches m ON msg.match_id = m.id
        WHERE msg.receiver_id = ${userId}
          AND msg.sender_id <> ${userId}
          AND msg.read = FALSE
          AND ((m.user_id_1 = ${userId} AND m.has_unread_messages_1 = TRUE)
            OR (m.user_id_2 = ${userId} AND m.has_unread_messages_2 = TRUE))
      `);
          const rows = result.rows;
          if (rows && rows.length > 0 && rows[0].unread_conversation_count !== void 0) {
            return Number(rows[0].unread_conversation_count);
          }
          console.log(
            "Falling back to original unread conversations count implementation"
          );
          const userMatches = await this.getMatchesByUserId(userId);
          let conversationsWithUnread = 0;
          for (const match of userMatches) {
            if (match.userId1 === userId && match.hasUnreadMessages1 || match.userId2 === userId && match.hasUnreadMessages2) {
              const matchMessages = await this.getMessagesByMatchId(match.id);
              const hasUnreadFromOther = matchMessages.some(
                (message) => message.receiverId === userId && message.senderId !== userId && !message.read
              );
              if (hasUnreadFromOther) {
                conversationsWithUnread++;
              }
            }
          }
          return conversationsWithUnread;
        } catch (error) {
          console.error("Error getting unread conversations count:", error);
          return 0;
        }
      }
      // Mark a match as having unread messages for the receiver
      async markMatchUnread(matchId, receiverId) {
        const match = await this.getMatchById(matchId);
        if (!match) return void 0;
        let updateFields = {};
        if (match.userId1 === receiverId) {
          updateFields = { hasUnreadMessages1: true, lastMessageAt: /* @__PURE__ */ new Date() };
        } else if (match.userId2 === receiverId) {
          updateFields = { hasUnreadMessages2: true, lastMessageAt: /* @__PURE__ */ new Date() };
        }
        const [updatedMatch] = await db.update(matches).set(updateFields).where(eq(matches.id, matchId)).returning();
        return updatedMatch;
      }
      // Mark a match as read for a specific user
      async markMatchRead(matchId, userId) {
        const match = await this.getMatchById(matchId);
        if (!match) return void 0;
        let updateFields = {};
        if (match.userId1 === userId) {
          updateFields = { hasUnreadMessages1: false };
        } else if (match.userId2 === userId) {
          updateFields = { hasUnreadMessages2: false };
        }
        const [updatedMatch] = await db.update(matches).set(updateFields).where(eq(matches.id, matchId)).returning();
        return updatedMatch;
      }
      // Mark match notification as delivered for a user
      async markMatchNotified(matchId, userId) {
        const match = await this.getMatchById(matchId);
        if (!match) return void 0;
        let updateFields = {};
        if (match.userId1 === userId) {
          updateFields = { notifiedUser1: true };
        } else if (match.userId2 === userId) {
          updateFields = { notifiedUser2: true };
        }
        const [updatedMatch] = await db.update(matches).set(updateFields).where(eq(matches.id, matchId)).returning();
        return updatedMatch;
      }
      async updateMatch(id, updates) {
        const updateFields = {
          ...updates,
          // When a match is confirmed, reset notification status
          ...updates.matched ? {
            notifiedUser1: false,
            notifiedUser2: false,
            hasUnreadMessages1: true,
            // Set unread for both users to show notification badge
            hasUnreadMessages2: true,
            isDislike: false
            // A confirmed match can't be a dislike
          } : {}
        };
        if (updates.metadata !== void 0) {
          updateFields.metadata = updates.metadata;
        }
        const [updatedMatch] = await db.update(matches).set(updateFields).where(eq(matches.id, id)).returning();
        if (updatedMatch && updates.matched) {
          console.log(`[SWIPE-CLEANUP] Starting cleanup for UPDATED match ${updatedMatch.id} between users ${updatedMatch.userId1} and ${updatedMatch.userId2}`);
          try {
            await this.removeMatchedUsersFromSwipeHistory(updatedMatch.userId1, updatedMatch.userId2);
          } catch (cleanupError) {
            console.error(`[SWIPE-CLEANUP] Failed for UPDATED match ${updatedMatch.id}:`, cleanupError);
          }
        }
        return updatedMatch;
      }
      async deleteMatch(id) {
        await db.delete(messages).where(eq(messages.matchId, id));
        await db.delete(matches).where(eq(matches.id, id));
      }
      // Message operations with duplicate prevention
      async createMessage(message) {
        const recentTime = /* @__PURE__ */ new Date();
        recentTime.setSeconds(recentTime.getSeconds() - 2);
        try {
          const existingMessages = await db.select().from(messages).where(
            and(
              eq(messages.matchId, message.matchId),
              eq(messages.senderId, message.senderId),
              eq(messages.receiverId, message.receiverId),
              eq(messages.content, message.content),
              sql`${messages.createdAt} >= ${recentTime.toISOString()}`
            )
          ).limit(1);
          if (existingMessages.length > 0) {
            console.log(
              `[DOUBLE-PREVENTION] Prevented duplicate message: ${message.content} (already exists as ID ${existingMessages[0].id})`
            );
            await this.markMatchUnread(message.matchId, message.receiverId);
            return existingMessages[0];
          }
        } catch (error) {
          console.error("Error checking for duplicate messages:", error);
        }
        const [newMessage] = await db.insert(messages).values({
          ...message,
          messageType: message.messageType || "text",
          // Default to text if not specified
          read: false,
          createdAt: /* @__PURE__ */ new Date()
        }).returning();
        await this.markMatchUnread(message.matchId, message.receiverId);
        return newMessage;
      }
      /**
       * Gets a single message by its unique ID
       * Used for security validation in message operations
       */
      async getMessageById(id) {
        const [message] = await db.select().from(messages).where(eq(messages.id, id));
        return message;
      }
      /**
       * Retrieves messages for a specific match, with additional security validation
       * to ensure messages are only accessible to users who are part of the match
       * Also filters out messages that have been auto-deleted for the requesting user
       */
      async getMessagesByMatchId(matchId, userId) {
        if (userId) {
          const match = await this.getMatchById(matchId);
          if (!match || match.userId1 !== userId && match.userId2 !== userId) {
            console.warn(
              `Security: User ${userId} attempted to access messages for match ${matchId} they're not part of`
            );
            return [];
          }
        }
        const allMessages = await db.select().from(messages).where(eq(messages.matchId, matchId)).orderBy(asc(messages.createdAt));
        let filteredMessages = allMessages;
        if (userId) {
          filteredMessages = allMessages.filter((message) => {
            if (message.deletedForUserId === userId) {
              return false;
            }
            return true;
          });
        }
        const transformedMessages = filteredMessages.map((message) => {
          const transformedMessage = { ...message };
          if (message.replyToMessageId && message.replyToContent && message.replyToSenderName) {
            let isCurrentUser = false;
            if (userId && message.replyToMessageId) {
              const originalMessage = allMessages.find(
                (m) => m.id === message.replyToMessageId
              );
              if (originalMessage) {
                isCurrentUser = originalMessage.senderId === userId;
                console.log(
                  `\u{1F504} [REPLY-TRANSFORM] Message ${message.id} "${message.content}"`
                );
                console.log(
                  `   \u{1F4E7} Replying to message ${message.replyToMessageId} "${message.replyToContent}"`
                );
                console.log(
                  `   \u{1F464} Original message sender: ${originalMessage.senderId}, Current viewer: ${userId}`
                );
                console.log(
                  `   \u{1F3AF} isCurrentUser = ${isCurrentUser} (should show "${isCurrentUser ? "You" : message.replyToSenderName}")`
                );
                console.log(
                  `   \u{1F4DD} Stored senderName: "${message.replyToSenderName}"`
                );
              } else {
                console.log(
                  `\u26A0\uFE0F [REPLY-TRANSFORM] Could not find original message ${message.replyToMessageId} for reply`
                );
              }
            }
            transformedMessage.replyToMessage = {
              id: message.replyToMessageId,
              content: message.replyToContent,
              senderName: message.replyToSenderName,
              isCurrentUser
              // Now correctly calculated from viewer's perspective
            };
          }
          return transformedMessage;
        });
        return transformedMessages;
      }
      /**
       * Get the count of messages for a specific match
       * Used to determine if a match can be deleted during undo operations
       */
      async getMessageCountForMatch(matchId) {
        const messageCount = await db.select({ count: count() }).from(messages).where(eq(messages.matchId, matchId));
        return messageCount[0]?.count || 0;
      }
      async markMessageAsRead(id) {
        const [updatedMessage] = await db.update(messages).set({ read: true }).where(eq(messages.id, id)).returning();
        if (updatedMessage) {
          const match = await this.getMatchById(updatedMessage.matchId);
          if (match) {
            if (match.userId1 === updatedMessage.receiverId) {
              await this.markMatchRead(match.id, match.userId1);
            } else if (match.userId2 === updatedMessage.receiverId) {
              await this.markMatchRead(match.id, match.userId2);
            }
          }
        }
        return updatedMessage;
      }
      // Find recent duplicate messages to prevent re-sending the same message multiple times
      async findRecentDuplicateMessages(params) {
        const {
          matchId,
          senderId,
          content,
          messageType,
          since,
          caseInsensitive = false
        } = params;
        try {
          let messagesQuery = db.select().from(messages).where(
            and(
              eq(messages.matchId, matchId),
              eq(messages.senderId, senderId),
              eq(messages.messageType, messageType || "text"),
              sql`${messages.createdAt} >= ${since}`
            )
          ).orderBy(desc(messages.createdAt));
          const allMessages = await messagesQuery;
          if (caseInsensitive) {
            console.log(
              `[CASE-INSENSITIVE] Checking for duplicates of "${content}" with case-insensitive matching`
            );
            const trimmedLowerContent = content.trim().toLowerCase();
            const duplicates = allMessages.filter((msg) => {
              const msgContent = msg.content.trim().toLowerCase();
              return msgContent === trimmedLowerContent;
            });
            console.log(
              `[CASE-INSENSITIVE] Found ${duplicates.length} case-insensitive matches for "${content}"`
            );
            return duplicates;
          } else {
            return allMessages.filter((msg) => msg.content === content);
          }
        } catch (error) {
          console.error("Error finding duplicate messages:", error);
          return [];
        }
      }
      // Case-insensitive functionality has been merged into findRecentDuplicateMessages with the caseInsensitive parameter
      async markMessageAsReadWithTimestamp(id) {
        const [updatedMessage] = await db.update(messages).set({
          read: true,
          readAt: /* @__PURE__ */ new Date()
        }).where(eq(messages.id, id)).returning();
        if (updatedMessage) {
          const match = await this.getMatchById(updatedMessage.matchId);
          if (match) {
            if (match.userId1 === updatedMessage.receiverId) {
              await this.markMatchRead(match.id, match.userId1);
            } else if (match.userId2 === updatedMessage.receiverId) {
              await this.markMatchRead(match.id, match.userId2);
            }
          }
        }
        return updatedMessage;
      }
      // User interests operations
      async addUserInterest(interest) {
        const interestWithDefaults = {
          ...interest,
          showOnProfile: interest.showOnProfile !== void 0 ? interest.showOnProfile : true
        };
        const [userInterest] = await db.insert(userInterests).values(interestWithDefaults).returning();
        await this.updateUserInterestsJson(interest.userId);
        return userInterest;
      }
      // Helper method to sync interests to users table JSON column
      async updateUserInterestsJson(userId) {
        const userInterestsList = await this.getUserInterests(userId);
        const interestNames = userInterestsList.map((ui) => ui.interest);
        await db.update(users).set({ interests: JSON.stringify(interestNames) }).where(eq(users.id, userId));
      }
      async getUserInterests(userId) {
        return await db.select().from(userInterests).where(eq(userInterests.userId, userId));
      }
      async deleteAllUserInterests(userId) {
        await db.delete(userInterests).where(eq(userInterests.userId, userId));
        await this.updateUserInterestsJson(userId);
      }
      async deleteUserInterest(userId, interest) {
        await db.delete(userInterests).where(
          and(
            eq(userInterests.userId, userId),
            eq(userInterests.interest, interest)
          )
        );
        await this.updateUserInterestsJson(userId);
      }
      async updateUserInterestsVisibility(userId, showOnProfile) {
        await db.update(userInterests).set({ showOnProfile }).where(eq(userInterests.userId, userId));
      }
      // Global interests operations
      async addGlobalInterest(interest) {
        const [globalInterest] = await db.insert(globalInterests).values({
          ...interest,
          createdAt: /* @__PURE__ */ new Date()
        }).returning();
        return globalInterest;
      }
      async getAllGlobalInterests() {
        return await db.select().from(globalInterests).orderBy(asc(globalInterests.interest));
      }
      async getGlobalInterestByName(interest) {
        const [globalInterest] = await db.select().from(globalInterests).where(eq(globalInterests.interest, interest));
        return globalInterest;
      }
      // Global deal breakers operations
      async addGlobalDealBreaker(dealBreaker) {
        const [globalDealBreaker] = await db.insert(globalDealBreakers).values({
          ...dealBreaker,
          createdAt: /* @__PURE__ */ new Date()
        }).returning();
        return globalDealBreaker;
      }
      async getAllGlobalDealBreakers() {
        return await db.select().from(globalDealBreakers).orderBy(asc(globalDealBreakers.dealBreaker));
      }
      async getGlobalDealBreakerByName(dealBreaker) {
        const [globalDealBreaker] = await db.select().from(globalDealBreakers).where(eq(globalDealBreakers.dealBreaker, dealBreaker));
        return globalDealBreaker;
      }
      // Global tribes operations
      async addGlobalTribe(tribe) {
        const [globalTribe] = await db.insert(globalTribes).values({
          ...tribe,
          createdAt: /* @__PURE__ */ new Date()
        }).returning();
        return globalTribe;
      }
      async getAllGlobalTribes() {
        return await db.select().from(globalTribes).orderBy(asc(globalTribes.tribe));
      }
      async getGlobalTribeByName(tribe) {
        const [globalTribe] = await db.select().from(globalTribes).where(eq(globalTribes.tribe, tribe));
        return globalTribe;
      }
      // Global religions operations
      async addGlobalReligion(religion) {
        const [globalReligion] = await db.insert(globalReligions).values({
          ...religion,
          createdAt: /* @__PURE__ */ new Date()
        }).returning();
        return globalReligion;
      }
      async getAllGlobalReligions() {
        return await db.select().from(globalReligions).orderBy(asc(globalReligions.religion));
      }
      async getGlobalReligionByName(religion) {
        const [globalReligion] = await db.select().from(globalReligions).where(eq(globalReligions.religion, religion));
        return globalReligion;
      }
      // Get all users for discover page (optimized approach - faster queries, separate interests fetch)
      async getDiscoverUsers(userId) {
        try {
          const startTime = Date.now();
          const existingInteractions = await db.select({ targetUserId: matches.userId2 }).from(matches).where(
            and(
              eq(matches.userId1, userId),
              or(
                isNull(matches.metadata),
                // Legacy MEET matches
                sql`${matches.metadata}::jsonb->>'suiteType' IS NULL`,
                // Explicit MEET matches
                sql`${matches.metadata}::jsonb->'additionalConnections' ? 'MEET'`
                // SUITE matches with MEET added
              )
            )
          ).union(
            db.select({ targetUserId: matches.userId1 }).from(matches).where(
              and(
                eq(matches.userId2, userId),
                or(
                  isNull(matches.metadata),
                  sql`${matches.metadata}::jsonb->>'suiteType' IS NULL`,
                  sql`${matches.metadata}::jsonb->'additionalConnections' ? 'MEET'`
                )
              )
            )
          );
          const excludeUserIds = existingInteractions.map((row) => row.targetUserId);
          excludeUserIds.push(userId);
          const swipeHistoryUsers = await db.select({ targetUserId: swipeHistory.targetUserId }).from(swipeHistory).where(
            and(
              eq(swipeHistory.userId, userId),
              eq(swipeHistory.appMode, "MEET")
            )
          );
          const swipeHistoryUserIds = swipeHistoryUsers.map((row) => row.targetUserId);
          excludeUserIds.push(...swipeHistoryUserIds);
          const discoverUsers = await db.select().from(users).where(
            and(
              notInArray(users.id, excludeUserIds.length > 0 ? excludeUserIds : [0]),
              // Exclude users with MEET interactions
              eq(users.profileHidden, false)
              // Only visible profiles
            )
          ).orderBy(desc(users.lastActive)).limit(50);
          const usersWithoutPasswords = discoverUsers.map((user) => {
            const { password, ...userWithoutPassword } = user;
            return {
              ...userWithoutPassword,
              visibleInterests: []
              // Empty for speed
            };
          });
          const duration = Date.now() - startTime;
          console.log(`[DISCOVER-FILTERED] User ${userId}: Query completed in ${duration}ms, excluded ${excludeUserIds.length} users, returning ${usersWithoutPasswords.length} users`);
          return usersWithoutPasswords;
        } catch (error) {
          console.error("Error in filtered getDiscoverUsers:", error);
          return [];
        }
      }
      // Potential matches
      async getPotentialMatches(userId) {
        const userMatches = await this.getMeetMatchesByUserId(userId);
        const matchedUserIds = userMatches.map(
          (match) => match.userId1 === userId ? match.userId2 : match.userId1
        );
        let potentialUsers = [];
        if (matchedUserIds.length > 0) {
          const conditions = matchedUserIds.map((matchId) => ne(users.id, matchId));
          conditions.push(ne(users.id, userId));
          potentialUsers = await db.select().from(users).where(and(...conditions));
        } else {
          potentialUsers = await db.select().from(users).where(ne(users.id, userId));
        }
        if (potentialUsers.length > 0) {
          return potentialUsers;
        }
        const currentTime = /* @__PURE__ */ new Date();
        const testUsers = [
          {
            id: 1001,
            username: "kofi_accra",
            password: "hashed_password",
            // Not a real password since it's just for display
            fullName: "Kofi Mensah",
            email: "kofi.mensah@example.com",
            phoneNumber: "+233501234567",
            gender: "Male",
            location: "Accra, Ghana",
            countryOfOrigin: "Ghana",
            bio: "Software developer passionate about creating technologies that unite the Ghanaian diaspora. Love exploring coastal towns on weekends.",
            profession: "Software Engineer",
            ethnicity: "Ashanti",
            secondaryTribe: "Ga",
            religion: "Christian",
            photoUrl: "https://randomuser.me/api/portraits/men/32.jpg",
            showProfilePhoto: true,
            dateOfBirth: new Date(1992, 5, 15),
            relationshipStatus: "Single",
            relationshipGoal: "Long-term relationship",
            interests: JSON.stringify([
              "Technology",
              "Coastal towns",
              "Software development"
            ]),
            visibilityPreferences: JSON.stringify({
              residence: true,
              countryOfOrigin: true,
              tribe: true,
              profession: true,
              religion: true,
              bio: true,
              relationshipStatus: true,
              relationshipGoal: true,
              interests: true
            }),
            verifiedByPhone: true,
            twoFactorEnabled: true,
            profileHidden: false,
            ghostMode: false,
            isOnline: true,
            lastActive: currentTime,
            createdAt: currentTime,
            showAppModeSelection: true,
            showNationalitySelection: true,
            lastUsedApp: "dating"
          },
          {
            id: 1002,
            username: "abenaa_london",
            password: "hashed_password",
            fullName: "Abena Osei",
            email: "abena.osei@example.com",
            phoneNumber: "+447912345678",
            gender: "Female",
            location: "London, UK",
            countryOfOrigin: "Ghana",
            bio: "Medical doctor in London with roots in Ghana. Love cooking traditional Ghanaian meals and bringing people together through culture and food.",
            profession: "Medical Doctor",
            ethnicity: "Fante",
            secondaryTribe: "Ashanti",
            religion: "Christian",
            photoUrl: "https://randomuser.me/api/portraits/women/67.jpg",
            showProfilePhoto: true,
            dateOfBirth: new Date(1990, 2, 3),
            relationshipStatus: "Single",
            relationshipGoal: "Long-term relationship",
            interests: JSON.stringify(["Medicine", "Cooking", "Culture", "Food"]),
            visibilityPreferences: JSON.stringify({
              residence: true,
              countryOfOrigin: true,
              tribe: true,
              profession: true,
              religion: true,
              bio: true,
              relationshipStatus: true,
              relationshipGoal: true,
              interests: true
            }),
            verifiedByPhone: true,
            twoFactorEnabled: true,
            profileHidden: false,
            ghostMode: false,
            isOnline: false,
            lastActive: new Date(currentTime.getTime() - 60 * 60 * 1e3),
            // 1 hour ago
            createdAt: currentTime,
            showAppModeSelection: true,
            showNationalitySelection: true,
            lastUsedApp: "dating"
          },
          {
            id: 1003,
            username: "kwame_ny",
            password: "hashed_password",
            fullName: "Kwame Boateng",
            email: "kwame.boateng@example.com",
            phoneNumber: "+12125551234",
            gender: "Male",
            location: "New York, USA",
            countryOfOrigin: "Ghana",
            bio: "Fintech entrepreneur connecting Africa to global markets. Passionate about Ghanaian art and supporting talent from the motherland.",
            profession: "Entrepreneur",
            ethnicity: "Ga",
            secondaryTribe: "Ewe",
            religion: "Spiritual",
            photoUrl: "https://randomuser.me/api/portraits/men/59.jpg",
            showProfilePhoto: true,
            dateOfBirth: new Date(1988, 8, 22),
            relationshipStatus: "Single",
            relationshipGoal: "Serious dating",
            interests: JSON.stringify([
              "Fintech",
              "African art",
              "Entrepreneurship"
            ]),
            visibilityPreferences: JSON.stringify({
              residence: true,
              countryOfOrigin: true,
              tribe: true,
              profession: true,
              religion: true,
              bio: true,
              relationshipStatus: true,
              relationshipGoal: true,
              interests: true
            }),
            verifiedByPhone: true,
            twoFactorEnabled: true,
            profileHidden: false,
            ghostMode: false,
            isOnline: true,
            lastActive: currentTime,
            createdAt: currentTime,
            showAppModeSelection: true,
            showNationalitySelection: true,
            lastUsedApp: "dating"
          },
          {
            id: 1004,
            username: "adwoa_kumasi",
            password: "hashed_password",
            fullName: "Adwoa Asamoah",
            email: "adwoa.asamoah@example.com",
            phoneNumber: "+233261234567",
            gender: "Female",
            location: "Kumasi, Ghana",
            countryOfOrigin: "Ghana",
            bio: "Fashion designer blending traditional Kente with modern styles. Looking for someone who appreciates both tradition and innovation.",
            profession: "Fashion Designer",
            ethnicity: "Ashanti",
            secondaryTribe: "Fante",
            religion: "Christian",
            photoUrl: "https://randomuser.me/api/portraits/women/16.jpg",
            showProfilePhoto: true,
            dateOfBirth: new Date(1993, 11, 5),
            relationshipStatus: "Single",
            relationshipGoal: "Long-term relationship",
            interests: JSON.stringify(["Fashion", "Kente", "Design", "Tradition"]),
            visibilityPreferences: JSON.stringify({
              residence: true,
              countryOfOrigin: true,
              tribe: true,
              profession: true,
              religion: true,
              bio: true,
              relationshipStatus: true,
              relationshipGoal: true,
              interests: true
            }),
            verifiedByPhone: true,
            twoFactorEnabled: true,
            profileHidden: false,
            ghostMode: false,
            isOnline: true,
            lastActive: currentTime,
            createdAt: currentTime,
            showAppModeSelection: true,
            showNationalitySelection: true,
            lastUsedApp: "dating"
          },
          {
            id: 1005,
            username: "kwesi_toronto",
            password: "hashed_password",
            fullName: "Kwesi Adjei",
            email: "kwesi.adjei@example.com",
            phoneNumber: "+14165551234",
            gender: "Male",
            location: "Toronto, Canada",
            countryOfOrigin: "Ghana",
            bio: "University professor specializing in African diaspora studies. Love jazz music, contemporary art, and staying connected to my Ghanaian heritage.",
            profession: "Professor",
            ethnicity: "Ewe",
            secondaryTribe: "Ga",
            religion: "Spiritual",
            photoUrl: "https://randomuser.me/api/portraits/men/85.jpg",
            showProfilePhoto: true,
            dateOfBirth: new Date(1985, 3, 18),
            relationshipStatus: "Single",
            relationshipGoal: "Serious dating",
            interests: JSON.stringify([
              "Jazz",
              "Art",
              "African diaspora",
              "Academia"
            ]),
            visibilityPreferences: JSON.stringify({
              residence: true,
              countryOfOrigin: true,
              tribe: true,
              profession: true,
              religion: true,
              bio: true,
              relationshipStatus: true,
              relationshipGoal: true,
              interests: true
            }),
            verifiedByPhone: true,
            twoFactorEnabled: true,
            profileHidden: false,
            ghostMode: false,
            isOnline: false,
            lastActive: new Date(currentTime.getTime() - 120 * 60 * 1e3),
            // 2 hours ago
            createdAt: currentTime,
            showAppModeSelection: true,
            showNationalitySelection: true,
            lastUsedApp: "dating"
          }
        ];
        return testUsers;
      }
      // User online status
      async updateUserOnlineStatus(userId, isOnline) {
        if (userId === null) return void 0;
        const user = await this.getUser(userId);
        if (!user) return void 0;
        const visibleOnlineStatus = user.ghostMode ? false : isOnline;
        const updateData = {
          isOnline: visibleOnlineStatus,
          lastActive: /* @__PURE__ */ new Date()
        };
        const [updatedUser] = await db.update(users).set(updateData).where(eq(users.id, userId)).returning();
        return updatedUser;
      }
      async getUserOnlineStatus(userId) {
        if (userId === null) return false;
        const user = await this.getUser(userId);
        if (!user) return false;
        if (user.ghostMode) return false;
        return user.isOnline || false;
      }
      // Typing status
      async updateTypingStatus(userId, matchId, isTyping) {
        const user = await this.getUser(userId);
        if (!user) {
          throw new Error("User not found");
        }
        const visibleTypingStatus = user.ghostMode ? false : isTyping;
        const existingStatus = await db.select().from(typingStatus).where(
          and(eq(typingStatus.userId, userId), eq(typingStatus.matchId, matchId))
        );
        if (existingStatus.length > 0) {
          const [updatedStatus] = await db.update(typingStatus).set({
            isTyping: visibleTypingStatus,
            updatedAt: /* @__PURE__ */ new Date()
          }).where(
            and(
              eq(typingStatus.userId, userId),
              eq(typingStatus.matchId, matchId)
            )
          ).returning();
          return updatedStatus;
        } else {
          const [newStatus] = await db.insert(typingStatus).values({
            userId,
            matchId,
            isTyping: visibleTypingStatus,
            updatedAt: /* @__PURE__ */ new Date()
          }).returning();
          return newStatus;
        }
      }
      async getTypingStatus(matchId) {
        return await db.select().from(typingStatus).where(eq(typingStatus.matchId, matchId));
      }
      // Video call operations
      async createVideoCall(videoCall) {
        const [newVideoCall] = await db.insert(videoCalls).values({
          ...videoCall,
          status: videoCall.status || "pending",
          createdAt: /* @__PURE__ */ new Date()
        }).returning();
        return newVideoCall;
      }
      async getVideoCallById(id) {
        const [videoCall] = await db.select().from(videoCalls).where(eq(videoCalls.id, id));
        return videoCall;
      }
      async updateVideoCallStatus(id, updates) {
        const [updatedVideoCall] = await db.update(videoCalls).set(updates).where(eq(videoCalls.id, id)).returning();
        return updatedVideoCall;
      }
      async getVideoCallsByUserId(userId) {
        return await db.select().from(videoCalls).where(
          or(
            eq(videoCalls.initiatorId, userId),
            eq(videoCalls.receiverId, userId)
          )
        );
      }
      // User photos operations for MEET dating app
      async addUserPhoto(photo) {
        if (photo.isPrimary) {
          await db.update(userPhotos).set({ isPrimary: false }).where(eq(userPhotos.userId, photo.userId));
        }
        const userPhotosCount = await db.select({ count: count() }).from(userPhotos).where(eq(userPhotos.userId, photo.userId));
        const isFirstPhoto = userPhotosCount.length === 0 || userPhotosCount[0].count === 0;
        const photoToInsert = {
          ...photo,
          isPrimary: isFirstPhoto ? true : photo.isPrimary
        };
        const [newPhoto] = await db.insert(userPhotos).values(photoToInsert).returning();
        if (newPhoto.isPrimary) {
          await this.updateUserProfile(photo.userId, {
            photoUrl: newPhoto.photoUrl
          });
        }
        return newPhoto;
      }
      async getUserPhotos(userId) {
        return await db.select().from(userPhotos).where(eq(userPhotos.userId, userId)).orderBy(desc(userPhotos.isPrimary), asc(userPhotos.createdAt));
      }
      async getUserPhotoById(id) {
        const [photo] = await db.select().from(userPhotos).where(eq(userPhotos.id, id));
        return photo;
      }
      async updateUserPhoto(id, updates) {
        try {
          const photo = await this.getUserPhotoById(id);
          if (!photo) return void 0;
          const [updatedPhoto] = await db.update(userPhotos).set({ photoUrl: updates.photoUrl }).where(eq(userPhotos.id, id)).returning();
          if (updatedPhoto.isPrimary) {
            await this.updateUserProfile(updatedPhoto.userId, {
              photoUrl: updates.photoUrl
            });
          }
          return updatedPhoto;
        } catch (error) {
          console.error(`Error updating photo ${id}:`, error);
          return void 0;
        }
      }
      // Note: Primary implementation of addUserPhoto is already defined above
      async deleteUserPhoto(id) {
        const [photo] = await db.select().from(userPhotos).where(eq(userPhotos.id, id));
        if (!photo) return;
        await db.delete(userPhotos).where(eq(userPhotos.id, id));
        if (photo.isPrimary) {
          const [anotherPhoto] = await db.select().from(userPhotos).where(eq(userPhotos.userId, photo.userId)).limit(1);
          if (anotherPhoto) {
            await this.setPrimaryPhoto(anotherPhoto.id, photo.userId);
          } else {
            await this.updateUserProfile(photo.userId, { photoUrl: null });
          }
        }
      }
      async setPrimaryPhoto(id, userId) {
        try {
          const [photo] = await db.select().from(userPhotos).where(and(eq(userPhotos.id, id), eq(userPhotos.userId, userId)));
          if (!photo) {
            throw new Error("Photo not found or does not belong to the user");
          }
          await db.update(userPhotos).set({ isPrimary: false }).where(eq(userPhotos.userId, userId));
          const [updatedPhoto] = await db.update(userPhotos).set({ isPrimary: true }).where(eq(userPhotos.id, id)).returning();
          if (updatedPhoto) {
            await this.updateUserProfile(userId, {
              photoUrl: updatedPhoto.photoUrl
            });
          }
          return updatedPhoto;
        } catch (error) {
          console.error(
            `Error setting primary photo (id: ${id} for user: ${userId}):`,
            error
          );
          throw error;
        }
      }
      // Section-specific primary photo management
      async updateSectionPrimaryPhoto(userId, photoId, section) {
        try {
          const [photo] = await db.select().from(userPhotos).where(and(eq(userPhotos.id, photoId), eq(userPhotos.userId, userId)));
          if (!photo) {
            return {
              success: false,
              error: "Photo not found or doesn't belong to user"
            };
          }
          const sectionFieldMap = {
            meet: "isPrimaryForMeet",
            job: "isPrimaryForJob",
            mentorship: "isPrimaryForMentorship",
            networking: "isPrimaryForNetworking"
          };
          const fieldName = sectionFieldMap[section];
          if (!fieldName) {
            return { success: false, error: "Invalid section" };
          }
          const resetUpdate = {};
          resetUpdate[fieldName] = false;
          await db.update(userPhotos).set(resetUpdate).where(eq(userPhotos.userId, userId));
          const setPrimaryUpdate = {};
          setPrimaryUpdate[fieldName] = true;
          await db.update(userPhotos).set(setPrimaryUpdate).where(eq(userPhotos.id, photoId));
          return { success: true };
        } catch (error) {
          console.error(`Error updating section primary photo:`, error);
          return { success: false, error: "Database error occurred" };
        }
      }
      async getUserPhotosWithSectionPrimary(userId, section) {
        return await db.select().from(userPhotos).where(eq(userPhotos.userId, userId)).orderBy(asc(userPhotos.createdAt));
      }
      async getSectionPrimaryPhoto(userId, section) {
        const sectionFieldMap = {
          meet: userPhotos.isPrimaryForMeet,
          job: userPhotos.isPrimaryForJob,
          mentorship: userPhotos.isPrimaryForMentorship,
          networking: userPhotos.isPrimaryForNetworking
        };
        const field = sectionFieldMap[section];
        if (!field) return void 0;
        const [photo] = await db.select().from(userPhotos).where(and(eq(userPhotos.userId, userId), eq(field, true))).limit(1);
        return photo;
      }
      // Get the lastActive timestamp for a user
      async getUserLastActive(userId) {
        if (userId === null) return null;
        const user = await this.getUser(userId);
        return user?.lastActive || null;
      }
      // Methods for chat activity status
      async updateActiveChatStatus(userId, matchId, isActive) {
        try {
          if (isActive) {
            const result = await db.execute(
              sql`INSERT INTO active_chats (user_id, match_id, is_active, updated_at) 
              VALUES (${userId}, ${matchId}, ${isActive}, NOW()) 
              ON CONFLICT (user_id, match_id) 
              DO UPDATE SET is_active = ${isActive}, updated_at = NOW()`
            );
          } else {
            await db.execute(
              sql`UPDATE active_chats 
              SET is_active = ${isActive}, updated_at = NOW() 
              WHERE user_id = ${userId} AND match_id = ${matchId}`
            );
          }
          return true;
        } catch (error) {
          console.error(
            `Error updating active chat status for user ${userId} in match ${matchId}:`,
            error
          );
          return false;
        }
      }
      async getActiveChatStatus(userId, matchId) {
        try {
          const result = await db.execute(
            sql`SELECT is_active FROM active_chats 
            WHERE user_id = ${userId} AND match_id = ${matchId} 
            AND is_active = true 
            AND updated_at > NOW() - INTERVAL '5 minutes'`
          );
          return result.rows.length > 0;
        } catch (error) {
          console.error(
            `Error getting active chat status for user ${userId} in match ${matchId}:`,
            error
          );
          return false;
        }
      }
      async getUsersInActiveChat(matchId) {
        try {
          const result = await db.execute(
            sql`SELECT user_id FROM active_chats 
            WHERE match_id = ${matchId} 
            AND is_active = true 
            AND updated_at > NOW() - INTERVAL '5 minutes'`
          );
          return result.rows.map((row) => Number(row.user_id));
        } catch (error) {
          console.error(
            `Error getting users in active chat for match ${matchId}:`,
            error
          );
          return [];
        }
      }
      // Message reactions methods
      async addMessageReaction(reaction) {
        try {
          console.log(
            `\u{1F504} [REACTION-DEBUG] Checking for existing reactions from user ${reaction.userId} on message ${reaction.messageId} with emoji ${reaction.emoji}`
          );
          const existingReactions = await db.select().from(messageReactions).where(
            and(
              eq(messageReactions.messageId, reaction.messageId),
              eq(messageReactions.userId, reaction.userId)
            )
          );
          console.log(
            `\u{1F50D} [REACTION-DEBUG] Found ${existingReactions.length} existing reactions:`,
            existingReactions.map((r) => `${r.emoji} (id: ${r.id})`)
          );
          if (existingReactions.length > 0) {
            console.log(
              `\u{1F5D1}\uFE0F [REACTION-DEBUG] Removing ${existingReactions.length} existing reaction(s) from user ${reaction.userId} on message ${reaction.messageId}`
            );
            const deleteResult = await db.delete(messageReactions).where(
              and(
                eq(messageReactions.messageId, reaction.messageId),
                eq(messageReactions.userId, reaction.userId)
              )
            ).returning();
            console.log(
              `\u2705 [REACTION-DEBUG] Successfully removed ${deleteResult.length} reaction(s). Now adding new reaction: ${reaction.emoji}`
            );
          } else {
            console.log(
              `\u2795 [REACTION-DEBUG] No existing reactions found. Adding first reaction: ${reaction.emoji}`
            );
          }
          const [newReaction] = await db.insert(messageReactions).values(reaction).returning();
          if (!newReaction) {
            throw new Error("Failed to insert new reaction");
          }
          console.log(
            `\u{1F389} Successfully added reaction ${reaction.emoji} for user ${reaction.userId} on message ${reaction.messageId}`
          );
          return newReaction;
        } catch (error) {
          console.error("Error adding message reaction:", error);
          throw error;
        }
      }
      async removeMessageReaction(messageId, userId, emoji) {
        try {
          await db.delete(messageReactions).where(
            and(
              eq(messageReactions.messageId, messageId),
              eq(messageReactions.userId, userId),
              eq(messageReactions.emoji, emoji)
            )
          );
        } catch (error) {
          console.error("Error removing message reaction:", error);
          throw error;
        }
      }
      async getMessageReactions(messageId) {
        try {
          return await db.select().from(messageReactions).where(eq(messageReactions.messageId, messageId)).orderBy(asc(messageReactions.createdAt));
        } catch (error) {
          console.error("Error getting message reactions:", error);
          return [];
        }
      }
      async getMessageReactionsByMatch(matchId) {
        try {
          return await db.select({
            id: messageReactions.id,
            messageId: messageReactions.messageId,
            userId: messageReactions.userId,
            emoji: messageReactions.emoji,
            createdAt: messageReactions.createdAt
          }).from(messageReactions).innerJoin(messages, eq(messageReactions.messageId, messages.id)).where(eq(messages.matchId, matchId)).orderBy(asc(messageReactions.createdAt));
        } catch (error) {
          console.error("Error getting message reactions by match:", error);
          return [];
        }
      }
      // Auto-delete functionality methods
      async getUserMatchSettings(userId, matchId) {
        try {
          const [settings] = await db.select().from(userMatchSettings).where(
            and(
              eq(userMatchSettings.userId, userId),
              eq(userMatchSettings.matchId, matchId)
            )
          );
          return settings;
        } catch (error) {
          console.error("Error getting user match settings:", error);
          return void 0;
        }
      }
      async updateUserMatchSettings(userId, matchId, settings) {
        try {
          const [updatedSettings] = await db.insert(userMatchSettings).values({
            userId,
            matchId,
            ...settings
          }).onConflictDoUpdate({
            target: [userMatchSettings.userId, userMatchSettings.matchId],
            set: {
              ...settings
            }
          }).returning();
          return updatedSettings;
        } catch (error) {
          console.error("Error updating user match settings:", error);
          throw error;
        }
      }
      async deleteMessagesForUser(userId, matchId) {
        try {
          const settings = await this.getUserMatchSettings(userId, matchId);
          if (!settings || settings.autoDeleteMode !== "always") {
            console.log(
              `No "always" mode deletion needed for user ${userId} in match ${matchId}`
            );
            return;
          }
          console.log(
            `Deleting messages for user ${userId} in match ${matchId} in "always" mode`
          );
          await db.update(messages).set({ deletedForUserId: userId }).where(
            and(
              eq(messages.matchId, matchId),
              or(eq(messages.senderId, userId), eq(messages.receiverId, userId))
            )
          );
          console.log(
            `Successfully marked messages as deleted for user ${userId} in match ${matchId}`
          );
        } catch (error) {
          console.error("Error deleting messages for user:", error);
          throw error;
        }
      }
      async scheduleMessageDeletion(messageId, deleteAt, mode) {
        try {
          await db.update(messages).set({
            autoDeleteScheduledAt: deleteAt,
            autoDeleteModeWhenSent: mode
          }).where(eq(messages.id, messageId));
        } catch (error) {
          console.error("Error scheduling message deletion:", error);
          throw error;
        }
      }
      async processAutoDeleteMessages() {
        try {
          const now = /* @__PURE__ */ new Date();
          const messagesToDelete = await db.select().from(messages).where(
            and(
              sql`${messages.autoDeleteScheduledAt} IS NOT NULL`,
              sql`${messages.autoDeleteScheduledAt} <= ${now.toISOString()}`
            )
          );
          for (const message of messagesToDelete) {
            if (message.autoDeleteModeWhenSent === "always") {
              await db.delete(messages).where(eq(messages.id, message.id));
            } else {
              await db.update(messages).set({ deletedForUserId: message.senderId }).where(eq(messages.id, message.id));
            }
          }
          console.log(`Processed ${messagesToDelete.length} auto-delete messages`);
        } catch (error) {
          console.error("Error processing auto-delete messages:", error);
        }
      }
      /**
       * Mark a message as deleted for a specific user (recipient-side deletion)
       * This allows recipients to hide messages from their view without affecting the sender
       */
      async markMessageAsDeletedForUser(messageId, userId) {
        try {
          await db.update(messages).set({ deletedForUserId: userId }).where(eq(messages.id, messageId));
          console.log(`Message ${messageId} marked as deleted for user ${userId}`);
        } catch (error) {
          console.error("Error marking message as deleted for user:", error);
          throw error;
        }
      }
      // ===================================
      // SUITE PROFILE SYSTEM METHODS
      // ===================================
      // ===== SUITE PROFILE SETTINGS =====
      async getSuiteProfileSettings(userId) {
        try {
          const [settings] = await db.select().from(suiteProfileSettings).where(eq(suiteProfileSettings.userId, userId));
          return settings;
        } catch (error) {
          console.error("Error getting SUITE profile settings:", error);
          return void 0;
        }
      }
      async updateSuiteProfileSettings(userId, settings) {
        try {
          const [updatedSettings] = await db.insert(suiteProfileSettings).values({
            userId,
            ...settings,
            updatedAt: /* @__PURE__ */ new Date()
          }).onConflictDoUpdate({
            target: [suiteProfileSettings.userId],
            set: {
              ...settings,
              updatedAt: /* @__PURE__ */ new Date()
            }
          }).returning();
          return updatedSettings;
        } catch (error) {
          console.error("Error updating SUITE profile settings:", error);
          throw error;
        }
      }
      // ===== JOB PROFILE METHODS =====
      async getSuiteJobProfile(userId) {
        try {
          const [jobProfile] = await db.select().from(suiteJobProfiles).where(
            and(
              eq(suiteJobProfiles.userId, userId),
              eq(suiteJobProfiles.isActive, true)
            )
          );
          return jobProfile;
        } catch (error) {
          console.error("Error getting job profile:", error);
          return void 0;
        }
      }
      async createOrUpdateSuiteJobProfile(userId, jobProfileData) {
        try {
          console.log("Creating/updating job profile for user:", userId);
          console.log("Job profile data:", jobProfileData);
          await db.update(suiteJobProfiles).set({ isActive: false, updatedAt: /* @__PURE__ */ new Date() }).where(eq(suiteJobProfiles.userId, userId));
          const [existingProfile] = await db.select().from(suiteJobProfiles).where(eq(suiteJobProfiles.userId, userId)).orderBy(sql`${suiteJobProfiles.createdAt} DESC`).limit(1);
          if (existingProfile) {
            const cleanData = { ...jobProfileData };
            delete cleanData.createdAt;
            delete cleanData.updatedAt;
            delete cleanData.id;
            const updateObject = {
              isActive: true,
              // Reactivate this profile
              updatedAt: /* @__PURE__ */ new Date()
            };
            Object.entries(cleanData).forEach(([key, value]) => {
              if (value !== null && value !== void 0) {
                updateObject[key] = value;
              }
            });
            console.log(
              "Storage layer: Updating most recent job profile with:",
              Object.keys(updateObject)
            );
            console.log("Storage layer: Update object:", updateObject);
            const [updatedProfile] = await db.update(suiteJobProfiles).set(updateObject).where(eq(suiteJobProfiles.id, existingProfile.id)).returning();
            if (updateObject.highSchool !== void 0 || updateObject.collegeUniversity !== void 0) {
              console.log("\u{1F4DA} [EDUCATION-SYNC] Syncing education fields to users table from job profile");
              const userUpdateData = {};
              if (updateObject.highSchool !== void 0) {
                userUpdateData.highSchool = updateObject.highSchool;
              }
              if (updateObject.collegeUniversity !== void 0) {
                userUpdateData.collegeUniversity = updateObject.collegeUniversity;
              }
              try {
                await db.update(users).set(userUpdateData).where(eq(users.id, userId));
                console.log("\u{1F4DA} [EDUCATION-SYNC] Successfully updated education fields in users table:", userUpdateData);
              } catch (syncError) {
                console.error("\u{1F4DA} [EDUCATION-SYNC] Failed to sync education fields to users table:", syncError);
              }
            }
            console.log("Updated job profile:", updatedProfile);
            return updatedProfile;
          } else {
            const defaultVisibilityPreferences = JSON.stringify({
              showProfilePhoto: true,
              jobTitle: true,
              location: true,
              workType: true,
              jobType: true,
              experienceLevel: true,
              skills: true,
              company: true,
              compensation: true,
              description: true,
              requirements: true,
              whyItMatters: true,
              whoShouldApply: true,
              culturalFit: true,
              areasOfExpertise: true,
              industryTags: true,
              applicationUrl: true,
              applicationEmail: true,
              applicationInstructions: true
            });
            const profileToInsert = {
              userId,
              role: jobProfileData.role,
              jobTitle: jobProfileData.jobTitle,
              description: jobProfileData.description,
              workType: jobProfileData.workType,
              jobType: jobProfileData.jobType,
              company: jobProfileData.company,
              compensation: jobProfileData.compensation,
              compensationCurrency: jobProfileData.compensationCurrency,
              compensationPeriod: jobProfileData.compensationPeriod,
              salary: jobProfileData.salary,
              salaryCurrency: jobProfileData.salaryCurrency,
              salaryPeriod: jobProfileData.salaryPeriod,
              requirements: jobProfileData.requirements,
              location: jobProfileData.location,
              experienceLevel: jobProfileData.experienceLevel,
              whyItMatters: jobProfileData.whyItMatters,
              whoShouldApply: jobProfileData.whoShouldApply,
              culturalFit: jobProfileData.culturalFit,
              areasOfExpertise: jobProfileData.areasOfExpertise,
              industryTags: jobProfileData.industryTags,
              skillTags: jobProfileData.skillTags,
              applicationUrl: jobProfileData.applicationUrl,
              applicationEmail: jobProfileData.applicationEmail,
              applicationInstructions: jobProfileData.applicationInstructions,
              expiresAt: jobProfileData.expiresAt,
              visibilityPreferences: jobProfileData.visibilityPreferences || defaultVisibilityPreferences,
              isActive: true
            };
            const [newProfile] = await db.insert(suiteJobProfiles).values(profileToInsert).returning();
            if (profileToInsert.highSchool || profileToInsert.collegeUniversity) {
              console.log("\u{1F4DA} [EDUCATION-SYNC] Syncing education fields to users table from new job profile");
              const userUpdateData = {};
              if (profileToInsert.highSchool) {
                userUpdateData.highSchool = profileToInsert.highSchool;
              }
              if (profileToInsert.collegeUniversity) {
                userUpdateData.collegeUniversity = profileToInsert.collegeUniversity;
              }
              try {
                await db.update(users).set(userUpdateData).where(eq(users.id, userId));
                console.log("\u{1F4DA} [EDUCATION-SYNC] Successfully updated education fields in users table:", userUpdateData);
              } catch (syncError) {
                console.error("\u{1F4DA} [EDUCATION-SYNC] Failed to sync education fields to users table:", syncError);
              }
            }
            console.log("Created new job profile:", newProfile);
            return newProfile;
          }
        } catch (error) {
          console.error("Error creating/updating job profile:", error);
          console.error("Error details:", error.message);
          throw error;
        }
      }
      async getDiscoveryJobProfiles(userId, limit, offset) {
        try {
          const jobProfiles = await db.select({
            // Job profile fields
            id: suiteJobProfiles.id,
            userId: suiteJobProfiles.userId,
            role: suiteJobProfiles.role,
            jobTitle: suiteJobProfiles.jobTitle,
            company: suiteJobProfiles.company,
            description: suiteJobProfiles.description,
            compensation: suiteJobProfiles.compensation,
            salary: suiteJobProfiles.salary,
            // Add missing salary field
            requirements: suiteJobProfiles.requirements,
            location: suiteJobProfiles.location,
            workType: suiteJobProfiles.workType,
            jobType: suiteJobProfiles.jobType,
            experienceLevel: suiteJobProfiles.experienceLevel,
            whyItMatters: suiteJobProfiles.whyItMatters,
            whoShouldApply: suiteJobProfiles.whoShouldApply,
            culturalFit: suiteJobProfiles.culturalFit,
            industryTags: suiteJobProfiles.industryTags,
            skillTags: suiteJobProfiles.skillTags,
            applicationUrl: suiteJobProfiles.applicationUrl,
            applicationEmail: suiteJobProfiles.applicationEmail,
            applicationInstructions: suiteJobProfiles.applicationInstructions,
            visibilityPreferences: suiteJobProfiles.visibilityPreferences,
            // Add missing visibility field
            isActive: suiteJobProfiles.isActive,
            expiresAt: suiteJobProfiles.expiresAt,
            createdAt: suiteJobProfiles.createdAt,
            updatedAt: suiteJobProfiles.updatedAt,
            // User fields
            user: {
              id: users.id,
              fullName: users.fullName,
              photoUrl: users.photoUrl,
              profession: users.profession,
              location: users.location,
              isVerified: users.isVerified
            }
          }).from(suiteJobProfiles).innerJoin(users, eq(suiteJobProfiles.userId, users.id)).innerJoin(
            suiteProfileSettings,
            eq(users.id, suiteProfileSettings.userId)
          ).where(
            and(
              ne(suiteJobProfiles.userId, userId),
              // Exclude current user
              eq(suiteJobProfiles.isActive, true),
              eq(suiteProfileSettings.hiddenInJobDiscovery, false),
              // COMPLETE BIDIRECTIONAL FILTERING: Use efficient SQL NOT EXISTS clauses like networking/mentorship
              // 1. Exclude profiles current user has already swiped on
              sql`NOT EXISTS (
              SELECT 1 FROM suite_job_applications sja1
              WHERE sja1.user_id = ${userId} 
              AND sja1.target_profile_id = suite_job_profiles.id
            )`,
              // 2. Exclude profiles owned by users who have already swiped on current user's profile
              sql`NOT EXISTS (
              SELECT 1 FROM suite_job_applications sja2
              WHERE sja2.user_id = suite_job_profiles.user_id 
              AND sja2.target_user_id = ${userId}
            )`,
              // 3. Exclude profiles for users in swipe history for SUITE_JOBS
              sql`NOT EXISTS (
              SELECT 1 FROM swipe_history sh
              WHERE sh.user_id = ${userId} 
              AND sh.target_user_id = suite_job_profiles.user_id
              AND sh.app_mode = 'SUITE_JOBS'
            )`,
              or(
                sql`${suiteJobProfiles.expiresAt} IS NULL`,
                sql`${suiteJobProfiles.expiresAt} > NOW()`
              )
            )
          ).orderBy(desc(suiteJobProfiles.createdAt)).limit(limit).offset(offset);
          const transformedProfiles = await Promise.all(
            jobProfiles.map(async (profile) => {
              let fieldVisibility = {};
              if (profile.visibilityPreferences) {
                try {
                  fieldVisibility = JSON.parse(profile.visibilityPreferences);
                } catch (error) {
                  console.error(
                    `Error parsing job visibility preferences for user ${profile.userId}:`,
                    error
                  );
                }
              }
              let jobPrimaryPhotoUrl = null;
              try {
                const jobPhotos = await db.select().from(userPhotos).where(
                  and(
                    eq(userPhotos.userId, profile.userId),
                    eq(userPhotos.isPrimaryForJob, true)
                  )
                ).limit(1);
                if (jobPhotos.length > 0) {
                  jobPrimaryPhotoUrl = jobPhotos[0].photoUrl;
                }
              } catch (error) {
                console.error(
                  `Error fetching job primary photo for user ${profile.userId}:`,
                  error
                );
              }
              return {
                ...profile,
                fieldVisibility,
                jobPrimaryPhotoUrl
              };
            })
          );
          return transformedProfiles;
        } catch (error) {
          console.error("Error getting discovery job profiles:", error);
          return [];
        }
      }
      async getSuiteJobProfileById(profileId) {
        try {
          const [jobProfile] = await db.select().from(suiteJobProfiles).where(
            and(
              eq(suiteJobProfiles.id, profileId),
              eq(suiteJobProfiles.isActive, true)
            )
          );
          return jobProfile;
        } catch (error) {
          console.error("Error getting job profile by ID:", error);
          return void 0;
        }
      }
      async getSuiteJobProfileByUserId(userId) {
        try {
          const [jobProfile] = await db.select().from(suiteJobProfiles).where(
            and(
              eq(suiteJobProfiles.userId, userId),
              eq(suiteJobProfiles.isActive, true)
            )
          );
          return jobProfile;
        } catch (error) {
          console.error("Error getting job profile by user ID:", error);
          return void 0;
        }
      }
      async updateSuiteJobProfileVisibility(userId, visibilityPreferences) {
        try {
          const [updatedProfile] = await db.update(suiteJobProfiles).set({
            visibilityPreferences,
            updatedAt: /* @__PURE__ */ new Date()
          }).where(
            and(
              eq(suiteJobProfiles.userId, userId),
              eq(suiteJobProfiles.isActive, true)
            )
          ).returning();
          return updatedProfile;
        } catch (error) {
          console.error("Error updating job profile visibility:", error);
          throw error;
        }
      }
      async deleteSuiteJobProfile(userId) {
        try {
          await db.delete(suiteJobProfiles).where(eq(suiteJobProfiles.userId, userId));
          console.log("Job profile deleted successfully for user:", userId);
        } catch (error) {
          console.error("Error deleting job profile:", error);
          throw error;
        }
      }
      // ===== MENTORSHIP PROFILE METHODS =====
      async getSuiteMentorshipProfile(userId, role) {
        try {
          const conditions = [
            eq(suiteMentorshipProfiles.userId, userId),
            eq(suiteMentorshipProfiles.isActive, true)
          ];
          if (role) {
            conditions.push(eq(suiteMentorshipProfiles.role, role));
          }
          const [result] = await db.select({
            // Include all mentorship profile fields
            ...suiteMentorshipProfiles,
            // Override education fields with data from users table for sync
            userHighSchool: users.highSchool,
            userCollegeUniversity: users.collegeUniversity
          }).from(suiteMentorshipProfiles).innerJoin(users, eq(users.id, suiteMentorshipProfiles.userId)).where(and(...conditions));
          if (!result) {
            return void 0;
          }
          const mentorshipProfile = {
            ...result,
            // Use education fields from users table if available, fallback to profile fields
            highSchool: result.userHighSchool || result.highSchool,
            collegeUniversity: result.userCollegeUniversity || result.collegeUniversity,
            // Remove the temporary fields
            userHighSchool: void 0,
            userCollegeUniversity: void 0
          };
          return mentorshipProfile;
        } catch (error) {
          console.error("Error getting mentorship profile:", error);
          return void 0;
        }
      }
      async getSuiteMentorshipProfileById(profileId) {
        try {
          const [mentorshipProfile] = await db.select().from(suiteMentorshipProfiles).where(
            and(
              eq(suiteMentorshipProfiles.id, profileId),
              eq(suiteMentorshipProfiles.isActive, true)
            )
          );
          return mentorshipProfile;
        } catch (error) {
          console.error("Error getting mentorship profile by ID:", error);
          return void 0;
        }
      }
      async getSuiteMentorshipProfileByRole(userId, role) {
        try {
          const [mentorshipProfile] = await db.select().from(suiteMentorshipProfiles).where(
            and(
              eq(suiteMentorshipProfiles.userId, userId),
              eq(suiteMentorshipProfiles.role, role),
              eq(suiteMentorshipProfiles.isActive, true)
            )
          );
          return mentorshipProfile;
        } catch (error) {
          console.error("Error getting mentorship profile by role:", error);
          return void 0;
        }
      }
      async getSuiteMentorshipProfiles(userId) {
        try {
          const mentorshipProfiles = await db.select().from(suiteMentorshipProfiles).where(
            and(
              eq(suiteMentorshipProfiles.userId, userId),
              eq(suiteMentorshipProfiles.isActive, true)
            )
          );
          return mentorshipProfiles;
        } catch (error) {
          console.error("Error getting mentorship profiles:", error);
          return [];
        }
      }
      async deleteSuiteMentorshipProfile(userId, role) {
        try {
          const conditions = [
            eq(suiteMentorshipProfiles.userId, userId)
          ];
          if (role) {
            conditions.push(eq(suiteMentorshipProfiles.role, role));
          }
          await db.delete(suiteMentorshipProfiles).where(and(...conditions));
          console.log(`Mentorship profile${role ? ` (${role})` : "s"} permanently deleted for user:`, userId);
        } catch (error) {
          console.error("Error deleting mentorship profile:", error);
          throw error;
        }
      }
      async createOrUpdateSuiteMentorshipProfile(userId, mentorshipProfileData) {
        try {
          console.log("Creating/updating mentorship profile for user:", userId);
          console.log("Mentorship profile data:", mentorshipProfileData);
          const role = mentorshipProfileData.role || "mentor";
          await db.update(suiteMentorshipProfiles).set({ isActive: false, updatedAt: /* @__PURE__ */ new Date() }).where(
            and(
              eq(suiteMentorshipProfiles.userId, userId),
              eq(suiteMentorshipProfiles.role, role)
            )
          );
          const [existingProfile] = await db.select().from(suiteMentorshipProfiles).where(
            and(
              eq(suiteMentorshipProfiles.userId, userId),
              eq(suiteMentorshipProfiles.role, role)
            )
          ).orderBy(sql`${suiteMentorshipProfiles.createdAt} DESC`).limit(1);
          if (existingProfile) {
            const cleanData = { ...mentorshipProfileData };
            delete cleanData.createdAt;
            delete cleanData.updatedAt;
            delete cleanData.id;
            const updateObject = {
              isActive: true,
              // Reactivate this profile
              updatedAt: /* @__PURE__ */ new Date()
            };
            Object.entries(cleanData).forEach(([key, value]) => {
              if (value !== null && value !== void 0) {
                updateObject[key] = value;
              }
            });
            console.log(
              `Storage layer: Updating most recent ${role} mentorship profile with:`,
              Object.keys(updateObject)
            );
            console.log("Storage layer: Update object:", updateObject);
            const [updatedProfile] = await db.update(suiteMentorshipProfiles).set(updateObject).where(eq(suiteMentorshipProfiles.id, existingProfile.id)).returning();
            if (updateObject.highSchool !== void 0 || updateObject.collegeUniversity !== void 0) {
              console.log("\u{1F4DA} [EDUCATION-SYNC] Syncing education fields to users table from mentorship profile");
              const userUpdateData = {};
              if (updateObject.highSchool !== void 0) {
                userUpdateData.highSchool = updateObject.highSchool;
              }
              if (updateObject.collegeUniversity !== void 0) {
                userUpdateData.collegeUniversity = updateObject.collegeUniversity;
              }
              try {
                await db.update(users).set(userUpdateData).where(eq(users.id, userId));
                console.log("\u{1F4DA} [EDUCATION-SYNC] Successfully updated education fields in users table:", userUpdateData);
              } catch (syncError) {
                console.error("\u{1F4DA} [EDUCATION-SYNC] Failed to sync education fields to users table:", syncError);
              }
            }
            console.log(`Updated ${role} mentorship profile:`, updatedProfile);
            return updatedProfile;
          } else {
            const profileToInsert = {
              userId,
              role,
              areasOfExpertise: mentorshipProfileData.areasOfExpertise,
              learningGoals: mentorshipProfileData.learningGoals,
              languagesSpoken: mentorshipProfileData.languagesSpoken,
              industriesOrDomains: mentorshipProfileData.industriesOrDomains,
              mentorshipStyle: mentorshipProfileData.mentorshipStyle,
              preferredFormat: mentorshipProfileData.preferredFormat,
              communicationStyle: mentorshipProfileData.communicationStyle,
              availability: mentorshipProfileData.availability,
              timeCommitment: mentorshipProfileData.timeCommitment,
              location: mentorshipProfileData.location,
              successStories: mentorshipProfileData.successStories,
              whyMentor: mentorshipProfileData.whyMentor,
              whySeekMentorship: mentorshipProfileData.whySeekMentorship,
              preferredMentorshipStyle: mentorshipProfileData.preferredMentorshipStyle,
              industryAspiration: mentorshipProfileData.industryAspiration,
              preferredMenteeLevel: mentorshipProfileData.preferredMenteeLevel,
              preferredMentorExperience: mentorshipProfileData.preferredMentorExperience,
              preferredIndustries: mentorshipProfileData.preferredIndustries,
              highSchool: mentorshipProfileData.highSchool,
              collegeUniversity: mentorshipProfileData.collegeUniversity,
              maxMentees: mentorshipProfileData.maxMentees,
              currentMentees: mentorshipProfileData.currentMentees || 0,
              visibilityPreferences: mentorshipProfileData.visibilityPreferences || null,
              isActive: true
            };
            const [newProfile] = await db.insert(suiteMentorshipProfiles).values(profileToInsert).returning();
            if (profileToInsert.highSchool || profileToInsert.collegeUniversity) {
              console.log("\u{1F4DA} [EDUCATION-SYNC] Syncing education fields to users table from new mentorship profile");
              const userUpdateData = {};
              if (profileToInsert.highSchool) {
                userUpdateData.highSchool = profileToInsert.highSchool;
              }
              if (profileToInsert.collegeUniversity) {
                userUpdateData.collegeUniversity = profileToInsert.collegeUniversity;
              }
              try {
                await db.update(users).set(userUpdateData).where(eq(users.id, userId));
                console.log("\u{1F4DA} [EDUCATION-SYNC] Successfully updated education fields in users table:", userUpdateData);
              } catch (syncError) {
                console.error("\u{1F4DA} [EDUCATION-SYNC] Failed to sync education fields to users table:", syncError);
              }
            }
            console.log(`Created new ${role} mentorship profile:`, newProfile);
            return newProfile;
          }
        } catch (error) {
          console.error("Error creating/updating mentorship profile:", error);
          console.error("Error details:", error.message);
          throw error;
        }
      }
      async getDiscoveryMentorshipProfiles(userId, limit, offset) {
        try {
          const mentorshipProfiles = await db.select({
            // Mentorship profile fields
            id: suiteMentorshipProfiles.id,
            userId: suiteMentorshipProfiles.userId,
            role: suiteMentorshipProfiles.role,
            areasOfExpertise: suiteMentorshipProfiles.areasOfExpertise,
            learningGoals: suiteMentorshipProfiles.learningGoals,
            languagesSpoken: suiteMentorshipProfiles.languagesSpoken,
            industriesOrDomains: suiteMentorshipProfiles.industriesOrDomains,
            mentorshipStyle: suiteMentorshipProfiles.mentorshipStyle,
            preferredFormat: suiteMentorshipProfiles.preferredFormat,
            communicationStyle: suiteMentorshipProfiles.communicationStyle,
            availability: suiteMentorshipProfiles.availability,
            timeCommitment: suiteMentorshipProfiles.timeCommitment,
            location: suiteMentorshipProfiles.location,
            successStories: suiteMentorshipProfiles.successStories,
            whyMentor: suiteMentorshipProfiles.whyMentor,
            whySeekMentorship: suiteMentorshipProfiles.whySeekMentorship,
            preferredMenteeLevel: suiteMentorshipProfiles.preferredMenteeLevel,
            preferredMentorExperience: suiteMentorshipProfiles.preferredMentorExperience,
            preferredIndustries: suiteMentorshipProfiles.preferredIndustries,
            isActive: suiteMentorshipProfiles.isActive,
            maxMentees: suiteMentorshipProfiles.maxMentees,
            currentMentees: suiteMentorshipProfiles.currentMentees,
            createdAt: suiteMentorshipProfiles.createdAt,
            updatedAt: suiteMentorshipProfiles.updatedAt,
            // Add missing fields from database
            visibilityPreferences: suiteMentorshipProfiles.visibilityPreferences,
            preferredMentorshipStyle: suiteMentorshipProfiles.preferredMentorshipStyle,
            industryAspiration: suiteMentorshipProfiles.industryAspiration,
            // Add education fields
            highSchool: suiteMentorshipProfiles.highSchool,
            collegeUniversity: suiteMentorshipProfiles.collegeUniversity,
            // User fields
            user: {
              id: users.id,
              fullName: users.fullName,
              photoUrl: users.photoUrl,
              profession: users.profession,
              location: users.location,
              isVerified: users.isVerified
            }
          }).from(suiteMentorshipProfiles).innerJoin(users, eq(suiteMentorshipProfiles.userId, users.id)).innerJoin(
            suiteProfileSettings,
            eq(users.id, suiteProfileSettings.userId)
          ).where(
            and(
              ne(suiteMentorshipProfiles.userId, userId),
              // Exclude current user
              eq(suiteMentorshipProfiles.isActive, true),
              eq(suiteProfileSettings.hiddenInMentorshipDiscovery, false),
              // Optimized bidirectional filtering using efficient table aliases and indexed lookups
              sql`NOT EXISTS (
              SELECT 1 FROM suite_mentorship_connections smc1
              WHERE smc1.user_id = ${userId} 
              AND smc1.target_profile_id = suite_mentorship_profiles.id
            )`,
              sql`NOT EXISTS (
              SELECT 1 FROM suite_mentorship_connections smc2
              WHERE smc2.user_id = suite_mentorship_profiles.user_id 
              AND smc2.target_user_id = ${userId}
            )`,
              // 3. Exclude profiles for users in swipe history for SUITE_MENTORSHIP
              sql`NOT EXISTS (
              SELECT 1 FROM swipe_history sh
              WHERE sh.user_id = ${userId} 
              AND sh.target_user_id = suite_mentorship_profiles.user_id
              AND sh.app_mode = 'SUITE_MENTORSHIP'
            )`
            )
          ).orderBy(desc(suiteMentorshipProfiles.createdAt)).limit(limit).offset(offset);
          const transformedProfiles = await Promise.all(
            mentorshipProfiles.map(async (profile) => {
              let fieldVisibility = {};
              if (profile.visibilityPreferences) {
                try {
                  fieldVisibility = JSON.parse(profile.visibilityPreferences);
                } catch (error) {
                  console.error(
                    `Error parsing mentorship visibility preferences for user ${profile.userId}:`,
                    error
                  );
                }
              }
              let mentorshipPrimaryPhotoUrl = null;
              try {
                const mentorshipPhotos = await db.select().from(userPhotos).where(
                  and(
                    eq(userPhotos.userId, profile.userId),
                    eq(userPhotos.isPrimaryForMentorship, true)
                  )
                ).limit(1);
                if (mentorshipPhotos.length > 0) {
                  mentorshipPrimaryPhotoUrl = mentorshipPhotos[0].photoUrl;
                }
              } catch (error) {
                console.error(
                  `Error fetching mentorship primary photo for user ${profile.userId}:`,
                  error
                );
              }
              return {
                ...profile,
                fieldVisibility,
                mentorshipPrimaryPhotoUrl
              };
            })
          );
          return transformedProfiles;
        } catch (error) {
          console.error("Error getting discovery mentorship profiles:", error);
          return [];
        }
      }
      // ===== NETWORKING PROFILE METHODS =====
      async getSuiteNetworkingProfile(userId) {
        try {
          const [result] = await db.select({
            // Include all networking profile fields
            ...suiteNetworkingProfiles,
            // Override education fields with data from users table for sync
            userHighSchool: users.highSchool,
            userCollegeUniversity: users.collegeUniversity
          }).from(suiteNetworkingProfiles).innerJoin(users, eq(users.id, suiteNetworkingProfiles.userId)).where(
            and(
              eq(suiteNetworkingProfiles.userId, userId),
              eq(suiteNetworkingProfiles.isActive, true)
            )
          );
          if (!result) {
            return void 0;
          }
          const networkingProfile = {
            ...result,
            // Use education fields from users table if available, fallback to profile fields
            highSchool: result.userHighSchool || result.highSchool,
            collegeUniversity: result.userCollegeUniversity || result.collegeUniversity,
            // Remove the temporary fields
            userHighSchool: void 0,
            userCollegeUniversity: void 0
          };
          return networkingProfile;
        } catch (error) {
          console.error("Error getting networking profile:", error);
          return void 0;
        }
      }
      async getSuiteNetworkingProfileById(profileId) {
        try {
          const [networkingProfile] = await db.select().from(suiteNetworkingProfiles).where(
            and(
              eq(suiteNetworkingProfiles.id, profileId),
              eq(suiteNetworkingProfiles.isActive, true)
            )
          );
          return networkingProfile;
        } catch (error) {
          console.error("Error getting networking profile by ID:", error);
          return void 0;
        }
      }
      async deleteSuiteNetworkingProfile(userId) {
        try {
          await db.delete(suiteNetworkingProfiles).where(eq(suiteNetworkingProfiles.userId, userId));
          console.log("Networking profile permanently deleted for user:", userId);
        } catch (error) {
          console.error("Error deleting networking profile:", error);
          throw error;
        }
      }
      async createOrUpdateSuiteNetworkingProfile(userId, networkingProfileData) {
        try {
          console.log("Creating/updating networking profile for user:", userId);
          console.log("Profile data received:", networkingProfileData);
          await db.update(suiteNetworkingProfiles).set({ isActive: false, updatedAt: /* @__PURE__ */ new Date() }).where(eq(suiteNetworkingProfiles.userId, userId));
          const [existingProfile] = await db.select().from(suiteNetworkingProfiles).where(eq(suiteNetworkingProfiles.userId, userId)).orderBy(sql`${suiteNetworkingProfiles.createdAt} DESC`).limit(1);
          if (existingProfile) {
            const cleanData = { ...networkingProfileData };
            delete cleanData.createdAt;
            delete cleanData.updatedAt;
            delete cleanData.id;
            const updateObject = {
              isActive: true,
              // Reactivate this profile
              updatedAt: /* @__PURE__ */ new Date()
            };
            Object.entries(cleanData).forEach(([key, value]) => {
              if (value !== null && value !== void 0) {
                updateObject[key] = value;
              }
            });
            console.log(
              "Storage layer: Updating most recent profile with:",
              Object.keys(updateObject)
            );
            console.log("Storage layer: Update object:", updateObject);
            const [updatedProfile] = await db.update(suiteNetworkingProfiles).set(updateObject).where(eq(suiteNetworkingProfiles.id, existingProfile.id)).returning();
            if (updateObject.highSchool !== void 0 || updateObject.collegeUniversity !== void 0) {
              console.log("\u{1F4DA} [EDUCATION-SYNC] Syncing education fields to users table from networking profile");
              const userUpdateData = {};
              if (updateObject.highSchool !== void 0) {
                userUpdateData.highSchool = updateObject.highSchool;
              }
              if (updateObject.collegeUniversity !== void 0) {
                userUpdateData.collegeUniversity = updateObject.collegeUniversity;
              }
              try {
                await db.update(users).set(userUpdateData).where(eq(users.id, userId));
                console.log("\u{1F4DA} [EDUCATION-SYNC] Successfully updated education fields in users table:", userUpdateData);
              } catch (syncError) {
                console.error("\u{1F4DA} [EDUCATION-SYNC] Failed to sync education fields to users table:", syncError);
              }
            }
            return updatedProfile;
          } else {
            const profileToInsert = {
              userId,
              professionalTagline: networkingProfileData.professionalTagline || null,
              currentRole: networkingProfileData.currentRole || null,
              currentCompany: networkingProfileData.currentCompany || null,
              industry: networkingProfileData.industry || null,
              experienceYears: networkingProfileData.experienceYears || null,
              networkingGoals: networkingProfileData.networkingGoals || null,
              lookingFor: networkingProfileData.lookingFor || null,
              canOffer: networkingProfileData.canOffer || null,
              professionalInterests: networkingProfileData.professionalInterests || null,
              causesIPassionate: networkingProfileData.causesIPassionate || null,
              collaborationTypes: networkingProfileData.collaborationTypes || null,
              workingStyle: networkingProfileData.workingStyle || null,
              timeCommitment: networkingProfileData.timeCommitment || null,
              lightUpWhenTalking: networkingProfileData.lightUpWhenTalking || null,
              wantToMeetSomeone: networkingProfileData.wantToMeetSomeone || null,
              currentProjects: networkingProfileData.currentProjects || null,
              dreamCollaboration: networkingProfileData.dreamCollaboration || null,
              preferredMeetingStyle: networkingProfileData.preferredMeetingStyle || null,
              availability: networkingProfileData.availability || null,
              location: networkingProfileData.location || null,
              openToRemote: networkingProfileData.openToRemote ?? true,
              preferredLocations: networkingProfileData.preferredLocations || null,
              highSchool: networkingProfileData.highSchool || null,
              collegeUniversity: networkingProfileData.collegeUniversity || null,
              isActive: true,
              lookingForOpportunities: networkingProfileData.lookingForOpportunities ?? true,
              visibilityPreferences: networkingProfileData.visibilityPreferences || null
            };
            console.log("Inserting new networking profile:", profileToInsert);
            const [networkingProfile] = await db.insert(suiteNetworkingProfiles).values(profileToInsert).returning();
            if (profileToInsert.highSchool || profileToInsert.collegeUniversity) {
              console.log("\u{1F4DA} [EDUCATION-SYNC] Syncing education fields to users table from new networking profile");
              const userUpdateData = {};
              if (profileToInsert.highSchool) {
                userUpdateData.highSchool = profileToInsert.highSchool;
              }
              if (profileToInsert.collegeUniversity) {
                userUpdateData.collegeUniversity = profileToInsert.collegeUniversity;
              }
              try {
                await db.update(users).set(userUpdateData).where(eq(users.id, userId));
                console.log("\u{1F4DA} [EDUCATION-SYNC] Successfully updated education fields in users table:", userUpdateData);
              } catch (syncError) {
                console.error("\u{1F4DA} [EDUCATION-SYNC] Failed to sync education fields to users table:", syncError);
              }
            }
            console.log("Created networking profile:", networkingProfile);
            return networkingProfile;
          }
        } catch (error) {
          console.error("Error creating/updating networking profile:", error);
          console.error("Error details:", error?.message);
          console.error("Stack trace:", error?.stack);
          throw error;
        }
      }
      async getDiscoveryNetworkingProfiles(userId, limit, offset) {
        try {
          const networkingProfiles = await db.select({
            // Networking profile fields
            id: suiteNetworkingProfiles.id,
            userId: suiteNetworkingProfiles.userId,
            professionalTagline: suiteNetworkingProfiles.professionalTagline,
            currentRole: suiteNetworkingProfiles.currentRole,
            currentCompany: suiteNetworkingProfiles.currentCompany,
            industry: suiteNetworkingProfiles.industry,
            experienceYears: suiteNetworkingProfiles.experienceYears,
            networkingGoals: suiteNetworkingProfiles.networkingGoals,
            lookingFor: suiteNetworkingProfiles.lookingFor,
            canOffer: suiteNetworkingProfiles.canOffer,
            professionalInterests: suiteNetworkingProfiles.professionalInterests,
            causesIPassionate: suiteNetworkingProfiles.causesIPassionate,
            collaborationTypes: suiteNetworkingProfiles.collaborationTypes,
            workingStyle: suiteNetworkingProfiles.workingStyle,
            timeCommitment: suiteNetworkingProfiles.timeCommitment,
            lightUpWhenTalking: suiteNetworkingProfiles.lightUpWhenTalking,
            wantToMeetSomeone: suiteNetworkingProfiles.wantToMeetSomeone,
            currentProjects: suiteNetworkingProfiles.currentProjects,
            dreamCollaboration: suiteNetworkingProfiles.dreamCollaboration,
            preferredMeetingStyle: suiteNetworkingProfiles.preferredMeetingStyle,
            availability: suiteNetworkingProfiles.availability,
            location: suiteNetworkingProfiles.location,
            openToRemote: suiteNetworkingProfiles.openToRemote,
            preferredLocations: suiteNetworkingProfiles.preferredLocations,
            isActive: suiteNetworkingProfiles.isActive,
            lookingForOpportunities: suiteNetworkingProfiles.lookingForOpportunities,
            visibilityPreferences: suiteNetworkingProfiles.visibilityPreferences,
            // Add education fields for swipe card display
            highSchool: suiteNetworkingProfiles.highSchool,
            collegeUniversity: suiteNetworkingProfiles.collegeUniversity,
            createdAt: suiteNetworkingProfiles.createdAt,
            updatedAt: suiteNetworkingProfiles.updatedAt,
            // User fields
            user: {
              id: users.id,
              fullName: users.fullName,
              photoUrl: users.photoUrl,
              profession: users.profession,
              location: users.location,
              isVerified: users.isVerified
            }
          }).from(suiteNetworkingProfiles).innerJoin(users, eq(suiteNetworkingProfiles.userId, users.id)).innerJoin(
            suiteProfileSettings,
            eq(users.id, suiteProfileSettings.userId)
          ).where(
            and(
              ne(suiteNetworkingProfiles.userId, userId),
              // Exclude current user
              eq(suiteNetworkingProfiles.isActive, true),
              eq(suiteProfileSettings.hiddenInNetworkingDiscovery, false),
              eq(suiteNetworkingProfiles.lookingForOpportunities, true),
              // Optimized bidirectional filtering using efficient EXISTS clauses instead of slow NOT IN
              sql`NOT EXISTS (
              SELECT 1 FROM suite_networking_connections snc1
              WHERE snc1.user_id = ${userId} 
              AND snc1.target_profile_id = suite_networking_profiles.id
            )`,
              sql`NOT EXISTS (
              SELECT 1 FROM suite_networking_connections snc2
              WHERE snc2.user_id = suite_networking_profiles.user_id 
              AND snc2.target_user_id = ${userId}
            )`,
              // 3. Exclude profiles for users in swipe history for SUITE_NETWORKING
              sql`NOT EXISTS (
              SELECT 1 FROM swipe_history sh
              WHERE sh.user_id = ${userId} 
              AND sh.target_user_id = suite_networking_profiles.user_id
              AND sh.app_mode = 'SUITE_NETWORKING'
            )`
            )
          ).orderBy(desc(suiteNetworkingProfiles.createdAt)).limit(limit).offset(offset);
          const profilesWithVisibilityAndPhotos = await Promise.all(
            networkingProfiles.map(async (profile) => {
              let fieldVisibility = {
                // Default visibility settings that match the preview dialog
                showProfilePhoto: false,
                showNetworkingPhotos: true,
                professionalTagline: true,
                currentRole: true,
                industry: true,
                workplace: true,
                experienceYears: true,
                lookingFor: true,
                canOffer: true,
                workingStyle: true,
                professionalInterests: true,
                networkingGoals: true,
                lightUpWhenTalking: true,
                languagesSpoken: true,
                openToCollaborateOn: true,
                preferredNetworkingFormat: true,
                signatureAchievement: true,
                timezone: true,
                location: true
              };
              if (profile.visibilityPreferences) {
                try {
                  const visibilityData = typeof profile.visibilityPreferences === "string" ? JSON.parse(profile.visibilityPreferences) : profile.visibilityPreferences;
                  fieldVisibility = { ...fieldVisibility, ...visibilityData };
                } catch (error) {
                  console.error(
                    `Error parsing visibility preferences for user ${profile.userId}:`,
                    error
                  );
                }
              }
              let networkingPrimaryPhotoUrl = null;
              try {
                const networkingPhotos = await db.select().from(userPhotos).where(
                  and(
                    eq(userPhotos.userId, profile.userId),
                    eq(userPhotos.isPrimaryForNetworking, true)
                  )
                ).limit(1);
                if (networkingPhotos.length > 0) {
                  networkingPrimaryPhotoUrl = networkingPhotos[0].photoUrl;
                }
              } catch (error) {
                console.error(
                  `Error fetching networking primary photo for user ${profile.userId}:`,
                  error
                );
              }
              return {
                ...profile,
                fieldVisibility,
                networkingPrimaryPhotoUrl
              };
            })
          );
          return profilesWithVisibilityAndPhotos;
        } catch (error) {
          console.error("Error getting discovery networking profiles:", error);
          return [];
        }
      }
      // ===== FIELD VISIBILITY METHODS =====
      async getFieldVisibility(userId, profileType) {
        try {
          const visibilitySettings = await db.select().from(suiteFieldVisibility).where(
            and(
              eq(suiteFieldVisibility.userId, userId),
              eq(suiteFieldVisibility.profileType, profileType)
            )
          );
          return visibilitySettings;
        } catch (error) {
          console.error("Error getting field visibility:", error);
          return [];
        }
      }
      async updateFieldVisibility(userId, profileType, fieldName, isVisible) {
        try {
          const [visibility] = await db.insert(suiteFieldVisibility).values({
            userId,
            profileType,
            fieldName,
            isVisible
          }).onConflictDoUpdate({
            target: [
              suiteFieldVisibility.userId,
              suiteFieldVisibility.profileType,
              suiteFieldVisibility.fieldName
            ],
            set: {
              isVisible,
              updatedAt: sql`NOW()`
            }
          }).returning();
          return visibility;
        } catch (error) {
          console.error("Error updating field visibility:", error);
          throw error;
        }
      }
      async updateMultipleFieldVisibility(userId, profileType, visibilityData) {
        try {
          await Promise.all(
            Object.entries(visibilityData).map(
              ([fieldName, isVisible]) => this.updateFieldVisibility(userId, profileType, fieldName, isVisible)
            )
          );
        } catch (error) {
          console.error("Error updating multiple field visibility:", error);
          throw error;
        }
      }
      // ===== SUITE CONNECTION STORAGE IMPLEMENTATIONS =====
      // Networking connections
      async createSuiteNetworkingConnection(connectionData) {
        try {
          const [connection] = await db.insert(suiteNetworkingConnections).values(connectionData).returning();
          return connection;
        } catch (error) {
          console.error("Error creating networking connection:", error);
          throw error;
        }
      }
      async getSuiteNetworkingConnection(userId, targetProfileId) {
        try {
          const [connection] = await db.select().from(suiteNetworkingConnections).where(
            and(
              eq(suiteNetworkingConnections.userId, userId),
              eq(suiteNetworkingConnections.targetProfileId, targetProfileId)
            )
          );
          return connection || void 0;
        } catch (error) {
          console.error("Error getting networking connection:", error);
          throw error;
        }
      }
      async updateSuiteNetworkingConnection(id, updates) {
        try {
          const [connection] = await db.update(suiteNetworkingConnections).set(updates).where(eq(suiteNetworkingConnections.id, id)).returning();
          return connection || void 0;
        } catch (error) {
          console.error("Error updating networking connection:", error);
          throw error;
        }
      }
      async getUserNetworkingConnections(userId) {
        try {
          const incomingConnections = await db.select({
            id: suiteNetworkingConnections.id,
            userId: suiteNetworkingConnections.userId,
            targetProfileId: suiteNetworkingConnections.targetProfileId,
            targetUserId: suiteNetworkingConnections.targetUserId,
            action: suiteNetworkingConnections.action,
            matched: suiteNetworkingConnections.matched,
            createdAt: suiteNetworkingConnections.createdAt,
            // Get the LIKER's profile data (the person who liked this user)
            targetProfile: suiteNetworkingProfiles,
            targetUser: users
          }).from(suiteNetworkingConnections).leftJoin(
            suiteNetworkingProfiles,
            eq(suiteNetworkingConnections.userId, suiteNetworkingProfiles.userId)
          ).leftJoin(users, eq(suiteNetworkingConnections.userId, users.id)).where(
            and(
              eq(suiteNetworkingConnections.targetUserId, userId),
              eq(suiteNetworkingConnections.action, "like"),
              eq(suiteNetworkingConnections.matched, false)
              // Only show unmatched connections
            )
          );
          const enrichedConnections = await Promise.all(
            incomingConnections.map(async (conn) => {
              let networkingPrimaryPhotoUrl = null;
              if (conn.userId) {
                const [networkingPhoto] = await db.select({
                  photoUrl: userPhotos.photoUrl
                }).from(userPhotos).where(
                  and(
                    eq(userPhotos.userId, conn.userId),
                    eq(userPhotos.isPrimaryForNetworking, true)
                  )
                );
                networkingPrimaryPhotoUrl = networkingPhoto?.photoUrl || null;
              }
              return {
                ...conn,
                fieldVisibility: conn.targetProfile?.visibilityPreferences,
                networkingPrimaryPhotoUrl
              };
            })
          );
          return enrichedConnections;
        } catch (error) {
          console.error("Error getting user networking connections:", error);
          throw error;
        }
      }
      // Mentorship connections
      async createSuiteMentorshipConnection(connectionData) {
        try {
          const [connection] = await db.insert(suiteMentorshipConnections).values(connectionData).returning();
          return connection;
        } catch (error) {
          console.error("Error creating mentorship connection:", error);
          throw error;
        }
      }
      async getSuiteMentorshipConnection(userId, targetProfileId) {
        try {
          const [connection] = await db.select().from(suiteMentorshipConnections).where(
            and(
              eq(suiteMentorshipConnections.userId, userId),
              eq(suiteMentorshipConnections.targetProfileId, targetProfileId)
            )
          );
          return connection || void 0;
        } catch (error) {
          console.error("Error getting mentorship connection:", error);
          throw error;
        }
      }
      async updateSuiteMentorshipConnection(id, updates) {
        try {
          const [connection] = await db.update(suiteMentorshipConnections).set(updates).where(eq(suiteMentorshipConnections.id, id)).returning();
          return connection || void 0;
        } catch (error) {
          console.error("Error updating mentorship connection:", error);
          throw error;
        }
      }
      async getUserMentorshipConnections(userId) {
        try {
          const incomingConnections = await db.select({
            id: suiteMentorshipConnections.id,
            userId: suiteMentorshipConnections.userId,
            targetProfileId: suiteMentorshipConnections.targetProfileId,
            targetUserId: suiteMentorshipConnections.targetUserId,
            action: suiteMentorshipConnections.action,
            matched: suiteMentorshipConnections.matched,
            createdAt: suiteMentorshipConnections.createdAt,
            // Get the LIKER's profile data (the person who liked this user)
            targetProfile: suiteMentorshipProfiles,
            targetUser: users
          }).from(suiteMentorshipConnections).leftJoin(
            suiteMentorshipProfiles,
            eq(suiteMentorshipConnections.userId, suiteMentorshipProfiles.userId)
          ).leftJoin(users, eq(suiteMentorshipConnections.userId, users.id)).where(
            and(
              eq(suiteMentorshipConnections.targetUserId, userId),
              eq(suiteMentorshipConnections.action, "like"),
              eq(suiteMentorshipConnections.matched, false)
              // Only show unmatched connections
            )
          );
          const transformedConnections = await Promise.all(
            incomingConnections.map(async (connection) => {
              if (connection.targetProfile) {
                let fieldVisibility = {};
                if (connection.targetProfile.visibilityPreferences) {
                  try {
                    fieldVisibility = JSON.parse(connection.targetProfile.visibilityPreferences);
                  } catch (error) {
                    console.error(
                      `Error parsing mentorship visibility preferences for connection ${connection.id}:`,
                      error
                    );
                  }
                }
                let mentorshipPrimaryPhotoUrl = null;
                try {
                  const mentorshipPhotos = await db.select().from(userPhotos).where(
                    and(
                      eq(userPhotos.userId, connection.userId),
                      eq(userPhotos.isPrimaryForMentorship, true)
                    )
                  ).limit(1);
                  if (mentorshipPhotos.length > 0) {
                    mentorshipPrimaryPhotoUrl = mentorshipPhotos[0].photoUrl;
                  }
                } catch (error) {
                  console.error(
                    `Error fetching mentorship primary photo for user ${connection.userId}:`,
                    error
                  );
                }
                connection.targetProfile = {
                  ...connection.targetProfile,
                  fieldVisibility: JSON.stringify(fieldVisibility)
                };
                return {
                  ...connection,
                  mentorshipPrimaryPhotoUrl,
                  fieldVisibility: JSON.stringify(fieldVisibility)
                };
              }
              return connection;
            })
          );
          return transformedConnections;
        } catch (error) {
          console.error("Error getting user mentorship connections:", error);
          throw error;
        }
      }
      // Job applications
      async createSuiteJobApplication(applicationData) {
        try {
          const [application] = await db.insert(suiteJobApplications).values(applicationData).returning();
          return application;
        } catch (error) {
          console.error("Error creating job application:", error);
          throw error;
        }
      }
      async getSuiteJobApplication(userId, targetProfileId) {
        try {
          const [application] = await db.select().from(suiteJobApplications).where(
            and(
              eq(suiteJobApplications.userId, userId),
              eq(suiteJobApplications.targetProfileId, targetProfileId)
            )
          );
          return application || void 0;
        } catch (error) {
          console.error("Error getting job application:", error);
          throw error;
        }
      }
      async updateSuiteJobApplication(id, updates) {
        try {
          const [application] = await db.update(suiteJobApplications).set(updates).where(eq(suiteJobApplications.id, id)).returning();
          return application || void 0;
        } catch (error) {
          console.error("Error updating job application:", error);
          throw error;
        }
      }
      async getSuiteJobApplicationById(id) {
        try {
          const [application] = await db.select().from(suiteJobApplications).where(eq(suiteJobApplications.id, id));
          return application || void 0;
        } catch (error) {
          console.error("Error getting job application by ID:", error);
          throw error;
        }
      }
      async getSuiteJobApplicationByUsers(userId, targetUserId) {
        try {
          const [application] = await db.select().from(suiteJobApplications).where(
            and(
              eq(suiteJobApplications.userId, userId),
              eq(suiteJobApplications.targetUserId, targetUserId)
            )
          );
          return application || void 0;
        } catch (error) {
          console.error("Error getting job application by users:", error);
          throw error;
        }
      }
      async getUserJobApplications(userId) {
        try {
          const incomingApplications = await db.select({
            id: suiteJobApplications.id,
            userId: suiteJobApplications.userId,
            targetProfileId: suiteJobApplications.targetProfileId,
            targetUserId: suiteJobApplications.targetUserId,
            action: suiteJobApplications.action,
            applicationStatus: suiteJobApplications.applicationStatus,
            matched: suiteJobApplications.matched,
            createdAt: suiteJobApplications.createdAt,
            // Get the APPLICANT's user data (the person who applied)
            applicantName: users.fullName,
            applicantPhoto: users.photoUrl,
            applicantProfession: users.profession,
            applicantLocation: users.location,
            applicantIsVerified: users.isVerified
          }).from(suiteJobApplications).leftJoin(users, eq(suiteJobApplications.userId, users.id)).where(
            and(
              eq(suiteJobApplications.targetUserId, userId),
              eq(suiteJobApplications.action, "like"),
              eq(suiteJobApplications.matched, false)
              // Only show unmatched applications
            )
          );
          return incomingApplications.map((app2) => ({
            ...app2,
            targetProfile: null,
            // Not needed for job applications display
            targetUser: {
              id: app2.userId,
              fullName: app2.applicantName,
              photoUrl: app2.applicantPhoto,
              profession: app2.applicantProfession,
              location: app2.applicantLocation,
              isVerified: app2.applicantIsVerified
            }
          }));
        } catch (error) {
          console.error("Error getting user job applications:", error);
          throw error;
        }
      }
      // Connection management by ID methods
      async getSuiteNetworkingConnectionById(id) {
        try {
          const [connection] = await db.select().from(suiteNetworkingConnections).where(eq(suiteNetworkingConnections.id, id));
          return connection || void 0;
        } catch (error) {
          console.error("Error getting networking connection by ID:", error);
          throw error;
        }
      }
      async getSuiteMentorshipConnectionById(id) {
        try {
          const [connection] = await db.select().from(suiteMentorshipConnections).where(eq(suiteMentorshipConnections.id, id));
          return connection || void 0;
        } catch (error) {
          console.error("Error getting mentorship connection by ID:", error);
          throw error;
        }
      }
      async deleteSuiteNetworkingConnectionById(id) {
        try {
          await db.delete(suiteNetworkingConnections).where(eq(suiteNetworkingConnections.id, id));
        } catch (error) {
          console.error("Error deleting networking connection by ID:", error);
          throw error;
        }
      }
      async deleteSuiteMentorshipConnectionById(id) {
        try {
          await db.delete(suiteMentorshipConnections).where(eq(suiteMentorshipConnections.id, id));
        } catch (error) {
          console.error("Error deleting mentorship connection by ID:", error);
          throw error;
        }
      }
      async deleteSuiteJobApplicationById(id) {
        try {
          await db.delete(suiteJobApplications).where(eq(suiteJobApplications.id, id));
        } catch (error) {
          console.error("Error deleting job application by ID:", error);
          throw error;
        }
      }
      // Clear all networking connections for testing
      async clearAllNetworkingConnections() {
        try {
          await db.delete(suiteNetworkingConnections);
          console.log("All networking connections cleared");
        } catch (error) {
          console.error("Error clearing networking connections:", error);
          throw error;
        }
      }
      // ===== SUITE COMPATIBILITY SCORING METHODS =====
      async createSuiteCompatibilityScore(scoreData) {
        try {
          const [score] = await db.insert(suiteCompatibilityScores).values(scoreData).returning();
          return score;
        } catch (error) {
          console.error("Error creating suite compatibility score:", error);
          throw error;
        }
      }
      async getSuiteCompatibilityScore(userId, targetProfileId) {
        try {
          const [score] = await db.select().from(suiteCompatibilityScores).where(
            and(
              eq(suiteCompatibilityScores.userId, userId),
              eq(suiteCompatibilityScores.targetProfileId, targetProfileId),
              eq(suiteCompatibilityScores.isActive, true)
            )
          );
          return score || void 0;
        } catch (error) {
          console.error("Error getting suite compatibility score:", error);
          throw error;
        }
      }
      async updateSuiteCompatibilityScore(id, updates) {
        try {
          const [score] = await db.update(suiteCompatibilityScores).set({
            ...updates,
            lastUpdated: /* @__PURE__ */ new Date()
          }).where(eq(suiteCompatibilityScores.id, id)).returning();
          return score;
        } catch (error) {
          console.error("Error updating suite compatibility score:", error);
          throw error;
        }
      }
      // ===== MENTORSHIP COMPATIBILITY SCORE METHODS =====
      async createSuiteMentorshipCompatibilityScore(scoreData) {
        try {
          const [score] = await db.insert(suiteMentorshipCompatibilityScores).values(scoreData).returning();
          return score;
        } catch (error) {
          console.error("Error creating mentorship compatibility score:", error);
          throw error;
        }
      }
      async getSuiteMentorshipCompatibilityScore(userId, targetProfileId) {
        try {
          const [score] = await db.select().from(suiteMentorshipCompatibilityScores).where(
            and(
              eq(suiteMentorshipCompatibilityScores.userId, userId),
              eq(suiteMentorshipCompatibilityScores.targetProfileId, targetProfileId),
              eq(suiteMentorshipCompatibilityScores.isActive, true)
            )
          );
          return score || void 0;
        } catch (error) {
          console.error("Error getting mentorship compatibility score:", error);
          throw error;
        }
      }
      async updateSuiteMentorshipCompatibilityScore(id, updates) {
        try {
          const [score] = await db.update(suiteMentorshipCompatibilityScores).set({
            ...updates,
            lastUpdated: /* @__PURE__ */ new Date()
          }).where(eq(suiteMentorshipCompatibilityScores.id, id)).returning();
          return score;
        } catch (error) {
          console.error("Error updating mentorship compatibility score:", error);
          throw error;
        }
      }
      async getUserByMentorshipProfileId(profileId) {
        try {
          const [result] = await db.select({
            id: users.id,
            fullName: users.fullName,
            photoUrl: users.photoUrl,
            profession: users.profession,
            location: users.location,
            email: users.email
          }).from(users).innerJoin(suiteMentorshipProfiles, eq(users.id, suiteMentorshipProfiles.userId)).where(eq(suiteMentorshipProfiles.id, profileId));
          return result || void 0;
        } catch (error) {
          console.error("Error getting user by mentorship profile ID:", error);
          throw error;
        }
      }
      async getSuiteMentorshipProfileByUserId(userId) {
        try {
          const [profile] = await db.select().from(suiteMentorshipProfiles).where(
            and(
              eq(suiteMentorshipProfiles.userId, userId),
              eq(suiteMentorshipProfiles.isActive, true)
            )
          );
          return profile || void 0;
        } catch (error) {
          console.error("Error getting mentorship profile by user ID:", error);
          throw error;
        }
      }
      async getSuiteMentorshipProfileById(profileId) {
        try {
          const [profile] = await db.select().from(suiteMentorshipProfiles).where(eq(suiteMentorshipProfiles.id, profileId));
          return profile || void 0;
        } catch (error) {
          console.error("Error getting mentorship profile by ID:", error);
          throw error;
        }
      }
      async getUserByNetworkingProfileId(profileId) {
        try {
          const [profile] = await db.select({
            user: users
          }).from(suiteNetworkingProfiles).innerJoin(users, eq(suiteNetworkingProfiles.userId, users.id)).where(eq(suiteNetworkingProfiles.id, profileId));
          return profile?.user || void 0;
        } catch (error) {
          console.error("Error getting user by networking profile ID:", error);
          throw error;
        }
      }
      // Professional Reviews System
      async createProfessionalReview(reviewData) {
        try {
          const result = await db.execute(sql`
        INSERT INTO professional_reviews (
          user_id, target_user_id, rating, review_text, category, is_anonymous, created_at, updated_at
        ) VALUES (
          ${reviewData.reviewerUserId}, 
          ${reviewData.reviewedUserId}, 
          ${reviewData.rating}, 
          ${reviewData.reviewText}, 
          ${reviewData.category || "overall"},
          ${reviewData.isAnonymous || false},
          NOW(),
          NOW()
        ) RETURNING *
      `);
          const review = result.rows[0];
          return {
            id: review.id,
            reviewedUserId: review.target_user_id,
            reviewerUserId: review.user_id,
            rating: review.rating,
            reviewText: review.review_text,
            isAnonymous: reviewData.isAnonymous || false,
            category: review.category,
            createdAt: review.created_at,
            updatedAt: review.updated_at
          };
        } catch (error) {
          console.error("Error creating professional review:", error);
          throw error;
        }
      }
      async getProfessionalReviewsForUser(reviewedUserId) {
        try {
          const reviews = await db.execute(sql`
        SELECT 
          pr.id,
          pr.target_user_id as reviewed_user_id,
          pr.user_id as reviewer_user_id,
          pr.rating,
          pr.review_text,
          pr.category,
          pr.is_anonymous,
          pr.created_at,
          pr.updated_at,
          u.id as reviewer_id,
          u.full_name as reviewer_full_name,
          u.photo_url as reviewer_photo_url,
          u.profession as reviewer_profession
        FROM professional_reviews pr
        LEFT JOIN users u ON pr.user_id = u.id
        WHERE pr.target_user_id = ${reviewedUserId}
        ORDER BY pr.created_at DESC
      `);
          return reviews.rows.map((r) => ({
            id: r.id,
            reviewedUserId: r.reviewed_user_id,
            reviewerUserId: r.reviewer_user_id,
            rating: r.rating,
            reviewText: r.review_text,
            isAnonymous: r.is_anonymous || false,
            category: r.category,
            createdAt: r.created_at,
            updatedAt: r.updated_at,
            reviewer: r.reviewer_id ? {
              id: r.reviewer_id,
              fullName: r.reviewer_full_name,
              photoUrl: r.reviewer_photo_url,
              profession: r.reviewer_profession
            } : null
          }));
        } catch (error) {
          console.error("Error getting professional reviews for user:", error);
          throw error;
        }
      }
      async getProfessionalReviewStats(reviewedUserId) {
        try {
          const reviews = await db.execute(sql`
        SELECT rating 
        FROM professional_reviews 
        WHERE target_user_id = ${reviewedUserId}
      `);
          if (reviews.rows.length === 0) {
            return {
              averageRating: 0,
              totalReviews: 0,
              ratingDistribution: { 1: 0, 2: 0, 3: 0, 4: 0, 5: 0 }
            };
          }
          const totalReviews = reviews.rows.length;
          const averageRating = reviews.rows.reduce((sum, r) => sum + r.rating, 0) / totalReviews;
          const ratingDistribution = { 1: 0, 2: 0, 3: 0, 4: 0, 5: 0 };
          reviews.rows.forEach((r) => {
            ratingDistribution[r.rating]++;
          });
          return {
            averageRating: Math.round(averageRating * 10) / 10,
            totalReviews,
            ratingDistribution
          };
        } catch (error) {
          console.error("Error getting professional review stats:", error);
          throw error;
        }
      }
      async getExistingReview(reviewedUserId, reviewerUserId, category = "overall") {
        try {
          const review = await db.execute(sql`
        SELECT * FROM professional_reviews 
        WHERE target_user_id = ${reviewedUserId} 
        AND user_id = ${reviewerUserId} 
        AND category = ${category}
        LIMIT 1
      `);
          if (review.rows.length === 0) return void 0;
          const r = review.rows[0];
          return {
            id: r.id,
            reviewedUserId: r.target_user_id,
            reviewerUserId: r.user_id,
            rating: r.rating,
            reviewText: r.review_text,
            isAnonymous: r.is_anonymous || false,
            category: r.category,
            createdAt: r.created_at,
            updatedAt: r.updated_at
          };
        } catch (error) {
          console.error("Error getting existing review:", error);
          throw error;
        }
      }
      async deleteProfessionalReview(reviewId, userId) {
        try {
          const result = await db.execute(sql`
        DELETE FROM professional_reviews 
        WHERE id = ${reviewId} AND user_id = ${userId}
        RETURNING id
      `);
          return result.rows.length > 0;
        } catch (error) {
          console.error("Error deleting professional review:", error);
          throw error;
        }
      }
      async updateProfessionalReview(id, updates) {
        try {
          const result = await db.execute(sql`
        UPDATE professional_reviews 
        SET 
          rating = ${updates.rating}, 
          review_text = ${updates.reviewText}, 
          is_anonymous = ${updates.isAnonymous || false},
          updated_at = NOW()
        WHERE id = ${id}
        RETURNING *
      `);
          if (result.rows.length === 0) return void 0;
          const r = result.rows[0];
          return {
            id: r.id,
            reviewedUserId: r.target_user_id,
            reviewerUserId: r.user_id,
            rating: r.rating,
            reviewText: r.review_text,
            isAnonymous: updates.isAnonymous || false,
            category: r.category,
            createdAt: r.created_at,
            updatedAt: r.updated_at
          };
        } catch (error) {
          console.error("Error updating professional review:", error);
          throw error;
        }
      }
      async recordJobApplication(applicationData) {
        try {
          const jobProfile = await this.getSuiteJobProfileById(applicationData.jobProfileId);
          if (!jobProfile) {
            throw new Error("Job profile not found");
          }
          const result = await db.execute(sql`
        INSERT INTO suite_job_applications (user_id, target_profile_id, target_user_id, action, application_status, matched) 
        VALUES (${applicationData.userId}, ${applicationData.jobProfileId}, ${jobProfile.userId}, ${applicationData.action}, ${applicationData.action === "like" ? "pending" : "rejected"}, false)
        ON CONFLICT (user_id, target_profile_id) 
        DO UPDATE SET action = ${applicationData.action}, application_status = ${applicationData.action === "like" ? "pending" : "rejected"}, created_at = CURRENT_TIMESTAMP
        RETURNING *
      `);
          return result.rows[0];
        } catch (error) {
          console.error("Error recording job application:", error);
          throw error;
        }
      }
      // Swipe history operations for persistent undo functionality
      async addSwipeHistory(swipeData) {
        try {
          const [history] = await db.insert(swipeHistory).values(swipeData).returning();
          return history;
        } catch (error) {
          console.error("Error adding swipe history:", error);
          throw error;
        }
      }
      async getUserSwipeHistory(userId, appMode, limit = 10) {
        try {
          const history = await db.select({
            id: swipeHistory.id,
            userId: swipeHistory.userId,
            targetUserId: swipeHistory.targetUserId,
            action: swipeHistory.action,
            appMode: swipeHistory.appMode,
            timestamp: swipeHistory.timestamp
          }).from(swipeHistory).where(
            and(
              eq(swipeHistory.userId, userId),
              eq(swipeHistory.appMode, appMode)
            )
          ).orderBy(desc(swipeHistory.timestamp)).limit(limit);
          return history;
        } catch (error) {
          console.error("Error getting swipe history:", error);
          throw error;
        }
      }
      async removeSwipeHistory(id) {
        try {
          await db.delete(swipeHistory).where(eq(swipeHistory.id, id));
        } catch (error) {
          console.error("Error removing swipe history:", error);
          throw error;
        }
      }
      async clearUserSwipeHistory(userId, appMode) {
        try {
          await db.delete(swipeHistory).where(
            and(
              eq(swipeHistory.userId, userId),
              eq(swipeHistory.appMode, appMode)
            )
          );
        } catch (error) {
          console.error("Error clearing swipe history:", error);
          throw error;
        }
      }
      async removeSwipeFromHistory(userId, targetUserId) {
        try {
          const [latestSwipe] = await db.select().from(swipeHistory).where(
            and(
              eq(swipeHistory.userId, userId),
              eq(swipeHistory.targetUserId, targetUserId)
            )
          ).orderBy(desc(swipeHistory.timestamp)).limit(1);
          if (latestSwipe) {
            await db.delete(swipeHistory).where(eq(swipeHistory.id, latestSwipe.id));
            console.log(`Removed swipe history record ${latestSwipe.id} for user ${userId} -> ${targetUserId}`);
          }
        } catch (error) {
          console.error("Error removing swipe from history:", error);
          throw error;
        }
      }
      async removeMatchedUsersFromSwipeHistory(userId1, userId2, appMode) {
        try {
          let whereCondition = or(
            and(
              eq(swipeHistory.userId, userId1),
              eq(swipeHistory.targetUserId, userId2)
            ),
            and(
              eq(swipeHistory.userId, userId2),
              eq(swipeHistory.targetUserId, userId1)
            )
          );
          if (appMode) {
            whereCondition = and(
              whereCondition,
              eq(swipeHistory.appMode, appMode)
            );
          }
          const result = await db.delete(swipeHistory).where(whereCondition);
          const modeText = appMode ? ` (${appMode})` : "";
          console.log(`[SWIPE-CLEANUP] Removed swipe history records for matched users ${userId1} \u2194 ${userId2}${modeText} to protect match integrity`);
        } catch (error) {
          console.error("Error removing matched users from swipe history:", error);
          throw error;
        }
      }
      // Connections Preferences Methods
      async getConnectionsPreferences(userId) {
        try {
          const [preferences] = await db.select().from(connectionsPreferences).where(eq(connectionsPreferences.userId, userId));
          return preferences || null;
        } catch (error) {
          console.error("Error getting connections preferences:", error);
          throw error;
        }
      }
      async saveConnectionsPreferences(userId, data) {
        try {
          const cleanData = { ...data };
          delete cleanData.id;
          delete cleanData.createdAt;
          delete cleanData.updatedAt;
          delete cleanData.userId;
          console.log("Saving connections preferences for user:", userId);
          console.log("\u{1F527} RAW DATA RECEIVED:", JSON.stringify(data, null, 2));
          const existing = await this.getConnectionsPreferences(userId);
          if (existing) {
            console.log("CRITICAL DEBUG: About to update with data:", cleanData);
            console.log("CRITICAL DEBUG: jobs_education_level value:", cleanData.jobs_education_level, typeof cleanData.jobs_education_level);
            console.log("CRITICAL DEBUG: jobs_salary_range value:", cleanData.jobs_salary_range, typeof cleanData.jobs_salary_range);
            const processedData = { ...cleanData };
            const arrayFields = [
              "mentorship_looking_for",
              "mentorship_experience_level",
              "mentorship_industries",
              "mentorship_areas_of_expertise",
              "mentorship_education_level",
              "mentorship_skills",
              "mentorship_topics",
              "mentorship_format",
              "networking_purpose",
              "networking_company_size",
              "networking_seniority",
              "networking_industries",
              "networking_areas_of_expertise",
              "networking_education_level",
              "networking_skills",
              "networking_functional_areas",
              "networking_event_preference",
              "jobs_types",
              "jobs_salary_range",
              "jobs_work_arrangement",
              "jobs_company_size",
              "jobs_industries",
              "jobs_education_level",
              "jobs_skills",
              "jobs_experience_level",
              "jobs_functional_areas",
              "deal_breakers"
            ];
            arrayFields.forEach((field) => {
              if (processedData[field] && Array.isArray(processedData[field])) {
                console.log(`ARRAY-FIX: Converting ${field}:`, processedData[field]);
              }
            });
            console.log("ARRAY-FIX: Final processed data:", processedData);
            const arrayFieldsToProcess = [
              "mentorship_looking_for",
              "mentorship_experience_level",
              "mentorship_industries",
              "mentorship_areas_of_expertise",
              "mentorship_education_level",
              "mentorship_skills",
              "mentorship_topics",
              "mentorship_format",
              "networking_purpose",
              "networking_company_size",
              "networking_seniority",
              "networking_industries",
              "networking_areas_of_expertise",
              "networking_education_level",
              "networking_skills",
              "networking_functional_areas",
              "networking_event_preference",
              "jobs_types",
              "jobs_salary_range",
              "jobs_work_arrangement",
              "jobs_company_size",
              "jobs_industries",
              "jobs_education_level",
              "jobs_skills",
              "jobs_experience_level",
              "jobs_functional_areas",
              "deal_breakers"
            ];
            for (const field of arrayFieldsToProcess) {
              if (processedData[field] && Array.isArray(processedData[field])) {
                console.log(`ARRAY-FIX: Processing ${field}:`, processedData[field]);
                try {
                  const arrayValue = `{${processedData[field].map((item) => `"${item}"`).join(",")}}`;
                  console.log(`ARRAY-FIX: PostgreSQL array format for ${field}:`, arrayValue);
                  await db.execute(sql.raw(`UPDATE connections_preferences 
                SET ${field} = '${arrayValue}'::text[], 
                    updated_at = NOW() 
                WHERE user_id = ${userId}`));
                  console.log(`ARRAY-FIX: Successfully updated ${field}`);
                } catch (sqlError) {
                  console.error(`ARRAY-FIX: Failed to update ${field}:`, sqlError);
                }
              }
            }
            const finalUpdateData = { ...processedData };
            if (data.networking_location_preference !== void 0) {
              finalUpdateData.networking_location_preference = data.networking_location_preference;
              console.log("\u{1F527} SINGLE-FIELD FIX: Using original networking_location_preference:", data.networking_location_preference);
            }
            if (data.mentorship_location_preference !== void 0) {
              finalUpdateData.mentorship_location_preference = data.mentorship_location_preference;
            }
            if (data.jobs_work_location !== void 0) {
              finalUpdateData.jobs_work_location = data.jobs_work_location;
            }
            if (data.mentorship_time_commitment !== void 0) {
              finalUpdateData.mentorship_time_commitment = data.mentorship_time_commitment;
            }
            if (data.jobs_weights !== void 0) {
              finalUpdateData.jobs_weights = data.jobs_weights;
            }
            if (data.mentorship_weights !== void 0) {
              finalUpdateData.mentorship_weights = data.mentorship_weights;
            }
            if (data.networking_weights !== void 0) {
              finalUpdateData.networking_weights = data.networking_weights;
            }
            const updateData = {
              ...finalUpdateData,
              updatedAt: /* @__PURE__ */ new Date()
            };
            if (updateData.networking_location_preference !== void 0) {
              await db.execute(sql`
            UPDATE connections_preferences 
            SET networking_location_preference = ${updateData.networking_location_preference}, 
                updated_at = ${updateData.updatedAt}
            WHERE user_id = ${userId}
          `);
              console.log("\u{1F527} DIRECT SQL: Updated networking_location_preference to:", updateData.networking_location_preference);
            }
            if (updateData.mentorship_location_preference !== void 0) {
              await db.execute(sql`
            UPDATE connections_preferences 
            SET mentorship_location_preference = ${updateData.mentorship_location_preference}, 
                updated_at = ${updateData.updatedAt}
            WHERE user_id = ${userId}
          `);
              console.log("\u{1F527} DIRECT SQL: Updated mentorship_location_preference to:", updateData.mentorship_location_preference);
            }
            if (updateData.jobs_work_location !== void 0) {
              await db.execute(sql`
            UPDATE connections_preferences 
            SET jobs_work_location = ${updateData.jobs_work_location}, 
                updated_at = ${updateData.updatedAt}
            WHERE user_id = ${userId}
          `);
              console.log("\u{1F527} DIRECT SQL: Updated jobs_work_location to:", updateData.jobs_work_location);
            }
            if (data.jobs_weights !== void 0) {
              await db.execute(sql`
            UPDATE connections_preferences 
            SET jobs_weights = ${JSON.stringify(data.jobs_weights)}, 
                updated_at = ${updateData.updatedAt}
            WHERE user_id = ${userId}
          `);
              console.log("\u{1F527} DIRECT SQL: Updated jobs_weights to:", data.jobs_weights);
            }
            if (data.jobs_salary_currency !== void 0) {
              await db.execute(sql`
            UPDATE connections_preferences 
            SET jobs_salary_currency = ${data.jobs_salary_currency}, 
                updated_at = ${updateData.updatedAt}
            WHERE user_id = ${userId}
          `);
              console.log("\u{1F527} SALARY: Updated jobs_salary_currency to:", data.jobs_salary_currency);
            }
            if (data.jobs_salary_min !== void 0) {
              await db.execute(sql`
            UPDATE connections_preferences 
            SET jobs_salary_min = ${data.jobs_salary_min}, 
                updated_at = ${updateData.updatedAt}
            WHERE user_id = ${userId}
          `);
              console.log("\u{1F527} SALARY: Updated jobs_salary_min to:", data.jobs_salary_min);
            }
            if (data.jobs_salary_max !== void 0) {
              await db.execute(sql`
            UPDATE connections_preferences 
            SET jobs_salary_max = ${data.jobs_salary_max}, 
                updated_at = ${updateData.updatedAt}
            WHERE user_id = ${userId}
          `);
              console.log("\u{1F527} SALARY: Updated jobs_salary_max to:", data.jobs_salary_max);
            }
            if (data.jobs_salary_period !== void 0) {
              await db.execute(sql`
            UPDATE connections_preferences 
            SET jobs_salary_period = ${data.jobs_salary_period}, 
                updated_at = ${updateData.updatedAt}
            WHERE user_id = ${userId}
          `);
              console.log("\u{1F527} SALARY: Updated jobs_salary_period to:", data.jobs_salary_period);
            }
            if (data.mentorship_weights !== void 0) {
              await db.execute(sql`
            UPDATE connections_preferences 
            SET mentorship_weights = ${JSON.stringify(data.mentorship_weights)}, 
                updated_at = ${updateData.updatedAt}
            WHERE user_id = ${userId}
          `);
              console.log("\u{1F527} DIRECT SQL: Updated mentorship_weights to:", data.mentorship_weights);
            }
            if (data.networking_weights !== void 0) {
              await db.execute(sql`
            UPDATE connections_preferences 
            SET networking_weights = ${JSON.stringify(data.networking_weights)}, 
                updated_at = ${updateData.updatedAt}
            WHERE user_id = ${userId}
          `);
              console.log("\u{1F527} DIRECT SQL: Updated networking_weights to:", data.networking_weights);
            }
            const [updated] = await db.update(connectionsPreferences).set(updateData).where(eq(connectionsPreferences.userId, userId)).returning();
            console.log("Connections preferences updated successfully for user:", userId);
            return updated;
          } else {
            const [created] = await db.insert(connectionsPreferences).values({
              ...cleanData,
              userId,
              createdAt: /* @__PURE__ */ new Date(),
              updatedAt: /* @__PURE__ */ new Date()
            }).returning();
            return created;
          }
        } catch (error) {
          console.error("Error saving connections preferences:", error);
          throw error;
        }
      }
      // ===================================
      // USER REPORT STRIKES METHODS
      // ===================================
      async createUserReportStrike(reportStrike) {
        const [strike] = await db.insert(userReportStrikes).values({
          ...reportStrike,
          createdAt: /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date()
        }).returning();
        return strike;
      }
      async getUserReportStrikes(reportedUserId) {
        return await db.select().from(userReportStrikes).where(eq(userReportStrikes.reportedUserId, reportedUserId)).orderBy(desc(userReportStrikes.createdAt));
      }
      async getUserReportStrikeCount(reportedUserId) {
        const result = await db.select({ count: count() }).from(userReportStrikes).where(eq(userReportStrikes.reportedUserId, reportedUserId));
        return result[0]?.count || 0;
      }
      async getReportStrikesInLast24Hours(reportedUserId) {
        const yesterday = /* @__PURE__ */ new Date();
        yesterday.setHours(yesterday.getHours() - 24);
        return await db.select().from(userReportStrikes).where(
          and(
            eq(userReportStrikes.reportedUserId, reportedUserId),
            sql`${userReportStrikes.createdAt} >= ${yesterday}`
          )
        ).orderBy(desc(userReportStrikes.createdAt));
      }
      // ===== PAYMENT SYSTEM IMPLEMENTATION =====
      // Subscription operations
      async createSubscription(subscription) {
        try {
          const [result] = await db.insert(subscriptions).values(subscription).returning();
          return result;
        } catch (error) {
          console.error("Error creating subscription:", error);
          throw error;
        }
      }
      async getSubscriptionById(id) {
        try {
          const [subscription] = await db.select().from(subscriptions).where(eq(subscriptions.id, id));
          return subscription || void 0;
        } catch (error) {
          console.error("Error getting subscription by ID:", error);
          throw error;
        }
      }
      async getUserSubscription(userId) {
        try {
          const [subscription] = await db.select().from(subscriptions).where(eq(subscriptions.userId, userId)).orderBy(desc(subscriptions.createdAt)).limit(1);
          return subscription || void 0;
        } catch (error) {
          console.error("Error getting user subscription:", error);
          throw error;
        }
      }
      async getUserActiveSubscription(userId) {
        try {
          const [subscription] = await db.select().from(subscriptions).where(
            and(
              eq(subscriptions.userId, userId),
              eq(subscriptions.status, "active"),
              sql`${subscriptions.currentPeriodEnd} > NOW()`
            )
          ).orderBy(desc(subscriptions.createdAt)).limit(1);
          return subscription || void 0;
        } catch (error) {
          console.error("Error getting user active subscription:", error);
          throw error;
        }
      }
      async updateSubscription(id, updates) {
        try {
          const [subscription] = await db.update(subscriptions).set({ ...updates, updatedAt: /* @__PURE__ */ new Date() }).where(eq(subscriptions.id, id)).returning();
          return subscription || void 0;
        } catch (error) {
          console.error("Error updating subscription:", error);
          throw error;
        }
      }
      async cancelSubscription(id) {
        try {
          const [subscription] = await db.update(subscriptions).set({
            status: "cancelled",
            cancelAtPeriodEnd: true,
            cancelledAt: /* @__PURE__ */ new Date(),
            updatedAt: /* @__PURE__ */ new Date()
          }).where(eq(subscriptions.id, id)).returning();
          return subscription || void 0;
        } catch (error) {
          console.error("Error cancelling subscription:", error);
          throw error;
        }
      }
      async getExpiredSubscriptions() {
        try {
          return await db.select().from(subscriptions).where(
            and(
              eq(subscriptions.status, "active"),
              sql`${subscriptions.currentPeriodEnd} < NOW()`
            )
          );
        } catch (error) {
          console.error("Error getting expired subscriptions:", error);
          throw error;
        }
      }
      async getSubscriptionsByProvider(provider) {
        try {
          return await db.select().from(subscriptions).where(eq(subscriptions.provider, provider)).orderBy(desc(subscriptions.createdAt));
        } catch (error) {
          console.error("Error getting subscriptions by provider:", error);
          throw error;
        }
      }
      async getUserSubscriptionHistory(userId) {
        try {
          return await db.select().from(subscriptions).where(eq(subscriptions.userId, userId)).orderBy(desc(subscriptions.createdAt));
        } catch (error) {
          console.error("Error getting user subscription history:", error);
          throw error;
        }
      }
      // Payment method operations
      async createPaymentMethod(paymentMethod) {
        try {
          const [result] = await db.insert(paymentMethods).values(paymentMethod).returning();
          return result;
        } catch (error) {
          console.error("Error creating payment method:", error);
          throw error;
        }
      }
      async getPaymentMethodById(id) {
        try {
          const [paymentMethod] = await db.select().from(paymentMethods).where(eq(paymentMethods.id, id));
          return paymentMethod || void 0;
        } catch (error) {
          console.error("Error getting payment method by ID:", error);
          throw error;
        }
      }
      async getUserPaymentMethods(userId) {
        try {
          return await db.select().from(paymentMethods).where(
            and(
              eq(paymentMethods.userId, userId),
              eq(paymentMethods.isActive, true)
            )
          ).orderBy(desc(paymentMethods.isDefault), desc(paymentMethods.createdAt));
        } catch (error) {
          console.error("Error getting user payment methods:", error);
          throw error;
        }
      }
      async getUserDefaultPaymentMethod(userId) {
        try {
          const [paymentMethod] = await db.select().from(paymentMethods).where(
            and(
              eq(paymentMethods.userId, userId),
              eq(paymentMethods.isDefault, true),
              eq(paymentMethods.isActive, true)
            )
          ).limit(1);
          return paymentMethod || void 0;
        } catch (error) {
          console.error("Error getting user default payment method:", error);
          throw error;
        }
      }
      async updatePaymentMethod(id, updates) {
        try {
          const [paymentMethod] = await db.update(paymentMethods).set({ ...updates, updatedAt: /* @__PURE__ */ new Date() }).where(eq(paymentMethods.id, id)).returning();
          return paymentMethod || void 0;
        } catch (error) {
          console.error("Error updating payment method:", error);
          throw error;
        }
      }
      async deletePaymentMethod(id) {
        try {
          await db.update(paymentMethods).set({ isActive: false, updatedAt: /* @__PURE__ */ new Date() }).where(eq(paymentMethods.id, id));
        } catch (error) {
          console.error("Error deleting payment method:", error);
          throw error;
        }
      }
      async setDefaultPaymentMethod(userId, paymentMethodId) {
        try {
          await db.update(paymentMethods).set({ isDefault: false, updatedAt: /* @__PURE__ */ new Date() }).where(eq(paymentMethods.userId, userId));
          const [paymentMethod] = await db.update(paymentMethods).set({ isDefault: true, updatedAt: /* @__PURE__ */ new Date() }).where(
            and(
              eq(paymentMethods.id, paymentMethodId),
              eq(paymentMethods.userId, userId)
            )
          ).returning();
          return paymentMethod || void 0;
        } catch (error) {
          console.error("Error setting default payment method:", error);
          throw error;
        }
      }
      // Payment history operations
      async createPaymentHistory(payment) {
        try {
          const [result] = await db.insert(paymentHistory).values(payment).returning();
          return result;
        } catch (error) {
          console.error("Error creating payment history:", error);
          throw error;
        }
      }
      async getPaymentHistoryById(id) {
        try {
          const [payment] = await db.select().from(paymentHistory).where(eq(paymentHistory.id, id));
          return payment || void 0;
        } catch (error) {
          console.error("Error getting payment history by ID:", error);
          throw error;
        }
      }
      async getUserPaymentHistory(userId) {
        try {
          return await db.select().from(paymentHistory).where(eq(paymentHistory.userId, userId)).orderBy(desc(paymentHistory.createdAt));
        } catch (error) {
          console.error("Error getting user payment history:", error);
          throw error;
        }
      }
      async getSubscriptionPaymentHistory(subscriptionId) {
        try {
          return await db.select().from(paymentHistory).where(eq(paymentHistory.subscriptionId, subscriptionId)).orderBy(desc(paymentHistory.createdAt));
        } catch (error) {
          console.error("Error getting subscription payment history:", error);
          throw error;
        }
      }
      async getPaymentHistoryByProvider(provider) {
        try {
          return await db.select().from(paymentHistory).where(eq(paymentHistory.provider, provider)).orderBy(desc(paymentHistory.createdAt));
        } catch (error) {
          console.error("Error getting payment history by provider:", error);
          throw error;
        }
      }
      async getFailedPayments(userId) {
        try {
          const conditions = [eq(paymentHistory.status, "failed")];
          if (userId) {
            conditions.push(eq(paymentHistory.userId, userId));
          }
          return await db.select().from(paymentHistory).where(and(...conditions)).orderBy(desc(paymentHistory.createdAt));
        } catch (error) {
          console.error("Error getting failed payments:", error);
          throw error;
        }
      }
      async updatePaymentStatus(id, status, metadata) {
        try {
          const updates = {
            status,
            updatedAt: /* @__PURE__ */ new Date()
          };
          if (metadata) {
            updates.metadata = metadata;
          }
          const [payment] = await db.update(paymentHistory).set(updates).where(eq(paymentHistory.id, id)).returning();
          return payment || void 0;
        } catch (error) {
          console.error("Error updating payment status:", error);
          throw error;
        }
      }
      // Subscription events operations
      async createSubscriptionEvent(event) {
        try {
          const [result] = await db.insert(subscriptionEvents).values(event).returning();
          return result;
        } catch (error) {
          console.error("Error creating subscription event:", error);
          throw error;
        }
      }
      async getSubscriptionEvents(subscriptionId) {
        try {
          return await db.select().from(subscriptionEvents).where(eq(subscriptionEvents.subscriptionId, subscriptionId)).orderBy(desc(subscriptionEvents.createdAt));
        } catch (error) {
          console.error("Error getting subscription events:", error);
          throw error;
        }
      }
      async getUserSubscriptionEvents(userId) {
        try {
          return await db.select().from(subscriptionEvents).where(eq(subscriptionEvents.userId, userId)).orderBy(desc(subscriptionEvents.createdAt));
        } catch (error) {
          console.error("Error getting user subscription events:", error);
          throw error;
        }
      }
      // Regional pricing operations
      async createRegionalPricing(pricing) {
        try {
          const [result] = await db.insert(regionalPricing).values(pricing).returning();
          return result;
        } catch (error) {
          console.error("Error creating regional pricing:", error);
          throw error;
        }
      }
      async getRegionalPricing(planType, region, currency) {
        try {
          const [pricing] = await db.select().from(regionalPricing).where(
            and(
              eq(regionalPricing.planType, planType),
              eq(regionalPricing.region, region),
              eq(regionalPricing.currency, currency),
              eq(regionalPricing.isActive, true),
              or(
                eq(regionalPricing.validUntil, null),
                sql`${regionalPricing.validUntil} > NOW()`
              )
            )
          ).orderBy(desc(regionalPricing.createdAt)).limit(1);
          return pricing || void 0;
        } catch (error) {
          console.error("Error getting regional pricing:", error);
          throw error;
        }
      }
      async getActivePricingForRegion(region) {
        try {
          return await db.select().from(regionalPricing).where(
            and(
              eq(regionalPricing.region, region),
              eq(regionalPricing.isActive, true),
              or(
                eq(regionalPricing.validUntil, null),
                sql`${regionalPricing.validUntil} > NOW()`
              )
            )
          ).orderBy(regionalPricing.planType, desc(regionalPricing.createdAt));
        } catch (error) {
          console.error("Error getting active pricing for region:", error);
          throw error;
        }
      }
      async updateRegionalPricing(id, updates) {
        try {
          const [pricing] = await db.update(regionalPricing).set({ ...updates, updatedAt: /* @__PURE__ */ new Date() }).where(eq(regionalPricing.id, id)).returning();
          return pricing || void 0;
        } catch (error) {
          console.error("Error updating regional pricing:", error);
          throw error;
        }
      }
      async getDefaultPricing(planType) {
        try {
          const [pricing] = await db.select().from(regionalPricing).where(
            and(
              eq(regionalPricing.planType, planType),
              eq(regionalPricing.region, "global"),
              eq(regionalPricing.isActive, true),
              or(
                eq(regionalPricing.validUntil, null),
                sql`${regionalPricing.validUntil} > NOW()`
              )
            )
          ).orderBy(desc(regionalPricing.createdAt)).limit(1);
          return pricing || void 0;
        } catch (error) {
          console.error("Error getting default pricing:", error);
          throw error;
        }
      }
      // Promotional code operations
      async createPromotionalCode(promoCode) {
        try {
          const [result] = await db.insert(promotionalCodes).values(promoCode).returning();
          return result;
        } catch (error) {
          console.error("Error creating promotional code:", error);
          throw error;
        }
      }
      async getPromotionalCodeByCode(code) {
        try {
          const [promoCode] = await db.select().from(promotionalCodes).where(
            and(
              eq(promotionalCodes.code, code),
              eq(promotionalCodes.isActive, true),
              sql`${promotionalCodes.validFrom} <= NOW()`,
              or(
                eq(promotionalCodes.validUntil, null),
                sql`${promotionalCodes.validUntil} > NOW()`
              )
            )
          );
          return promoCode || void 0;
        } catch (error) {
          console.error("Error getting promotional code by code:", error);
          throw error;
        }
      }
      async validatePromotionalCode(code, userId, planType, region) {
        try {
          const promoCode = await this.getPromotionalCodeByCode(code);
          if (!promoCode) {
            return { valid: false, error: "Invalid or expired promotional code" };
          }
          const existingUsage = await this.getUserPromotionalCodeUsage(userId, promoCode.id);
          if (existingUsage) {
            return { valid: false, error: "Promotional code already used" };
          }
          if (promoCode.maxUses && promoCode.currentUses >= promoCode.maxUses) {
            return { valid: false, error: "Promotional code usage limit reached" };
          }
          if (promoCode.planTypes) {
            const allowedPlanTypes = JSON.parse(promoCode.planTypes);
            if (!allowedPlanTypes.includes(planType)) {
              return { valid: false, error: "Promotional code not valid for this plan" };
            }
          }
          if (promoCode.regions) {
            const allowedRegions = JSON.parse(promoCode.regions);
            if (!allowedRegions.includes(region)) {
              return { valid: false, error: "Promotional code not valid for this region" };
            }
          }
          return { valid: true, discount: promoCode.value };
        } catch (error) {
          console.error("Error validating promotional code:", error);
          return { valid: false, error: "Error validating promotional code" };
        }
      }
      async usePromotionalCode(usage) {
        try {
          const [result] = await db.insert(promotionalCodeUsage).values(usage).returning();
          await this.incrementPromotionalCodeUsage(usage.promoCodeId);
          return result;
        } catch (error) {
          console.error("Error using promotional code:", error);
          throw error;
        }
      }
      async getPromotionalCodeUsage(userId) {
        try {
          return await db.select().from(promotionalCodeUsage).where(eq(promotionalCodeUsage.userId, userId)).orderBy(desc(promotionalCodeUsage.usedAt));
        } catch (error) {
          console.error("Error getting promotional code usage:", error);
          throw error;
        }
      }
      async getUserPromotionalCodeUsage(userId, promoCodeId) {
        try {
          const [usage] = await db.select().from(promotionalCodeUsage).where(
            and(
              eq(promotionalCodeUsage.userId, userId),
              eq(promotionalCodeUsage.promoCodeId, promoCodeId)
            )
          );
          return usage || void 0;
        } catch (error) {
          console.error("Error getting user promotional code usage:", error);
          throw error;
        }
      }
      async incrementPromotionalCodeUsage(promoCodeId) {
        try {
          const [promoCode] = await db.update(promotionalCodes).set({
            currentUses: sql`${promotionalCodes.currentUses} + 1`,
            updatedAt: /* @__PURE__ */ new Date()
          }).where(eq(promotionalCodes.id, promoCodeId)).returning();
          return promoCode || void 0;
        } catch (error) {
          console.error("Error incrementing promotional code usage:", error);
          throw error;
        }
      }
      // Payment analytics and reporting
      async getRevenueByRegion(startDate, endDate) {
        try {
          const conditions = [eq(paymentHistory.status, "succeeded")];
          if (startDate) {
            conditions.push(sql`${paymentHistory.createdAt} >= ${startDate}`);
          }
          if (endDate) {
            conditions.push(sql`${paymentHistory.createdAt} <= ${endDate}`);
          }
          const results = await db.select({
            region: subscriptions.region,
            revenue: sql`SUM(${paymentHistory.amount})`,
            currency: paymentHistory.currency
          }).from(paymentHistory).innerJoin(subscriptions, eq(paymentHistory.subscriptionId, subscriptions.id)).where(and(...conditions)).groupBy(subscriptions.region, paymentHistory.currency).orderBy(desc(sql`SUM(${paymentHistory.amount})`));
          return results;
        } catch (error) {
          console.error("Error getting revenue by region:", error);
          throw error;
        }
      }
      async getSubscriptionStats() {
        try {
          const [activeCount] = await db.select({ count: count() }).from(subscriptions).where(eq(subscriptions.status, "active"));
          const [cancelledCount] = await db.select({ count: count() }).from(subscriptions).where(eq(subscriptions.status, "cancelled"));
          const [totalCount] = await db.select({ count: count() }).from(subscriptions);
          return {
            active: activeCount.count,
            cancelled: cancelledCount.count,
            total: totalCount.count
          };
        } catch (error) {
          console.error("Error getting subscription stats:", error);
          throw error;
        }
      }
      async getPaymentFailureRate(provider) {
        try {
          const conditions = [];
          if (provider) {
            conditions.push(eq(paymentHistory.provider, provider));
          }
          const [totalPayments] = await db.select({ count: count() }).from(paymentHistory).where(conditions.length > 0 ? and(...conditions) : void 0);
          const failedConditions = [...conditions, eq(paymentHistory.status, "failed")];
          const [failedPayments] = await db.select({ count: count() }).from(paymentHistory).where(and(...failedConditions));
          if (totalPayments.count === 0) return 0;
          return failedPayments.count / totalPayments.count * 100;
        } catch (error) {
          console.error("Error getting payment failure rate:", error);
          throw error;
        }
      }
      async getMostUsedPaymentMethods() {
        try {
          const results = await db.select({
            type: paymentHistory.paymentMethod,
            count: sql`COUNT(*)`
          }).from(paymentHistory).where(eq(paymentHistory.status, "succeeded")).groupBy(paymentHistory.paymentMethod).orderBy(desc(sql`COUNT(*)`)).limit(10);
          return results;
        } catch (error) {
          console.error("Error getting most used payment methods:", error);
          throw error;
        }
      }
      // ===================================
      // SUBSCRIPTION IMPLEMENTATION METHODS
      // ===================================
      async createSubscription(subscription) {
        try {
          const [created] = await db.insert(subscriptions).values(subscription).returning();
          return created;
        } catch (error) {
          console.error("Error creating subscription:", error);
          throw error;
        }
      }
      async getSubscription(id) {
        try {
          const [subscription] = await db.select().from(subscriptions).where(eq(subscriptions.id, id));
          return subscription;
        } catch (error) {
          console.error("Error getting subscription:", error);
          throw error;
        }
      }
      async getSubscriptionByUser(userId) {
        try {
          const [subscription] = await db.select().from(subscriptions).where(eq(subscriptions.userId, userId));
          return subscription;
        } catch (error) {
          console.error("Error getting subscription by user:", error);
          throw error;
        }
      }
      async getSubscriptionByStripeId(subscriptionId) {
        try {
          const [subscription] = await db.select().from(subscriptions).where(eq(subscriptions.subscriptionId, subscriptionId));
          return subscription;
        } catch (error) {
          console.error("Error getting subscription by Stripe ID:", error);
          throw error;
        }
      }
      async updateSubscription(id, updates) {
        try {
          const [updated] = await db.update(subscriptions).set(updates).where(eq(subscriptions.id, id)).returning();
          return updated;
        } catch (error) {
          console.error("Error updating subscription:", error);
          throw error;
        }
      }
      async cancelSubscription(id) {
        try {
          const [cancelled] = await db.update(subscriptions).set({
            status: "cancelled",
            updatedAt: /* @__PURE__ */ new Date()
          }).where(eq(subscriptions.id, id)).returning();
          return cancelled;
        } catch (error) {
          console.error("Error cancelling subscription:", error);
          throw error;
        }
      }
      async createPaymentMethod(paymentMethod) {
        try {
          const [created] = await db.insert(paymentMethods).values(paymentMethod).returning();
          return created;
        } catch (error) {
          console.error("Error creating payment method:", error);
          throw error;
        }
      }
      async getPaymentMethodsByUser(userId) {
        try {
          return await db.select().from(paymentMethods).where(eq(paymentMethods.userId, userId));
        } catch (error) {
          console.error("Error getting payment methods by user:", error);
          throw error;
        }
      }
      async getPaymentMethod(id) {
        try {
          const [paymentMethod] = await db.select().from(paymentMethods).where(eq(paymentMethods.id, id));
          return paymentMethod;
        } catch (error) {
          console.error("Error getting payment method:", error);
          throw error;
        }
      }
      async updatePaymentMethod(id, updates) {
        try {
          const [updated] = await db.update(paymentMethods).set(updates).where(eq(paymentMethods.id, id)).returning();
          return updated;
        } catch (error) {
          console.error("Error updating payment method:", error);
          throw error;
        }
      }
      async deletePaymentMethod(id) {
        try {
          await db.delete(paymentMethods).where(eq(paymentMethods.id, id));
        } catch (error) {
          console.error("Error deleting payment method:", error);
          throw error;
        }
      }
      async createPaymentHistory(payment) {
        try {
          const [created] = await db.insert(paymentHistory).values(payment).returning();
          return created;
        } catch (error) {
          console.error("Error creating payment history:", error);
          throw error;
        }
      }
      async getPaymentHistoryByUser(userId) {
        try {
          return await db.select().from(paymentHistory).where(eq(paymentHistory.userId, userId)).orderBy(desc(paymentHistory.createdAt));
        } catch (error) {
          console.error("Error getting payment history by user:", error);
          throw error;
        }
      }
      async getPaymentHistoryBySubscription(subscriptionId) {
        try {
          return await db.select().from(paymentHistory).where(eq(paymentHistory.subscriptionId, subscriptionId)).orderBy(desc(paymentHistory.createdAt));
        } catch (error) {
          console.error("Error getting payment history by subscription:", error);
          throw error;
        }
      }
      async getRegionalPricing(region, planType) {
        try {
          const conditions = [
            eq(regionalPricing.region, region),
            eq(regionalPricing.isActive, true)
          ];
          if (planType) {
            conditions.push(eq(regionalPricing.planType, planType));
          }
          return await db.select().from(regionalPricing).where(and(...conditions)).orderBy(regionalPricing.planType);
        } catch (error) {
          console.error("Error getting regional pricing:", error);
          throw error;
        }
      }
      async getRegionalPricingByRegion(region) {
        try {
          return await db.select().from(regionalPricing).where(
            and(
              eq(regionalPricing.region, region),
              eq(regionalPricing.isActive, true),
              or(
                eq(regionalPricing.validUntil, null),
                sql`${regionalPricing.validUntil} > NOW()`
              )
            )
          ).orderBy(regionalPricing.planType);
        } catch (error) {
          console.error("Error getting regional pricing by region:", error);
          throw error;
        }
      }
      async createRegionalPricing(pricing) {
        try {
          const [created] = await db.insert(regionalPricing).values(pricing).returning();
          return created;
        } catch (error) {
          console.error("Error creating regional pricing:", error);
          throw error;
        }
      }
      async getPromotionalCode(code) {
        try {
          const [promo] = await db.select().from(promotionalCodes).where(eq(promotionalCodes.code, code));
          return promo;
        } catch (error) {
          console.error("Error getting promotional code:", error);
          throw error;
        }
      }
      async validatePromotionalCode(code, userId, region) {
        try {
          const promoCode = await this.getPromotionalCode(code);
          if (!promoCode) {
            return { valid: false, error: "Promotional code not found" };
          }
          if (!promoCode.isActive) {
            return { valid: false, error: "Promotional code is no longer active" };
          }
          if (promoCode.expiresAt && /* @__PURE__ */ new Date() > promoCode.expiresAt) {
            return { valid: false, error: "Promotional code has expired" };
          }
          if (promoCode.maxUses && promoCode.usedCount >= promoCode.maxUses) {
            return { valid: false, error: "Promotional code usage limit reached" };
          }
          const existingUsage = await this.getUserPromotionalCodeUsage(userId, promoCode.id);
          if (existingUsage) {
            return { valid: false, error: "You have already used this promotional code" };
          }
          return { valid: true, discount: promoCode.discountPercentage };
        } catch (error) {
          console.error("Error validating promotional code:", error);
          return { valid: false, error: "Error validating promotional code" };
        }
      }
      async createPromotionalCodeUsage(usage) {
        try {
          const [created] = await db.insert(promotionalCodeUsage).values(usage).returning();
          return created;
        } catch (error) {
          console.error("Error creating promotional code usage:", error);
          throw error;
        }
      }
      // Unified API performance optimization methods
      async getSwipeHistory(userId, appMode, limit) {
        try {
          const startTime = Date.now();
          const history = await db.select().from(swipeHistory).where(
            and(
              eq(swipeHistory.userId, userId),
              eq(swipeHistory.appMode, appMode)
            )
          ).orderBy(desc(swipeHistory.timestamp)).limit(limit);
          const duration = Date.now() - startTime;
          console.log(`[SWIPE-HISTORY-FAST] User ${userId}: Query completed in ${duration}ms, returning ${history.length} items`);
          return history;
        } catch (error) {
          console.error("Error fetching swipe history:", error);
          return [];
        }
      }
      // Matrix Factorization helper methods
      async getAllMatches() {
        try {
          const allMatches = await db.select({
            id: matches.id,
            userId1: matches.userId1,
            userId2: matches.userId2,
            matched: matches.matched,
            isDislike: matches.isDislike,
            createdAt: matches.createdAt,
            metadata: matches.metadata
          }).from(matches);
          console.log(`[STORAGE] Retrieved ${allMatches.length} matches for matrix factorization`);
          return allMatches;
        } catch (error) {
          console.error("Error fetching all matches:", error);
          return [];
        }
      }
      async getAllSwipeHistory() {
        try {
          const allSwipes = await db.select({
            id: swipeHistory.id,
            userId: swipeHistory.userId,
            targetUserId: swipeHistory.targetUserId,
            action: swipeHistory.action,
            appMode: swipeHistory.appMode,
            timestamp: swipeHistory.timestamp
          }).from(swipeHistory);
          console.log(`[STORAGE] Retrieved ${allSwipes.length} swipe history records for matrix factorization`);
          return allSwipes;
        } catch (error) {
          console.error("Error fetching all swipe history:", error);
          return [];
        }
      }
      async getPremiumStatus(userId) {
        try {
          const user = await this.getUser(userId);
          if (!user) {
            return { premiumAccess: false };
          }
          const subscription = await this.getUserActiveSubscription(userId);
          return {
            premiumAccess: user.premiumAccess || false,
            subscriptionStatus: subscription?.status || "none"
          };
        } catch (error) {
          console.error("Error fetching premium status:", error);
          return { premiumAccess: false };
        }
      }
      async getMatchCounts(userId) {
        try {
          console.log(`[MATCH-COUNTS-OPTIMIZED] User ${userId}: Starting optimized match count query`);
          const startTime = Date.now();
          const [result] = await db.select({
            confirmed: sql`COUNT(CASE WHEN matched = true THEN 1 END)`,
            pending: sql`COUNT(CASE WHEN matched = false AND is_dislike = false THEN 1 END)`,
            total: sql`COUNT(*)`
          }).from(matches).where(
            or(
              eq(matches.userId1, userId),
              eq(matches.userId2, userId)
            )
          );
          const duration = Date.now() - startTime;
          console.log(`[MATCH-COUNTS-OPTIMIZED] User ${userId}: Query completed in ${duration}ms`);
          return {
            confirmed: Number(result?.confirmed) || 0,
            pending: Number(result?.pending) || 0,
            total: Number(result?.total) || 0
          };
        } catch (error) {
          console.error("Error fetching match counts:", error);
          return { confirmed: 0, pending: 0, total: 0 };
        }
      }
      async getMatches(userId) {
        try {
          return await this.getMeetMatchesByUserId(userId);
        } catch (error) {
          console.error("Error fetching matches:", error);
          return [];
        }
      }
      async getSuiteConnectionCounts(userId) {
        try {
          console.log(`[SUITE-COUNTS-OPTIMIZED] User ${userId}: Starting optimized count queries`);
          const startTime = Date.now();
          const [networkingResult] = await db.select({
            confirmed: sql`COUNT(CASE WHEN matched = true THEN 1 END)`,
            pending: sql`COUNT(CASE WHEN matched = false AND is_dislike = false THEN 1 END)`
          }).from(suiteNetworkingConnections).where(eq(suiteNetworkingConnections.userId, userId));
          const [mentorshipResult] = await db.select({
            confirmed: sql`COUNT(CASE WHEN matched = true THEN 1 END)`,
            pending: sql`COUNT(CASE WHEN matched = false AND is_dislike = false THEN 1 END)`
          }).from(suiteMentorshipConnections).where(eq(suiteMentorshipConnections.userId, userId));
          const [jobsResult] = await db.select({
            accepted: sql`COUNT(CASE WHEN action = 'accepted' THEN 1 END)`,
            pending: sql`COUNT(CASE WHEN action = 'pending' THEN 1 END)`
          }).from(suiteJobApplications).where(eq(suiteJobApplications.userId, userId));
          const duration = Date.now() - startTime;
          console.log(`[SUITE-COUNTS-OPTIMIZED] User ${userId}: Query completed in ${duration}ms`);
          return {
            networking: {
              matches: Number(networkingResult?.confirmed) || 0,
              pending: Number(networkingResult?.pending) || 0
            },
            mentorship: {
              matches: Number(mentorshipResult?.confirmed) || 0,
              pending: Number(mentorshipResult?.pending) || 0
            },
            jobs: {
              matches: Number(jobsResult?.accepted) || 0,
              pending: Number(jobsResult?.pending) || 0
            }
          };
        } catch (error) {
          console.error("Error fetching suite connection counts:", error);
          return {
            networking: { matches: 0, pending: 0 },
            mentorship: { matches: 0, pending: 0 },
            jobs: { matches: 0, pending: 0 }
          };
        }
      }
    };
    storage = new DatabaseStorage();
  }
});

// server/auth.ts
import passport from "passport";
import { Strategy as LocalStrategy } from "passport-local";
import session2 from "express-session";
import { scrypt, randomBytes, timingSafeEqual } from "crypto";
import { promisify } from "util";
async function hashPassword(password) {
  const salt = randomBytes(16).toString("hex");
  const buf = await scryptAsync(password, salt, 64);
  return `${buf.toString("hex")}.${salt}`;
}
async function comparePasswords(supplied, stored) {
  const [hashed, salt] = stored.split(".");
  const hashedBuf = Buffer.from(hashed, "hex");
  const suppliedBuf = await scryptAsync(supplied, salt, 64);
  return timingSafeEqual(hashedBuf, suppliedBuf);
}
function setupAuth(app2) {
  const sessionSettings = {
    secret: process.env.SESSION_SECRET || "charley-app-secret-key",
    resave: true,
    // Save session on each request
    saveUninitialized: false,
    // Don't create session until something is stored
    store: storage.sessionStore,
    // Using PostgreSQL store for persistence
    cookie: {
      maxAge: 365 * 24 * 60 * 60 * 1e3,
      // 1 year expiration for long-term persistence
      secure: process.env.NODE_ENV === "production",
      sameSite: "lax",
      httpOnly: true,
      // Prevent JavaScript access to cookies
      path: "/"
    },
    rolling: true
    // Reset expiration with each request to keep session alive
  };
  app2.set("trust proxy", 1);
  app2.use(session2(sessionSettings));
  app2.use(passport.initialize());
  app2.use(passport.session());
  app2.use((req, res, next) => touchSession(req, res, next));
  const userLoginCache = /* @__PURE__ */ new Map();
  const CACHE_TTL = 5 * 60 * 1e3;
  passport.use(
    new LocalStrategy(
      { usernameField: "email" },
      async (email, password, done) => {
        try {
          const cacheKey = `${email}:${password}`;
          const cachedUser = userLoginCache.get(cacheKey);
          if (cachedUser && cachedUser.expiry > Date.now()) {
            return done(null, cachedUser.user);
          }
          const [emailUser, usernameUser, phoneUser] = await Promise.all([
            storage.getUserByEmail(email).catch(() => null),
            storage.getUserByUsername(email).catch(() => null),
            storage.getUserByPhoneNumber(email).catch(() => null)
          ]);
          const user = emailUser || usernameUser || phoneUser;
          if (!user) {
            return done(null, false);
          }
          if (user.isSuspended) {
            if (user.suspensionExpiresAt && /* @__PURE__ */ new Date() > user.suspensionExpiresAt) {
              await storage.updateUserProfile(user.id, {
                isSuspended: false,
                suspendedAt: null,
                suspensionExpiresAt: null
              });
              console.log(`\u{1F513} User ${user.id} suspension expired, automatically unsuspended`);
            } else {
              console.log(`\u26A0\uFE0F Suspended user ${user.username} (ID: ${user.id}) logged in - will see suspension interface`);
            }
          }
          console.log(`\u{1F50D} Attempting authentication for user: ${user.username} (ID: ${user.id})`);
          console.log(`\u{1F511} Stored password format: ${user.password?.substring(0, 20)}...`);
          const passwordValid = await comparePasswords(password, user.password);
          if (!passwordValid) {
            console.log(`\u274C Authentication failed for user: ${user.username} (ID: ${user.id})`);
            console.log(`\u{1F4DD} Password provided: ${password}`);
            return done(null, false);
          }
          userLoginCache.set(cacheKey, {
            user,
            expiry: Date.now() + CACHE_TTL
          });
          console.log("Authentication successful for user:", user.id);
          return done(null, user);
        } catch (error) {
          console.error("Authentication error:", error);
          return done(error);
        }
      }
    )
  );
  const userDeserializeCache = /* @__PURE__ */ new Map();
  const USER_CACHE_TTL = 5 * 60 * 1e3;
  passport.serializeUser((user, done) => done(null, user.id));
  passport.deserializeUser(async (id, done) => {
    try {
      const cached = userDeserializeCache.get(id);
      if (cached && cached.expiry > Date.now()) {
        return done(null, cached.user);
      }
      const user = await storage.getUser(id);
      if (!user) {
        console.log(`[AUTH-DESERIALIZE] User not found for ID: ${id}`);
        return done(null, false);
      }
      userDeserializeCache.set(id, {
        user,
        expiry: Date.now() + USER_CACHE_TTL
      });
      done(null, user);
    } catch (error) {
      console.error(`[AUTH-DESERIALIZE] Error deserializing user ${id}:`, error);
      done(null, false);
    }
  });
  app2.post("/api/register", async (req, res, next) => {
    try {
      const existenceChecks = [];
      if (req.body.phoneNumber) {
        existenceChecks.push(
          storage.getUserByPhoneNumber(req.body.phoneNumber).then((user2) => ({ type: "phone", user: user2 }))
        );
      }
      if (req.body.email) {
        existenceChecks.push(
          storage.getUserByEmail(req.body.email).then((user2) => ({ type: "email", user: user2 }))
        );
      }
      if (existenceChecks.length > 0) {
        const results = await Promise.all(existenceChecks);
        for (const result of results) {
          if (result.user && (!req.isAuthenticated() || req.user.id !== result.user.id)) {
            return res.status(400).send(`${result.type === "phone" ? "Phone number" : "Email"} already in use by another account`);
          }
        }
      }
      if (!req.body.username) {
        if (req.body.fullName) {
          req.body.username = req.body.fullName.replace(/\s+/g, "") + Math.floor(Math.random() * 1e4);
        } else if (req.body.email) {
          req.body.username = req.body.email.split("@")[0] + Math.floor(Math.random() * 1e4);
        } else {
          req.body.username = "user_" + Math.floor(Math.random() * 1e6);
        }
      }
      const user = await storage.createUser({
        ...req.body,
        password: await hashPassword(req.body.password),
        verifiedByPhone: req.body.phoneNumber ? true : false
      });
      const photoPromises = [];
      if (user.photoUrl) {
        photoPromises.push(
          storage.addUserPhoto({
            userId: user.id,
            photoUrl: user.photoUrl,
            isPrimary: true
          }).catch((photoError) => {
            console.error("Error adding primary user photo during registration:", photoError);
            return null;
          })
        );
      }
      if (req.body.photoUrl2) {
        photoPromises.push(
          storage.addUserPhoto({
            userId: user.id,
            photoUrl: req.body.photoUrl2,
            isPrimary: false
          }).catch((photoError) => {
            console.error("Error adding secondary user photo during registration:", photoError);
            return null;
          })
        );
      }
      if (photoPromises.length > 0) {
        await Promise.all(photoPromises);
      }
      req.login(user, (err) => {
        if (err) return next(err);
        if (req.session && req.session.cookie) {
          req.session.cookie.maxAge = 365 * 24 * 60 * 60 * 1e3;
        }
        const { password, ...userWithoutPassword } = user;
        console.log(`New user ${user.id} registered with persistent session`);
        res.status(201).json(userWithoutPassword);
      });
    } catch (error) {
      console.error("Registration error:", error);
      next(error);
    }
  });
  app2.post("/api/login", (req, res, next) => {
    passport.authenticate("local", (err, user, info) => {
      if (err) return next(err);
      if (!user) {
        return res.status(401).json({ message: "Invalid credentials" });
      }
      req.login(user, (loginErr) => {
        if (loginErr) return next(loginErr);
        if (req.session) {
          req.session.touch();
          if (req.session.cookie) {
            req.session.cookie.maxAge = 365 * 24 * 60 * 60 * 1e3;
          }
          req.session.save(async (saveErr) => {
            if (saveErr) {
              console.error("Session save error:", saveErr);
            }
            try {
              const freshUser = await storage.getUser(user.id);
              if (!freshUser) {
                return res.status(404).json({ message: "User not found" });
              }
              const { password, ...userWithoutPassword } = freshUser;
              console.log(`User ${user.id} logged in with persistent session (fresh DB fetch)`);
              res.status(200).json(userWithoutPassword);
            } catch (dbErr) {
              console.error("DB fetch error after login:", dbErr);
              res.status(500).json({ message: "Failed to fetch user after login" });
            }
          });
        } else {
          const { password, ...userWithoutPassword } = user;
          res.status(200).json(userWithoutPassword);
        }
      });
    })(req, res, next);
  });
  app2.post("/api/logout", (req, res, next) => {
    req.logout((err) => {
      if (err) return next(err);
      res.sendStatus(200);
    });
  });
  app2.get("/api/user", async (req, res) => {
    if (!req.isAuthenticated()) {
      console.log("User authentication check failed");
      return res.status(401).json({ message: "Unauthorized", status: "login_required" });
    }
    const userId = req.user.id;
    try {
      const freshUser = await storage.getUser(userId);
      if (!freshUser) {
        return res.status(404).json({ message: "User not found" });
      }
      if (freshUser.isSuspended) {
        if (freshUser.suspensionExpiresAt && /* @__PURE__ */ new Date() > freshUser.suspensionExpiresAt) {
          await storage.updateUserProfile(userId, {
            isSuspended: false,
            suspendedAt: null,
            suspensionExpiresAt: null
          });
          console.log(`\u{1F513} User ${userId} suspension expired, automatically unsuspended`);
        } else {
          console.log(`\u26A0\uFE0F Suspended user ${freshUser.username} (ID: ${userId}) accessing app - will see suspension interface`);
        }
      }
      if (req.session) {
        req.session.touch();
      }
      const { password, ...userWithoutPassword } = freshUser;
      console.log("User authenticated successfully, ID:", userId);
      res.json(userWithoutPassword);
    } catch (error) {
      console.error("Error checking user status:", error);
      return res.status(500).json({ message: "Internal server error" });
    }
  });
  app2.post("/api/user/activate-profile", async (req, res) => {
    if (!req.isAuthenticated()) {
      console.log("Profile activation failed - user not authenticated");
      return res.status(401).json({ message: "Unauthorized", status: "login_required" });
    }
    try {
      const userId = req.user.id;
      const updatedUser = await storage.updateUser(userId, {
        profileHidden: false,
        hasActivatedProfile: true,
        showProfilePhoto: true
      });
      if (!updatedUser) {
        return res.status(404).json({ message: "User not found" });
      }
      console.log(`MEET profile activated for user ${userId} - privacy toggle disabled and photo visibility enabled automatically`);
      const { password, ...userWithoutPassword } = updatedUser;
      res.json(userWithoutPassword);
    } catch (error) {
      console.error("Profile activation error:", error);
      res.status(500).json({ message: "Failed to activate profile" });
    }
  });
}
var scryptAsync, requireAuth, touchSession;
var init_auth = __esm({
  "server/auth.ts"() {
    "use strict";
    init_storage();
    scryptAsync = promisify(scrypt);
    requireAuth = (req, res, next) => {
      if (req.isAuthenticated()) {
        return next();
      }
      return res.status(401).json({ message: "Unauthorized" });
    };
    touchSession = (req, res, next) => {
      if (req.session) {
        req.session.touch();
      }
      next();
    };
  }
});

// server/match-api.ts
var match_api_exports = {};
__export(match_api_exports, {
  registerMatchAPI: () => registerMatchAPI,
  sendLikeNotification: () => sendLikeNotification,
  sendUnmatchNotification: () => sendUnmatchNotification,
  setWebSocketConnections: () => setWebSocketConnections
});
import { WebSocket } from "ws";
async function setupMatchAndNotify(matchId, user1Id, user2Id) {
  try {
    console.log(
      `Setting up match ${matchId} between users ${user1Id} and ${user2Id} (without automated welcome messages)`
    );
    const user1 = await storage.getUser(user1Id);
    const user2 = await storage.getUser(user2Id);
    if (!user1 || !user2) {
      console.error(`Could not find users for match ${matchId}`);
      return;
    }
    await storage.updateMatch(matchId, { matched: true });
    console.log(
      `Successfully set up match ${matchId} without automated welcome messages`
    );
    if (connectedUsers) {
      const user1Socket = connectedUsers.get(user1Id);
      if (user1Socket && user1Socket.readyState === WebSocket.OPEN) {
        user1Socket.send(
          JSON.stringify({
            type: "matches:refresh",
            matchId,
            reason: "new_match",
            timestamp: (/* @__PURE__ */ new Date()).toISOString()
          })
        );
        user1Socket.send(
          JSON.stringify({
            type: "match_notification",
            match: {
              id: matchId,
              userId1: user1Id,
              userId2: user2Id,
              matched: true
            },
            fromUserInfo: {
              id: user2Id,
              fullName: user2.fullName,
              photoUrl: user2.photoUrl
            },
            matchId,
            isMatch: true,
            forceDisplay: true
          })
        );
      }
      const user2Socket = connectedUsers.get(user2Id);
      if (user2Socket && user2Socket.readyState === WebSocket.OPEN) {
        user2Socket.send(
          JSON.stringify({
            type: "matches:refresh",
            matchId,
            reason: "new_match",
            timestamp: (/* @__PURE__ */ new Date()).toISOString()
          })
        );
        user2Socket.send(
          JSON.stringify({
            type: "match_notification",
            match: {
              id: matchId,
              userId1: user1Id,
              userId2: user2Id,
              matched: true
            },
            fromUserInfo: {
              id: user1Id,
              fullName: user1.fullName,
              photoUrl: user1.photoUrl
            },
            matchId,
            isMatch: true,
            forceDisplay: true
          })
        );
      }
      console.log(`Sent real-time updates to both users for match ${matchId}`);
    }
    await storage.updateMatch(matchId, {
      matched: true
    });
    try {
      const db2 = await Promise.resolve().then(() => (init_db(), db_exports)).then((module) => module.db);
      const matches2 = await Promise.resolve().then(() => (init_schema(), schema_exports)).then(
        (module) => module.matches
      );
      const { eq: eq6 } = await import("drizzle-orm");
      await db2.update(matches2).set({ lastMessageAt: /* @__PURE__ */ new Date() }).where(eq6(matches2.id, matchId));
      console.log(`Updated lastMessageAt for match ${matchId}`);
    } catch (dbError) {
      console.error(
        `Error updating lastMessageAt for match ${matchId}:`,
        dbError
      );
    }
  } catch (error) {
    console.error(
      `Error setting up match ${matchId}:`,
      error
    );
  }
}
function setWebSocketConnections(connections) {
  connectedUsers = connections;
}
async function sendLikeNotification(userId, matchData, fromUserId) {
  try {
    if (!connectedUsers) {
      console.warn(
        "WebSocket connections map not initialized. Notifications won't be sent."
      );
      return;
    }
    const userSocket = connectedUsers.get(userId);
    if (!userSocket || userSocket.readyState !== WebSocket.OPEN) {
      console.log(
        `Cannot send notification to user ${userId}: not connected or socket not ready`
      );
      return;
    }
    try {
      const allUserMatches = await storage.getMatchesByUserId(userId);
      const confirmedMatches = allUserMatches.filter((match) => match.matched);
      const pendingLikes = allUserMatches.filter(
        (match) => !match.matched && !match.isDislike && match.userId1 !== userId && match.userId2 === userId
      );
      const fromUser = await storage.getUser(fromUserId);
      let fromUserInfo = null;
      if (fromUser) {
        const { password, ...userWithoutPassword } = fromUser;
        fromUserInfo = userWithoutPassword;
      }
      const isMatch = matchData.matched === true;
      const notificationType = isMatch ? "new_match" : "new_like";
      console.log(
        `\u{1F525} CRITICAL FIX: Sending guaranteed match popup notification to user ${userId} from user ${fromUserId}`
      );
      if (isMatch) {
        userSocket.send(
          JSON.stringify({
            type: "match_popup_prepare",
            fromUserInfo,
            matchId: matchData.id,
            timestamp: Date.now()
          })
        );
        await new Promise((resolve) => setTimeout(resolve, 50));
      }
      userSocket.send(
        JSON.stringify({
          type: isMatch ? "match_notification" : "new_like",
          match: matchData,
          fromUserId,
          fromUserInfo,
          // Include user profile information
          counts: {
            confirmed: confirmedMatches.length,
            pending: pendingLikes.length,
            total: pendingLikes.length
            // FIXED: Only count pending likes in the total, not confirmed matches
          },
          isMatch,
          matchId: matchData.id,
          // Explicitly include matchId for easier handling
          timestamp: Date.now(),
          // CRITICAL: Add multiple flags to guarantee popup display
          priority: isMatch ? "critical" : "normal",
          guaranteed_match_popup: isMatch,
          forceDisplay: isMatch
        })
      );
      console.log(`WebSocket notification sent successfully to user ${userId}`);
    } catch (error) {
      console.error(`Error preparing enhanced notification data:`, error);
      const fallbackIsMatch = matchData.matched === true;
      userSocket.send(
        JSON.stringify({
          type: fallbackIsMatch ? "match_notification" : "new_like",
          match: matchData,
          matchId: matchData.id,
          fromUserId,
          isMatch: fallbackIsMatch,
          timestamp: Date.now(),
          forceDisplay: fallbackIsMatch
        })
      );
    }
  } catch (error) {
    console.error(`Error sending like notification to user ${userId}:`, error);
  }
}
async function sendUnmatchNotification(userId, matchId, unmatchedByUserId) {
  try {
    if (!connectedUsers) {
      console.warn(
        "WebSocket connections map not initialized. Unmatch notification won't be sent."
      );
      return;
    }
    const userSocket = connectedUsers.get(userId);
    if (!userSocket || userSocket.readyState !== WebSocket.OPEN) {
      console.log(
        `Cannot send unmatch notification to user ${userId}: not connected or socket not ready`
      );
      return;
    }
    userSocket.send(
      JSON.stringify({
        type: "unmatch_notification",
        matchId,
        unmatchedBy: unmatchedByUserId,
        timestamp: (/* @__PURE__ */ new Date()).toISOString(),
        // Add an action flag to instruct client to redirect to messages page
        action: "redirect_to_messages"
      })
    );
    userSocket.send(
      JSON.stringify({
        type: "matches:refresh",
        reason: "unmatch",
        timestamp: (/* @__PURE__ */ new Date()).toISOString()
      })
    );
    console.log(`Unmatch notification sent successfully to user ${userId}`);
  } catch (error) {
    console.error(`Error sending unmatch notification to user ${userId}:`, error);
  }
}
function registerMatchAPI(app2) {
  app2.post("/api/matches", async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        console.log("User not authenticated when creating a match/like");
        return res.status(401).json({ message: "Unauthorized" });
      }
      const userId = req.user.id;
      console.log(
        `Creating new match/like initiated by user ${userId}:`,
        req.body
      );
      const { userId1, userId2, matched = false, isDislike = false } = req.body;
      if (!userId1 || !userId2) {
        return res.status(400).json({ message: "Both user IDs are required" });
      }
      if (userId1 === userId2) {
        console.log(`User ${userId} attempted to match with themselves`);
        return res.status(400).json({ message: "Users cannot match with themselves" });
      }
      if (userId1 !== userId && userId2 !== userId) {
        console.log(
          `User ${userId} not authorized to create match between ${userId1} and ${userId2}`
        );
        return res.status(403).json({ message: "Not authorized to create this match" });
      }
      console.log(
        `\u{1F50D} [MEET-FIX] Checking if match exists between users ${userId1} and ${userId2}`
      );
      const allMatchesBetweenUsers = await storage.getAllMatchesBetweenUsers(userId1, userId2);
      console.log(`\u{1F50D} [MEET-FIX] Found ${allMatchesBetweenUsers.length} existing matches between users`);
      if (allMatchesBetweenUsers.length > 0) {
        allMatchesBetweenUsers.forEach((match, index) => {
          console.log(`\u{1F50D} [MEET-FIX] Match ${index + 1}: ID=${match.id}, metadata=${match.metadata}`);
        });
      }
      const existingMatch = allMatchesBetweenUsers.length > 0 ? allMatchesBetweenUsers[0] : null;
      if (existingMatch) {
        console.log(
          `Match already exists (ID: ${existingMatch.id}) between users ${existingMatch.userId1} and ${existingMatch.userId2}`
        );
        if (existingMatch.matched === matched && existingMatch.isDislike === isDislike) {
          if (existingMatch.metadata) {
            try {
              const existingMetadata = typeof existingMatch.metadata === "string" ? JSON.parse(existingMatch.metadata) : existingMatch.metadata;
              if (existingMetadata && existingMetadata.origin === "SUITE") {
                console.log(`\u{1F517} [MEET-FIX] Found SUITE match with origin: ${existingMetadata.origin}, suiteType: ${existingMetadata.suiteType}`);
                console.log(`\u{1F517} [MEET-FIX] Current additionalConnections: ${JSON.stringify(existingMetadata.additionalConnections)}`);
                if (!existingMetadata.additionalConnections) {
                  existingMetadata.additionalConnections = [];
                  console.log(`\u{1F517} [MEET-FIX] Initialized additionalConnections array`);
                }
                if (!existingMetadata.additionalConnections.includes("MEET")) {
                  existingMetadata.additionalConnections.push("MEET");
                  console.log(`\u{1F517} [MEET-FIX] Adding MEET to additionalConnections for same-state match ${existingMatch.id}`);
                  console.log(`\u{1F517} [MEET-FIX] New additionalConnections: ${JSON.stringify(existingMetadata.additionalConnections)}`);
                  const updatedMatch2 = await storage.updateMatch(existingMatch.id, {
                    metadata: JSON.stringify(existingMetadata)
                  });
                  console.log(`\u{1F517} [MEET-FIX] Successfully added MEET to additionalConnections for existing SUITE match ${existingMatch.id}`);
                  console.log(`\u{1F517} [MEET-FIX] Final updated metadata: ${updatedMatch2?.metadata}`);
                  return res.status(200).json({
                    message: "MEET added as additional connection to existing SUITE match",
                    match: updatedMatch2
                  });
                } else {
                  console.log(`\u{1F517} [MEET-FIX] MEET already exists in additionalConnections, no update needed`);
                }
              }
            } catch (parseError) {
              console.error("Failed to parse existing metadata during same-state check:", parseError);
            }
          }
          return res.status(409).json({
            message: "Match already exists with this state",
            existingMatch
          });
        }
        let finalMetadata = existingMatch.metadata;
        if (existingMatch.metadata) {
          try {
            const existingMetadata = typeof existingMatch.metadata === "string" ? JSON.parse(existingMatch.metadata) : existingMatch.metadata;
            if (existingMetadata && existingMetadata.origin === "SUITE") {
              if (!existingMetadata.additionalConnections) {
                existingMetadata.additionalConnections = [];
              }
              if (!existingMetadata.additionalConnections.includes("MEET")) {
                existingMetadata.additionalConnections.push("MEET");
                console.log(`\u{1F517} Adding MEET to additionalConnections for existing match ${existingMatch.id}`);
              }
              finalMetadata = JSON.stringify(existingMetadata);
            }
          } catch (parseError) {
            console.error("Failed to parse existing metadata during update:", parseError);
          }
        }
        const updatedMatch = await storage.updateMatch(existingMatch.id, {
          matched,
          isDislike,
          metadata: finalMetadata
        });
        if (matched && !existingMatch.matched && updatedMatch) {
          const otherUserId2 = userId1 === userId ? userId2 : userId1;
          await setupMatchAndNotify(
            updatedMatch.id,
            userId,
            otherUserId2
          );
          sendLikeNotification(otherUserId2, updatedMatch, userId);
          sendLikeNotification(userId, updatedMatch, otherUserId2);
          if (connectedUsers) {
            const user1Socket = connectedUsers.get(userId);
            if (user1Socket && user1Socket.readyState === WebSocket.OPEN) {
              user1Socket.send(
                JSON.stringify({
                  type: "matches:refresh",
                  matchId: updatedMatch.id,
                  reason: "new_match",
                  timestamp: (/* @__PURE__ */ new Date()).toISOString()
                })
              );
            }
            const user2Socket = connectedUsers.get(otherUserId2);
            if (user2Socket && user2Socket.readyState === WebSocket.OPEN) {
              user2Socket.send(
                JSON.stringify({
                  type: "matches:refresh",
                  matchId: updatedMatch.id,
                  reason: "new_match",
                  timestamp: (/* @__PURE__ */ new Date()).toISOString()
                })
              );
            }
          }
        }
        return res.status(200).json(updatedMatch);
      }
      const newMatch2 = await storage.createMatch({
        userId1,
        userId2,
        matched,
        isDislike,
        metadata: JSON.stringify({ origin: "MEET" })
      });
      console.log(`\u{1F517} Created new MEET match between users ${userId1} and ${userId2}`);
      console.log(
        `New match created (ID: ${newMatch2.id}) between users ${newMatch2.userId1} and ${newMatch2.userId2}`
      );
      const otherUserId = userId1 === userId ? userId2 : userId1;
      if (matched) {
        await setupMatchAndNotify(newMatch2.id, userId, otherUserId);
        sendLikeNotification(otherUserId, newMatch2, userId);
        sendLikeNotification(userId, newMatch2, otherUserId);
        if (connectedUsers) {
          const user1Socket = connectedUsers.get(userId);
          if (user1Socket && user1Socket.readyState === WebSocket.OPEN) {
            user1Socket.send(
              JSON.stringify({
                type: "matches:refresh",
                matchId: newMatch2.id,
                reason: "new_match",
                timestamp: (/* @__PURE__ */ new Date()).toISOString()
              })
            );
          }
          const user2Socket = connectedUsers.get(otherUserId);
          if (user2Socket && user2Socket.readyState === WebSocket.OPEN) {
            user2Socket.send(
              JSON.stringify({
                type: "matches:refresh",
                matchId: newMatch2.id,
                reason: "new_match",
                timestamp: (/* @__PURE__ */ new Date()).toISOString()
              })
            );
          }
        }
      } else {
        sendLikeNotification(otherUserId, newMatch2, userId);
      }
      return res.status(201).json(newMatch2);
    } catch (error) {
      console.error("Error creating match:", error);
      return res.status(500).json({ message: "Server error creating match" });
    }
  });
  app2.get("/api/matches/counts", async (req, res) => {
    if (!req.isAuthenticated()) {
      return res.status(401).json({ message: "Unauthorized" });
    }
    try {
      const userId = req.user.id;
      const matches2 = await storage.getMatchesByUserId(userId);
      const clickedIdsParam = req.query.clicked || "[]";
      let clickedMatchIds = [];
      try {
        clickedMatchIds = JSON.parse(clickedIdsParam);
        if (!Array.isArray(clickedMatchIds)) {
          clickedMatchIds = [];
        }
      } catch (e) {
        console.error("Error parsing clicked match IDs:", e);
        clickedMatchIds = [];
      }
      const confirmedMatches = matches2.filter((match) => match.matched);
      const pendingLikes = matches2.filter(
        (match) => !match.matched && !match.isDislike && match.userId1 !== userId && match.userId2 === userId
      );
      const visibleConfirmedMatches = confirmedMatches.filter(
        (match) => !clickedMatchIds.includes(match.id)
      );
      const visiblePendingLikes = pendingLikes.filter(
        (match) => !clickedMatchIds.includes(match.id)
      );
      console.log(
        `Match counts for user ${userId}: Confirmed=${visibleConfirmedMatches.length}, Pending=${visiblePendingLikes.length}`
      );
      return res.json({
        confirmed: visibleConfirmedMatches.length,
        pending: visiblePendingLikes.length,
        total: visiblePendingLikes.length,
        // FIXED: Only pending likes count in the total for notifications
        timestamp: Date.now()
      });
    } catch (error) {
      console.error("Error fetching match counts:", error);
      return res.status(500).json({ message: "Server error" });
    }
  });
  app2.get(
    "/api/matches/since/:timestamp",
    async (req, res) => {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      try {
        let since;
        const timestampParam = req.params.timestamp;
        if (timestampParam.includes("-") || timestampParam.includes("T")) {
          since = new Date(timestampParam);
        } else {
          const timestamp2 = parseInt(timestampParam, 10);
          if (isNaN(timestamp2)) {
            return res.status(400).json({ message: "Invalid timestamp format" });
          }
          since = new Date(timestamp2);
        }
        if (isNaN(since.getTime())) {
          return res.status(400).json({ message: "Invalid date from timestamp" });
        }
        const userId = req.user.id;
        const matches2 = await storage.getMatchesSince(userId, since);
        console.log(
          `\u{1F525} MATCH-CHECKER: Found ${matches2.length} matches for user ${userId} since ${since.toISOString()}`
        );
        if (matches2.length > 0) {
          const enhancedMatches = await Promise.all(
            matches2.map(async (match) => {
              try {
                const otherUserId = match.userId1 === userId ? match.userId2 : match.userId1;
                const otherUser = await storage.getUser(otherUserId);
                if (otherUser) {
                  const { password, ...userInfo } = otherUser;
                  return {
                    ...match,
                    userInfo,
                    // Include these properties for compatibility with showMatchPopup function
                    matchedUser: userInfo,
                    user: userInfo
                  };
                }
                return match;
              } catch (err) {
                console.error(
                  `Error enhancing match ${match.id} with user details:`,
                  err
                );
                return match;
              }
            })
          );
          res.json(enhancedMatches);
        } else {
          res.json(matches2);
        }
      } catch (error) {
        console.error("Error getting matches since timestamp:", error);
        res.status(500).json({ message: "Server error getting matches" });
      }
    }
  );
}
var connectedUsers;
var init_match_api = __esm({
  "server/match-api.ts"() {
    "use strict";
    init_storage();
    connectedUsers = null;
  }
});

// server/services/sendgrid.ts
var sendgrid_exports = {};
__export(sendgrid_exports, {
  sendContactFormEmail: () => sendContactFormEmail,
  sendEmail: () => sendEmail,
  sendPremiumSubscriptionEmail: () => sendPremiumSubscriptionEmail,
  sendWelcomeEmail: () => sendWelcomeEmail,
  testSendGridConfig: () => testSendGridConfig
});
import { MailService } from "@sendgrid/mail";
async function sendEmail(apiKey, params) {
  try {
    if (!process.env.SENDGRID_API_KEY) {
      mailService.setApiKey(apiKey);
    }
    const emailData = {
      to: params.to,
      from: params.from,
      subject: params.subject
    };
    if (params.text) {
      emailData.text = params.text;
    }
    if (params.html) {
      emailData.html = params.html;
    }
    await mailService.send(emailData);
    return true;
  } catch (error) {
    console.error("SendGrid email error:", error);
    return false;
  }
}
async function testSendGridConfig() {
  try {
    console.log("[SENDGRID-TEST] Testing SendGrid configuration...");
    console.log(
      "[SENDGRID-TEST] API Key present:",
      !!process.env.SENDGRID_API_KEY
    );
    console.log(
      "[SENDGRID-TEST] API Key starts with:",
      process.env.SENDGRID_API_KEY?.substring(0, 10)
    );
    const testEmail = {
      to: "admin@btechnos.com",
      from: "admin@btechnos.com",
      // Simplified format
      subject: "SendGrid Test Email",
      text: "This is a test email to verify SendGrid configuration."
    };
    await mailService.send(testEmail);
    console.log("[SENDGRID-TEST] Test email sent successfully!");
    return { success: true, message: "SendGrid test successful" };
  } catch (error) {
    console.error("[SENDGRID-TEST] Test failed:", error);
    if (error.response) {
      console.error("[SENDGRID-TEST] Error details:", {
        status: error.code,
        body: error.response?.body,
        message: error.message
      });
    }
    return {
      success: false,
      message: `SendGrid test failed: ${error.message}`
    };
  }
}
async function sendContactFormEmail(data) {
  try {
    console.log("[SENDGRID] Attempting to send contact form email...");
    const emailContent = {
      to: "admin@btechnos.com",
      from: "admin@btechnos.com",
      // Simplified - just the email
      subject: `Contact Form Submission from ${data.name}`,
      text: `
Name: ${data.name}
Email: ${data.email}
Phone: ${data.phoneNumber || "Not provided"}

Message:
${data.message}

---
This message was sent via the CHARLEY Contact Form.
      `.trim(),
      html: `
        <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
          <h2 style="color: #333; border-bottom: 2px solid #6366f1; padding-bottom: 10px;">
            New Contact Form Submission
          </h2>
          
          <div style="background: #f8fafc; padding: 20px; border-radius: 8px; margin: 20px 0;">
            <p><strong>Name:</strong> ${data.name}</p>
            <p><strong>Email:</strong> ${data.email}</p>
            <p><strong>Phone:</strong> ${data.phoneNumber || "Not provided"}</p>
          </div>
          
          <div style="background: #ffffff; padding: 20px; border: 1px solid #e2e8f0; border-radius: 8px;">
            <h3 style="color: #475569; margin-top: 0;">Message:</h3>
            <p style="line-height: 1.6; color: #334155;">${data.message.replace(/\n/g, "<br>")}</p>
          </div>
          
          <div style="margin-top: 30px; padding-top: 20px; border-top: 1px solid #e2e8f0; color: #64748b; font-size: 12px;">
            This message was sent via the CHARLEY Contact Form.
          </div>
        </div>
      `
    };
    await mailService.send(emailContent);
    console.log(
      `[SENDGRID] Contact form email sent successfully from ${data.email}`
    );
    return true;
  } catch (error) {
    console.error("[SENDGRID] Failed to send contact form email:", error);
    if (error.response) {
      console.error("[SENDGRID] Error response:", {
        status: error.code,
        body: error.response?.body,
        headers: error.response?.headers
      });
      if (error.code === 403) {
        console.error("[SENDGRID] 403 Forbidden - This usually means:");
        console.error(
          "1. The sender email address needs to be verified in SendGrid"
        );
        console.error("2. The API key doesn't have sufficient permissions");
        console.error("3. Account is suspended or has issues");
      }
    }
    return false;
  }
}
async function sendWelcomeEmail(data) {
  try {
    console.log("[SENDGRID] Sending welcome email to:", data.email);
    const emailContent = {
      to: data.email,
      from: "admin@btechnos.com",
      subject: `Welcome to CHARLEY, ${data.name}! \u{1F389} Join the Social Revolution`,
      text: `
Welcome to CHARLEY, ${data.name}!

Thank you for joining us on this incredible journey to revolutionize how people connect, build relationships, and create meaningful professional networks.

CHARLEY is not just another app; it\u2019s a bold movement toward restoring authenticity and depth to human connection. Born from a simple, yet profound question\u2014\u201CWhat if technology could truly understand us?\u201D\u2014CHARLEY brings together dating, networking, and mentorship into a single, seamless platform. It\u2019s more than a tool; it\u2019s a community shaped by empathy, powered by innovative AI, and guided by a commitment to human flourishing.

Why CHARLEY? Because we believe every connection should mean something. Our story began with a vision to move beyond superficial swipes and transactional exchanges, and instead, create a space where compatibility, mentorship, and meaningful professional relationships can thrive\u2014across continents, backgrounds, and ambitions.

Our Mission:
- Revolutionize dating by focusing on authentic compatibility
- Transform professional networking through meaningful connections
- Democratize mentorship and personal growth opportunities
- Create a global community built on trust, respect, and genuine human values

From Our Leadership Team:

CEO Sam's Message:
"At Baobab Technologies, we see CHARLEY as more than a product\u2014it\u2019s a movement grounded in the universal longing for belonging. In an age where loneliness quietly thrives behind curated profiles and viral trends, we are driven by both heart and intellect to redefine what connection means in the digital era. CHARLEY draws from cross-disciplinary insights\u2014psychology, sociology, and design thinking\u2014to create a space where vulnerability isn\u2019t a liability, but a strength, and where every interaction is an opportunity for understanding. We are committed to building a community that not only reflects the rich diversity of our world, but actively nurtures empathy and authentic human flourishing. Technology alone does not create connection\u2014people do. Our role is to set the stage for meaningful encounters, guided by both evidence and empathy."

CTO Obed's Message:
"As CTO, my approach to CHARLEY has always been informed by both rigorous engineering and a deep respect for the human spirit. Our team blends advanced data science, ethical design, and behavioral research to construct systems that protect, empower, and inspire. We challenge ourselves to see technology through the lens of lived experience: How do we foster trust in code? How can algorithms promote genuine dialogue rather than division? Each technical decision is anchored in the best research and a commitment to digital well-being. CHARLEY stands as a testament to what\u2019s possible when technology serves as a bridge, not a barrier\u2014amplifying the complexity and beauty of human relationships. Together, with our users and partners, we are co-authoring a new chapter in the science\u2014and the art\u2014of connection."

Important Reminders:
- Please take time to review our Privacy Policy and Terms of Service
- Complete your profile to unlock CHARLEY's full potential
- Explore all three platforms: MEET (dating), SUITE (professional networking), and our mentorship programs

Visit us at btechnos.com to learn more about our vision and the technology behind CHARLEY.

Welcome aboard!
The BTechnos Team
      `.trim(),
      html: `
        <!DOCTYPE html>
        <html>
        <head>
          <meta charset="utf-8">
          <meta name="viewport" content="width=device-width, initial-scale=1.0">
          <title>Welcome to CHARLEY</title>
        </head>
        <body style="margin: 0; padding: 0; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background: #f8fafc; min-height: 100vh;">
          
          <!-- Main Container -->
          <div style="max-width: 650px; margin: 0 auto; background: #ffffff; box-shadow: 0 25px 50px rgba(0,0,0,0.08); border-radius: 16px; overflow: hidden;">
            
            <!-- Header Section -->
            <div style="background: linear-gradient(135deg, #ff6b6b 0%, #feca57 25%, #ff9ff3 50%, #54a0ff 75%, #5f27cd 100%); padding: 60px 40px; text-align: center; position: relative; overflow: hidden;">
              <!-- Animated floating orbs -->
              <div style="position: absolute; top: -30px; left: -30px; width: 120px; height: 120px; background: radial-gradient(circle, rgba(255,255,255,0.15) 0%, rgba(255,255,255,0.05) 70%); border-radius: 50%; animation: float 6s ease-in-out infinite;"></div>
              <div style="position: absolute; top: 20px; right: -40px; width: 80px; height: 80px; background: radial-gradient(circle, rgba(255,255,255,0.2) 0%, rgba(255,255,255,0.08) 70%); border-radius: 50%; animation: float 4s ease-in-out infinite reverse;"></div>
              <div style="position: absolute; bottom: -20px; left: 30%; width: 60px; height: 60px; background: radial-gradient(circle, rgba(255,255,255,0.12) 0%, rgba(255,255,255,0.04) 70%); border-radius: 50%; animation: float 5s ease-in-out infinite;"></div>
              
              <!-- Sparkling effects -->
              <div style="position: absolute; top: 25%; left: 15%; width: 4px; height: 4px; background: rgba(255,255,255,0.8); border-radius: 50%; box-shadow: 0 0 10px rgba(255,255,255,0.8);"></div>
              <div style="position: absolute; top: 40%; right: 20%; width: 3px; height: 3px; background: rgba(255,255,255,0.9); border-radius: 50%; box-shadow: 0 0 8px rgba(255,255,255,0.9);"></div>
              <div style="position: absolute; bottom: 30%; left: 25%; width: 2px; height: 2px; background: rgba(255,255,255,0.7); border-radius: 50%; box-shadow: 0 0 6px rgba(255,255,255,0.7);"></div>
              
              <!-- Main content with enhanced styling -->
              <div style="position: relative; z-index: 10;">
                <h1 style="color: #ffffff; font-size: 48px; font-weight: 800; margin: 0 0 20px 0; text-shadow: 0 4px 8px rgba(0,0,0,0.3), 0 2px 4px rgba(0,0,0,0.2); letter-spacing: -1.5px; background: linear-gradient(45deg, rgba(255,255,255,1) 0%, rgba(255,255,255,0.9) 100%); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text;">
                  Welcome to CHARLEY
                </h1>
                <div style="background: rgba(255,255,255,0.15); backdrop-filter: blur(10px); border: 1px solid rgba(255,255,255,0.2); border-radius: 25px; padding: 15px 30px; display: inline-block; margin-top: 10px;">
                  <p style="color: rgba(255,255,255,0.95); font-size: 20px; margin: 0; font-weight: 400; text-shadow: 0 1px 2px rgba(0,0,0,0.2);">
                    Join the Social Revolution, ${data.name}!
                  </p>
                </div>
              </div>
              
              <!-- CSS Animation -->
              <style>
                @keyframes float {
                  0%, 100% { transform: translateY(0px) rotate(0deg); }
                  50% { transform: translateY(-20px) rotate(180deg); }
                }
              </style>
            </div>

            <!-- Main Content -->
            <div style="padding: 40px 30px;">
              
              <!-- Personal Welcome -->
              <div style="background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%); padding: 25px; border-radius: 12px; border-left: 4px solid #6366f1; margin-bottom: 30px;">
                <h2 style="color: #1e293b; font-size: 24px; margin: 0 0 15px 0; font-weight: 600;">
                  Dear ${data.name},
                </h2>
                <p style="color: #1f2937; line-height: 1.7; margin: 0; font-size: 16px;">
                  Thank you for joining us on this incredible journey to revolutionize how people connect, build relationships, and create meaningful professional networks. You're not just signing up for an app\u2014you're becoming part of a movement.
                </p>
              </div>

              <!-- Our Story Section -->
              <div style="margin-bottom: 35px;">
                <h3 style="color: #1e293b; font-size: 22px; margin: 0 0 20px 0; font-weight: 600; border-bottom: 2px solid #e2e8f0; padding-bottom: 10px;">
                  \u{1F680} Why CHARLEY?
                </h3>
                <p style="color: #1f2937; line-height: 1.7; margin: 0 0 15px 0; font-size: 16px;">
                  Our story began with a simple question: <em>"What if we could create a platform that truly understands human connection?"</em> From this question emerged CHARLEY\u2014an AI-powered ecosystem that goes beyond superficial matching to create genuine, lasting relationships across all areas of life.
                </p>
                <div style="background: #f8fafc; padding: 20px; border-radius: 8px; border: 1px solid #e2e8f0;">
                  <h4 style="color: #6366f1; margin: 0 0 12px 0; font-size: 18px; font-weight: 600;">Our Mission:</h4>
                  <ul style="color: #1f2937; line-height: 1.6; margin: 0; padding-left: 20px; font-size: 15px;">
                    <li style="margin-bottom: 8px; color: #1f2937;">Revolutionize dating by focusing on authentic compatibility</li>
                    <li style="margin-bottom: 8px; color: #1f2937;">Transform professional networking through meaningful connections</li>
                    <li style="margin-bottom: 8px; color: #1f2937;">Democratize mentorship and personal growth opportunities</li>
                    <li style="margin-bottom: 0; color: #1f2937;">Create a global community built on trust, respect, and genuine human values</li>
                  </ul>
                </div>
              </div>

              <!-- Leadership Messages -->
              <div style="margin-bottom: 35px;">
                <h3 style="color: #1e293b; font-size: 22px; margin: 0 0 25px 0; font-weight: 600; border-bottom: 2px solid #e2e8f0; padding-bottom: 10px;">
                  \u{1F465} Messages from Our Leadership Team
                </h3>
                
                <!-- CEO Message -->
                <div style="background: linear-gradient(135deg, #fef3f2 0%, #fef2f2 100%); border: 1px solid #fecaca; border-radius: 12px; padding: 25px; margin-bottom: 20px; position: relative;">
                  <div style="display: flex; align-items: center; margin-bottom: 15px;">
                    <div style="width: 60px; height: 60px; background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%); border-radius: 50%; display: flex; align-items: center; justify-content: center; margin-right: 15px; box-shadow: 0 4px 12px rgba(239, 68, 68, 0.3);">
                      <span style="color: white; font-weight: 700; font-size: 24px;">S</span>
                    </div>
                    <div>
                      <h4 style="color: #1e293b; margin: 0; font-size: 18px; font-weight: 600;">Sam - Chief Executive Officer</h4>
                    </div>
                  </div>
                  <blockquote style="color: #1f2937; font-style: italic; line-height: 1.6; margin: 0; font-size: 15px; border-left: 3px solid #ef4444; padding-left: 15px;">
                    "At Baobab Technologies, we see CHARLEY as more than a product\u2014it\u2019s a movement grounded in the universal longing for belonging. In an age where loneliness quietly thrives behind curated profiles and viral trends, we are driven by both heart and intellect to redefine what connection means in the digital era. CHARLEY draws from cross-disciplinary insights\u2014psychology, sociology, and design thinking\u2014to create a space where vulnerability isn\u2019t a liability, but a strength, and where every interaction is an opportunity for understanding. We are committed to building a community that not only reflects the rich diversity of our world, but actively nurtures empathy and authentic human flourishing. Technology alone does not create connection\u2014people do. Our role is to set the stage for meaningful encounters, guided by both evidence and empathy."
                  </blockquote>
                </div>

                <!-- CTO Message -->
                <div style="background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%); border: 1px solid #7dd3fc; border-radius: 12px; padding: 25px; position: relative;">
                  <div style="display: flex; align-items: center; margin-bottom: 15px;">
                    <div style="width: 60px; height: 60px; background: linear-gradient(135deg, #0ea5e9 0%, #0284c7 100%); border-radius: 50%; display: flex; align-items: center; justify-content: center; margin-right: 15px; box-shadow: 0 4px 12px rgba(14, 165, 233, 0.3);">
                      <span style="color: white; font-weight: 700; font-size: 24px;">O</span>
                    </div>
                    <div>
                      <h4 style="color: #1e293b; margin: 0; font-size: 18px; font-weight: 600;">Obed - Chief Technology Officer</h4>
                    </div>
                  </div>
                  <blockquote style="color: #1f2937; font-style: italic; line-height: 1.6; margin: 0; font-size: 15px; border-left: 3px solid #0ea5e9; padding-left: 15px;">
                    "As CTO, my approach to CHARLEY has always been informed by both rigorous engineering and a deep respect for the human spirit. Our team blends advanced data science, ethical design, and behavioral research to construct systems that protect, empower, and inspire. We challenge ourselves to see technology through the lens of lived experience: How do we foster trust in code? How can algorithms promote genuine dialogue rather than division? Each technical decision is anchored in the best research and a commitment to digital well-being. CHARLEY stands as a testament to what\u2019s possible when technology serves as a bridge, not a barrier\u2014amplifying the complexity and beauty of human relationships. Together, with our users and partners, we are co-authoring a new chapter in the science\u2014and the art\u2014of connection."
                  </blockquote>
                </div>
              </div>

              <!-- Important Reminders -->
              <div style="background: linear-gradient(135deg, #fffbeb 0%, #fef3c7 100%); border: 1px solid #fbbf24; border-radius: 12px; padding: 25px; margin-bottom: 35px;">
                <h4 style="color: #92400e; margin: 0 0 15px 0; font-size: 18px; font-weight: 600; display: flex; align-items: center;">
                  \u26A1 Important Reminders
                </h4>
                <ul style="color: #1f2937; line-height: 1.6; margin: 0; padding-left: 20px; font-size: 15px;">
                  <li style="margin-bottom: 8px;">Please take time to review our Privacy Policy and Terms of Service</li>
                  <li style="margin-bottom: 8px;">Complete your profile to unlock CHARLEY's full potential</li>
                  <li style="margin-bottom: 0;">Explore all three platforms: MEET (dating), SUITE (professional networking), and our mentorship programs</li>
                </ul>
              </div>

              <!-- Website Link -->
              <div style="text-align: center; margin-bottom: 30px;">
                <a href="https://btechnos.com" style="display: inline-block; background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%); color: white; text-decoration: none; padding: 15px 30px; border-radius: 25px; font-weight: 600; font-size: 16px; box-shadow: 0 4px 15px rgba(99, 102, 241, 0.4); transition: all 0.3s ease;">
                  Visit BTechnos.com
                </a>
              </div>

              <!-- Closing -->
              <div style="text-align: center; color: #64748b; font-size: 16px; line-height: 1.6;">
                <p style="margin: 0 0 10px 0; font-weight: 600; color: #1e293b;">Welcome aboard!</p>
                <p style="margin: 0; font-style: italic;">The BTechnos Team</p>
              </div>
            </div>

            <!-- Footer -->
            <div style="background: #f8fafc; padding: 25px 30px; text-align: center; border-top: 1px solid #e2e8f0;">
              <p style="color: #64748b; font-size: 12px; margin: 0; line-height: 1.5;">
                This email was sent from CHARLEY by BTechnos. You're receiving this because you successfully created an account with us.<br>
                \xA9 2025 BTechnos. All rights reserved. | <a href="https://btechnos.com" style="color: #6366f1; text-decoration: none;">btechnos.com</a>
              </p>
            </div>
          </div>
        </body>
        </html>
      `
    };
    await mailService.send(emailContent);
    console.log(`[SENDGRID] Welcome email sent successfully to ${data.email}`);
    return true;
  } catch (error) {
    console.error("[SENDGRID] Failed to send welcome email:", error);
    if (error.response) {
      console.error("[SENDGRID] Welcome email error details:", {
        status: error.code,
        body: error.response?.body,
        headers: error.response?.headers
      });
    }
    return false;
  }
}
async function sendPremiumSubscriptionEmail(data) {
  try {
    console.log("[SENDGRID] Sending premium subscription confirmation email to:", data.email);
    const planDisplayName = data.planType.replace("_", " ").replace(/\b\w/g, (l) => l.toUpperCase());
    const expirationText = data.subscriptionExpiresAt ? new Date(data.subscriptionExpiresAt).toLocaleDateString("en-US", {
      year: "numeric",
      month: "long",
      day: "numeric"
    }) : "Active";
    const emailContent = {
      to: data.email,
      from: "admin@btechnos.com",
      subject: `\u{1F389} Welcome to CHARLEY Premium, ${data.name}! Your Premium Journey Begins Now`,
      text: `
Welcome to CHARLEY Premium, ${data.name}!

\u{1F389} Congratulations! Your premium subscription is now active.

SUBSCRIPTION DETAILS:
- Plan: ${planDisplayName}
- Status: Active
- Next billing: ${expirationText}

PREMIUM FEATURES NOW UNLOCKED:
\u2713 Ghost Mode - Browse profiles anonymously
\u2713 Hide My Age - Keep your age private
\u2713 Advanced Privacy Controls - Full control over your visibility
\u2713 Priority Customer Support - Get help when you need it
\u2713 Enhanced Matching Algorithm - Better compatibility scores
\u2713 Unlimited Likes & Super Likes - No daily limits
\u2713 Read Receipts - See when messages are read
\u2713 Advanced Filters - Find exactly who you're looking for

WHAT'S NEXT?
1. Explore your new premium features in the Settings page
2. Update your privacy preferences with Ghost Mode
3. Try the advanced matching filters
4. Enjoy unlimited interactions across MEET, HEAT, and SUITE

Thank you for choosing CHARLEY Premium. We're excited to help you find meaningful connections!

The CHARLEY Team
BTechnos.com
      `,
      html: `
        <!DOCTYPE html>
        <html>
        <head>
          <meta charset="utf-8">
          <meta name="viewport" content="width=device-width, initial-scale=1.0">
          <title>Welcome to CHARLEY Premium</title>
        </head>
        <body style="margin: 0; padding: 0; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); min-height: 100vh;">
          <div style="max-width: 600px; margin: 0 auto; background: white; border-radius: 20px; overflow: hidden; box-shadow: 0 20px 40px rgba(0,0,0,0.1); margin-top: 20px; margin-bottom: 20px;">
            
            <!-- Premium Header with Crown Animation -->
            <div style="background: linear-gradient(135deg, #ffd700 0%, #ffb700 50%, #ff8c00 100%); padding: 40px 30px; text-align: center; position: relative; overflow: hidden;">
              <div style="position: absolute; top: 10px; right: 20px; font-size: 40px; animation: float 3s ease-in-out infinite;">\u{1F451}</div>
              <div style="position: absolute; top: 20px; left: 20px; font-size: 30px; animation: float 3s ease-in-out infinite reverse;">\u2728</div>
              
              <h1 style="color: #1a1a1a; margin: 0 0 15px 0; font-size: 32px; font-weight: 800; text-shadow: 2px 2px 4px rgba(0,0,0,0.1);">
                \u{1F389} Welcome to CHARLEY Premium!
              </h1>
              <p style="color: #2d2d2d; font-size: 18px; margin: 0; font-weight: 600;">
                Dear ${data.name}, your premium journey begins now!
              </p>
              
              <style>
                @keyframes float {
                  0%, 100% { transform: translateY(0px) rotate(0deg); }
                  50% { transform: translateY(-10px) rotate(5deg); }
                }
              </style>
            </div>

            <!-- Subscription Status Card -->
            <div style="padding: 30px; background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%);">
              <div style="background: white; padding: 25px; border-radius: 15px; border: 2px solid #ffd700; box-shadow: 0 8px 25px rgba(255, 215, 0, 0.2);">
                <h2 style="color: #1e293b; font-size: 24px; margin: 0 0 20px 0; font-weight: 700; text-align: center;">
                  \u{1F3C6} Subscription Activated
                </h2>
                
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 20px;">
                  <div style="background: #f8fafc; padding: 15px; border-radius: 8px; text-align: center;">
                    <div style="font-size: 14px; color: #64748b; font-weight: 600; margin-bottom: 5px;">PLAN</div>
                    <div style="font-size: 18px; color: #1e293b; font-weight: 700;">${planDisplayName}</div>
                  </div>
                  <div style="background: #f8fafc; padding: 15px; border-radius: 8px; text-align: center;">
                    <div style="font-size: 14px; color: #64748b; font-weight: 600; margin-bottom: 5px;">STATUS</div>
                    <div style="font-size: 18px; color: #10b981; font-weight: 700;">\u2705 Active</div>
                  </div>
                </div>
                

              </div>
            </div>

            <!-- Premium Features Showcase -->
            <div style="padding: 30px;">
              <h2 style="color: #1e293b; font-size: 26px; margin: 0 0 25px 0; font-weight: 700; text-align: center;">
                \u2728 Premium Features Unlocked
              </h2>
              
              <div style="display: grid; gap: 15px;">
                <div style="background: linear-gradient(135deg, #ede9fe 0%, #ddd6fe 100%); padding: 20px; border-radius: 12px; border-left: 4px solid #8b5cf6;">
                  <h3 style="color: #6b21a8; margin: 0 0 8px 0; font-size: 18px; font-weight: 600;">\u{1F47B} Ghost Mode</h3>
                  <p style="color: #1f2937; margin: 0; font-size: 15px; line-height: 1.5;">Browse profiles completely anonymously - they won't know you viewed them unless you interact!</p>
                </div>
                
                <div style="background: linear-gradient(135deg, #fef3f2 0%, #fecaca 100%); padding: 20px; border-radius: 12px; border-left: 4px solid #ef4444;">
                  <h3 style="color: #b91c1c; margin: 0 0 8px 0; font-size: 18px; font-weight: 600;">\u{1F512} Hide My Age</h3>
                  <p style="color: #1f2937; margin: 0; font-size: 15px; line-height: 1.5;">Keep your age private while still getting matched with age-appropriate connections.</p>
                </div>
                
                <div style="background: linear-gradient(135deg, #f0f9ff 0%, #bfdbfe 100%); padding: 20px; border-radius: 12px; border-left: 4px solid #3b82f6;">
                  <h3 style="color: #1d4ed8; margin: 0 0 8px 0; font-size: 18px; font-weight: 600;">\u26A1 Unlimited Interactions</h3>
                  <p style="color: #1f2937; margin: 0; font-size: 15px; line-height: 1.5;">No daily limits on likes, super likes, or messages. Connect as much as you want!</p>
                </div>
                
                <div style="background: linear-gradient(135deg, #f0fdf4 0%, #bbf7d0 100%); padding: 20px; border-radius: 12px; border-left: 4px solid #10b981;">
                  <h3 style="color: #047857; margin: 0 0 8px 0; font-size: 18px; font-weight: 600;">\u{1F3AF} Advanced Filters</h3>
                  <p style="color: #1f2937; margin: 0; font-size: 15px; line-height: 1.5;">Precise filtering options to find exactly who you're looking for across all platforms.</p>
                </div>
                
                <div style="background: linear-gradient(135deg, #fffbeb 0%, #fed7aa 100%); padding: 20px; border-radius: 12px; border-left: 4px solid #f59e0b;">
                  <h3 style="color: #b45309; margin: 0 0 8px 0; font-size: 18px; font-weight: 600;">\u{1F451} Priority Support</h3>
                  <p style="color: #1f2937; margin: 0; font-size: 15px; line-height: 1.5;">Get premium customer support with faster response times and dedicated assistance.</p>
                </div>
              </div>
            </div>

            <!-- Next Steps -->
            <div style="padding: 30px; background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%);">
              <h2 style="color: #1e293b; font-size: 24px; margin: 0 0 25px 0; font-weight: 700; text-align: center;">
                \u{1F680} What's Next?
              </h2>
              
              <div style="background: white; padding: 25px; border-radius: 12px; border: 1px solid #e2e8f0;">
                <ol style="color: #1f2937; line-height: 1.7; margin: 0; padding-left: 20px; font-size: 16px;">
                  <li style="margin-bottom: 12px;"><strong>Explore Premium Features:</strong> Visit your Settings page to configure Ghost Mode and privacy options</li>
                  <li style="margin-bottom: 12px;"><strong>Update Your Profile:</strong> Premium users get priority in the matching algorithm</li>
                  <li style="margin-bottom: 12px;"><strong>Try Advanced Filters:</strong> Find your perfect match with precision filtering</li>
                  <li style="margin-bottom: 0;"><strong>Connect Without Limits:</strong> Enjoy unlimited interactions across MEET, HEAT, and SUITE</li>
                </ol>
              </div>
            </div>

            <!-- CTA Section -->
            <div style="padding: 30px; text-align: center;">
              <div style="background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%); padding: 25px; border-radius: 15px; margin-bottom: 25px;">
                <h3 style="color: white; margin: 0 0 15px 0; font-size: 22px; font-weight: 700;">
                  Ready to Experience Premium?
                </h3>
                <p style="color: white; margin: 0 0 20px 0; font-size: 16px; opacity: 0.9;">
                  Your premium features are already active and waiting for you!
                </p>
                <a href="https://charley.btechnos.com/settings" style="display: inline-block; background: white; color: #6366f1; text-decoration: none; padding: 12px 30px; border-radius: 25px; font-weight: 600; font-size: 16px; box-shadow: 0 4px 15px rgba(255, 255, 255, 0.3);">
                  Explore Premium Features \u2192
                </a>
              </div>
            </div>

            <!-- Footer -->
            <div style="background: #1e293b; padding: 30px; text-align: center; color: white;">
              <div style="margin-bottom: 20px;">
                <h3 style="color: #ffd700; margin: 0 0 10px 0; font-size: 24px; font-weight: 700;">CHARLEY</h3>
                <p style="color: #94a3b8; margin: 0; font-size: 14px;">Premium Dating & Professional Networking</p>
              </div>
              
              <div style="border-top: 1px solid #334155; padding-top: 20px;">
                <p style="color: #94a3b8; font-size: 12px; margin: 0; line-height: 1.5;">
                  This email was sent from CHARLEY by BTechnos. You're receiving this because you successfully subscribed to CHARLEY Premium.<br>
                  Need help? Contact us at admin@btechnos.com<br>
                  \xA9 2025 BTechnos. All rights reserved. | <a href="https://btechnos.com" style="color: #ffd700; text-decoration: none;">btechnos.com</a>
                </p>
              </div>
            </div>
          </div>
        </body>
        </html>
      `
    };
    await mailService.send(emailContent);
    console.log(`[SENDGRID] Premium subscription email sent successfully to ${data.email}`);
    return true;
  } catch (error) {
    console.error("[SENDGRID] Failed to send premium subscription email:", error);
    if (error.response) {
      console.error("[SENDGRID] Premium subscription email error details:", {
        status: error.code,
        body: error.response?.body,
        headers: error.response?.headers
      });
    }
    return false;
  }
}
var mailService;
var init_sendgrid = __esm({
  "server/services/sendgrid.ts"() {
    "use strict";
    mailService = new MailService();
    if (process.env.SENDGRID_API_KEY) {
      mailService.setApiKey(process.env.SENDGRID_API_KEY);
      console.log("[SENDGRID] API key initialized successfully");
    } else {
      console.error("[SENDGRID] No API key found in environment variables");
    }
  }
});

// server/user-blocking-api.ts
var user_blocking_api_exports = {};
__export(user_blocking_api_exports, {
  areUsersBlocked: () => areUsersBlocked,
  getBlockedUserIds: () => getBlockedUserIds,
  getUsersWhoBlockedUser: () => getUsersWhoBlockedUser,
  registerUserBlockingAPI: () => registerUserBlockingAPI
});
import { eq as eq3, and as and3, or as or3 } from "drizzle-orm";
import { ZodError } from "zod";
import { fromZodError } from "zod-validation-error";
function registerUserBlockingAPI(app2) {
  app2.post("/api/user/block", async (req, res) => {
    try {
      if (!req.isAuthenticated() || !req.user || !req.user.id) {
        console.log("[USER-BLOCKING] Authentication failed:", {
          isAuthenticated: req.isAuthenticated ? req.isAuthenticated() : "function not available",
          hasUser: !!req.user,
          userId: req.user?.id
        });
        return res.status(401).json({
          message: "Unauthorized",
          details: "Valid authentication session required"
        });
      }
      const currentUserId = req.user.id;
      console.log(`[USER-BLOCKING] User ${currentUserId} initiating block request`);
      console.log("[USER-BLOCKING] Validating request body:", req.body);
      const { blockedUserId, reason } = req.body;
      if (!blockedUserId || typeof blockedUserId !== "number") {
        return res.status(400).json({ message: "Valid blockedUserId is required" });
      }
      const completeData = {
        blockerUserId: currentUserId,
        blockedUserId,
        reason: reason || null
      };
      const validatedData = insertUserBlockSchema.parse(completeData);
      console.log("[USER-BLOCKING] Validation successful:", validatedData);
      console.log(`[USER-BLOCKING] User ${currentUserId} attempting to block user ${blockedUserId}`);
      if (currentUserId === blockedUserId) {
        console.log(`[USER-BLOCKING] User ${currentUserId} attempted to block themselves`);
        return res.status(400).json({ message: "Cannot block yourself" });
      }
      try {
        const newBlock = await db.insert(userBlocks).values({
          blockerUserId: currentUserId,
          blockedUserId,
          reason: reason || null
        }).returning();
        console.log(`[USER-BLOCKING] Successfully created block ${newBlock[0].id}: User ${currentUserId} blocked user ${blockedUserId}`);
        const targetUser = await storage.getUser(blockedUserId);
        if (!targetUser) {
          console.log(`[USER-BLOCKING] Target user ${blockedUserId} not found after blocking`);
          return res.status(404).json({ message: "User not found" });
        }
        res.status(201).json({
          message: "User blocked successfully",
          blockId: newBlock[0].id,
          blockedUser: {
            id: targetUser.id,
            fullName: targetUser.fullName
          }
        });
      } catch (blockError) {
        if (blockError.code === "23505" || blockError.constraint?.includes("unique")) {
          console.log(`[USER-BLOCKING] Block already exists between users ${currentUserId} and ${blockedUserId}`);
          return res.status(200).json({
            message: "User is already blocked",
            note: "Block already exists"
          });
        }
        if (blockError.code === "23503") {
          console.log(`[USER-BLOCKING] Target user ${blockedUserId} not found (foreign key violation)`);
          return res.status(404).json({ message: "User not found" });
        }
        throw blockError;
      }
    } catch (error) {
      console.error("[USER-BLOCKING] Error blocking user:", error);
      if (error instanceof ZodError) {
        const validationError = fromZodError(error);
        return res.status(400).json({
          message: "Validation error",
          details: validationError.toString()
        });
      }
      res.status(500).json({ message: "Failed to block user" });
    }
  });
  app2.delete("/api/user/unblock/:blockedUserId", requireAuth, async (req, res) => {
    try {
      const currentUserId = req.user?.id;
      if (!currentUserId) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      const blockedUserId = parseInt(req.params.blockedUserId);
      if (isNaN(blockedUserId)) {
        return res.status(400).json({ message: "Invalid user ID" });
      }
      console.log(`[USER-BLOCKING] User ${currentUserId} attempting to unblock user ${blockedUserId}`);
      const deletedBlocks = await db.delete(userBlocks).where(
        and3(
          eq3(userBlocks.blockerUserId, currentUserId),
          eq3(userBlocks.blockedUserId, blockedUserId)
        )
      ).returning();
      if (deletedBlocks.length === 0) {
        console.log(`[USER-BLOCKING] No block found between users ${currentUserId} and ${blockedUserId}`);
        return res.status(404).json({ message: "Block not found" });
      }
      console.log(`[USER-BLOCKING] Successfully removed block ${deletedBlocks[0].id}: User ${currentUserId} unblocked user ${blockedUserId}`);
      res.status(200).json({
        message: "User unblocked successfully",
        unblocked: true
      });
    } catch (error) {
      console.error("[USER-BLOCKING] Error unblocking user:", error);
      res.status(500).json({ message: "Failed to unblock user" });
    }
  });
  app2.get("/api/user/blocked-users", requireAuth, async (req, res) => {
    try {
      const currentUserId = req.user?.id;
      if (!currentUserId) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      console.log(`[USER-BLOCKING] Getting blocked users list for user ${currentUserId}`);
      const blockedUsers = await db.select().from(userBlocks).where(eq3(userBlocks.blockerUserId, currentUserId)).orderBy(userBlocks.createdAt);
      const blockedUsersWithInfo = await Promise.all(
        blockedUsers.map(async (block) => {
          const user = await storage.getUser(block.blockedUserId);
          return {
            blockId: block.id,
            blockedUserId: block.blockedUserId,
            reason: block.reason,
            createdAt: block.createdAt,
            fullName: user?.fullName || "Unknown User",
            photoUrl: user?.photoUrl || null
          };
        })
      );
      console.log(`[USER-BLOCKING] Found ${blockedUsersWithInfo.length} blocked users for user ${currentUserId}`);
      res.status(200).json({
        blockedUsers: blockedUsersWithInfo,
        totalCount: blockedUsersWithInfo.length
      });
    } catch (error) {
      console.error("[USER-BLOCKING] Error getting blocked users:", error);
      res.status(500).json({ message: "Failed to get blocked users" });
    }
  });
  app2.get("/api/user/is-blocked/:userId", requireAuth, async (req, res) => {
    try {
      const currentUserId = req.user?.id;
      if (!currentUserId) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      const targetUserId = parseInt(req.params.userId);
      if (isNaN(targetUserId)) {
        return res.status(400).json({ message: "Invalid user ID" });
      }
      const blocks = await db.select().from(userBlocks).where(
        or3(
          and3(
            eq3(userBlocks.blockerUserId, currentUserId),
            eq3(userBlocks.blockedUserId, targetUserId)
          ),
          and3(
            eq3(userBlocks.blockerUserId, targetUserId),
            eq3(userBlocks.blockedUserId, currentUserId)
          )
        )
      );
      const isBlocked = blocks.length > 0;
      const blockType = blocks.length > 0 ? blocks[0].blockerUserId === currentUserId ? "blocked_by_you" : "blocked_you" : null;
      res.status(200).json({
        isBlocked,
        blockType,
        blockDetails: blocks.length > 0 ? blocks[0] : null
      });
    } catch (error) {
      console.error("[USER-BLOCKING] Error checking block status:", error);
      res.status(500).json({ message: "Failed to check block status" });
    }
  });
  console.log("[USER-BLOCKING] User blocking API endpoints registered");
}
async function areUsersBlocked(userId1, userId2) {
  try {
    const blocks = await db.select().from(userBlocks).where(
      or3(
        and3(
          eq3(userBlocks.blockerUserId, userId1),
          eq3(userBlocks.blockedUserId, userId2)
        ),
        and3(
          eq3(userBlocks.blockerUserId, userId2),
          eq3(userBlocks.blockedUserId, userId1)
        )
      )
    ).limit(1);
    return blocks.length > 0;
  } catch (error) {
    console.error("[USER-BLOCKING] Error checking if users are blocked:", error);
    return false;
  }
}
async function getBlockedUserIds(userId) {
  try {
    const blocks = await db.select({ blockedUserId: userBlocks.blockedUserId }).from(userBlocks).where(eq3(userBlocks.blockerUserId, userId));
    return blocks.map((block) => block.blockedUserId);
  } catch (error) {
    console.error("[USER-BLOCKING] Error getting blocked user IDs:", error);
    return [];
  }
}
async function getUsersWhoBlockedUser(userId) {
  try {
    const blocks = await db.select({ blockerUserId: userBlocks.blockerUserId }).from(userBlocks).where(eq3(userBlocks.blockedUserId, userId));
    return blocks.map((block) => block.blockerUserId);
  } catch (error) {
    console.error("[USER-BLOCKING] Error getting users who blocked user:", error);
    return [];
  }
}
var init_user_blocking_api = __esm({
  "server/user-blocking-api.ts"() {
    "use strict";
    init_storage();
    init_auth();
    init_schema();
    init_db();
  }
});

// server/geocoding-service.ts
import fetch2 from "node-fetch";
import dotenv from "dotenv";
var GeocodingService, geocodingService;
var init_geocoding_service = __esm({
  "server/geocoding-service.ts"() {
    "use strict";
    dotenv.config();
    GeocodingService = class {
      coordinateCache = /* @__PURE__ */ new Map();
      googlePlacesApiKey = process.env.VITE_GOOGLE_PLACES_API_KEY;
      /**
       * TIMEZONE API INTEGRATION
       * Get timezone information from coordinates using Google Timezone API
       */
      async getTimezoneFromCoordinates(lat, lng) {
        try {
          if (!this.googlePlacesApiKey) {
            return null;
          }
          const timestamp2 = Math.floor(Date.now() / 1e3);
          const url = `https://maps.googleapis.com/maps/api/timezone/json?location=${lat},${lng}&timestamp=${timestamp2}&key=${this.googlePlacesApiKey}`;
          console.log(`[TIMEZONE] Getting timezone for coordinates: ${lat}, ${lng}`);
          const response = await fetch2(url);
          const data = await response.json();
          if (data.status === "OK") {
            const rawOffset = data.rawOffset / 3600;
            const dstOffset = data.dstOffset / 3600;
            const totalOffset = rawOffset + dstOffset;
            console.log(`[TIMEZONE] Success: ${data.timeZoneId}, offset: ${totalOffset}h`);
            return {
              timezone: data.timeZoneId,
              offset: totalOffset
            };
          } else {
            console.log(`[TIMEZONE] API returned status: ${data.status}`);
            return null;
          }
        } catch (error) {
          console.error(`[TIMEZONE] Error getting timezone:`, error);
          return null;
        }
      }
      /**
       * GOOGLE PLACES API GEOCODING
       * Real-time location lookup using Google Places API for global coverage
       */
      async geocodeWithGooglePlaces(location) {
        try {
          if (!this.googlePlacesApiKey) {
            console.log("[GEOCODING] Google Places API key not found, using fallback database");
            return null;
          }
          const encodedLocation = encodeURIComponent(location);
          const url = `https://maps.googleapis.com/maps/api/geocode/json?address=${encodedLocation}&key=${this.googlePlacesApiKey}`;
          console.log(`[GEOCODING] Geocoding "${location}" with Google Places API`);
          const response = await fetch2(url);
          const data = await response.json();
          if (data.status === "OK" && data.results.length > 0) {
            const result = data.results[0];
            const { lat, lng } = result.geometry.location;
            let city;
            let country;
            for (const component of result.address_components) {
              if (component.types.includes("locality") || component.types.includes("administrative_area_level_1")) {
                city = component.long_name;
              }
              if (component.types.includes("country")) {
                country = component.long_name;
              }
            }
            const timezoneInfo = await this.getTimezoneFromCoordinates(lat, lng);
            const locationData = {
              coordinates: { latitude: lat, longitude: lng },
              city,
              country,
              timezone: timezoneInfo?.timezone,
              timezoneOffset: timezoneInfo?.offset,
              confidence: 0.95,
              // High confidence for Google Places API
              source: "google-places"
            };
            console.log(`[GEOCODING] Successfully geocoded "${location}": ${lat}, ${lng} (${city}, ${country}, ${timezoneInfo?.timezone})`);
            return locationData;
          } else {
            console.log(`[GEOCODING] Google Places API returned status: ${data.status} for "${location}"`);
            return null;
          }
        } catch (error) {
          console.error(`[GEOCODING] Error with Google Places API for "${location}":`, error);
          return null;
        }
      }
      /**
       * Fallback location coordinate database for offline/backup scenarios
       */
      fallbackLocationDatabase = {
        // Major US Cities
        "richardson, tx, usa": { coordinates: { latitude: 32.9483, longitude: -96.7299 }, city: "Richardson", country: "USA", confidence: 0.95, source: "precise" },
        "dallas, tx, usa": { coordinates: { latitude: 32.7767, longitude: -96.797 }, city: "Dallas", country: "USA", confidence: 0.95, source: "precise" },
        "houston, tx, usa": { coordinates: { latitude: 29.7604, longitude: -95.3698 }, city: "Houston", country: "USA", confidence: 0.95, source: "precise" },
        "austin, tx, usa": { coordinates: { latitude: 30.2672, longitude: -97.7431 }, city: "Austin", country: "USA", confidence: 0.95, source: "precise" },
        "new york, ny, usa": { coordinates: { latitude: 40.7128, longitude: -74.006 }, city: "New York", country: "USA", confidence: 0.95, source: "precise" },
        "los angeles, ca, usa": { coordinates: { latitude: 34.0522, longitude: -118.2437 }, city: "Los Angeles", country: "USA", confidence: 0.95, source: "precise" },
        "chicago, il, usa": { coordinates: { latitude: 41.8781, longitude: -87.6298 }, city: "Chicago", country: "USA", confidence: 0.95, source: "precise" },
        "miami, fl, usa": { coordinates: { latitude: 25.7617, longitude: -80.1918 }, city: "Miami", country: "USA", confidence: 0.95, source: "precise" },
        // European Cities  
        "madrid, spain": { coordinates: { latitude: 40.4168, longitude: -3.7038 }, city: "Madrid", country: "Spain", confidence: 0.95, source: "precise" },
        "barcelona, spain": { coordinates: { latitude: 41.3851, longitude: 2.1734 }, city: "Barcelona", country: "Spain", confidence: 0.95, source: "precise" },
        "berlin, germany": { coordinates: { latitude: 52.52, longitude: 13.405 }, city: "Berlin", country: "Germany", confidence: 0.95, source: "precise" },
        "munich, germany": { coordinates: { latitude: 48.1351, longitude: 11.582 }, city: "Munich", country: "Germany", confidence: 0.95, source: "precise" },
        "london, uk": { coordinates: { latitude: 51.5074, longitude: -0.1278 }, city: "London", country: "UK", confidence: 0.95, source: "precise" },
        "manchester, uk": { coordinates: { latitude: 53.4808, longitude: -2.2426 }, city: "Manchester", country: "UK", confidence: 0.95, source: "precise" },
        "paris, france": { coordinates: { latitude: 48.8566, longitude: 2.3522 }, city: "Paris", country: "France", confidence: 0.95, source: "precise" },
        "rome, italy": { coordinates: { latitude: 41.9028, longitude: 12.4964 }, city: "Rome", country: "Italy", confidence: 0.95, source: "precise" },
        "amsterdam, netherlands": { coordinates: { latitude: 52.3676, longitude: 4.9041 }, city: "Amsterdam", country: "Netherlands", confidence: 0.95, source: "precise" },
        // African Cities
        "accra, ghana": { coordinates: { latitude: 5.6037, longitude: -0.187 }, city: "Accra", country: "Ghana", confidence: 0.95, source: "precise" },
        "kumasi, ghana": { coordinates: { latitude: 6.6885, longitude: -1.6244 }, city: "Kumasi", country: "Ghana", confidence: 0.95, source: "precise" },
        "tamale, ghana": { coordinates: { latitude: 9.4075, longitude: -0.8533 }, city: "Tamale", country: "Ghana", confidence: 0.95, source: "precise" },
        "lagos, nigeria": { coordinates: { latitude: 6.5244, longitude: 3.3792 }, city: "Lagos", country: "Nigeria", confidence: 0.95, source: "precise" },
        "abuja, nigeria": { coordinates: { latitude: 9.0765, longitude: 7.3986 }, city: "Abuja", country: "Nigeria", confidence: 0.95, source: "precise" },
        "kano, nigeria": { coordinates: { latitude: 12.0022, longitude: 8.592 }, city: "Kano", country: "Nigeria", confidence: 0.95, source: "precise" },
        // Canadian Cities
        "toronto, canada": { coordinates: { latitude: 43.6532, longitude: -79.3832 }, city: "Toronto", country: "Canada", confidence: 0.95, source: "precise" },
        "vancouver, canada": { coordinates: { latitude: 49.2827, longitude: -123.1207 }, city: "Vancouver", country: "Canada", confidence: 0.95, source: "precise" },
        "montreal, canada": { coordinates: { latitude: 45.5019, longitude: -73.5674 }, city: "Montreal", country: "Canada", confidence: 0.95, source: "precise" },
        // Country Fallbacks (approximate center coordinates)
        "usa": { coordinates: { latitude: 39.8283, longitude: -98.5795 }, city: void 0, country: "USA", confidence: 0.6, source: "fallback" },
        "united states": { coordinates: { latitude: 39.8283, longitude: -98.5795 }, city: void 0, country: "USA", confidence: 0.6, source: "fallback" },
        "spain": { coordinates: { latitude: 40.4637, longitude: -3.7492 }, city: void 0, country: "Spain", confidence: 0.6, source: "fallback" },
        "germany": { coordinates: { latitude: 51.1657, longitude: 10.4515 }, city: void 0, country: "Germany", confidence: 0.6, source: "fallback" },
        "ghana": { coordinates: { latitude: 7.9465, longitude: -1.0232 }, city: void 0, country: "Ghana", confidence: 0.6, source: "fallback" },
        "nigeria": { coordinates: { latitude: 9.082, longitude: 8.6753 }, city: void 0, country: "Nigeria", confidence: 0.6, source: "fallback" },
        "uk": { coordinates: { latitude: 55.3781, longitude: -3.436 }, city: void 0, country: "UK", confidence: 0.6, source: "fallback" },
        "united kingdom": { coordinates: { latitude: 55.3781, longitude: -3.436 }, city: void 0, country: "UK", confidence: 0.6, source: "fallback" },
        "france": { coordinates: { latitude: 46.6034, longitude: 1.8883 }, city: void 0, country: "France", confidence: 0.6, source: "fallback" },
        "italy": { coordinates: { latitude: 41.8719, longitude: 12.5674 }, city: void 0, country: "Italy", confidence: 0.6, source: "fallback" },
        "netherlands": { coordinates: { latitude: 52.1326, longitude: 5.2913 }, city: void 0, country: "Netherlands", confidence: 0.6, source: "fallback" },
        "canada": { coordinates: { latitude: 56.1304, longitude: -106.3468 }, city: void 0, country: "Canada", confidence: 0.6, source: "fallback" }
      };
      /**
       * Get coordinates for a location string
       */
      async getCoordinates(location) {
        if (!location || location.trim() === "") {
          return null;
        }
        const locationKey = this.normalizeLocationString(location);
        console.log(`[GEOCODING] Looking up coordinates for: "${location}" \u2192 normalized: "${locationKey}"`);
        if (this.coordinateCache.has(locationKey)) {
          const cached = this.coordinateCache.get(locationKey);
          console.log(`[GEOCODING] Cache hit: ${cached.coordinates.latitude}, ${cached.coordinates.longitude} (${cached.source})`);
          return cached;
        }
        const locationData = await this.findLocationInDatabase(locationKey);
        if (locationData) {
          this.coordinateCache.set(locationKey, locationData);
          console.log(`[GEOCODING] Location found: ${locationData.coordinates.latitude}, ${locationData.coordinates.longitude} (${locationData.source})`);
          return locationData;
        }
        const parsedLocation = this.parseStructuredLocation(location);
        if (parsedLocation) {
          this.coordinateCache.set(locationKey, parsedLocation);
          console.log(`[GEOCODING] Parsed location: ${parsedLocation.coordinates.latitude}, ${parsedLocation.coordinates.longitude} (${parsedLocation.source})`);
          return parsedLocation;
        }
        console.log(`[GEOCODING] No coordinates found for: "${location}"`);
        return null;
      }
      /**
       * Normalize location string for consistent matching
       */
      normalizeLocationString(location) {
        return location.toLowerCase().trim().replace(/\s+/g, " ").replace(/[,]+/g, ",").replace(/\s*,\s*/g, ", ");
      }
      /**
       * Find location using Google Places API first, then fallback database
       */
      async findLocationInDatabase(normalizedLocation) {
        const googleResult = await this.geocodeWithGooglePlaces(normalizedLocation);
        if (googleResult) {
          return googleResult;
        }
        if (this.fallbackLocationDatabase[normalizedLocation]) {
          return this.fallbackLocationDatabase[normalizedLocation];
        }
        for (const [key, data] of Object.entries(this.fallbackLocationDatabase)) {
          if (normalizedLocation.includes(key) || key.includes(normalizedLocation)) {
            return data;
          }
          const locationParts = normalizedLocation.split(",").map((p) => p.trim());
          const keyParts = key.split(",").map((p) => p.trim());
          const hasMatch = locationParts.some(
            (part) => keyParts.some(
              (keyPart) => part.includes(keyPart) || keyPart.includes(part)
            )
          );
          if (hasMatch) {
            return { ...data, confidence: data.confidence * 0.8, source: "approximate" };
          }
        }
        return null;
      }
      /**
       * Parse structured location (City, State, Country format)
       */
      parseStructuredLocation(location) {
        const parts = location.split(",").map((p) => p.trim().toLowerCase());
        if (parts.length >= 2) {
          const lastPart = parts[parts.length - 1];
          const countryData = this.fallbackLocationDatabase[lastPart];
          if (countryData) {
            return {
              ...countryData,
              confidence: countryData.confidence * 0.7,
              source: "approximate"
            };
          }
        }
        return null;
      }
      /**
       * Calculate distance between two coordinates using Haversine formula
       */
      calculateDistance(coord1, coord2) {
        const R = 6371;
        const lat1Rad = this.toRadians(coord1.latitude);
        const lat2Rad = this.toRadians(coord2.latitude);
        const deltaLatRad = this.toRadians(coord2.latitude - coord1.latitude);
        const deltaLonRad = this.toRadians(coord2.longitude - coord1.longitude);
        const a = Math.sin(deltaLatRad / 2) * Math.sin(deltaLatRad / 2) + Math.cos(lat1Rad) * Math.cos(lat2Rad) * Math.sin(deltaLonRad / 2) * Math.sin(deltaLonRad / 2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        const distance = R * c;
        return Math.round(distance * 100) / 100;
      }
      /**
       * Calculate distance between two location strings
       */
      async calculateLocationDistance(location1, location2) {
        console.log(`[DISTANCE-CALC] Calculating distance between "${location1}" and "${location2}"`);
        const [coord1Data, coord2Data] = await Promise.all([
          this.getCoordinates(location1),
          this.getCoordinates(location2)
        ]);
        if (!coord1Data || !coord2Data) {
          console.log(`[DISTANCE-CALC] Missing coordinates - coord1: ${!!coord1Data}, coord2: ${!!coord2Data}`);
          return {
            distance: null,
            confidence: 0,
            details: {
              location1Data: coord1Data,
              location2Data: coord2Data
            }
          };
        }
        const distance = this.calculateDistance(coord1Data.coordinates, coord2Data.coordinates);
        const confidence = Math.min(coord1Data.confidence, coord2Data.confidence);
        console.log(`[DISTANCE-CALC] Distance: ${distance}km, Confidence: ${confidence}`);
        console.log(`[DISTANCE-CALC] Locations: (${coord1Data.coordinates.latitude}, ${coord1Data.coordinates.longitude}) \u2192 (${coord2Data.coordinates.latitude}, ${coord2Data.coordinates.longitude})`);
        return {
          distance,
          confidence,
          details: {
            location1Data: coord1Data,
            location2Data: coord2Data
          }
        };
      }
      /**
       * Check if distance is within preference range
       */
      async isWithinDistancePreference(userLocation, candidateLocation, maxDistanceKm) {
        const distanceResult = await this.calculateLocationDistance(userLocation, candidateLocation);
        if (distanceResult.distance === null) {
          return {
            withinRange: true,
            actualDistance: null,
            confidence: 0
          };
        }
        const withinRange = distanceResult.distance <= maxDistanceKm;
        console.log(`[DISTANCE-FILTER] ${userLocation} \u2192 ${candidateLocation}: ${distanceResult.distance}km ${withinRange ? "\u2713" : "\u2717"} ${maxDistanceKm}km limit`);
        return {
          withinRange,
          actualDistance: distanceResult.distance,
          confidence: distanceResult.confidence
        };
      }
      /**
       * FACTOR 4: TIMEZONE COMPATIBILITY CALCULATIONS
       * Calculate timezone compatibility between two locations
       */
      async calculateTimezoneCompatibility(location1, location2) {
        console.log(`[TIMEZONE-COMPAT] Calculating timezone compatibility: "${location1}" vs "${location2}"`);
        try {
          const [loc1Data, loc2Data] = await Promise.all([
            this.getCoordinates(location1),
            this.getCoordinates(location2)
          ]);
          if (!loc1Data || !loc2Data) {
            console.log(`[TIMEZONE-COMPAT] Missing location data`);
            return {
              score: 0.5,
              // Neutral score when data unavailable
              hoursDifference: 0,
              overlappingHours: [],
              compatibility: "fair",
              confidence: 0
            };
          }
          let offset1 = loc1Data.timezoneOffset;
          let offset2 = loc2Data.timezoneOffset;
          if (offset1 === void 0 || offset2 === void 0) {
            offset1 = offset1 ?? Math.round(loc1Data.coordinates.longitude / 15);
            offset2 = offset2 ?? Math.round(loc2Data.coordinates.longitude / 15);
            console.log(`[TIMEZONE-COMPAT] Using longitude-based timezone estimation`);
          }
          const hoursDifference = Math.abs(offset1 - offset2);
          const activeHours1 = this.getActiveHours(offset1);
          const activeHours2 = this.getActiveHours(offset2);
          const overlappingHours = activeHours1.filter((hour) => activeHours2.includes(hour));
          let score;
          let compatibility;
          if (hoursDifference === 0) {
            score = 1;
            compatibility = "excellent";
          } else if (hoursDifference <= 3) {
            score = 0.8 - hoursDifference * 0.1;
            compatibility = "good";
          } else if (hoursDifference <= 8) {
            score = 0.6 - hoursDifference * 0.05;
            compatibility = "fair";
          } else {
            score = Math.max(0.1, 0.4 - hoursDifference * 0.02);
            compatibility = "poor";
          }
          const overlapBonus = overlappingHours.length / 14;
          score = Math.min(1, score + overlapBonus * 0.2);
          const confidence = Math.min(loc1Data.confidence, loc2Data.confidence);
          console.log(`[TIMEZONE-COMPAT] ${location1} (UTC${offset1}) vs ${location2} (UTC${offset2})`);
          console.log(`[TIMEZONE-COMPAT] Hours difference: ${hoursDifference}, Overlapping hours: ${overlappingHours.length}`);
          console.log(`[TIMEZONE-COMPAT] Score: ${(score * 100).toFixed(1)}%, Compatibility: ${compatibility}`);
          return {
            score,
            hoursDifference,
            overlappingHours,
            compatibility,
            confidence
          };
        } catch (error) {
          console.error(`[TIMEZONE-COMPAT] Error calculating timezone compatibility:`, error);
          return {
            score: 0.5,
            hoursDifference: 0,
            overlappingHours: [],
            compatibility: "fair",
            confidence: 0
          };
        }
      }
      /**
       * Get active hours in UTC for a given timezone offset
       * Assumes people are active from 9 AM to 11 PM local time
       */
      getActiveHours(utcOffset) {
        const activeHours = [];
        for (let localHour = 9; localHour <= 23; localHour++) {
          let utcHour = localHour - utcOffset;
          if (utcHour < 0) utcHour += 24;
          if (utcHour >= 24) utcHour -= 24;
          activeHours.push(utcHour);
        }
        return activeHours.sort((a, b) => a - b);
      }
      /**
       * Helper function to convert degrees to radians
       */
      toRadians(degrees) {
        return degrees * (Math.PI / 180);
      }
      /**
       * Convert degrees to radians
       */
      toRadians(degrees) {
        return degrees * (Math.PI / 180);
      }
      /**
       * Get distance-based compatibility score (0-1 scale)
       */
      async getDistanceCompatibilityScore(userLocation, candidateLocation, maxDistanceKm = 100) {
        const distanceResult = await this.calculateLocationDistance(userLocation, candidateLocation);
        if (distanceResult.distance === null || distanceResult.confidence < 0.3) {
          return 0.5;
        }
        const distance = distanceResult.distance;
        if (distance <= maxDistanceKm) {
          const proximityScore = Math.max(0.5, 1 - distance / maxDistanceKm * 0.5);
          return proximityScore * distanceResult.confidence;
        } else {
          const excessDistance = distance - maxDistanceKm;
          const decayScore = Math.max(0.1, Math.exp(-excessDistance / maxDistanceKm));
          return decayScore * distanceResult.confidence;
        }
      }
      /**
       * Get comprehensive location analysis
       */
      async analyzeLocationCompatibility(userLocation, candidateLocation, distancePreference) {
        const maxDistance = distancePreference || 100;
        const distanceResult = await this.calculateLocationDistance(userLocation, candidateLocation);
        const score = await this.getDistanceCompatibilityScore(userLocation, candidateLocation, maxDistance);
        let analysis = "";
        if (distanceResult.distance === null) {
          analysis = "Distance calculation unavailable - using neutral scoring";
        } else if (distanceResult.distance <= maxDistance) {
          analysis = `Within ${maxDistance}km preference (${distanceResult.distance}km) - high compatibility`;
        } else {
          analysis = `Beyond ${maxDistance}km preference (${distanceResult.distance}km) - reduced compatibility`;
        }
        return {
          score,
          distance: distanceResult.distance,
          withinPreference: distanceResult.distance !== null && distanceResult.distance <= maxDistance,
          confidence: distanceResult.confidence,
          analysis
        };
      }
    };
    geocodingService = new GeocodingService();
  }
});

// server/advanced-matching-algorithms.ts
var AdvancedMatchingEngine, advancedMatchingEngine;
var init_advanced_matching_algorithms = __esm({
  "server/advanced-matching-algorithms.ts"() {
    "use strict";
    init_geocoding_service();
    AdvancedMatchingEngine = class {
      interactionCache = /* @__PURE__ */ new Map();
      vectorCache = /* @__PURE__ */ new Map();
      diversityThreshold = 0.15;
      // Minimum diversity injection percentage
      /**
       * Enhanced content scoring using multiple similarity algorithms
       */
      calculateAdvancedContentScore(user, candidate, userPreferences3, candidatePreferences) {
        const userVector = this.createUserVector(user, userPreferences3 || void 0);
        const candidateVector = this.createUserVector(candidate, candidatePreferences || void 0);
        const cosineSim = this.calculateCosineSimilarity(userVector, candidateVector);
        const jaccardSim = this.calculateJaccardSimilarity(user, candidate, userPreferences3 || void 0, candidatePreferences || void 0);
        const tfidfSim = this.calculateTFIDFSimilarity(user, candidate);
        const preferenceScore = this.calculatePreferenceAlignment(candidate, userPreferences3);
        const finalScore = cosineSim * 0.3 + jaccardSim * 0.25 + tfidfSim * 0.2 + preferenceScore * 0.25;
        return {
          score: Math.min(finalScore, 1),
          details: {
            cosine: cosineSim,
            jaccard: jaccardSim,
            tfidf: tfidfSim,
            preference: preferenceScore
          }
        };
      }
      /**
       * Matrix Factorization using simplified SVD approach
       */
      async calculateMatrixFactorizationScore(userId, candidateId, interactionMatrix) {
        try {
          const userIndex = interactionMatrix.userIds.indexOf(userId);
          const candidateIndex = interactionMatrix.userIds.indexOf(candidateId);
          if (userIndex === -1 || candidateIndex === -1) {
            return 0.5;
          }
          const userInteractions = interactionMatrix.interactions[userIndex];
          const candidateProfile = interactionMatrix.profileVectors.get(candidateId);
          if (!candidateProfile) return 0.5;
          const similarUsers = this.findSimilarUsersMatrix(userId, interactionMatrix);
          let weightedSum = 0;
          let totalWeight = 0;
          for (const { userId: simUserId, similarity } of similarUsers) {
            const simUserIndex = interactionMatrix.userIds.indexOf(simUserId);
            if (simUserIndex !== -1) {
              const simUserInteraction = interactionMatrix.interactions[simUserIndex][candidateIndex];
              if (simUserInteraction > 0) {
                weightedSum += similarity * simUserInteraction;
                totalWeight += Math.abs(similarity);
              }
            }
          }
          return totalWeight > 0 ? Math.min(weightedSum / totalWeight, 1) : 0.5;
        } catch (error) {
          console.error("[MATRIX-FACTORIZATION] Error:", error);
          return 0.5;
        }
      }
      /**
       * Advanced context scoring with reciprocity analysis
       */
      calculateAdvancedContextScore(candidate, context, reciprocityData) {
        let score = 0.5;
        const details = {};
        if (candidate.lastActive) {
          const hoursSinceActive = (context.currentTime.getTime() - candidate.lastActive.getTime()) / (1e3 * 60 * 60);
          const activityScore = Math.exp(-hoursSinceActive / 24);
          score += activityScore * 0.3;
          details.activity = activityScore;
        }
        if (candidate.isOnline) {
          score += 0.2;
          details.online = true;
        }
        const completeness = this.calculateProfileCompleteness(candidate);
        const completenessBonus = Math.sqrt(completeness) * 0.25;
        score += completenessBonus;
        details.completeness = completeness;
        const reciprocityScore = this.calculateReciprocityScore(reciprocityData);
        score += reciprocityScore * 0.25;
        details.reciprocity = reciprocityScore;
        return {
          score: Math.min(score, 1),
          details
        };
      }
      /**
       * ENHANCED DEMOGRAPHIC DIVERSITY INJECTION & FILTER BUBBLE PREVENTION
       * 
       * Implements all 5 demographic diversity categories:
       * 1. Age range expansion beyond preferences
       * 2. Ethnicity and secondaryTribe variety  
       * 3. Education level diversity
       * 4. Profession category mixing
       * 5. Location geographic diversity
       */
      injectDemographicDiversity(rankedCandidates, allCandidates, currentUser, userPreferences3, diversityPercentage = 0.15) {
        console.log(`[DEMOGRAPHIC-DIVERSITY] \u{1F3AF} Starting diversity injection for user ${currentUser.id}`);
        console.log(`[DEMOGRAPHIC-DIVERSITY] Total candidates: ${allCandidates.length}, Top results: ${rankedCandidates.length}`);
        const totalResults = rankedCandidates.length;
        const diversityCount = Math.floor(totalResults * diversityPercentage);
        if (diversityCount === 0 || allCandidates.length <= rankedCandidates.length) {
          console.log(`[DEMOGRAPHIC-DIVERSITY] \u26A0\uFE0F Skipping diversity injection (insufficient candidates)`);
          return rankedCandidates;
        }
        const topCandidateIds = new Set(rankedCandidates.map((r) => r.userId));
        const diversityCandidates = allCandidates.filter((c) => !topCandidateIds.has(c.id));
        console.log(`[DEMOGRAPHIC-DIVERSITY] Available diversity candidates: ${diversityCandidates.length}`);
        const ageExpandedCandidates = this.expandAgeRangeDiversity(diversityCandidates, currentUser, userPreferences3);
        const ethnicityDiverseCandidates = this.injectEthnicityDiversity(diversityCandidates, currentUser);
        const educationDiverseCandidates = this.injectEducationDiversity(diversityCandidates, currentUser);
        const professionDiverseCandidates = this.injectProfessionDiversity(diversityCandidates, currentUser);
        const geographicDiverseCandidates = this.injectGeographicDiversity(diversityCandidates, currentUser);
        const allDiversityCandidates = [
          ...ageExpandedCandidates,
          ...ethnicityDiverseCandidates,
          ...educationDiverseCandidates,
          ...professionDiverseCandidates,
          ...geographicDiverseCandidates
        ];
        const uniqueDiversityCandidates = Array.from(
          new Map(allDiversityCandidates.map((c) => [c.id, c])).values()
        ).slice(0, diversityCount * 2);
        console.log(`[DEMOGRAPHIC-DIVERSITY] Selected ${uniqueDiversityCandidates.length} unique diversity candidates`);
        const diverseResults = [];
        for (let i = 0; i < Math.min(diversityCount, uniqueDiversityCandidates.length); i++) {
          const candidate = uniqueDiversityCandidates[i];
          const diversityScore = this.calculateDiversityScore(candidate, currentUser);
          diverseResults.push({
            userId: candidate.id,
            contentScore: 0.4,
            collaborativeScore: 0.3,
            contextScore: 0.5,
            diversityBonus: diversityScore,
            // Calculated diversity boost
            reciprocityScore: 0.5,
            finalScore: 0.5 + diversityScore * 0.3,
            // Base score + diversity bonus
            algorithmVersion: "advanced-v1.0-demographic-diversity",
            reasons: ["Demographic diversity", "Filter bubble prevention", "Serendipitous match"]
          });
        }
        console.log(`[DEMOGRAPHIC-DIVERSITY] \u2705 Created ${diverseResults.length} diversity recommendations`);
        const result = [...rankedCandidates];
        const injectionInterval = Math.floor(totalResults / diversityCount);
        for (let i = 0; i < diverseResults.length; i++) {
          const insertPosition = (i + 1) * injectionInterval;
          if (insertPosition < result.length) {
            result.splice(insertPosition + i, 0, diverseResults[i]);
          } else {
            result.push(diverseResults[i]);
          }
        }
        console.log(`[DEMOGRAPHIC-DIVERSITY] \u{1F3AF} Final results: ${result.length} total matches (${diverseResults.length} diversity injected)`);
        return result;
      }
      /**
       * DEMOGRAPHIC DIVERSITY CATEGORY 1: AGE RANGE EXPANSION
       * Includes users slightly outside age preferences for diversity
       */
      expandAgeRangeDiversity(candidates, currentUser, preferences) {
        if (!preferences || !currentUser.dateOfBirth) return [];
        const userAge = this.calculateAge(currentUser.dateOfBirth);
        const minAge = preferences.minAge || 18;
        const maxAge = preferences.maxAge || 45;
        const expandedMinAge = Math.max(18, minAge - 4);
        const expandedMaxAge = Math.min(50, maxAge + 4);
        const ageDiverseCandidates = candidates.filter((candidate) => {
          if (!candidate.dateOfBirth) return false;
          const candidateAge = this.calculateAge(candidate.dateOfBirth);
          const inExpandedRange = candidateAge >= expandedMinAge && candidateAge <= expandedMaxAge;
          const outsideOriginalPrefs = candidateAge < minAge || candidateAge > maxAge;
          return inExpandedRange && outsideOriginalPrefs;
        });
        const boostedCandidates = ageDiverseCandidates.map((candidate) => ({
          candidate,
          newUserBoost: this.calculateNewUserBoost(candidate)
        })).sort((a, b) => b.newUserBoost - a.newUserBoost).map((item) => item.candidate);
        console.log(`[AGE-DIVERSITY] Found ${ageDiverseCandidates.length} candidates outside age prefs (${minAge}-${maxAge} \u2192 ${expandedMinAge}-${expandedMaxAge}) with new user boosts applied`);
        return boostedCandidates.slice(0, 3);
      }
      /**
       * DEMOGRAPHIC DIVERSITY CATEGORY 2: ETHNICITY & SECONDARY TRIBE VARIETY
       * Introduces ethnic diversity beyond user's typical preferences
       */
      injectEthnicityDiversity(candidates, currentUser) {
        const currentEthnicity = currentUser.ethnicity;
        const currentSecondaryTribe = currentUser.secondaryTribe;
        const ethnicityDiverseCandidates = candidates.filter((candidate) => {
          const differentEthnicity = candidate.ethnicity && candidate.ethnicity !== currentEthnicity;
          const differentSecondaryTribe = candidate.secondaryTribe && candidate.secondaryTribe !== currentSecondaryTribe;
          return differentEthnicity || differentSecondaryTribe;
        });
        console.log(`[ETHNICITY-DIVERSITY] Found ${ethnicityDiverseCandidates.length} candidates with different ethnic backgrounds`);
        return ethnicityDiverseCandidates.slice(0, 3);
      }
      /**
       * DEMOGRAPHIC DIVERSITY CATEGORY 3: EDUCATION LEVEL DIVERSITY
       * Mixes different education levels for broader perspectives
       */
      injectEducationDiversity(candidates, currentUser) {
        const currentEducation = currentUser.educationLevel;
        const educationDiverseCandidates = candidates.filter((candidate) => {
          return candidate.educationLevel && candidate.educationLevel !== currentEducation;
        });
        console.log(`[EDUCATION-DIVERSITY] Found ${educationDiverseCandidates.length} candidates with different education levels`);
        return educationDiverseCandidates.slice(0, 3);
      }
      /**
       * DEMOGRAPHIC DIVERSITY CATEGORY 4: PROFESSION CATEGORY MIXING
       * Introduces professional diversity across categories
       */
      injectProfessionDiversity(candidates, currentUser) {
        const currentProfession = currentUser.profession;
        const currentCategory = this.categorizeProfession(currentProfession || null);
        const professionDiverseCandidates = candidates.filter((candidate) => {
          if (!candidate.profession) return false;
          const candidateCategory = this.categorizeProfession(candidate.profession || null);
          return candidateCategory !== currentCategory;
        });
        console.log(`[PROFESSION-DIVERSITY] Found ${professionDiverseCandidates.length} candidates from different profession categories`);
        return professionDiverseCandidates.slice(0, 3);
      }
      /**
       * DEMOGRAPHIC DIVERSITY CATEGORY 5: GEOGRAPHIC DIVERSITY
       * Introduces location diversity beyond typical preferences
       */
      injectGeographicDiversity(candidates, currentUser) {
        const currentLocation = currentUser.location;
        const geographicDiverseCandidates = candidates.filter((candidate) => {
          return candidate.location && candidate.location !== currentLocation;
        });
        console.log(`[GEOGRAPHIC-DIVERSITY] Found ${geographicDiverseCandidates.length} candidates from different locations`);
        return geographicDiverseCandidates.slice(0, 3);
      }
      /**
       * Calculate comprehensive diversity score for a candidate
       */
      calculateDiversityScore(candidate, currentUser) {
        let diversityScore = 0;
        let factors = 0;
        if (candidate.dateOfBirth && currentUser.dateOfBirth) {
          const ageGap = Math.abs(this.calculateAge(candidate.dateOfBirth) - this.calculateAge(currentUser.dateOfBirth));
          diversityScore += Math.min(ageGap / 10, 0.3);
          factors++;
        }
        if (candidate.ethnicity !== currentUser.ethnicity) {
          diversityScore += 0.25;
          factors++;
        }
        if (candidate.educationLevel !== currentUser.educationLevel) {
          diversityScore += 0.2;
          factors++;
        }
        const currentProfessionCategory = this.categorizeProfession(currentUser.profession || null);
        const candidateProfessionCategory = this.categorizeProfession(candidate.profession || null);
        if (candidateProfessionCategory !== currentProfessionCategory) {
          diversityScore += 0.2;
          factors++;
        }
        if (candidate.location !== currentUser.location) {
          diversityScore += 0.15;
          factors++;
        }
        return factors > 0 ? Math.min(diversityScore / factors, 1) : 0.3;
      }
      /**
       * Categorize profession for diversity analysis
       */
      /**
       * Enhanced comprehensive profession categorization for global diversity
       * Covers wide range of careers from all walks of life worldwide
       */
      categorizeProfession(profession) {
        if (!profession) return "Other";
        const professionLower = profession.toLowerCase().trim();
        if (this.matchesProfessionKeywords(professionLower, [
          "author",
          "writer",
          "journalist",
          "blogger",
          "copywriter",
          "editor",
          "poet",
          "content creator",
          "artist",
          "painter",
          "sculptor",
          "illustrator",
          "graphic designer",
          "web designer",
          "interior designer",
          "fashion designer",
          "architect",
          "musician",
          "singer",
          "composer",
          "producer",
          "dj",
          "sound engineer",
          "audio",
          "photographer",
          "videographer",
          "filmmaker",
          "director",
          "cinematographer",
          "video editor",
          "actor",
          "actress",
          "performer",
          "dancer",
          "choreographer",
          "theater",
          "drama",
          "animator",
          "game designer",
          "ux designer",
          "ui designer",
          "creative director",
          "influencer"
        ])) {
          return "Creative & Arts";
        }
        if (this.matchesProfessionKeywords(professionLower, [
          "software engineer",
          "developer",
          "programmer",
          "coder",
          "full stack",
          "frontend",
          "backend",
          "data scientist",
          "data analyst",
          "machine learning",
          "ai engineer",
          "data engineer",
          "analyst",
          "cybersecurity",
          "security analyst",
          "network engineer",
          "system administrator",
          "devops",
          "mobile developer",
          "ios developer",
          "android developer",
          "web developer",
          "engineer",
          "mechanical engineer",
          "electrical engineer",
          "civil engineer",
          "chemical engineer",
          "aerospace engineer",
          "biomedical engineer",
          "environmental engineer",
          "industrial engineer",
          "it specialist",
          "tech support",
          "system analyst",
          "database administrator",
          "cloud engineer"
        ])) {
          return "Technology & Engineering";
        }
        if (this.matchesProfessionKeywords(professionLower, [
          "doctor",
          "physician",
          "surgeon",
          "specialist",
          "cardiologist",
          "neurologist",
          "pediatrician",
          "nurse",
          "registered nurse",
          "nurse practitioner",
          "nursing",
          "midwife",
          "dentist",
          "orthodontist",
          "dental hygienist",
          "oral surgeon",
          "pharmacist",
          "pharmacy technician",
          "pharmaceutical",
          "therapist",
          "physical therapist",
          "occupational therapist",
          "speech therapist",
          "psychologist",
          "psychiatrist",
          "medical technician",
          "radiologist",
          "lab technician",
          "medical assistant",
          "veterinarian",
          "vet tech",
          "animal doctor",
          "veterinary",
          "paramedic",
          "emt",
          "emergency medical",
          "first aid",
          "optometrist",
          "chiropractor",
          "nutritionist",
          "dietitian"
        ])) {
          return "Healthcare & Medical";
        }
        if (this.matchesProfessionKeywords(professionLower, [
          "manager",
          "director",
          "executive",
          "ceo",
          "cfo",
          "coo",
          "president",
          "vice president",
          "business analyst",
          "consultant",
          "strategy consultant",
          "management consultant",
          "entrepreneur",
          "founder",
          "startup",
          "business owner",
          "small business",
          "accountant",
          "bookkeeper",
          "financial analyst",
          "investment banker",
          "financial advisor",
          "banker",
          "loan officer",
          "credit analyst",
          "insurance agent",
          "real estate agent",
          "sales",
          "sales representative",
          "account manager",
          "business development",
          "marketing",
          "digital marketing",
          "marketing manager",
          "brand manager",
          "social media manager",
          "hr",
          "human resources",
          "recruiter",
          "talent acquisition",
          "hr manager",
          "project manager",
          "product manager",
          "operations manager",
          "general manager"
        ])) {
          return "Business & Finance";
        }
        if (this.matchesProfessionKeywords(professionLower, [
          "teacher",
          "educator",
          "instructor",
          "tutor",
          "professor",
          "lecturer",
          "principal",
          "school administrator",
          "academic",
          "researcher",
          "teaching assistant",
          "substitute teacher",
          "kindergarten teacher",
          "elementary teacher",
          "high school teacher",
          "college professor",
          "university professor",
          "librarian",
          "school counselor",
          "education coordinator",
          "scientist",
          "research scientist",
          "lab researcher",
          "research assistant",
          "curriculum developer",
          "instructional designer",
          "educational consultant"
        ])) {
          return "Education & Research";
        }
        if (this.matchesProfessionKeywords(professionLower, [
          "carpenter",
          "electrician",
          "plumber",
          "hvac technician",
          "mechanic",
          "auto mechanic",
          "construction worker",
          "builder",
          "contractor",
          "roofer",
          "painter",
          "welder",
          "machinist",
          "technician",
          "maintenance",
          "repair technician",
          "handyman",
          "truck driver",
          "delivery driver",
          "courier",
          "logistics",
          "warehouse worker",
          "factory worker",
          "manufacturing",
          "assembly line",
          "production worker",
          "chef",
          "cook",
          "baker",
          "culinary",
          "restaurant",
          "food service",
          "barber",
          "hairstylist",
          "beautician",
          "cosmetologist",
          "nail technician"
        ])) {
          return "Trades & Skilled Labor";
        }
        if (this.matchesProfessionKeywords(professionLower, [
          "athlete",
          "soccer player",
          "football player",
          "basketball player",
          "tennis player",
          "baseball player",
          "rugby player",
          "cricket player",
          "volleyball player",
          "coach",
          "sports coach",
          "fitness coach",
          "personal trainer",
          "gym instructor",
          "sports analyst",
          "sports journalist",
          "sports photographer",
          "sports medicine",
          "referee",
          "umpire",
          "sports official",
          "athletic trainer",
          "yoga instructor",
          "pilates instructor",
          "dance instructor",
          "martial arts instructor"
        ])) {
          return "Sports & Fitness";
        }
        if (this.matchesProfessionKeywords(professionLower, [
          "lawyer",
          "attorney",
          "legal counsel",
          "paralegal",
          "legal assistant",
          "judge",
          "police officer",
          "detective",
          "security guard",
          "law enforcement",
          "firefighter",
          "paramedic",
          "emergency services",
          "first responder",
          "government",
          "civil servant",
          "public administrator",
          "diplomat",
          "politician",
          "social worker",
          "case worker",
          "community organizer",
          "nonprofit",
          "military",
          "soldier",
          "navy",
          "air force",
          "marine",
          "veteran"
        ])) {
          return "Law & Public Service";
        }
        if (this.matchesProfessionKeywords(professionLower, [
          "hotel manager",
          "hospitality",
          "tourism",
          "travel agent",
          "tour guide",
          "flight attendant",
          "pilot",
          "airline",
          "cruise",
          "resort",
          "restaurant manager",
          "waiter",
          "waitress",
          "server",
          "bartender",
          "event planner",
          "wedding planner",
          "catering"
        ])) {
          return "Hospitality & Tourism";
        }
        if (this.matchesProfessionKeywords(professionLower, [
          "retail",
          "sales associate",
          "cashier",
          "store manager",
          "customer service",
          "call center",
          "support representative",
          "shop assistant",
          "merchandiser"
        ])) {
          return "Retail & Customer Service";
        }
        return "Other";
      }
      /**
       * Helper method to match profession keywords efficiently
       */
      matchesProfessionKeywords(profession, keywords) {
        return keywords.some((keyword) => profession.includes(keyword));
      }
      /**
       * Legacy diversity injection method (keeping for backwards compatibility)
       */
      injectDiversity(rankedCandidates, allCandidates, diversityPercentage = 0.15) {
        console.log(`[DIVERSITY] Using legacy diversity injection (${diversityPercentage * 100}%)`);
        const totalResults = rankedCandidates.length;
        const diversityCount = Math.floor(totalResults * diversityPercentage);
        if (diversityCount === 0 || allCandidates.length <= rankedCandidates.length) {
          return rankedCandidates;
        }
        const topCandidateIds = new Set(rankedCandidates.map((r) => r.userId));
        const diversityCandidates = allCandidates.filter((c) => !topCandidateIds.has(c.id)).slice(0, diversityCount * 2);
        const diverseResults = [];
        for (let i = 0; i < Math.min(diversityCount, diversityCandidates.length); i++) {
          const candidate = diversityCandidates[i];
          diverseResults.push({
            userId: candidate.id,
            contentScore: 0.4,
            collaborativeScore: 0.3,
            contextScore: 0.5,
            diversityBonus: 0.3,
            reciprocityScore: 0.5,
            finalScore: 0.6,
            algorithmVersion: "advanced-v1.0-basic-diversity",
            reasons: ["Basic diversity", "Serendipitous match"]
          });
        }
        const result = [...rankedCandidates];
        const injectionInterval = Math.floor(totalResults / diversityCount);
        for (let i = 0; i < diverseResults.length; i++) {
          const insertPosition = (i + 1) * injectionInterval;
          if (insertPosition < result.length) {
            result.splice(insertPosition + i, 0, diverseResults[i]);
          } else {
            result.push(diverseResults[i]);
          }
        }
        return result;
      }
      /**
       * Cosine similarity calculation for user vectors
       */
      calculateCosineSimilarity(vector1, vector2) {
        try {
          const v1 = [
            vector1.ageNormalized,
            vector1.heightCompatibility || 0.5,
            // NEW: Height compatibility
            vector1.profileCompleteness,
            vector1.activityScore,
            ...vector1.locationVector,
            ...vector1.interestVector
          ];
          const v2 = [
            vector2.ageNormalized,
            vector2.heightCompatibility || 0.5,
            // NEW: Height compatibility
            vector2.profileCompleteness,
            vector2.activityScore,
            ...vector2.locationVector,
            ...vector2.interestVector
          ];
          const maxLength = Math.max(v1.length, v2.length);
          while (v1.length < maxLength) v1.push(0);
          while (v2.length < maxLength) v2.push(0);
          let dotProduct = 0;
          let norm1 = 0;
          let norm2 = 0;
          for (let i = 0; i < maxLength; i++) {
            dotProduct += v1[i] * v2[i];
            norm1 += v1[i] * v1[i];
            norm2 += v2[i] * v2[i];
          }
          const denominator = Math.sqrt(norm1) * Math.sqrt(norm2);
          return denominator === 0 ? 0 : dotProduct / denominator;
        } catch (error) {
          console.error("[COSINE-SIMILARITY] Error:", error);
          return 0;
        }
      }
      /**
       * Enhanced TF-IDF similarity for comprehensive textual content analysis
       * Includes: bio, profession, interests (parsed), relationshipGoal, education fields
       */
      calculateTFIDFSimilarity(user1, user2) {
        try {
          console.log(`[TFIDF-SIMILARITY] Analyzing textual content for user ${user1.id} vs user ${user2.id}`);
          const text1 = this.createEnhancedTextualContent(user1);
          const text2 = this.createEnhancedTextualContent(user2);
          console.log(`[TFIDF-SIMILARITY] User ${user1.id} content length: ${text1.length} characters`);
          console.log(`[TFIDF-SIMILARITY] User ${user2.id} content length: ${text2.length} characters`);
          if (!text1.trim() || !text2.trim()) {
            console.log("[TFIDF-SIMILARITY] Empty text content, returning 0");
            return 0;
          }
          const tokens1 = this.tokenize(text1);
          const tokens2 = this.tokenize(text2);
          console.log(`[TFIDF-SIMILARITY] User ${user1.id} tokens: ${tokens1.length}, User ${user2.id} tokens: ${tokens2.length}`);
          const allTokens = /* @__PURE__ */ new Set([...tokens1, ...tokens2]);
          const vector1 = [];
          const vector2 = [];
          let commonTokens = 0;
          for (const token of allTokens) {
            const tf1 = this.calculateTF(token, tokens1);
            const tf2 = this.calculateTF(token, tokens2);
            const documentsWithTerm = (tf1 > 0 ? 1 : 0) + (tf2 > 0 ? 1 : 0);
            const idf = Math.log(2 / (1 + documentsWithTerm));
            vector1.push(tf1 * idf);
            vector2.push(tf2 * idf);
            if (tf1 > 0 && tf2 > 0) commonTokens++;
          }
          const similarity = this.calculateVectorCosineSimilarity(vector1, vector2);
          console.log(`[TFIDF-SIMILARITY] Common tokens: ${commonTokens}/${allTokens.size}, Final similarity: ${similarity.toFixed(4)}`);
          return similarity;
        } catch (error) {
          console.error("[TFIDF-SIMILARITY] Error:", error);
          return 0;
        }
      }
      /**
       * Create enhanced textual content combining all available fields
       */
      createEnhancedTextualContent(user) {
        const contentParts = [];
        if (user.bio?.trim()) {
          contentParts.push(user.bio.trim());
        }
        if (user.profession?.trim()) {
          contentParts.push(user.profession.trim());
        }
        if (user.interests?.trim()) {
          try {
            const interestsArray = JSON.parse(user.interests);
            if (Array.isArray(interestsArray)) {
              contentParts.push(interestsArray.join(" "));
            } else {
              contentParts.push(user.interests.trim());
            }
          } catch (e) {
            contentParts.push(user.interests.trim());
          }
        }
        if (user.relationshipGoal?.trim()) {
          contentParts.push(user.relationshipGoal.trim());
        }
        if (user.highSchool?.trim()) {
          contentParts.push(user.highSchool.trim());
        }
        if (user.collegeUniversity?.trim()) {
          contentParts.push(user.collegeUniversity.trim());
        }
        const combinedContent = contentParts.join(" ").toLowerCase();
        console.log(`[TFIDF-CONTENT] User ${user.id} enhanced content: "${combinedContent.substring(0, 100)}${combinedContent.length > 100 ? "..." : ""}"`);
        return combinedContent;
      }
      /**
       * Create comprehensive user vector for mathematical operations
       */
      createUserVector(user, preferences) {
        const ageNormalized = user.dateOfBirth ? Math.min((this.calculateAge(user.dateOfBirth) - 18) / 62, 1) : 0.5;
        const heightCompatibility = this.calculateHeightCompatibility(user, preferences);
        const locationVector = this.createLocationVector(user.location);
        const interestVector = this.createInterestVector(user.interests);
        const religionVector = this.createCategoricalVector(user.religion, ["Christian", "Muslim", "Traditional", "Other"]);
        const ethnicityVector = this.createCategoricalVector(user.ethnicity, ["Akan", "Ewe", "Ga", "Dagbani", "Other"]);
        return {
          userId: user.id,
          ageNormalized,
          heightCompatibility,
          // NEW: Added height compatibility score
          locationVector,
          interestVector,
          religionVector,
          ethnicityVector,
          profileCompleteness: this.calculateProfileCompleteness(user),
          activityScore: user.isOnline ? 1 : user.lastActive ? 0.5 : 0.1
        };
      }
      /**
       * Helper methods
       */
      calculateAge(dateOfBirth) {
        const today = /* @__PURE__ */ new Date();
        let age = today.getFullYear() - dateOfBirth.getFullYear();
        const monthDiff = today.getMonth() - dateOfBirth.getMonth();
        if (monthDiff < 0 || monthDiff === 0 && today.getDate() < dateOfBirth.getDate()) {
          age--;
        }
        return age;
      }
      calculateProfileCompleteness(user) {
        const fields = [
          user.bio,
          user.profession,
          user.interests,
          user.photoUrl,
          user.religion,
          user.ethnicity,
          user.dateOfBirth,
          user.relationshipGoal
        ];
        const completedFields = fields.filter((field) => field && field.toString().trim().length > 0);
        return completedFields.length / fields.length;
      }
      /**
       * Calculate height compatibility score between user and preferences
       */
      calculateHeightCompatibility(candidate, preferences) {
        if (!preferences || !candidate.height) return 0.5;
        const { minHeightPreference, maxHeightPreference } = preferences;
        if (!minHeightPreference && !maxHeightPreference) return 0.5;
        const candidateHeight = candidate.height;
        if (minHeightPreference && maxHeightPreference) {
          if (candidateHeight >= minHeightPreference && candidateHeight <= maxHeightPreference) {
            return 1;
          }
          const minDistance = Math.max(0, minHeightPreference - candidateHeight);
          const maxDistance = Math.max(0, candidateHeight - maxHeightPreference);
          const totalDistance = minDistance + maxDistance;
          return Math.max(0, 1 - totalDistance / 20);
        }
        if (minHeightPreference && !maxHeightPreference) {
          return candidateHeight >= minHeightPreference ? 1 : Math.max(0, 1 - (minHeightPreference - candidateHeight) / 20);
        }
        if (!minHeightPreference && maxHeightPreference) {
          return candidateHeight <= maxHeightPreference ? 1 : Math.max(0, 1 - (candidateHeight - maxHeightPreference) / 20);
        }
        return 0.5;
      }
      createLocationVector(location) {
        const locations = ["Ghana", "Diaspora", "Other"];
        return locations.map((loc) => location === loc ? 1 : 0);
      }
      createInterestVector(interests) {
        if (!interests) return new Array(20).fill(0);
        try {
          const userInterests3 = JSON.parse(interests);
          const commonInterests = [
            "music",
            "sports",
            "travel",
            "food",
            "movies",
            "reading",
            "fitness",
            "art",
            "technology",
            "cooking",
            "dancing",
            "gaming",
            "fashion",
            "photography",
            "hiking",
            "swimming",
            "business",
            "education",
            "politics",
            "religion"
          ];
          return commonInterests.map(
            (interest) => userInterests3.some((ui) => ui.toLowerCase().includes(interest)) ? 1 : 0
          );
        } catch {
          return new Array(20).fill(0);
        }
      }
      createCategoricalVector(category, categories) {
        return categories.map((cat) => category === cat ? 1 : 0);
      }
      /**
       * COMPREHENSIVE JACCARD SIMILARITY ALGORITHM FOR CATEGORICAL FEATURES
       * Implements all 8 categorical features identified in the technical audit:
       * 1. ethnicity + secondaryTribe vs ethnicityPreference
       * 2. religion vs religionPreference  
       * 3. bodyType vs bodyTypePreference
       * 4. educationLevel vs educationLevelPreference
       * 5. hasChildren vs hasChildrenPreference
       * 6. wantsChildren vs wantsChildrenPreference
       * 7. relationshipGoal vs relationshipGoalPreference (text-based)
       * 8. location/countryOfOrigin vs locationPreference/poolCountry
       */
      calculateJaccardSimilarity(user1, user2, user1Preferences, user2Preferences) {
        try {
          console.log(`[JACCARD-SIMILARITY] Analyzing user ${user1.id} vs user ${user2.id}`);
          const features = [];
          const ethnicityScore = this.calculateEthnicityJaccard(user1, user2, user1Preferences, user2Preferences);
          features.push({ name: "ethnicity", score: ethnicityScore, weight: 0.15 });
          const religionScore = this.calculateReligionJaccard(user1, user2, user1Preferences, user2Preferences);
          features.push({ name: "religion", score: religionScore, weight: 0.2 });
          const bodyTypeScore = this.calculateBodyTypeJaccard(user1, user2, user1Preferences, user2Preferences);
          features.push({ name: "bodyType", score: bodyTypeScore, weight: 0.1 });
          const educationScore = this.calculateEducationJaccard(user1, user2, user1Preferences, user2Preferences);
          features.push({ name: "education", score: educationScore, weight: 0.15 });
          const hasChildrenScore = this.calculateChildrenJaccard(user1, user2, "has", user1Preferences, user2Preferences);
          features.push({ name: "hasChildren", score: hasChildrenScore, weight: 0.15 });
          const wantsChildrenScore = this.calculateChildrenJaccard(user1, user2, "wants", user1Preferences, user2Preferences);
          features.push({ name: "wantsChildren", score: wantsChildrenScore, weight: 0.15 });
          const relationshipGoalScore = this.calculateRelationshipGoalJaccard(user1, user2, user1Preferences, user2Preferences);
          features.push({ name: "relationshipGoal", score: relationshipGoalScore, weight: 0.1 });
          const locationScore = this.calculateLocationJaccard(user1, user2, user1Preferences, user2Preferences);
          features.push({ name: "location", score: locationScore, weight: 0.1 });
          const totalWeight = features.reduce((sum, f) => sum + f.weight, 0);
          const weightedSum = features.reduce((sum, f) => sum + f.score * f.weight, 0);
          const finalScore = totalWeight > 0 ? weightedSum / totalWeight : 0.5;
          console.log(`[JACCARD-SIMILARITY] Final score: ${finalScore.toFixed(4)}`);
          features.forEach((f) => console.log(`  ${f.name}: ${f.score.toFixed(3)} (weight: ${f.weight})`));
          return Math.min(Math.max(finalScore, 0), 1);
        } catch (error) {
          console.error("[JACCARD-SIMILARITY] Error:", error);
          return 0.5;
        }
      }
      /**
       * FEATURE 1: Ethnicity + Secondary Tribe Jaccard Similarity
       */
      calculateEthnicityJaccard(user1, user2, user1Prefs, user2Prefs) {
        try {
          const user1Ethnicities = /* @__PURE__ */ new Set();
          if (user1.ethnicity) user1Ethnicities.add(user1.ethnicity);
          if (user1.secondaryTribe) user1Ethnicities.add(user1.secondaryTribe);
          const user2Ethnicities = /* @__PURE__ */ new Set();
          if (user2.ethnicity) user2Ethnicities.add(user2.ethnicity);
          if (user2.secondaryTribe) user2Ethnicities.add(user2.secondaryTribe);
          let user1EthnicityPrefs = /* @__PURE__ */ new Set();
          let user2EthnicityPrefs = /* @__PURE__ */ new Set();
          try {
            if (user1Prefs?.ethnicityPreference) {
              const prefs = JSON.parse(user1Prefs.ethnicityPreference);
              user1EthnicityPrefs = new Set(Array.isArray(prefs) ? prefs : []);
            }
            if (user2Prefs?.ethnicityPreference) {
              const prefs = JSON.parse(user2Prefs.ethnicityPreference);
              user2EthnicityPrefs = new Set(Array.isArray(prefs) ? prefs : []);
            }
          } catch (e) {
            console.log("[JACCARD-ETHNICITY] JSON parse error for preferences");
          }
          if (user1Ethnicities.size === 0 && user2Ethnicities.size === 0) {
            return 0.5;
          }
          let score1 = 0.5;
          let score2 = 0.5;
          if (user2EthnicityPrefs.size > 0 && user1Ethnicities.size > 0) {
            const intersection1 = [...user1Ethnicities].filter((e) => user2EthnicityPrefs.has(e));
            score1 = intersection1.length > 0 ? 1 : 0;
          }
          if (user1EthnicityPrefs.size > 0 && user2Ethnicities.size > 0) {
            const intersection2 = [...user2Ethnicities].filter((e) => user1EthnicityPrefs.has(e));
            score2 = intersection2.length > 0 ? 1 : 0;
          }
          return (score1 + score2) / 2;
        } catch (error) {
          console.error("[JACCARD-ETHNICITY] Error:", error);
          return 0.5;
        }
      }
      /**
       * FEATURE 2: Religion Jaccard Similarity
       */
      calculateReligionJaccard(user1, user2, user1Prefs, user2Prefs) {
        try {
          const user1Religion = user1.religion;
          const user2Religion = user2.religion;
          if (!user1Religion || !user2Religion) return 0.5;
          let user1ReligionPrefs = /* @__PURE__ */ new Set();
          let user2ReligionPrefs = /* @__PURE__ */ new Set();
          try {
            if (user1Prefs?.religionPreference) {
              const prefs = JSON.parse(user1Prefs.religionPreference);
              user1ReligionPrefs = new Set(Array.isArray(prefs) ? prefs : []);
            }
            if (user2Prefs?.religionPreference) {
              const prefs = JSON.parse(user2Prefs.religionPreference);
              user2ReligionPrefs = new Set(Array.isArray(prefs) ? prefs : []);
            }
          } catch (e) {
            console.log("[JACCARD-RELIGION] JSON parse error for preferences");
          }
          let score1 = 0.5;
          let score2 = 0.5;
          if (user2ReligionPrefs.size > 0) {
            score1 = user2ReligionPrefs.has(user1Religion) ? 1 : 0;
          }
          if (user1ReligionPrefs.size > 0) {
            score2 = user1ReligionPrefs.has(user2Religion) ? 1 : 0;
          }
          return (score1 + score2) / 2;
        } catch (error) {
          console.error("[JACCARD-RELIGION] Error:", error);
          return 0.5;
        }
      }
      /**
       * FEATURE 3: Body Type Jaccard Similarity
       */
      calculateBodyTypeJaccard(user1, user2, user1Prefs, user2Prefs) {
        try {
          const user1BodyType = user1.bodyType;
          const user2BodyType = user2.bodyType;
          if (!user1BodyType || !user2BodyType) return 0.5;
          let user1BodyTypePrefs = /* @__PURE__ */ new Set();
          let user2BodyTypePrefs = /* @__PURE__ */ new Set();
          try {
            if (user1Prefs?.bodyTypePreference) {
              const prefs = JSON.parse(user1Prefs.bodyTypePreference);
              user1BodyTypePrefs = new Set(Array.isArray(prefs) ? prefs : []);
            }
            if (user2Prefs?.bodyTypePreference) {
              const prefs = JSON.parse(user2Prefs.bodyTypePreference);
              user2BodyTypePrefs = new Set(Array.isArray(prefs) ? prefs : []);
            }
          } catch (e) {
            console.log("[JACCARD-BODYTYPE] JSON parse error for preferences");
          }
          let score1 = 0.5;
          let score2 = 0.5;
          if (user2BodyTypePrefs.size > 0) {
            score1 = user2BodyTypePrefs.has(user1BodyType) ? 1 : 0;
          }
          if (user1BodyTypePrefs.size > 0) {
            score2 = user1BodyTypePrefs.has(user2BodyType) ? 1 : 0;
          }
          return (score1 + score2) / 2;
        } catch (error) {
          console.error("[JACCARD-BODYTYPE] Error:", error);
          return 0.5;
        }
      }
      /**
       * FEATURE 4: Education Level Jaccard Similarity
       */
      calculateEducationJaccard(user1, user2, user1Prefs, user2Prefs) {
        try {
          const user1Education = user1.educationLevel;
          const user2Education = user2.educationLevel;
          if (!user1Education || !user2Education) return 0.5;
          let user1EducationPrefs = /* @__PURE__ */ new Set();
          let user2EducationPrefs = /* @__PURE__ */ new Set();
          try {
            if (user1Prefs?.educationLevelPreference) {
              const prefs = JSON.parse(user1Prefs.educationLevelPreference);
              user1EducationPrefs = new Set(Array.isArray(prefs) ? prefs : []);
            }
            if (user2Prefs?.educationLevelPreference) {
              const prefs = JSON.parse(user2Prefs.educationLevelPreference);
              user2EducationPrefs = new Set(Array.isArray(prefs) ? prefs : []);
            }
          } catch (e) {
            console.log("[JACCARD-EDUCATION] JSON parse error for preferences");
          }
          let score1 = 0.5;
          let score2 = 0.5;
          if (user2EducationPrefs.size > 0) {
            score1 = user2EducationPrefs.has(user1Education) ? 1 : 0;
          }
          if (user1EducationPrefs.size > 0) {
            score2 = user1EducationPrefs.has(user2Education) ? 1 : 0;
          }
          return (score1 + score2) / 2;
        } catch (error) {
          console.error("[JACCARD-EDUCATION] Error:", error);
          return 0.5;
        }
      }
      /**
       * FEATURE 5 & 6: Children Jaccard Similarity (has/wants)
       */
      calculateChildrenJaccard(user1, user2, type, user1Prefs, user2Prefs) {
        try {
          const user1Children = type === "has" ? user1.hasChildren : user1.wantsChildren;
          const user2Children = type === "has" ? user2.hasChildren : user2.wantsChildren;
          if (!user1Children || !user2Children) return 0.5;
          const user1ChildrenPref = type === "has" ? user1Prefs?.hasChildrenPreference : user1Prefs?.wantsChildrenPreference;
          const user2ChildrenPref = type === "has" ? user2Prefs?.hasChildrenPreference : user2Prefs?.wantsChildrenPreference;
          const convertPref = (pref) => {
            if (pref === "true" || pref === true) return "yes";
            if (pref === "false" || pref === false) return "no";
            if (pref === "any") return "any";
            return null;
          };
          const user1PrefConverted = convertPref(user1ChildrenPref);
          const user2PrefConverted = convertPref(user2ChildrenPref);
          let score1 = 0.5;
          let score2 = 0.5;
          if (user2PrefConverted) {
            if (user2PrefConverted === "any") {
              score1 = 1;
            } else {
              score1 = user1Children === user2PrefConverted ? 1 : 0;
            }
          }
          if (user1PrefConverted) {
            if (user1PrefConverted === "any") {
              score2 = 1;
            } else {
              score2 = user2Children === user1PrefConverted ? 1 : 0;
            }
          }
          return (score1 + score2) / 2;
        } catch (error) {
          console.error(`[JACCARD-CHILDREN-${type.toUpperCase()}] Error:`, error);
          return 0.5;
        }
      }
      /**
       * FEATURE 7: Relationship Goal Jaccard Similarity (text-based)
       */
      calculateRelationshipGoalJaccard(user1, user2, user1Prefs, user2Prefs) {
        try {
          const user1Goal = user1.relationshipGoal;
          const user2Goal = user2.relationshipGoal;
          const user1GoalPref = user1Prefs?.relationshipGoalPreference;
          const user2GoalPref = user2Prefs?.relationshipGoalPreference;
          if (!user1Goal || !user2Goal) return 0.5;
          const tokenize = (text2) => {
            return new Set(text2.toLowerCase().replace(/[^\w\s]/g, " ").split(/\s+/).filter((token) => token.length > 2));
          };
          const user1GoalTokens = tokenize(user1Goal);
          const user2GoalTokens = tokenize(user2Goal);
          let user1PrefTokens = /* @__PURE__ */ new Set();
          let user2PrefTokens = /* @__PURE__ */ new Set();
          if (user1GoalPref) user1PrefTokens = tokenize(user1GoalPref);
          if (user2GoalPref) user2PrefTokens = tokenize(user2GoalPref);
          let score1 = 0.5;
          let score2 = 0.5;
          if (user2PrefTokens.size > 0) {
            const intersection1 = [...user1GoalTokens].filter((token) => user2PrefTokens.has(token));
            const union1 = /* @__PURE__ */ new Set([...user1GoalTokens, ...user2PrefTokens]);
            score1 = union1.size > 0 ? intersection1.length / union1.size : 0;
          }
          if (user1PrefTokens.size > 0) {
            const intersection2 = [...user2GoalTokens].filter((token) => user1PrefTokens.has(token));
            const union2 = /* @__PURE__ */ new Set([...user2GoalTokens, ...user1PrefTokens]);
            score2 = union2.size > 0 ? intersection2.length / union2.size : 0;
          }
          return (score1 + score2) / 2;
        } catch (error) {
          console.error("[JACCARD-RELATIONSHIP-GOAL] Error:", error);
          return 0.5;
        }
      }
      /**
       * FEATURE 8: Enhanced Location/Country of Origin Cultural Alignment
       * Now includes comprehensive cultural distance calculations and country-of-origin similarity
       */
      calculateLocationJaccard(user1, user2, user1Prefs, user2Prefs) {
        try {
          console.log(`[CULTURAL-ALIGNMENT] Analyzing cultural compatibility for user ${user1.id} vs user ${user2.id}`);
          const extractCountry = (location) => {
            const locationLower = location.toLowerCase();
            if (locationLower.includes("usa") || locationLower.includes("united states") || locationLower.includes("america")) return "USA";
            if (locationLower.includes("spain")) return "Spain";
            if (locationLower.includes("ghana")) return "Ghana";
            if (locationLower.includes("germany")) return "Germany";
            if (locationLower.includes("nigeria")) return "Nigeria";
            if (locationLower.includes("uk") || locationLower.includes("united kingdom") || locationLower.includes("england")) return "UK";
            if (locationLower.includes("canada")) return "Canada";
            if (locationLower.includes("france")) return "France";
            if (locationLower.includes("italy")) return "Italy";
            if (locationLower.includes("netherlands")) return "Netherlands";
            return location;
          };
          const user1Location = user1.location ? extractCountry(user1.location) : null;
          const user2Location = user2.location ? extractCountry(user2.location) : null;
          const user1Country = user1.countryOfOrigin;
          const user2Country = user2.countryOfOrigin;
          const user1SecondaryCountry = user1.secondaryCountryOfOrigin;
          const user2SecondaryCountry = user2.secondaryCountryOfOrigin;
          const user1PoolCountry = user1Prefs?.poolCountry;
          const user2PoolCountry = user2Prefs?.poolCountry;
          console.log(`[CULTURAL-ALIGNMENT] User ${user1.id}: Location=${user1Location}, Origin=${user1Country}, Secondary=${user1SecondaryCountry}, PoolPref=${user1PoolCountry}`);
          console.log(`[CULTURAL-ALIGNMENT] User ${user2.id}: Location=${user2Location}, Origin=${user2Country}, Secondary=${user2SecondaryCountry}, PoolPref=${user2PoolCountry}`);
          const user1CulturalIdentities = /* @__PURE__ */ new Set();
          if (user1Location) user1CulturalIdentities.add(user1Location);
          if (user1Country) user1CulturalIdentities.add(user1Country);
          if (user1SecondaryCountry) user1CulturalIdentities.add(user1SecondaryCountry);
          const user2CulturalIdentities = /* @__PURE__ */ new Set();
          if (user2Location) user2CulturalIdentities.add(user2Location);
          if (user2Country) user2CulturalIdentities.add(user2Country);
          if (user2SecondaryCountry) user2CulturalIdentities.add(user2SecondaryCountry);
          if (user1CulturalIdentities.size === 0 || user2CulturalIdentities.size === 0) {
            console.log("[CULTURAL-ALIGNMENT] Insufficient cultural data, returning neutral score");
            return 0.5;
          }
          let totalScore = 0;
          let componentCount = 0;
          const locationScore = this.calculateLocationPreferenceScore(user1CulturalIdentities, user2CulturalIdentities, user1PoolCountry || void 0, user2PoolCountry || void 0);
          totalScore += locationScore * 0.4;
          componentCount++;
          console.log(`[CULTURAL-ALIGNMENT] Location preference score: ${locationScore.toFixed(3)} (weight: 0.4)`);
          const originScore = this.calculateCountryOfOriginScore(user1Country || void 0, user2Country || void 0, user1SecondaryCountry || void 0, user2SecondaryCountry || void 0);
          totalScore += originScore * 0.35;
          componentCount++;
          console.log(`[CULTURAL-ALIGNMENT] Country of origin score: ${originScore.toFixed(3)} (weight: 0.35)`);
          const culturalDistanceScore = this.calculateCulturalDistance(user1CulturalIdentities, user2CulturalIdentities);
          totalScore += culturalDistanceScore * 0.25;
          componentCount++;
          console.log(`[CULTURAL-ALIGNMENT] Cultural distance score: ${culturalDistanceScore.toFixed(3)} (weight: 0.25)`);
          const finalScore = componentCount > 0 ? totalScore : 0.5;
          console.log(`[CULTURAL-ALIGNMENT] Final cultural alignment score: ${finalScore.toFixed(3)}`);
          return Math.min(Math.max(finalScore, 0), 1);
        } catch (error) {
          console.error("[CULTURAL-ALIGNMENT] Error:", error);
          return 0.5;
        }
      }
      /**
       * Calculate location preference scoring based on pool country preferences
       */
      calculateLocationPreferenceScore(user1Identities, user2Identities, user1PoolCountry, user2PoolCountry) {
        try {
          let score1 = 0.5;
          let score2 = 0.5;
          if (user2PoolCountry) {
            if (user2PoolCountry === "ANYWHERE") {
              score1 = 1;
            } else {
              score1 = [...user1Identities].some(
                (identity) => identity.toLowerCase().includes(user2PoolCountry.toLowerCase()) || user2PoolCountry.toLowerCase().includes(identity.toLowerCase())
              ) ? 1 : 0.3;
            }
          }
          if (user1PoolCountry) {
            if (user1PoolCountry === "ANYWHERE") {
              score2 = 1;
            } else {
              score2 = [...user2Identities].some(
                (identity) => identity.toLowerCase().includes(user1PoolCountry.toLowerCase()) || user1PoolCountry.toLowerCase().includes(identity.toLowerCase())
              ) ? 1 : 0.3;
            }
          }
          return (score1 + score2) / 2;
        } catch (error) {
          console.error("[LOCATION-PREFERENCE] Error:", error);
          return 0.5;
        }
      }
      /**
       * Calculate country of origin similarity with multi-cultural background bonus
       */
      calculateCountryOfOriginScore(user1Country, user2Country, user1SecondaryCountry, user2SecondaryCountry) {
        try {
          if (!user1Country && !user2Country) return 0.5;
          if (!user1Country || !user2Country) return 0.3;
          const user1Origins = /* @__PURE__ */ new Set();
          if (user1Country) user1Origins.add(user1Country.toLowerCase());
          if (user1SecondaryCountry) user1Origins.add(user1SecondaryCountry.toLowerCase());
          const user2Origins = /* @__PURE__ */ new Set();
          if (user2Country) user2Origins.add(user2Country.toLowerCase());
          if (user2SecondaryCountry) user2Origins.add(user2SecondaryCountry.toLowerCase());
          const intersection = [...user1Origins].filter((origin) => user2Origins.has(origin));
          const union = /* @__PURE__ */ new Set([...user1Origins, ...user2Origins]);
          if (intersection.length === 0) {
            return this.calculateRegionalCulturalSimilarity(user1Origins, user2Origins);
          }
          let score = intersection.length / union.size;
          if (user1SecondaryCountry && user2SecondaryCountry) {
            score += 0.1;
          }
          return Math.min(score, 1);
        } catch (error) {
          console.error("[COUNTRY-ORIGIN] Error:", error);
          return 0.5;
        }
      }
      /**
       * Calculate regional cultural similarity for non-matching countries
       */
      calculateRegionalCulturalSimilarity(user1Origins, user2Origins) {
        try {
          const culturalClusters = {
            // West African cultural cluster
            westAfrica: {
              countries: ["nigeria", "ghana", "senegal", "ivory coast", "burkina faso", "togo", "benin"],
              similarity: 0.7
            },
            // European cultural cluster  
            europe: {
              countries: ["germany", "france", "spain", "italy", "netherlands", "uk", "belgium"],
              similarity: 0.5
            },
            // North American cultural cluster
            northAmerica: {
              countries: ["usa", "canada"],
              similarity: 0.8
            },
            // Former British colonies (shared colonial history)
            britishColonies: {
              countries: ["nigeria", "ghana", "uk", "usa", "canada", "australia"],
              similarity: 0.4
            },
            // French-influenced regions
            francophone: {
              countries: ["france", "ivory coast", "senegal", "burkina faso", "canada"],
              similarity: 0.4
            }
          };
          let maxSimilarity = 0;
          for (const cluster of Object.values(culturalClusters)) {
            const user1Match = [...user1Origins].some(
              (origin) => cluster.countries.some((country) => origin.includes(country) || country.includes(origin))
            );
            const user2Match = [...user2Origins].some(
              (origin) => cluster.countries.some((country) => origin.includes(country) || country.includes(origin))
            );
            if (user1Match && user2Match) {
              maxSimilarity = Math.max(maxSimilarity, cluster.similarity);
            }
          }
          return maxSimilarity;
        } catch (error) {
          console.error("[REGIONAL-CULTURAL] Error:", error);
          return 0.2;
        }
      }
      /**
       * Calculate cultural distance based on comprehensive cultural identities
       */
      calculateCulturalDistance(user1Identities, user2Identities) {
        try {
          const intersection = [...user1Identities].filter(
            (identity) => [...user2Identities].some(
              (otherIdentity) => identity.toLowerCase() === otherIdentity.toLowerCase() || identity.toLowerCase().includes(otherIdentity.toLowerCase()) || otherIdentity.toLowerCase().includes(identity.toLowerCase())
            )
          );
          const union = /* @__PURE__ */ new Set([...user1Identities, ...user2Identities]);
          if (intersection.length === 0) return 0.2;
          const jaccardScore = intersection.length / union.size;
          const dataRichnessBonus = Math.min((user1Identities.size + user2Identities.size) / 10, 0.1);
          return Math.min(jaccardScore + dataRichnessBonus, 1);
        } catch (error) {
          console.error("[CULTURAL-DISTANCE] Error:", error);
          return 0.5;
        }
      }
      /**
       * Create comprehensive location sets for cultural analysis
       */
      createUserCulturalIdentities(user) {
        const identities = /* @__PURE__ */ new Set();
        if (user.location) {
          const locationLower = user.location.toLowerCase();
          if (locationLower.includes("usa") || locationLower.includes("united states")) identities.add("USA");
          else if (locationLower.includes("spain")) identities.add("Spain");
          else if (locationLower.includes("ghana")) identities.add("Ghana");
          else if (locationLower.includes("germany")) identities.add("Germany");
          else if (locationLower.includes("nigeria")) identities.add("Nigeria");
          else identities.add(user.location);
        }
        if (user.countryOfOrigin) identities.add(user.countryOfOrigin);
        if (user.secondaryCountryOfOrigin) identities.add(user.secondaryCountryOfOrigin);
        return identities;
      }
      /**
       * FACTOR 3: Distance Calculations - Comprehensive distance-based compatibility scoring
       * 
       * Calculates compatibility based on geographic distance between users and their distance preferences.
       * Uses Haversine formula for accurate distance calculations and provides weighted scoring.
       */
      async calculateDistanceCompatibility(user, candidate, userPreferences3) {
        try {
          console.log(`[DISTANCE-COMPATIBILITY] Analyzing distance between user ${user.id} and candidate ${candidate.id}`);
          const userLocation = user.location;
          const candidateLocation = candidate.location;
          if (!userLocation || !candidateLocation) {
            console.log(`[DISTANCE-COMPATIBILITY] Missing location data - user: ${!!userLocation}, candidate: ${!!candidateLocation}`);
            return 0.5;
          }
          const maxDistanceKm = userPreferences3?.distancePreference || 100;
          console.log(`[DISTANCE-COMPATIBILITY] User ${user.id} distance preference: ${maxDistanceKm}km`);
          const compatibilityResult = await geocodingService.analyzeLocationCompatibility(
            userLocation,
            candidateLocation,
            maxDistanceKm
          );
          console.log(`[DISTANCE-COMPATIBILITY] Distance analysis: ${compatibilityResult.distance}km, score: ${compatibilityResult.score.toFixed(3)}, confidence: ${compatibilityResult.confidence.toFixed(3)}`);
          console.log(`[DISTANCE-COMPATIBILITY] Analysis: ${compatibilityResult.analysis}`);
          const finalScore = compatibilityResult.score;
          console.log(`[DISTANCE-COMPATIBILITY] Final distance compatibility score: ${finalScore.toFixed(3)}`);
          return Math.min(Math.max(finalScore, 0), 1);
        } catch (error) {
          console.error("[DISTANCE-COMPATIBILITY] Error calculating distance compatibility:", error);
          return 0.5;
        }
      }
      /**
       * Enhanced preference alignment considering user's matching priorities with weighted importance
       */
      calculatePreferenceAlignment(candidate, preferences) {
        if (!preferences) return 0.5;
        let userPriorities = [];
        try {
          if (preferences.matchingPriorities) {
            userPriorities = JSON.parse(preferences.matchingPriorities);
          }
        } catch (e) {
          console.log("[PREFERENCE-ALIGNMENT] Error parsing matching priorities");
        }
        if (userPriorities.length === 0) {
          return this.calculateBasicPreferenceAlignment(candidate, preferences);
        }
        console.log(`[PREFERENCE-ALIGNMENT] User priorities: [${userPriorities.join(", ")}]`);
        let totalScore = 0;
        let totalWeight = 0;
        const priorityWeights = [0.4, 0.3, 0.2, 0.1, 0.1, 0.1, 0.1];
        userPriorities.forEach((priority, index) => {
          const weight = priorityWeights[index] || 0.05;
          const categoryScore = this.calculateCategoryScore(priority, candidate, preferences);
          totalScore += categoryScore * weight;
          totalWeight += weight;
          console.log(`[PREFERENCE-ALIGNMENT] ${priority} (priority ${index + 1}): ${categoryScore.toFixed(3)} (weight: ${weight})`);
        });
        const finalScore = totalWeight > 0 ? totalScore / totalWeight : 0.5;
        console.log(`[PREFERENCE-ALIGNMENT] Final weighted score: ${finalScore.toFixed(4)}`);
        return Math.min(Math.max(finalScore, 0), 1);
      }
      /**
       * Calculate score for individual matching priority category
       */
      calculateCategoryScore(category, candidate, preferences) {
        switch (category) {
          case "values":
            return this.calculateValuesScore(candidate, preferences);
          case "personality":
            return this.calculatePersonalityScore(candidate, preferences);
          case "looks":
            return this.calculateLooksScore(candidate, preferences);
          case "career":
            return this.calculateCareerScore(candidate, preferences);
          case "religion":
            return this.calculateReligionScore(candidate, preferences);
          case "tribe":
            return this.calculateTribeScore(candidate, preferences);
          case "intellect":
            return this.calculateIntellectScore(candidate, preferences);
          default:
            console.log(`[PREFERENCE-ALIGNMENT] Unknown category: ${category}`);
            return 0.5;
        }
      }
      /**
       * VALUES: Interests + Religion + Relationship Goals compatibility
       */
      calculateValuesScore(candidate, preferences) {
        let score = 0;
        let factors = 0;
        if (candidate.interests && preferences?.interestPreferences) {
          try {
            const candidateInterests = new Set(JSON.parse(candidate.interests));
            const preferredInterests = new Set(JSON.parse(preferences.interestPreferences));
            const commonInterests = [...candidateInterests].filter((interest) => preferredInterests.has(interest));
            const totalUniqueInterests = (/* @__PURE__ */ new Set([...candidateInterests, ...preferredInterests])).size;
            if (totalUniqueInterests > 0) {
              const overlapScore = commonInterests.length / Math.min(candidateInterests.size, preferredInterests.size);
              const diversityScore = this.calculateInterestDiversity(candidate, preferences.userId ? candidate : candidate, preferences);
              const combinedScore = overlapScore * 0.7 + diversityScore * 0.3;
              score += combinedScore;
              factors++;
              console.log(`[VALUES-SCORE] Interest combination: ${overlapScore.toFixed(3)} overlap + ${diversityScore.toFixed(3)} diversity = ${combinedScore.toFixed(3)}`);
            }
          } catch (e) {
            console.log("[VALUES-SCORE] Interest parsing error");
          }
        }
        if (candidate.religion && preferences?.religionPreference) {
          try {
            const religionPrefs = new Set(JSON.parse(preferences.religionPreference));
            score += religionPrefs.has(candidate.religion) ? 1 : 0;
            factors++;
          } catch (e) {
            if (preferences.religionPreference === candidate.religion) {
              score += 1;
              factors++;
            }
          }
        }
        if (candidate.relationshipGoal && preferences?.relationshipGoalPreference) {
          const goalSimilarity = this.calculateTextSimilarity(
            candidate.relationshipGoal.toLowerCase(),
            preferences.relationshipGoalPreference.toLowerCase()
          );
          score += goalSimilarity;
          factors++;
        }
        return factors > 0 ? score / factors : 0.5;
      }
      /**
       * PERSONALITY: Bio analysis + Shared interests
       */
      calculatePersonalityScore(candidate, preferences) {
        let score = 0;
        let factors = 0;
        if (candidate.bio && preferences && "bio" in preferences) {
          score += 0.7;
          factors++;
        }
        if (candidate.interests && preferences?.interestPreferences) {
          try {
            const candidateInterests = new Set(JSON.parse(candidate.interests));
            const preferredInterests = new Set(JSON.parse(preferences.interestPreferences));
            const overlap = [...candidateInterests].filter((i) => preferredInterests.has(i)).length;
            const union = (/* @__PURE__ */ new Set([...candidateInterests, ...preferredInterests])).size;
            if (union > 0) {
              score += overlap / union;
              factors++;
            }
          } catch (e) {
            console.log("[PERSONALITY-SCORE] Interest parsing error");
          }
        }
        return factors > 0 ? score / factors : 0.5;
      }
      /**
       * LOOKS: Enhanced body type + Height preferences with range expansion (Feature 3)
       */
      calculateLooksScore(candidate, preferences) {
        let score = 0;
        let factors = 0;
        if (candidate.bodyType && preferences?.bodyTypePreference) {
          try {
            const bodyTypePrefs = new Set(JSON.parse(preferences.bodyTypePreference));
            if (bodyTypePrefs.has(candidate.bodyType)) {
              console.log(`[BODY-TYPE-EXPANSION] Exact body type match: ${candidate.bodyType}`);
              score += 1;
            } else {
              const expansionScore = this.calculateBodyTypeRangeExpansion(candidate.bodyType, bodyTypePrefs);
              console.log(`[BODY-TYPE-EXPANSION] Expanding range for ${candidate.bodyType}: ${expansionScore.toFixed(3)}`);
              score += expansionScore;
            }
            factors++;
          } catch (e) {
            if (preferences.bodyTypePreference === candidate.bodyType) {
              score += 1;
            } else {
              const expansionScore = this.calculateBasicBodyTypeExpansion(candidate.bodyType, preferences.bodyTypePreference);
              score += expansionScore;
            }
            factors++;
          }
        }
        if (candidate.height && preferences?.minHeightPreference && preferences?.maxHeightPreference) {
          const inRange = candidate.height >= preferences.minHeightPreference && candidate.height <= preferences.maxHeightPreference;
          score += inRange ? 1 : 0;
          factors++;
        }
        return factors > 0 ? score / factors : 0.5;
      }
      /**
       * CAREER: Profession + Education level compatibility
       */
      calculateCareerScore(candidate, preferences) {
        let score = 0;
        let factors = 0;
        if (candidate.educationLevel && preferences?.educationLevelPreference) {
          try {
            const educationPrefs = new Set(JSON.parse(preferences.educationLevelPreference));
            score += educationPrefs.has(candidate.educationLevel) ? 1 : 0;
            factors++;
          } catch (e) {
            if (preferences.educationLevelPreference === candidate.educationLevel) {
              score += 1;
              factors++;
            }
          }
        }
        if (candidate.profession && preferences && "profession" in preferences) {
          score += 0.6;
          factors++;
        }
        return factors > 0 ? score / factors : 0.5;
      }
      /**
       * RELIGION: Enhanced religion matching with tolerance expansion (Feature 2)
       * Expands religion preferences when religion is not in user's deal breakers
       */
      calculateReligionScore(candidate, preferences) {
        if (!candidate.religion || !preferences?.religionPreference) return 0.5;
        try {
          const religionPrefs = new Set(JSON.parse(preferences.religionPreference));
          if (religionPrefs.has(candidate.religion)) {
            console.log(`[RELIGION-TOLERANCE] Exact religion match: ${candidate.religion}`);
            return 1;
          }
          const isReligionDealBreaker = this.isReligionDealBreaker(preferences);
          if (isReligionDealBreaker) {
            console.log(`[RELIGION-TOLERANCE] Religion is deal breaker - strict matching only`);
            return 0;
          }
          const toleranceScore = this.calculateReligionTolerance(candidate.religion, religionPrefs);
          console.log(`[RELIGION-TOLERANCE] Applying tolerance for ${candidate.religion}: ${toleranceScore.toFixed(3)}`);
          return toleranceScore;
        } catch (e) {
          const exactMatch = preferences.religionPreference === candidate.religion;
          if (exactMatch) return 1;
          const isReligionDealBreaker = this.isReligionDealBreaker(preferences);
          if (isReligionDealBreaker) return 0;
          return this.calculateBasicReligionTolerance(candidate.religion, preferences.religionPreference);
        }
      }
      /**
       * TRIBE: Ethnicity + Secondary tribe matching
       */
      calculateTribeScore(candidate, preferences) {
        if (!preferences?.ethnicityPreference) return 0.5;
        try {
          const ethnicityPrefs = new Set(JSON.parse(preferences.ethnicityPreference));
          let matches2 = 0;
          let total = 0;
          if (candidate.ethnicity) {
            matches2 += ethnicityPrefs.has(candidate.ethnicity) ? 1 : 0;
            total++;
          }
          if (candidate.secondaryTribe) {
            matches2 += ethnicityPrefs.has(candidate.secondaryTribe) ? 1 : 0;
            total++;
          }
          return total > 0 ? matches2 / total : 0.5;
        } catch (e) {
          const hasEthnicityMatch = preferences.ethnicityPreference === candidate.ethnicity;
          const hasSecondaryMatch = preferences.ethnicityPreference === candidate.secondaryTribe;
          return hasEthnicityMatch || hasSecondaryMatch ? 1 : 0;
        }
      }
      /**
       * INTELLECT: Education level + University + Profession analysis
       */
      calculateIntellectScore(candidate, preferences) {
        let score = 0;
        let factors = 0;
        if (candidate.educationLevel && preferences?.educationLevelPreference) {
          const educationHierarchy = {
            "high_school": 1,
            "some_college": 2,
            "bachelors": 3,
            "masters": 4,
            "doctorate": 5
          };
          try {
            const educationPrefs = JSON.parse(preferences.educationLevelPreference);
            const candidateLevel = educationHierarchy[candidate.educationLevel] || 0;
            const hasCompatibleEducation = educationPrefs.some(
              (pref) => educationHierarchy[pref] === candidateLevel
            );
            score += hasCompatibleEducation ? 1 : 0;
            factors++;
          } catch (e) {
            score += preferences.educationLevelPreference === candidate.educationLevel ? 1 : 0;
            factors++;
          }
        }
        if (candidate.collegeUniversity) {
          score += 0.7;
          factors++;
        }
        return factors > 0 ? score / factors : 0.5;
      }
      /**
       * Basic preference alignment for users without matching priorities
       */
      calculateBasicPreferenceAlignment(candidate, preferences) {
        if (!preferences) return 0.5;
        let score = 0;
        let factors = 0;
        if (preferences.minAge && preferences.maxAge && candidate.dateOfBirth) {
          const candidateAge = this.calculateAge(candidate.dateOfBirth);
          if (candidateAge >= preferences.minAge && candidateAge <= preferences.maxAge) {
            score += 1;
          }
          factors++;
        }
        if (preferences.locationPreference && candidate.location) {
          if (preferences.locationPreference === "Both" || preferences.locationPreference === candidate.location) {
            score += 1;
          }
          factors++;
        }
        return factors > 0 ? score / factors : 0.5;
      }
      /**
       * Simple text similarity for relationship goals
       */
      calculateTextSimilarity(text1, text2) {
        const words1 = new Set(text1.split(/\s+/).filter((w) => w.length > 2));
        const words2 = new Set(text2.split(/\s+/).filter((w) => w.length > 2));
        const intersection = [...words1].filter((w) => words2.has(w)).length;
        const union = (/* @__PURE__ */ new Set([...words1, ...words2])).size;
        return union > 0 ? intersection / union : 0;
      }
      findSimilarUsersMatrix(userId, matrix) {
        const userIndex = matrix.userIds.indexOf(userId);
        if (userIndex === -1) return [];
        const similarities = [];
        const userInteractions = matrix.interactions[userIndex];
        for (let i = 0; i < matrix.userIds.length; i++) {
          if (i === userIndex) continue;
          const otherUserId = matrix.userIds[i];
          const otherInteractions = matrix.interactions[i];
          const similarity = this.calculateInteractionSimilarity(userInteractions, otherInteractions);
          if (similarity > 0.3) {
            similarities.push({ userId: otherUserId, similarity });
          }
        }
        return similarities.sort((a, b) => b.similarity - a.similarity).slice(0, 10);
      }
      calculateInteractionSimilarity(interactions1, interactions2) {
        let dotProduct = 0;
        let norm1 = 0;
        let norm2 = 0;
        for (let i = 0; i < Math.min(interactions1.length, interactions2.length); i++) {
          dotProduct += interactions1[i] * interactions2[i];
          norm1 += interactions1[i] * interactions1[i];
          norm2 += interactions2[i] * interactions2[i];
        }
        const denominator = Math.sqrt(norm1) * Math.sqrt(norm2);
        return denominator === 0 ? 0 : dotProduct / denominator;
      }
      calculateReciprocityScore(reciprocityData) {
        const responseScore = reciprocityData.responseRate;
        const timeScore = Math.exp(-reciprocityData.averageResponseTime / 3600);
        return (responseScore + timeScore) / 2;
      }
      tokenize(text2) {
        return text2.toLowerCase().replace(/[^\w\s]/g, "").split(/\s+/).filter((token) => token.length > 2);
      }
      calculateTF(term, tokens) {
        const count2 = tokens.filter((token) => token === term).length;
        return count2 / tokens.length;
      }
      calculateVectorCosineSimilarity(vector1, vector2) {
        let dotProduct = 0;
        let norm1 = 0;
        let norm2 = 0;
        for (let i = 0; i < Math.min(vector1.length, vector2.length); i++) {
          dotProduct += vector1[i] * vector2[i];
          norm1 += vector1[i] * vector1[i];
          norm2 += vector2[i] * vector2[i];
        }
        const denominator = Math.sqrt(norm1) * Math.sqrt(norm2);
        return denominator === 0 ? 0 : dotProduct / denominator;
      }
      /**
       * ============================================================================
       * PREFERENCE EXPANSION FEATURES - COMPLETE IMPLEMENTATION
       * ============================================================================
       */
      /**
       * FEATURE 2: Religion Tolerance Expansion
       * Check if religion is marked as a deal breaker in user preferences
       */
      isReligionDealBreaker(preferences) {
        if (!preferences?.dealBreakers) return false;
        try {
          const dealBreakers = JSON.parse(preferences.dealBreakers);
          return dealBreakers.includes("religion") || dealBreakers.includes("Religion");
        } catch (e) {
          return preferences.dealBreakers.toLowerCase().includes("religion");
        }
      }
      /**
       * FEATURE 2: Calculate religion tolerance when not a deal breaker
       */
      calculateReligionTolerance(candidateReligion, preferredReligions) {
        const religion = candidateReligion.toLowerCase();
        const religionCompatibilityMap = {
          "christian": {
            "christian": 1,
            "catholic": 0.8,
            "protestant": 0.8,
            "orthodox": 0.7,
            "spiritual": 0.6,
            "other": 0.4,
            "muslim": 0.3,
            "traditional": 0.2,
            "atheist": 0.1
          },
          "muslim": {
            "muslim": 1,
            "spiritual": 0.6,
            "christian": 0.3,
            "traditional": 0.3,
            "other": 0.4,
            "atheist": 0.1
          },
          "traditional": {
            "traditional": 1,
            "spiritual": 0.7,
            "other": 0.5,
            "christian": 0.3,
            "muslim": 0.3,
            "atheist": 0.2
          },
          "spiritual": {
            "spiritual": 1,
            "christian": 0.6,
            "muslim": 0.6,
            "traditional": 0.7,
            "other": 0.6,
            "atheist": 0.3
          },
          "other": {
            "other": 1,
            "spiritual": 0.6,
            "traditional": 0.5,
            "christian": 0.4,
            "muslim": 0.4,
            "atheist": 0.4
          },
          "atheist": {
            "atheist": 1,
            "spiritual": 0.3,
            "other": 0.4,
            "christian": 0.1,
            "muslim": 0.1,
            "traditional": 0.2
          }
        };
        let maxToleranceScore = 0;
        for (const preferredReligion of preferredReligions) {
          const preferred = preferredReligion.toLowerCase();
          const toleranceScore = religionCompatibilityMap[preferred]?.[religion] || 0.2;
          maxToleranceScore = Math.max(maxToleranceScore, toleranceScore);
        }
        console.log(`[RELIGION-TOLERANCE] ${candidateReligion} tolerance with preferences [${Array.from(preferredReligions).join(", ")}]: ${maxToleranceScore.toFixed(3)}`);
        return maxToleranceScore;
      }
      /**
       * FEATURE 2: Basic religion tolerance for string-based preferences
       */
      calculateBasicReligionTolerance(candidateReligion, preferredReligion) {
        const fakeSet = /* @__PURE__ */ new Set([preferredReligion]);
        return this.calculateReligionTolerance(candidateReligion, fakeSet);
      }
      /**
       * FEATURE 3: Body Type Range Expansion
       * Expand body type preferences for diversity
       */
      calculateBodyTypeRangeExpansion(candidateBodyType, preferredBodyTypes) {
        const bodyType = candidateBodyType.toLowerCase();
        const bodyTypeCompatibilityMap = {
          "slim": {
            "slim": 1,
            "athletic": 0.8,
            "average": 0.7,
            "curvy": 0.5,
            "thick": 0.4,
            "plus size": 0.3,
            "other": 0.5
          },
          "athletic": {
            "athletic": 1,
            "slim": 0.8,
            "toned": 0.9,
            "average": 0.7,
            "muscular": 0.8,
            "curvy": 0.6,
            "thick": 0.5,
            "other": 0.5
          },
          "average": {
            "average": 1,
            "slim": 0.7,
            "athletic": 0.7,
            "curvy": 0.8,
            "thick": 0.7,
            "plus size": 0.6,
            "other": 0.6
          },
          "curvy": {
            "curvy": 1,
            "thick": 0.8,
            "average": 0.8,
            "plus size": 0.7,
            "athletic": 0.6,
            "slim": 0.5,
            "other": 0.6
          },
          "thick": {
            "thick": 1,
            "curvy": 0.8,
            "plus size": 0.8,
            "average": 0.7,
            "athletic": 0.5,
            "slim": 0.4,
            "other": 0.6
          },
          "plus size": {
            "plus size": 1,
            "thick": 0.8,
            "curvy": 0.7,
            "average": 0.6,
            "athletic": 0.4,
            "slim": 0.3,
            "other": 0.5
          },
          "muscular": {
            "muscular": 1,
            "athletic": 0.8,
            "toned": 0.8,
            "average": 0.6,
            "thick": 0.5,
            "slim": 0.5,
            "other": 0.5
          },
          "toned": {
            "toned": 1,
            "athletic": 0.9,
            "muscular": 0.8,
            "slim": 0.7,
            "average": 0.6,
            "curvy": 0.6,
            "other": 0.5
          }
        };
        let maxExpansionScore = 0;
        for (const preferredBodyType of preferredBodyTypes) {
          const preferred = preferredBodyType.toLowerCase();
          const expansionScore = bodyTypeCompatibilityMap[preferred]?.[bodyType] || 0.3;
          maxExpansionScore = Math.max(maxExpansionScore, expansionScore);
        }
        console.log(`[BODY-TYPE-EXPANSION] ${candidateBodyType} expansion with preferences [${Array.from(preferredBodyTypes).join(", ")}]: ${maxExpansionScore.toFixed(3)}`);
        return maxExpansionScore;
      }
      /**
       * FEATURE 3: Basic body type expansion for string-based preferences
       */
      calculateBasicBodyTypeExpansion(candidateBodyType, preferredBodyType) {
        const fakeSet = /* @__PURE__ */ new Set([preferredBodyType]);
        return this.calculateBodyTypeRangeExpansion(candidateBodyType, fakeSet);
      }
      /**
       * FEATURE 4: New User Priority Boosting
       * Boost priority for new users to improve their visibility
       */
      calculateNewUserBoost(candidate) {
        const createdAt = candidate.createdAt;
        if (!createdAt) return 0;
        const createdDate = new Date(createdAt);
        const now = /* @__PURE__ */ new Date();
        const daysSinceJoined = (now.getTime() - createdDate.getTime()) / (1e3 * 60 * 60 * 24);
        if (daysSinceJoined <= 7) {
          const boost = 0.3 * (1 - daysSinceJoined / 7);
          console.log(`[NEW-USER-BOOST] User ${candidate.id} joined ${daysSinceJoined.toFixed(1)} days ago, boost: ${boost.toFixed(3)}`);
          return boost;
        } else if (daysSinceJoined <= 30) {
          const boost = 0.1 * (1 - (daysSinceJoined - 7) / 23);
          console.log(`[NEW-USER-BOOST] User ${candidate.id} joined ${daysSinceJoined.toFixed(1)} days ago, boost: ${boost.toFixed(3)}`);
          return boost;
        } else {
          return 0;
        }
      }
      /**
       * FEATURE 1: Enhanced Interest Diversity Analysis
       * Calculate complementary vs. overlapping interests for better diversity
       */
      calculateInterestDiversity(candidate, currentUser, preferences) {
        if (!candidate.interests || !currentUser.interests) {
          console.log(`[INTEREST-DIVERSITY] User ${candidate.id}: Missing interests data, returning neutral 0.5`);
          return 0.5;
        }
        try {
          const candidateInterests = new Set(JSON.parse(candidate.interests));
          const currentUserInterests = new Set(JSON.parse(currentUser.interests));
          if (candidateInterests.size === 0 || currentUserInterests.size === 0) {
            console.log(`[INTEREST-DIVERSITY] User ${candidate.id}: Empty interests, returning neutral 0.5`);
            return 0.5;
          }
          const commonInterests = [...candidateInterests].filter((interest) => currentUserInterests.has(interest));
          const overlapRatio = commonInterests.length / Math.min(candidateInterests.size, currentUserInterests.size);
          const uniqueCandidateInterests = [...candidateInterests].filter((interest) => !currentUserInterests.has(interest));
          const complementaryRatio = uniqueCandidateInterests.length / candidateInterests.size;
          const diversityScore = overlapRatio * 0.6 + complementaryRatio * 0.4;
          console.log(`[INTEREST-DIVERSITY] User ${candidate.id}: ${overlapRatio.toFixed(2)} overlap + ${complementaryRatio.toFixed(2)} complementary = ${diversityScore.toFixed(3)} diversity`);
          return Math.min(diversityScore, 1);
        } catch (e) {
          console.log("[INTEREST-DIVERSITY] Error parsing interests");
          return 0.5;
        }
      }
    };
    advancedMatchingEngine = new AdvancedMatchingEngine();
  }
});

// server/matrix-factorization.ts
var MatrixFactorization, matrixFactorization;
var init_matrix_factorization = __esm({
  "server/matrix-factorization.ts"() {
    "use strict";
    init_storage();
    MatrixFactorization = class {
      model;
      NUM_FACTORS = 50;
      // Latent factors for embeddings
      LEARNING_RATE = 0.01;
      REGULARIZATION = 0.01;
      MAX_ITERATIONS = 100;
      MIN_IMPROVEMENT = 1e-3;
      constructor() {
        this.model = {
          userEmbeddings: /* @__PURE__ */ new Map(),
          itemEmbeddings: /* @__PURE__ */ new Map(),
          globalBias: 0,
          numFactors: this.NUM_FACTORS,
          learningRate: this.LEARNING_RATE,
          regularization: this.REGULARIZATION,
          trained: false
        };
      }
      /**
       * Build user-item interaction matrix from matches and swipe history
       */
      async buildInteractionMatrix() {
        try {
          console.log("[MATRIX-FACTORIZATION] Building user-item interaction matrix...");
          const interactions = [];
          const allMatches = await this.getAllMatches();
          console.log(`[MATRIX-FACTORIZATION] Found ${allMatches.length} match interactions`);
          for (const match of allMatches) {
            const rating = match.matched ? 2 : match.isDislike ? -1 : 0;
            if (rating !== 0) {
              interactions.push({
                userId: match.userId1,
                itemId: match.userId2,
                rating,
                timestamp: match.createdAt || /* @__PURE__ */ new Date()
              });
              interactions.push({
                userId: match.userId2,
                itemId: match.userId1,
                rating,
                timestamp: match.createdAt || /* @__PURE__ */ new Date()
              });
            }
          }
          const allSwipes = await this.getAllSwipeHistory();
          console.log(`[MATRIX-FACTORIZATION] Found ${allSwipes.length} swipe interactions`);
          for (const swipe of allSwipes) {
            let rating = 0;
            if (swipe.action === "like") rating = 1;
            else if (swipe.action === "star") rating = 2;
            else if (swipe.action === "dislike") rating = -1;
            if (rating !== 0) {
              interactions.push({
                userId: swipe.userId,
                itemId: swipe.targetUserId,
                rating,
                timestamp: swipe.timestamp || /* @__PURE__ */ new Date()
              });
            }
          }
          console.log(`[MATRIX-FACTORIZATION] Built interaction matrix with ${interactions.length} interactions`);
          const deduplicatedInteractions = this.deduplicateInteractions(interactions);
          console.log(`[MATRIX-FACTORIZATION] After deduplication: ${deduplicatedInteractions.length} unique interactions`);
          return deduplicatedInteractions;
        } catch (error) {
          console.error("[MATRIX-FACTORIZATION] Error building interaction matrix:", error);
          return [];
        }
      }
      /**
       * Train the matrix factorization model using gradient descent
       */
      async trainModel() {
        try {
          console.log("[MATRIX-FACTORIZATION] Starting model training...");
          const interactions = await this.buildInteractionMatrix();
          if (interactions.length === 0) {
            console.log("[MATRIX-FACTORIZATION] No interactions available for training");
            return false;
          }
          this.initializeEmbeddings(interactions);
          this.model.globalBias = interactions.reduce((sum, i) => sum + i.rating, 0) / interactions.length;
          console.log(`[MATRIX-FACTORIZATION] Global bias: ${this.model.globalBias.toFixed(3)}`);
          let previousError = Infinity;
          let improvementCount = 0;
          for (let iteration = 0; iteration < this.MAX_ITERATIONS; iteration++) {
            let totalError = 0;
            let trainingCount = 0;
            const shuffledInteractions = this.shuffleArray([...interactions]);
            for (const interaction of shuffledInteractions) {
              const error = this.performGradientDescentStep(interaction);
              totalError += error * error;
              trainingCount++;
            }
            const rmse = Math.sqrt(totalError / trainingCount);
            const improvement = previousError - rmse;
            if (iteration % 10 === 0) {
              console.log(`[MATRIX-FACTORIZATION] Iteration ${iteration}: RMSE = ${rmse.toFixed(4)}, Improvement = ${improvement.toFixed(4)}`);
            }
            if (improvement < this.MIN_IMPROVEMENT) {
              improvementCount++;
              if (improvementCount >= 3) {
                console.log(`[MATRIX-FACTORIZATION] Converged at iteration ${iteration}`);
                break;
              }
            } else {
              improvementCount = 0;
            }
            previousError = rmse;
          }
          this.model.trained = true;
          console.log(`[MATRIX-FACTORIZATION] Training completed. Model ready for predictions.`);
          console.log(`[MATRIX-FACTORIZATION] User embeddings: ${this.model.userEmbeddings.size}, Item embeddings: ${this.model.itemEmbeddings.size}`);
          return true;
        } catch (error) {
          console.error("[MATRIX-FACTORIZATION] Error training model:", error);
          return false;
        }
      }
      /**
       * Predict user-item rating using trained embeddings
       */
      predictRating(userId, itemId) {
        if (!this.model.trained) {
          return 0.5;
        }
        const userEmbedding = this.model.userEmbeddings.get(userId);
        const itemEmbedding = this.model.itemEmbeddings.get(itemId);
        if (!userEmbedding || !itemEmbedding) {
          return this.model.globalBias;
        }
        let dotProduct = 0;
        for (let f = 0; f < this.NUM_FACTORS; f++) {
          dotProduct += userEmbedding.factors[f] * itemEmbedding.factors[f];
        }
        const prediction = this.model.globalBias + userEmbedding.bias + itemEmbedding.bias + dotProduct;
        return Math.max(0, Math.min(1, (prediction + 2) / 4));
      }
      /**
       * Find users with similar embeddings
       */
      findSimilarUsers(userId, topK = 10) {
        if (!this.model.trained) return [];
        const userEmbedding = this.model.userEmbeddings.get(userId);
        if (!userEmbedding) return [];
        const similarities = [];
        for (const [otherUserId, otherEmbedding] of this.model.userEmbeddings) {
          if (otherUserId === userId) continue;
          const similarity = this.calculateEmbeddingSimilarity(userEmbedding.factors, otherEmbedding.factors);
          similarities.push({ userId: otherUserId, similarity });
        }
        return similarities.filter((s) => s.similarity > 0.1).sort((a, b) => b.similarity - a.similarity).slice(0, topK).map((s) => s.userId);
      }
      /**
       * Get collaborative filtering score for user-candidate pair
       */
      getCollaborativeScore(userId, candidateId) {
        try {
          const directScore = this.predictRating(userId, candidateId);
          const similarUsers = this.findSimilarUsers(userId, 5);
          let similarityBoost = 0;
          if (similarUsers.length > 0) {
            let positiveVotes = 0;
            for (const similarUserId of similarUsers) {
              const similarUserScore = this.predictRating(similarUserId, candidateId);
              if (similarUserScore > 0.6) {
                positiveVotes++;
              }
            }
            similarityBoost = positiveVotes / similarUsers.length * 0.2;
          }
          const finalScore = Math.min(1, directScore + similarityBoost);
          console.log(`[MATRIX-FACTORIZATION] User ${userId} \u2192 User ${candidateId}: Direct=${directScore.toFixed(3)}, Boost=${similarityBoost.toFixed(3)}, Final=${finalScore.toFixed(3)}`);
          return finalScore;
        } catch (error) {
          console.error("[MATRIX-FACTORIZATION] Error calculating collaborative score:", error);
          return 0.5;
        }
      }
      // Private helper methods
      async getAllMatches() {
        try {
          const matches2 = [];
          const allMatches = await storage.getAllMatches();
          return allMatches || [];
        } catch (error) {
          console.error("[MATRIX-FACTORIZATION] Error getting all matches:", error);
          return [];
        }
      }
      async getAllSwipeHistory() {
        try {
          const allSwipes = await storage.getAllSwipeHistory();
          return allSwipes || [];
        } catch (error) {
          console.error("[MATRIX-FACTORIZATION] Error getting all swipe history:", error);
          return [];
        }
      }
      deduplicateInteractions(interactions) {
        const interactionMap = /* @__PURE__ */ new Map();
        for (const interaction of interactions) {
          const key = `${interaction.userId}-${interaction.itemId}`;
          const existing = interactionMap.get(key);
          if (!existing || Math.abs(interaction.rating) > Math.abs(existing.rating) || interaction.timestamp > existing.timestamp) {
            interactionMap.set(key, interaction);
          }
        }
        return Array.from(interactionMap.values());
      }
      initializeEmbeddings(interactions) {
        const users2 = /* @__PURE__ */ new Set();
        const items = /* @__PURE__ */ new Set();
        for (const interaction of interactions) {
          users2.add(interaction.userId);
          items.add(interaction.itemId);
        }
        console.log(`[MATRIX-FACTORIZATION] Initializing embeddings for ${users2.size} users and ${items.size} items`);
        for (const userId of users2) {
          const factors = Array(this.NUM_FACTORS).fill(0).map(() => (Math.random() - 0.5) * 0.1);
          this.model.userEmbeddings.set(userId, {
            userId,
            factors,
            bias: 0,
            interactionCount: interactions.filter((i) => i.userId === userId).length
          });
        }
        for (const itemId of items) {
          const factors = Array(this.NUM_FACTORS).fill(0).map(() => (Math.random() - 0.5) * 0.1);
          const itemInteractions = interactions.filter((i) => i.itemId === itemId);
          const popularity = itemInteractions.length;
          this.model.itemEmbeddings.set(itemId, {
            itemId,
            factors,
            bias: 0,
            popularityScore: popularity
          });
        }
      }
      performGradientDescentStep(interaction) {
        const userEmbedding = this.model.userEmbeddings.get(interaction.userId);
        const itemEmbedding = this.model.itemEmbeddings.get(interaction.itemId);
        if (!userEmbedding || !itemEmbedding) return 0;
        let prediction = this.model.globalBias + userEmbedding.bias + itemEmbedding.bias;
        for (let f = 0; f < this.NUM_FACTORS; f++) {
          prediction += userEmbedding.factors[f] * itemEmbedding.factors[f];
        }
        const error = interaction.rating - prediction;
        const userBiasOld = userEmbedding.bias;
        const itemBiasOld = itemEmbedding.bias;
        userEmbedding.bias += this.LEARNING_RATE * (error - this.REGULARIZATION * userBiasOld);
        itemEmbedding.bias += this.LEARNING_RATE * (error - this.REGULARIZATION * itemBiasOld);
        for (let f = 0; f < this.NUM_FACTORS; f++) {
          const userFactorOld = userEmbedding.factors[f];
          const itemFactorOld = itemEmbedding.factors[f];
          userEmbedding.factors[f] += this.LEARNING_RATE * (error * itemFactorOld - this.REGULARIZATION * userFactorOld);
          itemEmbedding.factors[f] += this.LEARNING_RATE * (error * userFactorOld - this.REGULARIZATION * itemFactorOld);
        }
        return error;
      }
      calculateEmbeddingSimilarity(factors1, factors2) {
        let dotProduct = 0;
        let norm1 = 0;
        let norm2 = 0;
        for (let i = 0; i < factors1.length; i++) {
          dotProduct += factors1[i] * factors2[i];
          norm1 += factors1[i] * factors1[i];
          norm2 += factors2[i] * factors2[i];
        }
        const magnitude = Math.sqrt(norm1) * Math.sqrt(norm2);
        return magnitude > 0 ? dotProduct / magnitude : 0;
      }
      shuffleArray(array) {
        const shuffled = [...array];
        for (let i = shuffled.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
        }
        return shuffled;
      }
    };
    matrixFactorization = new MatrixFactorization();
  }
});

// server/hard-filters.ts
var HardFiltersEngine, hardFiltersEngine;
var init_hard_filters = __esm({
  "server/hard-filters.ts"() {
    "use strict";
    init_geocoding_service();
    HardFiltersEngine = class {
      /**
       * Apply all hard filters to candidate pool
       * Returns only candidates who pass ALL non-negotiable criteria
       */
      async applyHardFilters(candidates, currentUser, userPreferences3, config = {
        enforceAccountStatus: true,
        enforceAgeBoundaries: true,
        enforceDistanceLimits: true,
        enforceChildrenPreferences: true,
        enforceDealBreakers: true
      }) {
        console.log(`[HARD-FILTERS] Starting hard filter enforcement for user ${currentUser.id}`);
        console.log(`[HARD-FILTERS] Initial candidate pool: ${candidates.length} users`);
        let filteredCandidates = [...candidates];
        const startTime = Date.now();
        if (config.enforceAccountStatus) {
          filteredCandidates = await this.filterByAccountStatus(filteredCandidates, currentUser.id);
          console.log(`[HARD-FILTERS] After account status: ${filteredCandidates.length} candidates`);
        }
        if (config.enforceDealBreakers && userPreferences3?.dealBreakers) {
          filteredCandidates = await this.filterByDealBreakers(filteredCandidates, userPreferences3);
          console.log(`[HARD-FILTERS] After deal breakers: ${filteredCandidates.length} candidates`);
        }
        if (config.enforceAgeBoundaries && userPreferences3?.minAge && userPreferences3?.maxAge) {
          filteredCandidates = this.filterByAgeBoundaries(filteredCandidates, userPreferences3);
          console.log(`[HARD-FILTERS] After age boundaries: ${filteredCandidates.length} candidates`);
        }
        if (config.enforceDistanceLimits && userPreferences3?.distancePreference && userPreferences3.distancePreference !== -1) {
          filteredCandidates = await this.filterByDistanceLimits(filteredCandidates, currentUser, userPreferences3);
          console.log(`[HARD-FILTERS] After distance limits: ${filteredCandidates.length} candidates`);
        }
        if (userPreferences3) {
          filteredCandidates = this.filterBySmokingDrinkingPreferences(filteredCandidates, userPreferences3);
          console.log(`[HARD-FILTERS] After smoking/drinking preferences: ${filteredCandidates.length} candidates`);
        }
        if (config.enforceChildrenPreferences && userPreferences3) {
          filteredCandidates = this.filterByChildrenDealBreakers(filteredCandidates, userPreferences3);
          console.log(`[HARD-FILTERS] After children deal breakers: ${filteredCandidates.length} candidates`);
        }
        const duration = Date.now() - startTime;
        const filterRate = ((candidates.length - filteredCandidates.length) / candidates.length * 100).toFixed(1);
        console.log(`[HARD-FILTERS] \u2705 Filtering complete in ${duration}ms`);
        console.log(`[HARD-FILTERS] Filtered out ${candidates.length - filteredCandidates.length} users (${filterRate}%)`);
        console.log(`[HARD-FILTERS] Final acceptable pool: ${filteredCandidates.length} candidates`);
        return filteredCandidates;
      }
      /**
       * FILTER 0: Account Status Enforcement (CRITICAL SAFETY)
       * Removes candidates with problematic account statuses:
       * - Suspended users (isSuspended = true)
       * - Hidden profiles (profileHidden = true)
       * - Inactive profiles (hasActivatedProfile = false)
       * - Blocked users (bidirectional blocking)
       */
      async filterByAccountStatus(candidates, currentUserId) {
        console.log(`[ACCOUNT-STATUS] Starting account status filtering on ${candidates.length} candidates`);
        const { areUsersBlocked: areUsersBlocked2 } = await Promise.resolve().then(() => (init_user_blocking_api(), user_blocking_api_exports));
        const filteredCandidates = [];
        for (const candidate of candidates) {
          const now = /* @__PURE__ */ new Date();
          if (candidate.isSuspended) {
            if (candidate.suspensionExpiresAt && new Date(candidate.suspensionExpiresAt) > now) {
              console.log(`[ACCOUNT-STATUS] \u274C User ${candidate.id} is suspended until ${candidate.suspensionExpiresAt}`);
              continue;
            } else if (candidate.suspensionExpiresAt && new Date(candidate.suspensionExpiresAt) <= now) {
              console.log(`[ACCOUNT-STATUS] \u26A0\uFE0F User ${candidate.id} suspension expired, allowing through`);
            } else {
              console.log(`[ACCOUNT-STATUS] \u274C User ${candidate.id} is suspended (no expiry date)`);
              continue;
            }
          }
          if (candidate.profileHidden) {
            console.log(`[ACCOUNT-STATUS] \u274C User ${candidate.id} has hidden their profile`);
            continue;
          }
          if (!candidate.hasActivatedProfile) {
            console.log(`[ACCOUNT-STATUS] \u274C User ${candidate.id} has not activated their profile`);
            continue;
          }
          const isBlocked = await areUsersBlocked2(currentUserId, candidate.id);
          if (isBlocked) {
            console.log(`[ACCOUNT-STATUS] \u274C User ${candidate.id} is blocked (bidirectional blocking)`);
            continue;
          }
          filteredCandidates.push(candidate);
        }
        const filteredCount = candidates.length - filteredCandidates.length;
        console.log(`[ACCOUNT-STATUS] Filtered out ${filteredCount} users with problematic account status`);
        console.log(`[ACCOUNT-STATUS] Account status filter complete: ${filteredCandidates.length} candidates remaining`);
        return filteredCandidates;
      }
      /**
       * FILTER 1: Deal Breakers Enforcement
       * Removes candidates who match user's specified deal breakers
       */
      async filterByDealBreakers(candidates, preferences) {
        try {
          const dealBreakers = JSON.parse(preferences.dealBreakers || "[]");
          if (dealBreakers.length === 0) {
            console.log(`[DEAL-BREAKERS] No deal breakers specified`);
            return candidates;
          }
          console.log(`[DEAL-BREAKERS] Applying ${dealBreakers.length} deal breakers:`, dealBreakers);
          const filteredCandidates = candidates.filter((candidate) => {
            for (const dealBreaker of dealBreakers) {
              if (this.candidateViolatesDealBreaker(candidate, dealBreaker)) {
                console.log(`[DEAL-BREAKERS] \u274C User ${candidate.id} violates deal breaker: ${dealBreaker}`);
                return false;
              }
            }
            return true;
          });
          return filteredCandidates;
        } catch (error) {
          console.error(`[DEAL-BREAKERS] Error parsing deal breakers:`, error);
          return candidates;
        }
      }
      /**
       * Check if candidate violates a specific deal breaker
       */
      candidateViolatesDealBreaker(candidate, dealBreaker) {
        switch (dealBreaker) {
          case "smoking":
            const smoking = candidate.smoking;
            return smoking === "yes" || smoking === "occasionally" || smoking === true;
          case "drinking":
            const drinking = candidate.drinking;
            return drinking === "yes" || drinking === "occasionally" || drinking === "socially" || drinking === true;
          case "heavy_smoking":
            const heavySmoking = candidate.smoking;
            return heavySmoking === "yes" || heavySmoking === true;
          case "heavy_drinking":
            const heavyDrinking = candidate.drinking;
            return heavyDrinking === "yes" || heavyDrinking === true;
          case "different_religion":
            return false;
          // Let religion matching handle this with tolerance
          case "no_education":
            return !candidate.educationLevel || candidate.educationLevel === "no_formal_education";
          case "different_tribe":
            return false;
          // Let ethnicity matching handle this
          case "long_distance":
            return false;
          // Let distance filtering handle this
          case "has_children":
            return candidate.hasChildren === true || candidate.hasChildren === "yes";
          default:
            console.log(`[DEAL-BREAKERS] Unknown deal breaker: ${dealBreaker}`);
            return false;
        }
      }
      /**
       * FILTER 2: Age Boundaries Enforcement
       * Removes candidates outside specified age range
       */
      filterByAgeBoundaries(candidates, preferences) {
        const minAge = preferences.minAge;
        const maxAge = preferences.maxAge;
        if (!minAge || !maxAge) {
          console.log(`[AGE-BOUNDARIES] No age boundaries specified`);
          return candidates;
        }
        console.log(`[AGE-BOUNDARIES] Enforcing age range: ${minAge}-${maxAge} years`);
        const filteredCandidates = candidates.filter((candidate) => {
          if (!candidate.dateOfBirth) {
            console.log(`[AGE-BOUNDARIES] \u274C User ${candidate.id} has no birth date`);
            return false;
          }
          const candidateAge = this.calculateAge(candidate.dateOfBirth);
          const withinRange = candidateAge >= minAge && candidateAge <= maxAge;
          if (!withinRange) {
            console.log(`[AGE-BOUNDARIES] \u274C User ${candidate.id} age ${candidateAge} outside range ${minAge}-${maxAge}`);
          }
          return withinRange;
        });
        return filteredCandidates;
      }
      /**
       * FILTER 3: Distance Limits Enforcement
       * Removes candidates beyond specified distance preference
       * Converts miles to kilometers for accurate filtering
       */
      async filterByDistanceLimits(candidates, currentUser, preferences) {
        const distancePreferenceMiles = preferences.distancePreference;
        if (!distancePreferenceMiles || distancePreferenceMiles === -1) {
          console.log(`[DISTANCE-LIMITS] No distance limit specified or unlimited`);
          return candidates;
        }
        let maxDistanceKm;
        if (distancePreferenceMiles >= 999999) {
          maxDistanceKm = 999999;
          console.log(`[DISTANCE-LIMITS] Country-level filtering: ${maxDistanceKm}km`);
        } else {
          maxDistanceKm = Math.round(distancePreferenceMiles * 1.60934);
          console.log(`[DISTANCE-LIMITS] Converting ${distancePreferenceMiles} miles \u2192 ${maxDistanceKm}km`);
        }
        console.log(`[DISTANCE-LIMITS] Enforcing maximum distance: ${maxDistanceKm}km (from ${distancePreferenceMiles} miles preference)`);
        const userCoordinates = await geocodingService.getCoordinates(currentUser.location || "");
        if (!userCoordinates) {
          console.log(`[DISTANCE-LIMITS] \u26A0\uFE0F Cannot get coordinates for user location: ${currentUser.location}`);
          return candidates;
        }
        const filteredCandidates = [];
        for (const candidate of candidates) {
          if (!candidate.location) {
            console.log(`[DISTANCE-LIMITS] \u274C User ${candidate.id} has no location`);
            continue;
          }
          const candidateCoordinates = await geocodingService.getCoordinates(candidate.location);
          if (!candidateCoordinates) {
            console.log(`[DISTANCE-LIMITS] \u26A0\uFE0F Cannot get coordinates for candidate location: ${candidate.location}`);
            continue;
          }
          const distance = this.calculateDistance(
            userCoordinates.coordinates.latitude,
            userCoordinates.coordinates.longitude,
            candidateCoordinates.coordinates.latitude,
            candidateCoordinates.coordinates.longitude
          );
          if (distance <= maxDistanceKm) {
            filteredCandidates.push(candidate);
          } else {
            console.log(`[DISTANCE-LIMITS] \u274C User ${candidate.id} distance ${distance.toFixed(1)}km > ${maxDistanceKm}km (${distancePreferenceMiles} miles preference)`);
          }
        }
        return filteredCandidates;
      }
      /**
       * FILTER 4: Smoking/Drinking Preferences Enforcement
       * Filters candidates based on user's smoking and drinking preferences
       */
      filterBySmokingDrinkingPreferences(candidates, preferences) {
        const smokingPref = preferences.smokingPreference;
        const drinkingPref = preferences.drinkingPreference;
        if (!smokingPref && !drinkingPref) {
          console.log(`[SMOKING-DRINKING] No smoking/drinking preferences specified`);
          return candidates;
        }
        console.log(`[SMOKING-DRINKING] Enforcing preferences - smoking: ${smokingPref}, drinking: ${drinkingPref}`);
        const filteredCandidates = candidates.filter((candidate) => {
          if (smokingPref && smokingPref !== "any") {
            const candidateSmoking = candidate.smoking || "no";
            if (!this.isSmokingCompatible(candidateSmoking, smokingPref)) {
              console.log(`[SMOKING-DRINKING] \u274C User ${candidate.id} smoking incompatible: ${candidateSmoking} vs preference ${smokingPref}`);
              return false;
            }
          }
          if (drinkingPref && drinkingPref !== "any") {
            const candidateDrinking = candidate.drinking || "no";
            if (!this.isDrinkingCompatible(candidateDrinking, drinkingPref)) {
              console.log(`[SMOKING-DRINKING] \u274C User ${candidate.id} drinking incompatible: ${candidateDrinking} vs preference ${drinkingPref}`);
              return false;
            }
          }
          return true;
        });
        return filteredCandidates;
      }
      /**
       * Check if candidate's smoking habit is compatible with user's preference
       */
      isSmokingCompatible(candidateSmoking, userPreference) {
        switch (userPreference) {
          case "no":
            return candidateSmoking === "no";
          case "occasionally":
            return candidateSmoking === "no" || candidateSmoking === "occasionally";
          case "yes":
            return true;
          default:
            return true;
        }
      }
      /**
       * Check if candidate's drinking habit is compatible with user's preference
       */
      isDrinkingCompatible(candidateDrinking, userPreference) {
        switch (userPreference) {
          case "no":
            return candidateDrinking === "no";
          case "socially":
            return candidateDrinking === "no" || candidateDrinking === "socially";
          case "occasionally":
            return candidateDrinking === "no" || candidateDrinking === "socially" || candidateDrinking === "occasionally";
          case "yes":
            return true;
          default:
            return true;
        }
      }
      /**
       * FILTER 5: Children Preferences Deal Breaker Logic
       * Removes candidates with incompatible children preferences
       */
      filterByChildrenDealBreakers(candidates, preferences) {
        const hasChildrenPref = preferences.hasChildrenPreference;
        const wantsChildrenPref = preferences.wantsChildrenPreference;
        if (!hasChildrenPref && !wantsChildrenPref) {
          console.log(`[CHILDREN-DEAL-BREAKERS] No children preferences specified`);
          return candidates;
        }
        console.log(`[CHILDREN-DEAL-BREAKERS] Enforcing children preferences - has: ${hasChildrenPref}, wants: ${wantsChildrenPref}`);
        const filteredCandidates = candidates.filter((candidate) => {
          if (hasChildrenPref && hasChildrenPref !== "any") {
            const candidateHasChildren = this.normalizeBoolean(candidate.hasChildren);
            const preferenceHasChildren = hasChildrenPref === "yes";
            if (candidateHasChildren !== preferenceHasChildren) {
              console.log(`[CHILDREN-DEAL-BREAKERS] \u274C User ${candidate.id} hasChildren mismatch: ${candidateHasChildren} vs wanted ${preferenceHasChildren}`);
              return false;
            }
          }
          if (wantsChildrenPref && wantsChildrenPref !== "any") {
            const candidateWantsChildren = this.normalizeBoolean(candidate.wantsChildren);
            const preferenceWantsChildren = wantsChildrenPref === "yes";
            if (candidateWantsChildren !== preferenceWantsChildren) {
              console.log(`[CHILDREN-DEAL-BREAKERS] \u274C User ${candidate.id} wantsChildren mismatch: ${candidateWantsChildren} vs wanted ${preferenceWantsChildren}`);
              return false;
            }
          }
          return true;
        });
        return filteredCandidates;
      }
      /**
       * Helper: Calculate age from date of birth
       */
      calculateAge(dateOfBirth) {
        const today = /* @__PURE__ */ new Date();
        const birthDate = new Date(dateOfBirth);
        let age = today.getFullYear() - birthDate.getFullYear();
        const monthDiff = today.getMonth() - birthDate.getMonth();
        if (monthDiff < 0 || monthDiff === 0 && today.getDate() < birthDate.getDate()) {
          age--;
        }
        return age;
      }
      /**
       * Helper: Calculate distance using Haversine formula
       */
      calculateDistance(lat1, lon1, lat2, lon2) {
        const R = 6371;
        const dLat = (lat2 - lat1) * Math.PI / 180;
        const dLon = (lon2 - lon1) * Math.PI / 180;
        const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) + Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) * Math.sin(dLon / 2) * Math.sin(dLon / 2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        return R * c;
      }
      /**
       * Helper: Normalize boolean values from various formats
       */
      normalizeBoolean(value) {
        if (value === true || value === "yes" || value === "true") return true;
        if (value === false || value === "no" || value === "false") return false;
        return null;
      }
      /**
       * Get filtering statistics for debugging
       */
      async getFilteringStats(candidates, currentUser, userPreferences3) {
        if (!userPreferences3) {
          return {
            total: candidates.length,
            afterDealBreakers: candidates.length,
            afterAgeBoundaries: candidates.length,
            afterDistanceLimits: candidates.length,
            afterChildrenFilters: candidates.length,
            filteringRate: 0
          };
        }
        let filtered = [...candidates];
        const stats = { total: candidates.length };
        if (userPreferences3.dealBreakers) {
          filtered = await this.filterByDealBreakers(filtered, userPreferences3);
          stats.afterDealBreakers = filtered.length;
        } else {
          stats.afterDealBreakers = filtered.length;
        }
        if (userPreferences3.minAge && userPreferences3.maxAge) {
          filtered = this.filterByAgeBoundaries(filtered, userPreferences3);
          stats.afterAgeBoundaries = filtered.length;
        } else {
          stats.afterAgeBoundaries = filtered.length;
        }
        if (userPreferences3.distancePreference && userPreferences3.distancePreference !== -1) {
          filtered = await this.filterByDistanceLimits(filtered, currentUser, userPreferences3);
          stats.afterDistanceLimits = filtered.length;
        } else {
          stats.afterDistanceLimits = filtered.length;
        }
        filtered = this.filterByChildrenDealBreakers(filtered, userPreferences3);
        stats.afterChildrenFilters = filtered.length;
        stats.filteringRate = (candidates.length - filtered.length) / candidates.length * 100;
        return stats;
      }
    };
    hardFiltersEngine = new HardFiltersEngine();
  }
});

// server/user-behavior-patterns.ts
var user_behavior_patterns_exports = {};
__export(user_behavior_patterns_exports, {
  UserBehaviorPatterns: () => UserBehaviorPatterns,
  userBehaviorPatterns: () => userBehaviorPatterns
});
import { neon } from "@neondatabase/serverless";
import dotenv2 from "dotenv";
var sql3, UserBehaviorPatterns, userBehaviorPatterns;
var init_user_behavior_patterns = __esm({
  "server/user-behavior-patterns.ts"() {
    "use strict";
    init_geocoding_service();
    dotenv2.config();
    sql3 = neon(process.env.DATABASE_URL);
    UserBehaviorPatterns = class {
      /**
       * TEMPORAL FACTOR 1: Online Status Detection
       * Real-time user engagement boost for currently active users
       */
      async calculateOnlineStatus(userId) {
        try {
          console.log(`[USER-BEHAVIOR] Calculating online status for user ${userId}`);
          const userActivity = await sql3`
        SELECT 
          id,
          last_active,
          is_online,
          EXTRACT(EPOCH FROM (NOW() - last_active))/60 as minutes_since_active
        FROM users 
        WHERE id = ${userId}
      `;
          if (userActivity.length === 0) {
            return { isOnline: false, onlineBoost: 0 };
          }
          const user = userActivity[0];
          const minutesSinceActive = user.minutes_since_active ? Number(user.minutes_since_active) : null;
          let isOnline = false;
          let onlineBoost = 0;
          if (user.is_online === true) {
            isOnline = true;
            onlineBoost = 1;
          } else if (minutesSinceActive !== null) {
            if (minutesSinceActive <= 5) {
              isOnline = true;
              onlineBoost = 1;
            } else if (minutesSinceActive <= 15) {
              isOnline = false;
              onlineBoost = 0.8;
            } else if (minutesSinceActive <= 30) {
              isOnline = false;
              onlineBoost = 0.6;
            } else if (minutesSinceActive <= 120) {
              isOnline = false;
              onlineBoost = 0.3;
            } else {
              isOnline = false;
              onlineBoost = 0.1;
            }
          }
          console.log(`[USER-BEHAVIOR] User ${userId} online status: ${isOnline} (boost: ${onlineBoost.toFixed(2)})`);
          return { isOnline, onlineBoost };
        } catch (error) {
          console.error(`[USER-BEHAVIOR] Error calculating online status for user ${userId}:`, error);
          return { isOnline: false, onlineBoost: 0 };
        }
      }
      /**
       * TEMPORAL FACTOR 2: Last Active Recency Scoring
       * Time-decay scoring based on user's last activity timestamp
       */
      async calculateRecencyScore(userId) {
        try {
          console.log(`[USER-BEHAVIOR] Calculating recency score for user ${userId}`);
          const userRecency = await sql3`
        SELECT 
          id,
          last_active,
          CASE 
            WHEN last_active IS NULL THEN 0
            WHEN last_active >= NOW() - INTERVAL '1 hour' THEN 100
            WHEN last_active >= NOW() - INTERVAL '6 hours' THEN 80
            WHEN last_active >= NOW() - INTERVAL '24 hours' THEN 60
            WHEN last_active >= NOW() - INTERVAL '3 days' THEN 40
            WHEN last_active >= NOW() - INTERVAL '7 days' THEN 20
            ELSE 10
          END as recency_score,
          EXTRACT(EPOCH FROM (NOW() - last_active))/3600 as hours_since_active
        FROM users 
        WHERE id = ${userId}
      `;
          if (userRecency.length === 0) {
            return 0;
          }
          const recencyScore = Number(userRecency[0].recency_score);
          const hoursAgo = userRecency[0].hours_since_active ? Number(userRecency[0].hours_since_active).toFixed(1) : "Unknown";
          console.log(`[USER-BEHAVIOR] User ${userId} recency score: ${recencyScore}/100 (${hoursAgo}h ago)`);
          return recencyScore / 100;
        } catch (error) {
          console.error(`[USER-BEHAVIOR] Error calculating recency score for user ${userId}:`, error);
          return 0.1;
        }
      }
      /**
       * TEMPORAL FACTOR 3: Profile Update Freshness
       * Boost users with recently updated profiles indicating active engagement
       */
      async calculateProfileFreshness(userId) {
        try {
          console.log(`[USER-BEHAVIOR] Calculating profile freshness for user ${userId}`);
          const updateTimestamp = await sql3`
        SELECT 
          id,
          updated_at,
          created_at,
          CASE 
            WHEN updated_at IS NOT NULL THEN
              CASE 
                WHEN updated_at >= NOW() - INTERVAL '24 hours' THEN 100
                WHEN updated_at >= NOW() - INTERVAL '7 days' THEN 80
                WHEN updated_at >= NOW() - INTERVAL '30 days' THEN 60
                WHEN updated_at >= NOW() - INTERVAL '90 days' THEN 40
                ELSE 20
              END
            WHEN created_at >= NOW() - INTERVAL '7 days' THEN 70
            WHEN created_at >= NOW() - INTERVAL '30 days' THEN 50
            ELSE 30
          END as freshness_score,
          EXTRACT(EPOCH FROM (NOW() - COALESCE(updated_at, created_at)))/86400 as days_since_update
        FROM users 
        WHERE id = ${userId}
      `;
          if (updateTimestamp.length === 0) {
            return 0.3;
          }
          const freshnessScore = Number(updateTimestamp[0].freshness_score);
          const daysAgo = updateTimestamp[0].days_since_update ? Number(updateTimestamp[0].days_since_update).toFixed(1) : "Unknown";
          console.log(`[USER-BEHAVIOR] User ${userId} profile freshness: ${freshnessScore}/100 (${daysAgo} days since update)`);
          return freshnessScore / 100;
        } catch (error) {
          console.error(`[USER-BEHAVIOR] Error calculating profile freshness for user ${userId}:`, error);
          return 0.3;
        }
      }
      /**
       * TEMPORAL FACTOR 4: Peak Activity Hours Analysis
       * Identify user's most active hours for temporal compatibility matching
       */
      async analyzePeakActivityHours(userId) {
        try {
          console.log(`[USER-BEHAVIOR] Analyzing peak activity hours for user ${userId}`);
          const messageActivity = await sql3`
        SELECT 
          EXTRACT(HOUR FROM created_at) as activity_hour,
          COUNT(*) as message_count
        FROM messages 
        WHERE sender_id = ${userId}
          AND created_at >= NOW() - INTERVAL '30 days'
        GROUP BY EXTRACT(HOUR FROM created_at)
        ORDER BY message_count DESC
        LIMIT 5
      `;
          const swipeActivity = await sql3`
        SELECT 
          EXTRACT(HOUR FROM timestamp) as activity_hour,
          COUNT(*) as swipe_count
        FROM swipe_history 
        WHERE user_id = ${userId}
          AND timestamp >= NOW() - INTERVAL '30 days'
        GROUP BY EXTRACT(HOUR FROM timestamp)
        ORDER BY swipe_count DESC
        LIMIT 5
      `;
          const activityMap = /* @__PURE__ */ new Map();
          messageActivity.forEach((record) => {
            const hour = Number(record.activity_hour);
            const weight = Number(record.message_count) * 2;
            activityMap.set(hour, (activityMap.get(hour) || 0) + weight);
          });
          swipeActivity.forEach((record) => {
            const hour = Number(record.activity_hour);
            const weight = Number(record.swipe_count) * 1;
            activityMap.set(hour, (activityMap.get(hour) || 0) + weight);
          });
          const sortedActivity = Array.from(activityMap.entries()).sort((a, b) => b[1] - a[1]).slice(0, 3);
          const peakHours = sortedActivity.map(([hour]) => hour);
          const totalActivity = Array.from(activityMap.values()).reduce((sum, count2) => sum + count2, 0);
          const activityStrength = totalActivity > 0 ? Math.min(totalActivity / 50, 1) : 0.1;
          console.log(`[USER-BEHAVIOR] User ${userId} peak hours: [${peakHours.join(", ")}] (strength: ${activityStrength.toFixed(2)})`);
          return { peakHours, activityStrength };
        } catch (error) {
          console.error(`[USER-BEHAVIOR] Error analyzing peak activity for user ${userId}:`, error);
          return { peakHours: [], activityStrength: 0.1 };
        }
      }
      /**
       * TEMPORAL FACTOR 4: Timezone Compatibility
       * Calculate timezone-based compatibility between two users
       */
      async calculateTimezoneCompatibility(userLocation1, userLocation2) {
        try {
          console.log(`[USER-BEHAVIOR] Calculating timezone compatibility: "${userLocation1}" vs "${userLocation2}"`);
          if (!userLocation1 || !userLocation2) {
            console.log(`[USER-BEHAVIOR] Missing location data for timezone compatibility`);
            return 0.5;
          }
          const timezoneCompatibility = await geocodingService.calculateTimezoneCompatibility(
            userLocation1,
            userLocation2
          );
          console.log(`[USER-BEHAVIOR] Timezone compatibility: ${(timezoneCompatibility.score * 100).toFixed(1)}% (${timezoneCompatibility.compatibility})`);
          console.log(`[USER-BEHAVIOR] Hours difference: ${timezoneCompatibility.hoursDifference}, Overlapping hours: ${timezoneCompatibility.overlappingHours.length}`);
          return timezoneCompatibility.score;
        } catch (error) {
          console.error(`[USER-BEHAVIOR] Error calculating timezone compatibility:`, error);
          return 0.5;
        }
      }
      /**
       * Calculate Activity Hours Alignment Between Two Users
       * Users active at similar times are more likely to engage successfully
       */
      async calculateActivityAlignment(userId1, userId2) {
        try {
          console.log(`[USER-BEHAVIOR] Calculating activity alignment: ${userId1} vs ${userId2}`);
          const user1Activity = await this.analyzePeakActivityHours(userId1);
          const user2Activity = await this.analyzePeakActivityHours(userId2);
          if (user1Activity.peakHours.length === 0 || user2Activity.peakHours.length === 0) {
            return 0.5;
          }
          const user1Hours = new Set(user1Activity.peakHours);
          const user2Hours = new Set(user2Activity.peakHours);
          const sharedHours = [...user1Hours].filter((hour) => user2Hours.has(hour));
          let alignmentScore = 0;
          if (sharedHours.length > 0) {
            alignmentScore += 0.6 * (sharedHours.length / Math.max(user1Hours.size, user2Hours.size));
          }
          let adjacentHours = 0;
          for (const hour1 of user1Activity.peakHours) {
            for (const hour2 of user2Activity.peakHours) {
              const hourDiff = Math.abs(hour1 - hour2);
              if (hourDiff === 1 || hourDiff === 23) {
                adjacentHours++;
              }
            }
          }
          if (adjacentHours > 0) {
            alignmentScore += 0.3 * Math.min(adjacentHours / 3, 1);
          }
          const strengthFactor = (user1Activity.activityStrength + user2Activity.activityStrength) / 2;
          alignmentScore *= strengthFactor;
          alignmentScore = Math.max(0, Math.min(1, alignmentScore));
          console.log(`[USER-BEHAVIOR] Activity alignment ${userId1} vs ${userId2}: ${alignmentScore.toFixed(3)} (shared: ${sharedHours.length}, adjacent: ${adjacentHours})`);
          return alignmentScore;
        } catch (error) {
          console.error(`[USER-BEHAVIOR] Error calculating activity alignment:`, error);
          return 0.5;
        }
      }
      /**
       * Generate Complete Temporal Context Profile
       * Combines all 4 temporal factors into comprehensive user context
       */
      async generateTemporalProfile(userId) {
        try {
          console.log(`[USER-BEHAVIOR] Generating temporal profile for user ${userId}`);
          const [onlineStatus, recencyScore, freshnessScore, activityData] = await Promise.all([
            this.calculateOnlineStatus(userId),
            this.calculateRecencyScore(userId),
            this.calculateProfileFreshness(userId),
            this.analyzePeakActivityHours(userId)
          ]);
          const profile = {
            userId,
            isOnline: onlineStatus.isOnline,
            lastActiveScore: recencyScore * 100,
            // Convert back to 0-100 for display
            profileFreshnessScore: freshnessScore * 100,
            peakActivityHours: activityData.peakHours,
            activityPatternScore: activityData.activityStrength
          };
          console.log(`[USER-BEHAVIOR] Temporal profile for user ${userId}:`, {
            online: profile.isOnline,
            recency: profile.lastActiveScore.toFixed(1),
            freshness: profile.profileFreshnessScore.toFixed(1),
            peaks: profile.peakActivityHours,
            strength: profile.activityPatternScore.toFixed(2)
          });
          return profile;
        } catch (error) {
          console.error(`[USER-BEHAVIOR] Error generating temporal profile for user ${userId}:`, error);
          return {
            userId,
            isOnline: false,
            lastActiveScore: 30,
            profileFreshnessScore: 50,
            peakActivityHours: [],
            activityPatternScore: 0.1
          };
        }
      }
      /**
       * FACTOR 3: Distance Calculations - Calculate geographic distance compatibility
       * 
       * Integrates with geocoding service to provide distance-based compatibility scoring
       * as part of Geographic Context Factors alongside location preferences and cultural alignment
       */
      async calculateDistanceCompatibility(targetUser, candidateUser, targetPreferences) {
        try {
          console.log(`[DISTANCE-CONTEXT] Calculating distance compatibility: ${targetUser.id} \u2192 ${candidateUser.id}`);
          const targetLocation = targetUser.location;
          const candidateLocation = candidateUser.location;
          if (!targetLocation || !candidateLocation) {
            console.log(`[DISTANCE-CONTEXT] Missing location data - target: ${!!targetLocation}, candidate: ${!!candidateLocation}`);
            return 0.5;
          }
          const maxDistanceKm = targetPreferences?.distancePreference || 100;
          const distanceAnalysis = await geocodingService.analyzeLocationCompatibility(
            targetLocation,
            candidateLocation,
            maxDistanceKm
          );
          console.log(`[DISTANCE-CONTEXT] Distance: ${distanceAnalysis.distance}km, score: ${distanceAnalysis.score.toFixed(3)}, within pref: ${distanceAnalysis.withinPreference}`);
          return distanceAnalysis.score;
        } catch (error) {
          console.error("[DISTANCE-CONTEXT] Error calculating distance compatibility:", error);
          return 0.5;
        }
      }
      /**
       * Calculate Combined Context Score
       * Integrates all temporal factors into single context-aware score for re-ranking
       */
      async calculateContextScore(targetUserId, candidateUserId) {
        try {
          console.log(`[USER-BEHAVIOR] Calculating context score: ${targetUserId} evaluating ${candidateUserId}`);
          const [candidateProfile, activityAlignment] = await Promise.all([
            this.generateTemporalProfile(candidateUserId),
            this.calculateActivityAlignment(targetUserId, candidateUserId)
          ]);
          const onlineWeight = 0.3;
          const recencyWeight = 0.25;
          const freshnessWeight = 0.2;
          const alignmentWeight = 0.25;
          let contextScore = 0;
          const onlineBoost = await this.calculateOnlineStatus(candidateUserId);
          contextScore += onlineWeight * onlineBoost.onlineBoost;
          contextScore += recencyWeight * (candidateProfile.lastActiveScore / 100);
          contextScore += freshnessWeight * (candidateProfile.profileFreshnessScore / 100);
          contextScore += alignmentWeight * activityAlignment;
          contextScore = Math.max(0, Math.min(1, contextScore));
          console.log(`[USER-BEHAVIOR] Context score ${targetUserId} \u2192 ${candidateUserId}: ${contextScore.toFixed(3)} (online: ${onlineBoost.onlineBoost.toFixed(2)}, recency: ${(candidateProfile.lastActiveScore / 100).toFixed(2)}, fresh: ${(candidateProfile.profileFreshnessScore / 100).toFixed(2)}, align: ${activityAlignment.toFixed(2)})`);
          return contextScore;
        } catch (error) {
          console.error(`[USER-BEHAVIOR] Error calculating context score:`, error);
          return 0.5;
        }
      }
      /**
       * Bulk Context Score Calculation
       * Efficiently calculate context scores for multiple candidates
       */
      async calculateBulkContextScores(targetUserId, candidateUserIds) {
        try {
          console.log(`[USER-BEHAVIOR] Calculating bulk context scores for ${candidateUserIds.length} candidates`);
          const contextScores = /* @__PURE__ */ new Map();
          const batchSize = 5;
          for (let i = 0; i < candidateUserIds.length; i += batchSize) {
            const batch = candidateUserIds.slice(i, i + batchSize);
            const batchPromises = batch.map(
              (candidateId) => this.calculateContextScore(targetUserId, candidateId).then((score) => ({ candidateId, score }))
            );
            const batchResults = await Promise.all(batchPromises);
            batchResults.forEach(({ candidateId, score }) => {
              contextScores.set(candidateId, score);
            });
          }
          console.log(`[USER-BEHAVIOR] Bulk context scoring complete for user ${targetUserId}: ${contextScores.size} scores calculated`);
          return contextScores;
        } catch (error) {
          console.error(`[USER-BEHAVIOR] Error in bulk context scoring:`, error);
          const fallbackScores = /* @__PURE__ */ new Map();
          candidateUserIds.forEach((id) => fallbackScores.set(id, 0.5));
          return fallbackScores;
        }
      }
      /**
       * GEOGRAPHIC CONTEXT FACTORS - 4/4 COMPLETE 
       * Calculate comprehensive geographic compatibility between two users
       */
      async calculateGeographicContextFactors(targetUser, candidateUser, targetPreferences) {
        try {
          console.log(`[GEOGRAPHIC-CONTEXT] Calculating all 4 geographic factors: ${targetUser.id} \u2192 ${candidateUser.id}`);
          const locationPreferenceScore = 0.7;
          const culturalAlignmentScore = 0.6;
          const distanceScore = await this.calculateDistanceCompatibility(
            targetUser,
            candidateUser,
            targetPreferences
          );
          const timezoneScore = await this.calculateTimezoneCompatibility(
            targetUser.location || "",
            candidateUser.location || ""
          );
          const factors = {
            locationPreferences: locationPreferenceScore,
            culturalAlignment: culturalAlignmentScore,
            distanceCalculations: distanceScore,
            timezoneCompatibility: timezoneScore
          };
          const overallScore = factors.locationPreferences * 0.3 + factors.culturalAlignment * 0.25 + factors.distanceCalculations * 0.25 + factors.timezoneCompatibility * 0.2;
          const confidence = targetUser.location && candidateUser.location ? 0.9 : 0.5;
          console.log(`[GEOGRAPHIC-CONTEXT] Geographic factors for ${targetUser.id} \u2192 ${candidateUser.id}:`);
          console.log(`[GEOGRAPHIC-CONTEXT] - Location Preferences: ${(factors.locationPreferences * 100).toFixed(1)}%`);
          console.log(`[GEOGRAPHIC-CONTEXT] - Cultural Alignment: ${(factors.culturalAlignment * 100).toFixed(1)}%`);
          console.log(`[GEOGRAPHIC-CONTEXT] - Distance Calculations: ${(factors.distanceCalculations * 100).toFixed(1)}%`);
          console.log(`[GEOGRAPHIC-CONTEXT] - Timezone Compatibility: ${(factors.timezoneCompatibility * 100).toFixed(1)}% \u2705 NEW`);
          console.log(`[GEOGRAPHIC-CONTEXT] - Overall Score: ${(overallScore * 100).toFixed(1)}%`);
          return {
            overallScore,
            factors,
            confidence
          };
        } catch (error) {
          console.error(`[GEOGRAPHIC-CONTEXT] Error calculating geographic factors:`, error);
          return {
            overallScore: 0.5,
            factors: {
              locationPreferences: 0.5,
              culturalAlignment: 0.5,
              distanceCalculations: 0.5,
              timezoneCompatibility: 0.5
            },
            confidence: 0
          };
        }
      }
      // ===============================
      // TEMPORAL CONTEXT FACTORS
      // ===============================
      /**
       * Calculate Temporal Context Profile for Context-Aware Re-ranking
       * Analyzes online status, last active, profile freshness, and activity patterns
       */
      async calculateTemporalContextProfile(userId) {
        try {
          console.log(`[TEMPORAL-CONTEXT] Calculating temporal factors for user ${userId}`);
          const userResult = await sql3`SELECT * FROM users WHERE id = ${userId}`;
          if (userResult.length === 0) {
            return {
              activityPatternScore: 0.5,
              lastActiveScore: 50,
              profileFreshnessScore: 50,
              isOnline: false
            };
          }
          const user = userResult[0];
          const now = /* @__PURE__ */ new Date();
          const isOnline = user.is_online || false;
          let onlineScore = isOnline ? 100 : 20;
          let lastActiveScore = 20;
          if (user.last_seen) {
            const hoursSinceActive = (now.getTime() - new Date(user.last_seen).getTime()) / (1e3 * 60 * 60);
            if (hoursSinceActive <= 1) lastActiveScore = 100;
            else if (hoursSinceActive <= 6) lastActiveScore = 80;
            else if (hoursSinceActive <= 24) lastActiveScore = 60;
            else if (hoursSinceActive <= 72) lastActiveScore = 40;
            else lastActiveScore = 20;
          }
          let profileFreshnessScore = 20;
          if (user.updated_at) {
            const daysSinceUpdate = (now.getTime() - new Date(user.updated_at).getTime()) / (1e3 * 60 * 60 * 24);
            if (daysSinceUpdate <= 1) profileFreshnessScore = 100;
            else if (daysSinceUpdate <= 7) profileFreshnessScore = 80;
            else if (daysSinceUpdate <= 30) profileFreshnessScore = 60;
            else if (daysSinceUpdate <= 90) profileFreshnessScore = 40;
            else profileFreshnessScore = 20;
          }
          const activityPatternScore = (onlineScore * 0.3 + lastActiveScore * 0.25 + profileFreshnessScore * 0.2 + 75 * 0.25) / 100;
          console.log(`[TEMPORAL-CONTEXT] User ${userId}: Online=${isOnline}, LastActive=${lastActiveScore}, Freshness=${profileFreshnessScore}, Pattern=${activityPatternScore.toFixed(3)}`);
          return {
            activityPatternScore,
            lastActiveScore,
            profileFreshnessScore,
            isOnline
          };
        } catch (error) {
          console.error("[TEMPORAL-CONTEXT] Error calculating temporal factors:", error);
          return {
            activityPatternScore: 0.5,
            lastActiveScore: 50,
            profileFreshnessScore: 50,
            isOnline: false
          };
        }
      }
      /**
       * PROFILE HEALTH METRICS - Calculate Profile Completeness & Quality Score
       * 
       * Comprehensive analysis of 5 profile health factors for Context-Aware Re-ranking:
       * 1. Photo count and quality (userPhotos table)
       * 2. Bio completeness (bio length and quality)
       * 3. Field completion percentage (profile fields)
       * 4. hasActivatedProfile status (profile activation)
       * 5. isVerified badge status (manual verification)
       */
      async calculateProfileHealthMetrics(userId) {
        try {
          console.log(`[PROFILE-HEALTH] Calculating profile health metrics for user ${userId}`);
          const [userData, userPhotos2] = await Promise.all([
            sql3`
          SELECT 
            id, bio, profession, ethnicity, religion, photo_url,
            date_of_birth, relationship_goal, high_school, college_university,
            interests, has_activated_profile, is_verified
          FROM users 
          WHERE id = ${userId}
        `,
            sql3`
          SELECT 
            id, photo_url, is_primary_for_meet, created_at
          FROM user_photos 
          WHERE user_id = ${userId}
          ORDER BY created_at DESC
        `
          ]);
          if (userData.length === 0) {
            throw new Error(`User ${userId} not found`);
          }
          const user = userData[0];
          const photoScore = this.calculatePhotoQualityScore(userPhotos2);
          const bioScore = this.calculateBioCompletenessScore(user.bio);
          const fieldCompletionScore = this.calculateFieldCompletionScore(user);
          const activationScore = user.has_activated_profile ? 100 : 0;
          const verificationScore = user.is_verified ? 100 : 0;
          const photoWeight = 0.25;
          const bioWeight = 0.2;
          const fieldWeight = 0.25;
          const activationWeight = 0.15;
          const verificationWeight = 0.15;
          const overallHealthScore = Math.round(
            photoScore * photoWeight + bioScore * bioWeight + fieldCompletionScore * fieldWeight + activationScore * activationWeight + verificationScore * verificationWeight
          );
          const healthMetrics = {
            userId,
            photoScore,
            bioScore,
            fieldCompletionScore,
            activationScore,
            verificationScore,
            overallHealthScore
          };
          console.log(`[PROFILE-HEALTH] User ${userId} health metrics: overall ${overallHealthScore}/100 (photo: ${photoScore}, bio: ${bioScore}, fields: ${fieldCompletionScore}, active: ${activationScore}, verified: ${verificationScore})`);
          return healthMetrics;
        } catch (error) {
          console.error(`[PROFILE-HEALTH] Error calculating health metrics for user ${userId}:`, error);
          return {
            userId,
            photoScore: 50,
            bioScore: 50,
            fieldCompletionScore: 50,
            activationScore: 50,
            verificationScore: 0,
            overallHealthScore: 40
          };
        }
      }
      /**
       * Calculate Photo Quality Score (0-100)
       * Based on photo count, primary photo setup, and recency
       */
      calculatePhotoQualityScore(userPhotos2) {
        let score = 0;
        const photoCount = userPhotos2.length;
        if (photoCount === 0) return 0;
        score += 40;
        if (photoCount > 1) score += 30;
        const hasPrimaryPhoto = userPhotos2.some((p) => p.is_primary_for_meet);
        if (hasPrimaryPhoto) score += 20;
        if (photoCount > 2) score += 10;
        return Math.min(100, score);
      }
      /**
       * Calculate Bio Completeness Score (0-100)
       * Based on bio length, word count, and content quality
       */
      calculateBioCompletenessScore(bio) {
        if (!bio) return 0;
        let score = 0;
        const bioLength = bio.length;
        const wordCount = bio.split(/\s+/).filter((word) => word.length > 0).length;
        if (bioLength > 0) score += 20;
        if (bioLength >= 50) score += 30;
        if (bioLength >= 100) score += 20;
        if (bioLength >= 200) score += 10;
        if (wordCount >= 10) score += 20;
        return Math.min(100, score);
      }
      /**
       * Calculate Field Completion Score (0-100)
       * Based on completion of core profile fields
       */
      calculateFieldCompletionScore(user) {
        const coreFields = [
          user.bio,
          user.profession,
          user.ethnicity,
          user.religion,
          user.photo_url,
          user.date_of_birth,
          user.relationship_goal,
          user.high_school,
          user.college_university,
          user.interests
        ];
        const completedFields = coreFields.filter(
          (field) => field && field.toString().trim().length > 0
        );
        return Math.round(completedFields.length / coreFields.length * 100);
      }
      // ===============================
      // RECIPROCITY & ENGAGEMENT SCORING
      // ===============================
      /**
       * MUTUAL INTEREST INDICATOR 1: Historical Response Rates
       * Calculate response rate between two users based on message history
       */
      async calculateHistoricalResponseRate(userId, targetUserId) {
        try {
          console.log(`[RECIPROCITY] Calculating response rate: ${userId} \u2194 ${targetUserId}`);
          const responseAnalysis = await sql3`
        WITH conversation_threads AS (
          SELECT 
            sender_id,
            receiver_id,
            created_at,
            LAG(sender_id) OVER (ORDER BY created_at) as previous_sender,
            EXTRACT(EPOCH FROM (created_at - LAG(created_at) OVER (ORDER BY created_at)))/3600 as response_time_hours
          FROM messages
          WHERE (sender_id = ${userId} AND receiver_id = ${targetUserId})
             OR (sender_id = ${targetUserId} AND receiver_id = ${userId})
          ORDER BY created_at
        )
        SELECT 
          COUNT(*) as total_messages,
          COUNT(CASE WHEN previous_sender IS NOT NULL AND previous_sender != sender_id THEN 1 END) as responses,
          AVG(CASE WHEN previous_sender IS NOT NULL AND previous_sender != sender_id THEN response_time_hours END) as avg_response_time_hours
        FROM conversation_threads
        WHERE previous_sender IS NOT NULL
      `;
          if (responseAnalysis.length === 0 || responseAnalysis[0].total_messages === 0) {
            console.log(`[RECIPROCITY] No message history between users ${userId} and ${targetUserId}`);
            return 0.5;
          }
          const data = responseAnalysis[0];
          const responses = Number(data.responses) || 0;
          const totalMessages = Number(data.total_messages) || 1;
          const avgResponseTime = Number(data.avg_response_time_hours) || 24;
          const responseRate = responses / totalMessages;
          let timeBonus = 1;
          if (avgResponseTime <= 1) timeBonus = 1.2;
          else if (avgResponseTime <= 6) timeBonus = 1.1;
          else if (avgResponseTime <= 24) timeBonus = 1;
          else timeBonus = 0.8;
          const finalScore = Math.min(1, responseRate * timeBonus);
          console.log(`[RECIPROCITY] Response rate ${userId} \u2194 ${targetUserId}: ${(responseRate * 100).toFixed(1)}% (avg time: ${avgResponseTime.toFixed(1)}h, score: ${finalScore.toFixed(3)})`);
          return finalScore;
        } catch (error) {
          console.error("[RECIPROCITY] Error calculating response rate:", error);
          return 0.5;
        }
      }
      /**
       * MUTUAL INTEREST INDICATOR 2: Message Engagement Quality
       * Analyze message quality and conversation depth between users
       */
      async calculateMessageEngagementQuality(userId, targetUserId) {
        try {
          console.log(`[ENGAGEMENT] Calculating message engagement: ${userId} \u2194 ${targetUserId}`);
          const engagementAnalysis = await sql3`
        SELECT 
          COUNT(*) as total_messages,
          AVG(LENGTH(content)) as avg_message_length,
          COUNT(CASE WHEN LENGTH(content) > 50 THEN 1 END) as substantial_messages,
          COUNT(CASE WHEN content LIKE '%?%' THEN 1 END) as question_messages,
          COUNT(CASE WHEN content LIKE '%!%' THEN 1 END) as enthusiastic_messages,
          COUNT(DISTINCT DATE(created_at)) as conversation_days,
          MAX(created_at) - MIN(created_at) as conversation_span
        FROM messages
        WHERE ((sender_id = ${userId} AND receiver_id = ${targetUserId})
           OR (sender_id = ${targetUserId} AND receiver_id = ${userId}))
        AND content IS NOT NULL AND content != ''
      `;
          if (engagementAnalysis.length === 0 || engagementAnalysis[0].total_messages === 0) {
            console.log(`[ENGAGEMENT] No messages between users ${userId} and ${targetUserId}`);
            return 0.5;
          }
          const data = engagementAnalysis[0];
          const totalMessages = Number(data.total_messages) || 0;
          const avgLength = Number(data.avg_message_length) || 0;
          const substantialMessages = Number(data.substantial_messages) || 0;
          const questionMessages = Number(data.question_messages) || 0;
          const enthusiasticMessages = Number(data.enthusiastic_messages) || 0;
          const lengthScore = Math.min(1, avgLength / 100);
          const substantialRate = totalMessages > 0 ? substantialMessages / totalMessages : 0;
          const questionRate = totalMessages > 0 ? questionMessages / totalMessages : 0;
          const enthusiasmRate = totalMessages > 0 ? enthusiasticMessages / totalMessages : 0;
          const engagementScore = lengthScore * 0.3 + // 30% - Average message length
          substantialRate * 0.3 + // 30% - Substantial content rate
          questionRate * 0.2 + // 20% - Question asking rate
          enthusiasmRate * 0.2;
          console.log(`[ENGAGEMENT] Message quality ${userId} \u2194 ${targetUserId}: ${totalMessages} msgs, ${avgLength.toFixed(0)} avg chars, quality: ${engagementScore.toFixed(3)}`);
          return Math.min(1, engagementScore);
        } catch (error) {
          console.error("[ENGAGEMENT] Error calculating engagement quality:", error);
          return 0.5;
        }
      }
      /**
       * MUTUAL INTEREST INDICATOR 3: Profile View Frequency
       * Track how often users view each other's profiles (using swipe_history as proxy)
       */
      async calculateProfileViewFrequency(userId, targetUserId) {
        try {
          console.log(`[PROFILE-VIEWS] Calculating view frequency: ${userId} \u2192 ${targetUserId}`);
          const profileViewsExists = await sql3`
        SELECT EXISTS (
          SELECT FROM information_schema.tables 
          WHERE table_schema = 'public' AND table_name = 'profile_views'
        )
      `;
          if (profileViewsExists[0]?.exists) {
            const viewData = await sql3`
          SELECT 
            view_count,
            last_viewed_at,
            EXTRACT(EPOCH FROM (NOW() - last_viewed_at))/86400 as days_since_view
          FROM profile_views
          WHERE viewer_id = ${userId} AND viewed_id = ${targetUserId}
        `;
            if (viewData.length > 0) {
              const views = Number(viewData[0].view_count) || 0;
              const daysSinceView = Number(viewData[0].days_since_view) || 365;
              const viewCountScore = Math.min(1, views / 10);
              const recencyBonus2 = Math.max(0.1, Math.exp(-daysSinceView / 30));
              const viewScore = viewCountScore * recencyBonus2;
              console.log(`[PROFILE-VIEWS] Direct views ${userId} \u2192 ${targetUserId}: ${views} views, ${daysSinceView.toFixed(1)} days ago, score: ${viewScore.toFixed(3)}`);
              return viewScore;
            }
          }
          const swipeInteractions = await sql3`
        SELECT 
          COUNT(*) as total_interactions,
          MAX(timestamp) as last_interaction,
          array_agg(action) as actions,
          EXTRACT(EPOCH FROM (NOW() - MAX(timestamp)))/86400 as days_since_interaction
        FROM swipe_history
        WHERE user_id = ${userId} AND target_user_id = ${targetUserId}
      `;
          if (swipeInteractions.length === 0 || swipeInteractions[0].total_interactions === 0) {
            console.log(`[PROFILE-VIEWS] No interactions between ${userId} \u2192 ${targetUserId}`);
            return 0.1;
          }
          const data = swipeInteractions[0];
          const interactions = Number(data.total_interactions) || 0;
          const daysSinceInteraction = Number(data.days_since_interaction) || 365;
          const interactionScore = Math.min(0.8, interactions / 5);
          const recencyBonus = Math.max(0.1, Math.exp(-daysSinceInteraction / 14));
          const proxyScore = interactionScore * recencyBonus;
          console.log(`[PROFILE-VIEWS] Proxy views ${userId} \u2192 ${targetUserId}: ${interactions} interactions, ${daysSinceInteraction.toFixed(1)} days ago, score: ${proxyScore.toFixed(3)}`);
          return proxyScore;
        } catch (error) {
          console.error("[PROFILE-VIEWS] Error calculating view frequency:", error);
          return 0.3;
        }
      }
      /**
       * MUTUAL INTEREST INDICATOR 4: Star/Like Probability Based on Profile Similarity
       * Predict likelihood of positive action based on profile similarity patterns
       */
      async calculateStarLikeProbability(userId, targetUserId) {
        try {
          console.log(`[LIKE-PROBABILITY] Calculating like probability: ${userId} \u2192 ${targetUserId}`);
          const userProfiles = await sql3`
        SELECT 
          id,
          ethnicity,
          religion,
          profession,
          relationship_goal,
          EXTRACT(YEAR FROM AGE(date_of_birth)) as age,
          location
        FROM users
        WHERE id IN (${userId}, ${targetUserId})
      `;
          if (userProfiles.length < 2) {
            console.log(`[LIKE-PROBABILITY] Missing user profiles for ${userId} or ${targetUserId}`);
            return 0.5;
          }
          const userProfile = userProfiles.find((u) => u.id === userId);
          const targetProfile = userProfiles.find((u) => u.id === targetUserId);
          const similarityPatterns = await sql3`
        WITH user_similarities AS (
          SELECT 
            sh.user_id,
            sh.action,
            u1.ethnicity = u2.ethnicity as same_ethnicity,
            u1.religion = u2.religion as same_religion,
            u1.profession = u2.profession as same_profession,
            u1.relationship_goal = u2.relationship_goal as same_goal,
            ABS(EXTRACT(YEAR FROM AGE(u1.date_of_birth)) - EXTRACT(YEAR FROM AGE(u2.date_of_birth))) <= 5 as similar_age,
            u1.location = u2.location as same_location
          FROM swipe_history sh
          JOIN users u1 ON sh.user_id = u1.id
          JOIN users u2 ON sh.target_user_id = u2.id
        )
        SELECT 
          action,
          COUNT(*) as total_actions,
          AVG(CASE WHEN same_ethnicity THEN 1.0 ELSE 0.0 END) as ethnicity_like_rate,
          AVG(CASE WHEN same_religion THEN 1.0 ELSE 0.0 END) as religion_like_rate,
          AVG(CASE WHEN same_profession THEN 1.0 ELSE 0.0 END) as profession_like_rate,
          AVG(CASE WHEN same_goal THEN 1.0 ELSE 0.0 END) as goal_like_rate,
          AVG(CASE WHEN similar_age THEN 1.0 ELSE 0.0 END) as age_like_rate,
          AVG(CASE WHEN same_location THEN 1.0 ELSE 0.0 END) as location_like_rate
        FROM user_similarities
        GROUP BY action
      `;
          const similarityFactors = {
            sameEthnicity: userProfile.ethnicity === targetProfile.ethnicity,
            sameReligion: userProfile.religion === targetProfile.religion,
            sameProfession: userProfile.profession === targetProfile.profession,
            sameGoal: userProfile.relationship_goal === targetProfile.relationship_goal,
            similarAge: Math.abs((userProfile.age || 0) - (targetProfile.age || 0)) <= 5,
            sameLocation: userProfile.location === targetProfile.location
          };
          let probability = 0.5;
          if (similarityPatterns.length > 0) {
            const likePattern = similarityPatterns.find((p) => p.action === "like" || p.action === "star");
            if (likePattern) {
              let probabilityBoost = 0;
              if (similarityFactors.sameEthnicity) probabilityBoost += Number(likePattern.ethnicity_like_rate) * 0.2;
              if (similarityFactors.sameReligion) probabilityBoost += Number(likePattern.religion_like_rate) * 0.15;
              if (similarityFactors.sameProfession) probabilityBoost += Number(likePattern.profession_like_rate) * 0.15;
              if (similarityFactors.sameGoal) probabilityBoost += Number(likePattern.goal_like_rate) * 0.2;
              if (similarityFactors.similarAge) probabilityBoost += Number(likePattern.age_like_rate) * 0.15;
              if (similarityFactors.sameLocation) probabilityBoost += Number(likePattern.location_like_rate) * 0.15;
              probability = Math.min(1, 0.3 + probabilityBoost);
            }
          }
          console.log(`[LIKE-PROBABILITY] Probability ${userId} \u2192 ${targetUserId}: ${probability.toFixed(3)} (ethnicity: ${similarityFactors.sameEthnicity}, age: ${similarityFactors.similarAge})`);
          return probability;
        } catch (error) {
          console.error("[LIKE-PROBABILITY] Error calculating like probability:", error);
          return 0.5;
        }
      }
      /**
       * Calculate Complete Reciprocity & Engagement Profile
       * Combines all 4 Mutual Interest Indicators into comprehensive scoring
       */
      async calculateReciprocityEngagementProfile(userId, targetUserId) {
        try {
          console.log(`[RECIPROCITY-ENGAGEMENT] Calculating full profile: ${userId} \u2194 ${targetUserId}`);
          const [responseRate, engagementQuality, viewFrequency, likeProbability] = await Promise.all([
            this.calculateHistoricalResponseRate(userId, targetUserId),
            this.calculateMessageEngagementQuality(userId, targetUserId),
            this.calculateProfileViewFrequency(userId, targetUserId),
            this.calculateStarLikeProbability(userId, targetUserId)
          ]);
          const responseWeight = 0.3;
          const engagementWeight = 0.25;
          const viewWeight = 0.2;
          const probabilityWeight = 0.25;
          const safeResponseRate = isNaN(responseRate) ? 0.5 : responseRate;
          const safeEngagementQuality = isNaN(engagementQuality) ? 0.5 : engagementQuality;
          const safeViewFrequency = isNaN(viewFrequency) ? 0.3 : viewFrequency;
          const safeLikeProbability = isNaN(likeProbability) ? 0.5 : likeProbability;
          const overallScore = safeResponseRate * responseWeight + safeEngagementQuality * engagementWeight + safeViewFrequency * viewWeight + safeLikeProbability * probabilityWeight;
          const profile = {
            userId,
            targetUserId,
            historicalResponseRate: safeResponseRate,
            messageEngagementQuality: safeEngagementQuality,
            profileViewFrequency: safeViewFrequency,
            starLikeProbability: safeLikeProbability,
            overallReciprocityScore: Math.min(1, overallScore)
          };
          console.log(`[RECIPROCITY-ENGAGEMENT] Overall score ${userId} \u2194 ${targetUserId}: ${profile.overallReciprocityScore.toFixed(3)} (response: ${responseRate.toFixed(2)}, engagement: ${engagementQuality.toFixed(2)}, views: ${viewFrequency.toFixed(2)}, probability: ${likeProbability.toFixed(2)})`);
          return profile;
        } catch (error) {
          console.error("[RECIPROCITY-ENGAGEMENT] Error calculating reciprocity profile:", error);
          return {
            userId,
            targetUserId,
            historicalResponseRate: 0.5,
            messageEngagementQuality: 0.5,
            profileViewFrequency: 0.3,
            starLikeProbability: 0.5,
            overallReciprocityScore: 0.45
          };
        }
      }
      /**
       * Check Implementation Readiness for Mutual Interest Indicators
       * Audit which indicators have sufficient data for implementation
       */
      async checkMutualInterestReadiness() {
        try {
          console.log("[READINESS-CHECK] Auditing Mutual Interest Indicators implementation readiness");
          const [messagesCount, swipeCount, profileViewsExists] = await Promise.all([
            sql3`SELECT COUNT(*) as count FROM messages`,
            sql3`SELECT COUNT(*) as count FROM swipe_history`,
            sql3`SELECT EXISTS (SELECT FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'profile_views')`
          ]);
          const hasMessages = Number(messagesCount[0].count) > 0;
          const hasSwipes = Number(swipeCount[0].count) > 0;
          const hasProfileViews = profileViewsExists[0]?.exists || false;
          const indicators = {
            responseRateReady: hasMessages,
            engagementQualityReady: hasMessages,
            profileViewReady: hasProfileViews || hasSwipes,
            // Swipes as fallback
            likeProbabilityReady: hasSwipes,
            implementationStatus: "NOT_READY"
          };
          const readyCount = [
            indicators.responseRateReady,
            indicators.engagementQualityReady,
            indicators.profileViewReady,
            indicators.likeProbabilityReady
          ].filter(Boolean).length;
          if (readyCount >= 3) indicators.implementationStatus = "READY";
          else if (readyCount >= 2) indicators.implementationStatus = "PARTIAL";
          else indicators.implementationStatus = "NOT_READY";
          console.log(`[READINESS-CHECK] Status: ${indicators.implementationStatus} (${readyCount}/4 ready) - Messages: ${hasMessages}, Swipes: ${hasSwipes}, Views: ${hasProfileViews}`);
          return indicators;
        } catch (error) {
          console.error("[READINESS-CHECK] Error checking readiness:", error);
          return {
            responseRateReady: false,
            engagementQualityReady: false,
            profileViewReady: false,
            likeProbabilityReady: false,
            implementationStatus: "NOT_READY"
          };
        }
      }
      // ===============================
      // COMPREHENSIVE CONTEXT SCORING
      // ===============================
      /**
       * CONTEXT-AWARE RE-RANKING: COMPREHENSIVE CONTEXT SCORING
       * Combines all 4 context components for final Context-Aware Re-ranking score
       * Used by hybrid matching engine for 25% weight in final algorithm
       */
      async calculateComprehensiveContextScore(userId, targetUserId) {
        try {
          console.log(`[COMPREHENSIVE-CONTEXT] Calculating context score: ${userId} \u2192 ${targetUserId}`);
          const [userProfile, targetProfile] = await Promise.all([
            sql3`SELECT * FROM users WHERE id = ${userId}`.then((r) => r[0] || null),
            sql3`SELECT * FROM users WHERE id = ${targetUserId}`.then((r) => r[0] || null)
          ]);
          if (!userProfile || !targetProfile) {
            console.log(`[COMPREHENSIVE-CONTEXT] Missing user profiles: ${userId}=${!!userProfile}, ${targetUserId}=${!!targetProfile}`);
            return {
              overallContextScore: 0.5,
              temporalScore: 0.5,
              geographicScore: 0.5,
              profileHealthScore: 0.5,
              reciprocityScore: 0.5,
              breakdown: { error: "Missing user profiles" }
            };
          }
          const [
            temporalProfile,
            geographicFactors,
            profileHealth,
            reciprocityProfile
          ] = await Promise.all([
            // 1. Temporal Context Factors (25% weight)
            this.calculateTemporalContextProfile(targetUserId).catch(() => ({
              activityPatternScore: 0.5,
              lastActiveScore: 50,
              profileFreshnessScore: 50,
              isOnline: false
            })),
            // 2. Geographic Context Factors (25% weight) 
            this.calculateGeographicContextFactors(userProfile, targetProfile).catch(() => ({
              overallCompatibility: 0.5
            })),
            // 3. Profile Health Metrics (25% weight)
            this.calculateProfileHealthMetrics(targetUserId).catch(() => ({
              overallHealthScore: 50
            })),
            // 4. Reciprocity & Engagement Scoring (25% weight)
            this.calculateReciprocityEngagementProfile(userId, targetUserId).catch(() => ({
              overallReciprocityScore: 0.5
            }))
          ]);
          const temporalScore = temporalProfile.activityPatternScore || 0.5;
          const geographicScore = geographicFactors.overallCompatibility || 0.5;
          const profileHealthScore = (profileHealth.overallHealthScore || 50) / 100;
          const reciprocityScore = reciprocityProfile.overallReciprocityScore || 0.5;
          const overallContextScore = temporalScore * 0.25 + geographicScore * 0.25 + profileHealthScore * 0.25 + reciprocityScore * 0.25;
          const breakdown = {
            temporal: {
              score: temporalScore,
              weight: 0.25,
              contribution: temporalScore * 0.25,
              details: {
                activity: temporalProfile.activityPatternScore,
                lastActive: temporalProfile.lastActiveScore,
                freshness: temporalProfile.profileFreshnessScore,
                isOnline: temporalProfile.isOnline
              }
            },
            geographic: {
              score: geographicScore,
              weight: 0.25,
              contribution: geographicScore * 0.25,
              details: geographicFactors
            },
            profileHealth: {
              score: profileHealthScore,
              weight: 0.25,
              contribution: profileHealthScore * 0.25,
              details: profileHealth
            },
            reciprocity: {
              score: reciprocityScore,
              weight: 0.25,
              contribution: reciprocityScore * 0.25,
              details: reciprocityProfile
            }
          };
          console.log(`[COMPREHENSIVE-CONTEXT] ${userId} \u2192 ${targetUserId}: Overall=${overallContextScore.toFixed(3)} (T:${temporalScore.toFixed(2)}, G:${geographicScore.toFixed(2)}, P:${profileHealthScore.toFixed(2)}, R:${reciprocityScore.toFixed(2)})`);
          return {
            overallContextScore,
            temporalScore,
            geographicScore,
            profileHealthScore,
            reciprocityScore,
            breakdown
          };
        } catch (error) {
          console.error("[COMPREHENSIVE-CONTEXT] Error calculating comprehensive context score:", error);
          return {
            overallContextScore: 0.5,
            temporalScore: 0.5,
            geographicScore: 0.5,
            profileHealthScore: 0.5,
            reciprocityScore: 0.5,
            breakdown: { error: error.message }
          };
        }
      }
    };
    userBehaviorPatterns = new UserBehaviorPatterns();
  }
});

// server/matching-engine.ts
var MatchingEngine, matchingEngine;
var init_matching_engine = __esm({
  "server/matching-engine.ts"() {
    "use strict";
    init_storage();
    init_advanced_matching_algorithms();
    init_matrix_factorization();
    init_hard_filters();
    MatchingEngine = class _MatchingEngine {
      // Configurable weights for hybrid scoring
      static CONTENT_WEIGHT = 0.4;
      static COLLABORATIVE_WEIGHT = 0.35;
      static CONTEXT_WEIGHT = 0.25;
      matrixFactorizationInitialized = false;
      /**
       * Main entry point: Get ranked discovery results with advanced algorithms
       */
      async getRankedDiscovery(userId, context, limit = 50) {
        console.log(`[MATCHING-ENGINE] Starting ranked discovery for user ${userId} in ${context.mode} mode`);
        try {
          const [user, preferences] = await Promise.all([
            storage.getUser(userId),
            storage.getUserPreferences(userId)
          ]);
          if (!user) {
            console.error(`[MATCHING-ENGINE] User ${userId} not found`);
            return [];
          }
          const allCandidates = await this.getCandidatePool(userId, context.mode);
          if (allCandidates.length === 0) {
            console.log(`[MATCHING-ENGINE] No potential users found for ${userId}`);
            return [];
          }
          console.log(`[MATCHING-ENGINE] \u{1F512} Applying hard filters before matching algorithm`);
          const filteredCandidates = await hardFiltersEngine.applyHardFilters(
            allCandidates,
            user,
            preferences || null
          );
          if (filteredCandidates.length === 0) {
            console.log(`[MATCHING-ENGINE] \u274C No candidates passed hard filters for user ${userId}`);
            return [];
          }
          console.log(`[MATCHING-ENGINE] \u2705 ${filteredCandidates.length}/${allCandidates.length} candidates passed hard filters (${(filteredCandidates.length / allCandidates.length * 100).toFixed(1)}%)`);
          const potentialUsers = filteredCandidates;
          const scoredUsers = await this.calculateAdvancedHybridScores(
            user,
            preferences || null,
            potentialUsers,
            context
          );
          const diverseScores = advancedMatchingEngine.injectDemographicDiversity(
            scoredUsers.sort((a, b) => b.finalScore - a.finalScore),
            potentialUsers,
            user,
            // Current user for demographic analysis
            preferences || null,
            // User preferences for age range expansion
            0.15
            // 15% diversity injection
          );
          const rankedUsers = diverseScores.slice(0, limit).map((score) => potentialUsers.find((u) => u.id === score.userId)).filter(Boolean);
          console.log(`[MATCHING-ENGINE] Ranked ${rankedUsers.length} users for ${userId}`);
          if (scoredUsers.length > 0) {
            const topMatches = scoredUsers.slice(0, 3);
            console.log(`[MATCHING-ENGINE] Top matches:`, topMatches.map((m) => ({
              userId: m.userId,
              score: m.finalScore.toFixed(3),
              content: m.contentScore.toFixed(3),
              collaborative: m.collaborativeScore.toFixed(3),
              context: m.contextScore.toFixed(3)
            })));
          }
          return rankedUsers;
        } catch (error) {
          console.error(`[MATCHING-ENGINE] Error in getRankedDiscovery:`, error);
          return this.getCandidatePool(userId, context.mode);
        }
      }
      /**
       * Get candidate pool using existing discovery logic
       */
      async getCandidatePool(userId, mode) {
        try {
          switch (mode) {
            case "meet":
            case "heat":
              return await storage.getDiscoverUsers(userId);
            case "suite":
              return await storage.getDiscoverUsers(userId);
            default:
              return await storage.getDiscoverUsers(userId);
          }
        } catch (error) {
          console.error(`[MATCHING-ENGINE] Error getting candidate pool:`, error);
          return [];
        }
      }
      /**
       * Calculate advanced hybrid scores for all candidates using sophisticated algorithms
       * PERFORMANCE OPTIMIZED: Batch operations to eliminate N+1 query problem
       */
      async calculateAdvancedHybridScores(user, preferences, candidates, context) {
        const startTime = Date.now();
        console.log(`[PERFORMANCE] Starting batch scoring for ${candidates.length} candidates`);
        const candidateIds = candidates.map((c) => c.id);
        const allCandidatePreferences = await this.batchGetUserPreferences(candidateIds);
        const userInteractions = await this.getUserInteractionPattern(user.id);
        const contextCalculations = candidates.map(
          (candidate) => this.calculateEnhancedContextScore(user.id, candidate, context)
        );
        const allContextResults = await Promise.all(contextCalculations);
        const scores = [];
        const batchTime = Date.now() - startTime;
        console.log(`[PERFORMANCE] Batch operations completed in ${batchTime}ms`);
        for (let i = 0; i < candidates.length; i++) {
          const candidate = candidates[i];
          try {
            const candidatePreferences = allCandidatePreferences.get(candidate.id);
            const contentResult = advancedMatchingEngine.calculateAdvancedContentScore(user, candidate, preferences, candidatePreferences);
            const collaborativeScore = await this.calculateCollaborativeScore(user, candidate, userInteractions);
            const contextResult = allContextResults[i];
            const diversityBonus = 0;
            const finalScore = contentResult.score * _MatchingEngine.CONTENT_WEIGHT + collaborativeScore * _MatchingEngine.COLLABORATIVE_WEIGHT + contextResult.score * _MatchingEngine.CONTEXT_WEIGHT;
            const reasons = [
              ...this.generateMatchReasons(contentResult.score, collaborativeScore, contextResult.score),
              `Content: ${contentResult.details.cosine?.toFixed(2)} cosine, ${contentResult.details.jaccard?.toFixed(2)} jaccard`,
              `Context: Temporal=${contextResult.details.temporal?.toFixed(2)}, Geographic=${contextResult.details.geographic?.toFixed(2)}, Profile=${contextResult.details.profileHealth?.toFixed(2)}, Reciprocity=${contextResult.details.reciprocity?.toFixed(2)}`
            ];
            scores.push({
              userId: candidate.id,
              contentScore: contentResult.score,
              collaborativeScore,
              contextScore: contextResult.score,
              diversityBonus,
              reciprocityScore: contextResult.details.reciprocity || 0.5,
              finalScore,
              algorithmVersion: "advanced-v1.0",
              reasons
            });
          } catch (error) {
            console.error(`[ADVANCED-MATCHING] Error scoring candidate ${candidate.id}:`, error);
            scores.push({
              userId: candidate.id,
              contentScore: 0.1,
              collaborativeScore: 0.1,
              contextScore: 0.1,
              diversityBonus: 0,
              reciprocityScore: 0.1,
              finalScore: 0.1,
              algorithmVersion: "fallback-v1.0",
              reasons: ["Basic compatibility (error in advanced scoring)"]
            });
          }
        }
        const totalTime = Date.now() - startTime;
        console.log(`[PERFORMANCE] \u26A1 COMPLETED: Scored ${candidates.length} candidates in ${totalTime}ms (vs previous ~${candidates.length * 200}ms)`);
        return scores;
      }
      /**
       *  PERFORMANCE OPTIMIZATION: Batch load user preferences in single query
       */
      async batchGetUserPreferences(userIds) {
        const preferences = /* @__PURE__ */ new Map();
        if (userIds.length === 0) return preferences;
        try {
          const startTime = Date.now();
          const allPreferences = await storage.batchGetUserPreferences(userIds);
          userIds.forEach((id) => preferences.set(id, null));
          allPreferences.forEach((pref) => {
            preferences.set(pref.userId, pref);
          });
          const duration = Date.now() - startTime;
          console.log(`[PERFORMANCE] Batch loaded ${allPreferences.length}/${userIds.length} preferences in ${duration}ms`);
          return preferences;
        } catch (error) {
          console.error(`[PERFORMANCE] Error batch loading preferences:`, error);
          userIds.forEach((id) => preferences.set(id, null));
          return preferences;
        }
      }
      /**
       * Calculate hybrid scores for all candidates (legacy method for backward compatibility)
       */
      async calculateHybridScores(user, preferences, candidates, context) {
        const scores = [];
        const userInteractions = await this.getUserInteractionPattern(user.id);
        for (const candidate of candidates) {
          try {
            const contentScore = this.calculateContentScore(user, candidate, preferences);
            const collaborativeScore = await this.calculateCollaborativeScore(user, candidate, userInteractions);
            const contextScore = this.calculateContextScore(candidate, context);
            const finalScore = contentScore * _MatchingEngine.CONTENT_WEIGHT + collaborativeScore * _MatchingEngine.COLLABORATIVE_WEIGHT + contextScore * _MatchingEngine.CONTEXT_WEIGHT;
            const reasons = this.generateMatchReasons(contentScore, collaborativeScore, contextScore);
            scores.push({
              userId: candidate.id,
              contentScore,
              collaborativeScore,
              contextScore,
              finalScore,
              reasons
            });
          } catch (error) {
            console.error(`[MATCHING-ENGINE] Error scoring candidate ${candidate.id}:`, error);
            scores.push({
              userId: candidate.id,
              contentScore: 0.1,
              collaborativeScore: 0.1,
              contextScore: 0.1,
              finalScore: 0.1,
              reasons: ["Basic compatibility"]
            });
          }
        }
        return scores;
      }
      /**
       * Content-Based Filtering: Profile and preference matching
       */
      calculateContentScore(user, candidate, preferences) {
        let score = 0;
        let factors = 0;
        try {
          if (preferences?.minAge && preferences?.maxAge && candidate.dateOfBirth) {
            const candidateAge = this.calculateAge(candidate.dateOfBirth);
            if (candidateAge >= preferences.minAge && candidateAge <= preferences.maxAge) {
              score += 0.25;
            }
            factors++;
          }
          if (preferences?.locationPreference && candidate.location) {
            if (preferences.locationPreference === "Both" || preferences.locationPreference === candidate.location) {
              score += 0.2;
            }
            factors++;
          }
          if (preferences?.religionPreference && candidate.religion) {
            const religionPrefs = this.parseJsonArray(preferences.religionPreference);
            if (religionPrefs.includes(candidate.religion)) {
              score += 0.2;
            }
            factors++;
          }
          if (preferences?.ethnicityPreference && candidate.ethnicity) {
            const ethnicityPrefs = this.parseJsonArray(preferences.ethnicityPreference);
            if (ethnicityPrefs.includes(candidate.ethnicity)) {
              score += 0.15;
            }
            factors++;
          }
          if (user.interests && candidate.interests) {
            const userInterests3 = this.parseJsonArray(user.interests);
            const candidateInterests = this.parseJsonArray(candidate.interests);
            const similarity = this.calculateInterestSimilarity(userInterests3, candidateInterests);
            score += similarity * 0.2;
            factors++;
          }
          return factors > 0 ? score / factors : 0.1;
        } catch (error) {
          console.error(`[MATCHING-ENGINE] Error in content scoring:`, error);
          return 0.1;
        }
      }
      /**
       * Collaborative Filtering: Enhanced with Matrix Factorization
       */
      async calculateCollaborativeScore(user, candidate, userInteractions) {
        try {
          if (!this.matrixFactorizationInitialized) {
            console.log("[MATCHING-ENGINE] Initializing Matrix Factorization model...");
            await matrixFactorization.trainModel();
            this.matrixFactorizationInitialized = true;
          }
          const matrixScore = matrixFactorization.getCollaborativeScore(user.id, candidate.id);
          const traditionalScore = await this.calculateTraditionalCollaborativeScore(user, candidate, userInteractions);
          const blendedScore = matrixScore * 0.7 + traditionalScore * 0.3;
          console.log(`[COLLABORATIVE-FILTERING] User ${user.id} \u2192 User ${candidate.id}: Matrix=${matrixScore.toFixed(3)}, Traditional=${traditionalScore.toFixed(3)}, Blended=${blendedScore.toFixed(3)}`);
          return Math.max(0, Math.min(1, blendedScore));
        } catch (error) {
          console.error(`[MATCHING-ENGINE] Error in collaborative scoring:`, error);
          return 0.5;
        }
      }
      /**
       * Traditional collaborative filtering as fallback/enhancement
       */
      async calculateTraditionalCollaborativeScore(user, candidate, userInteractions) {
        try {
          const similarUsers = await this.findSimilarUsers(user.id, userInteractions);
          if (similarUsers.length === 0) {
            return 0.5;
          }
          let positiveVotes = 0;
          let totalVotes = 0;
          for (const similarUserId of similarUsers) {
            const interactions = await this.getUserInteractionPattern(similarUserId);
            if (interactions.likedUsers.includes(candidate.id)) {
              positiveVotes++;
            }
            if (interactions.likedUsers.includes(candidate.id) || interactions.dislikedUsers.includes(candidate.id)) {
              totalVotes++;
            }
          }
          if (totalVotes === 0) {
            return 0.5;
          }
          return positiveVotes / totalVotes;
        } catch (error) {
          console.error(`[MATCHING-ENGINE] Error in traditional collaborative scoring:`, error);
          return 0.5;
        }
      }
      /**
       * Context-Aware Re-ranking: Real-time adjustments with comprehensive Reciprocity & Engagement scoring
       */
      async calculateEnhancedContextScore(currentUserId, candidate, context) {
        try {
          const { userBehaviorPatterns: userBehaviorPatterns2 } = await Promise.resolve().then(() => (init_user_behavior_patterns(), user_behavior_patterns_exports));
          const contextAnalysis = await userBehaviorPatterns2.calculateComprehensiveContextScore(
            currentUserId,
            candidate.id
          );
          return {
            score: contextAnalysis.overallContextScore,
            details: {
              temporal: contextAnalysis.temporalScore,
              geographic: contextAnalysis.geographicScore,
              profileHealth: contextAnalysis.profileHealthScore,
              reciprocity: contextAnalysis.reciprocityScore,
              activity: candidate.isOnline || false,
              breakdown: contextAnalysis.breakdown
            }
          };
        } catch (error) {
          console.error(`[CONTEXT-SCORING] Error in enhanced context scoring for ${candidate.id}:`, error);
          return {
            score: this.calculateBasicContextScore(candidate, context),
            details: { fallback: true, activity: candidate.isOnline }
          };
        }
      }
      /**
       * Basic Context-Aware Re-ranking fallback method
       */
      calculateBasicContextScore(candidate, context) {
        let score = 0.5;
        try {
          if (candidate.lastActive) {
            const minutesSinceActive = (context.currentTime.getTime() - candidate.lastActive.getTime()) / (1e3 * 60);
            if (minutesSinceActive <= context.lastActiveThreshold) {
              score += 0.3;
            } else if (minutesSinceActive <= context.lastActiveThreshold * 2) {
              score += 0.15;
            }
          }
          if (candidate.isOnline) {
            score += 0.2;
          }
          const completeness = this.calculateProfileCompleteness(candidate);
          score += completeness * 0.3;
          return Math.min(score, 1);
        } catch (error) {
          console.error(`[MATCHING-ENGINE] Error in basic context scoring:`, error);
          return 0.5;
        }
      }
      /**
       * Legacy context scoring method (kept for backward compatibility)
       */
      calculateContextScore(candidate, context) {
        return this.calculateBasicContextScore(candidate, context);
      }
      /**
       * Helper methods
       */
      calculateAge(dateOfBirth) {
        const today = /* @__PURE__ */ new Date();
        let age = today.getFullYear() - dateOfBirth.getFullYear();
        const monthDiff = today.getMonth() - dateOfBirth.getMonth();
        if (monthDiff < 0 || monthDiff === 0 && today.getDate() < dateOfBirth.getDate()) {
          age--;
        }
        return age;
      }
      parseJsonArray(jsonString) {
        try {
          const parsed = JSON.parse(jsonString);
          return Array.isArray(parsed) ? parsed : [parsed];
        } catch {
          return [];
        }
      }
      calculateInterestSimilarity(interests1, interests2) {
        if (interests1.length === 0 || interests2.length === 0) return 0;
        const set1 = new Set(interests1.map((i) => i.toLowerCase()));
        const set2 = new Set(interests2.map((i) => i.toLowerCase()));
        const intersection = new Set([...set1].filter((x) => set2.has(x)));
        const union = /* @__PURE__ */ new Set([...set1, ...set2]);
        return intersection.size / union.size;
      }
      calculateProfileCompleteness(user) {
        const fields = [
          user.bio,
          user.profession,
          user.interests,
          user.photoUrl,
          user.religion,
          user.ethnicity
        ];
        const completedFields = fields.filter((field) => field && field.trim().length > 0);
        return completedFields.length / fields.length;
      }
      async getUserInteractionPattern(userId) {
        try {
          const matches2 = await storage.getMeetMatchesByUserId(userId);
          const swipeHistory2 = await storage.getSwipeHistory(userId, "MEET", 100);
          const likedUsers = [];
          const dislikedUsers = [];
          matches2.forEach((match) => {
            if (match.matched || !match.isDislike) {
              const otherUserId = match.userId1 === userId ? match.userId2 : match.userId1;
              likedUsers.push(otherUserId);
            }
          });
          swipeHistory2.forEach((swipe) => {
            if (swipe.action === "dislike") {
              dislikedUsers.push(swipe.targetUserId);
            } else if (swipe.action === "like") {
              likedUsers.push(swipe.targetUserId);
            }
          });
          return {
            userId,
            likedUsers: [...new Set(likedUsers)],
            // Remove duplicates
            dislikedUsers: [...new Set(dislikedUsers)],
            averageResponseTime: 0,
            // TODO: Calculate from message data
            preferredAgeRange: [18, 50],
            // TODO: Infer from interaction patterns
            preferredLocations: [],
            // TODO: Infer from liked users
            interactionFrequency: swipeHistory2.length
          };
        } catch (error) {
          console.error(`[MATCHING-ENGINE] Error getting interaction pattern:`, error);
          return {
            userId,
            likedUsers: [],
            dislikedUsers: [],
            averageResponseTime: 0,
            preferredAgeRange: [18, 50],
            preferredLocations: [],
            interactionFrequency: 0
          };
        }
      }
      async findSimilarUsers(userId, userPattern) {
        try {
          if (userPattern.likedUsers.length === 0) {
            return [];
          }
          const allMatches = await storage.getMatches(userId);
          const userSimilarities = [];
          const otherUsers = /* @__PURE__ */ new Set();
          allMatches.forEach((match) => {
            if (match.userId1 !== userId) otherUsers.add(match.userId1);
            if (match.userId2 !== userId) otherUsers.add(match.userId2);
          });
          for (const otherUserId of otherUsers) {
            const otherPattern = await this.getUserInteractionPattern(otherUserId);
            const similarity = this.calculateUserSimilarity(userPattern, otherPattern);
            if (similarity > 0.3) {
              userSimilarities.push({ userId: otherUserId, similarity });
            }
          }
          return userSimilarities.sort((a, b) => b.similarity - a.similarity).slice(0, 10).map((s) => s.userId);
        } catch (error) {
          console.error(`[MATCHING-ENGINE] Error finding similar users:`, error);
          return [];
        }
      }
      calculateUserSimilarity(pattern1, pattern2) {
        const likes1 = new Set(pattern1.likedUsers);
        const likes2 = new Set(pattern2.likedUsers);
        if (likes1.size === 0 && likes2.size === 0) return 0;
        const intersection = new Set([...likes1].filter((x) => likes2.has(x)));
        const union = /* @__PURE__ */ new Set([...likes1, ...likes2]);
        return intersection.size / union.size;
      }
      generateMatchReasons(contentScore, collaborativeScore, contextScore) {
        const reasons = [];
        if (contentScore > 0.7) reasons.push("Strong profile compatibility");
        if (contentScore > 0.5) reasons.push("Good preference match");
        if (collaborativeScore > 0.7) reasons.push("Liked by similar users");
        if (collaborativeScore > 0.5) reasons.push("Community recommended");
        if (contextScore > 0.7) reasons.push("Recently active");
        if (contextScore > 0.5) reasons.push("Complete profile");
        return reasons.length > 0 ? reasons : ["Basic compatibility"];
      }
    };
    matchingEngine = new MatchingEngine();
  }
});

// server/enhanced-discovery-api.ts
var enhanced_discovery_api_exports = {};
__export(enhanced_discovery_api_exports, {
  registerEnhancedDiscoveryAPI: () => registerEnhancedDiscoveryAPI
});
function registerEnhancedDiscoveryAPI(app2) {
  app2.get("/api/discovery/enhanced", requireAuth, async (req, res) => {
    try {
      const userId = req.user.id;
      const limit = parseInt(req.query.limit) || 50;
      console.log(`[ENHANCED-DISCOVERY] Starting enhanced discovery for user ${userId}`);
      const context = {
        currentTime: /* @__PURE__ */ new Date(),
        lastActiveThreshold: 60,
        // 1 hour
        mode: "meet"
      };
      const rankedUsers = await matchingEngine.getRankedDiscovery(userId, context, limit);
      const safeUsers = rankedUsers.map((user) => {
        const { password, ...safeUser } = user;
        return safeUser;
      });
      console.log(`[ENHANCED-DISCOVERY] Returning ${safeUsers.length} ranked users for ${userId}`);
      res.json(safeUsers);
    } catch (error) {
      console.error("[ENHANCED-DISCOVERY] Error in enhanced discovery:", error);
      try {
        const fallbackUsers = await storage.getDiscoverUsers(req.user.id);
        const safeUsers = fallbackUsers.map((user) => {
          const { password, ...safeUser } = user;
          return safeUser;
        });
        console.log(`[ENHANCED-DISCOVERY] Fallback: Returning ${safeUsers.length} users`);
        res.json(safeUsers);
      } catch (fallbackError) {
        console.error("[ENHANCED-DISCOVERY] Fallback also failed:", fallbackError);
        res.status(500).json({
          message: "Discovery service temporarily unavailable",
          error: fallbackError instanceof Error ? fallbackError.message : "Unknown error"
        });
      }
    }
  });
  app2.get("/api/suite/discovery/networking/enhanced", requireAuth, async (req, res) => {
    try {
      const userId = req.user.id;
      const limit = parseInt(req.query.limit) || 30;
      console.log(`[ENHANCED-SUITE] Starting enhanced networking discovery for user ${userId}`);
      const context = {
        currentTime: /* @__PURE__ */ new Date(),
        lastActiveThreshold: 120,
        // 2 hours (professionals check less frequently)
        mode: "suite"
      };
      const rankedUsers = await matchingEngine.getRankedDiscovery(userId, context, limit);
      const safeUsers = rankedUsers.map((user) => {
        const { password, ...safeUser } = user;
        return safeUser;
      });
      console.log(`[ENHANCED-SUITE] Returning ${safeUsers.length} ranked networking profiles for ${userId}`);
      res.json(safeUsers);
    } catch (error) {
      console.error("[ENHANCED-SUITE] Error in enhanced networking discovery:", error);
      try {
        const fallbackUsers = await storage.getDiscoverUsers(req.user.id);
        const safeUsers = fallbackUsers.map((user) => {
          const { password, ...safeUser } = user;
          return safeUser;
        });
        console.log(`[ENHANCED-SUITE] Fallback: Returning ${safeUsers.length} users`);
        res.json(safeUsers);
      } catch (fallbackError) {
        console.error("[ENHANCED-SUITE] Fallback also failed:", fallbackError);
        res.status(500).json({
          message: "Networking discovery service temporarily unavailable",
          error: fallbackError instanceof Error ? fallbackError.message : "Unknown error"
        });
      }
    }
  });
  app2.get("/api/matching-engine/stats", requireAuth, async (req, res) => {
    try {
      const userId = req.user.id;
      const [matches2, preferences] = await Promise.all([
        storage.getMeetMatchesByUserId(userId),
        storage.getUserPreferences(userId)
      ]);
      const stats = {
        totalMatches: matches2.length,
        hasPreferences: !!preferences,
        preferenceCompleteness: preferences ? calculatePreferenceCompleteness(preferences) : 0,
        lastMatchDate: matches2.length > 0 ? Math.max(...matches2.map((m) => new Date(m.createdAt).getTime())) : null,
        matchingEngineStatus: "active",
        algorithmVersion: "1.0-hybrid"
      };
      res.json(stats);
    } catch (error) {
      console.error("[MATCHING-ENGINE-STATS] Error getting stats:", error);
      res.status(500).json({
        message: "Stats temporarily unavailable",
        error: error instanceof Error ? error.message : "Unknown error"
      });
    }
  });
  app2.post("/api/discovery/mode", requireAuth, async (req, res) => {
    try {
      const { mode } = req.body;
      const userId = req.user.id;
      if (!mode || !["enhanced", "original"].includes(mode)) {
        return res.status(400).json({
          message: "Invalid mode. Use 'enhanced' or 'original'"
        });
      }
      console.log(`[DISCOVERY-MODE] User ${userId} set discovery mode to: ${mode}`);
      res.json({
        message: `Discovery mode set to ${mode}`,
        mode,
        userId
      });
    } catch (error) {
      console.error("[DISCOVERY-MODE] Error setting discovery mode:", error);
      res.status(500).json({
        message: "Failed to set discovery mode",
        error: error instanceof Error ? error.message : "Unknown error"
      });
    }
  });
  app2.post("/api/matching-engine/refresh", requireAuth, async (req, res) => {
    try {
      const userId = req.user.id;
      console.log(`[MATCHING-ENGINE-REFRESH] Manual refresh triggered by user ${userId}`);
      const context = {
        currentTime: /* @__PURE__ */ new Date(),
        lastActiveThreshold: 60,
        mode: "meet"
      };
      const refreshedUsers = await matchingEngine.getRankedDiscovery(userId, context, 10);
      res.json({
        message: "Matching engine refreshed successfully",
        refreshedCount: refreshedUsers.length,
        timestamp: (/* @__PURE__ */ new Date()).toISOString()
      });
    } catch (error) {
      console.error("[MATCHING-ENGINE-REFRESH] Error refreshing:", error);
      res.status(500).json({
        message: "Failed to refresh matching engine",
        error: error instanceof Error ? error.message : "Unknown error"
      });
    }
  });
  app2.get("/api/matching-engine/advanced-test/:candidateId", requireAuth, async (req, res) => {
    try {
      const userId = req.user.id;
      const candidateId = parseInt(req.params.candidateId);
      console.log(`[ADVANCED-TEST] Testing advanced algorithms between ${userId} and ${candidateId}`);
      const user = await storage.getUser(userId);
      const candidate = await storage.getUser(candidateId);
      const preferences = await storage.getUserPreferences(userId);
      if (!user || !candidate) {
        return res.status(404).json({ error: "User not found" });
      }
      const contentResult = advancedMatchingEngine.calculateAdvancedContentScore(user, candidate, preferences);
      const contextResult = advancedMatchingEngine.calculateAdvancedContextScore(
        candidate,
        { currentTime: /* @__PURE__ */ new Date() },
        { responseRate: 0.8, averageResponseTime: 1200 }
      );
      res.json({
        success: true,
        userId,
        candidateId,
        results: {
          content: contentResult,
          context: contextResult,
          timestamp: (/* @__PURE__ */ new Date()).toISOString()
        }
      });
    } catch (error) {
      console.error("[ADVANCED-TEST] Error:", error);
      res.status(500).json({
        error: "Advanced algorithm test failed",
        details: error instanceof Error ? error.message : "Unknown error"
      });
    }
  });
  app2.post("/api/matching-engine/feedback", requireAuth, async (req, res) => {
    try {
      const userId = req.user.id;
      const { targetUserId, action, feedback, algorithmVersion } = req.body;
      console.log(`[FEEDBACK] User ${userId} provided feedback on ${targetUserId}: ${action}`);
      const feedbackData = {
        userId,
        targetUserId: parseInt(targetUserId),
        action,
        // 'like', 'dislike', 'message', 'skip'
        feedback,
        // Optional text feedback
        algorithmVersion,
        timestamp: /* @__PURE__ */ new Date(),
        sessionId: req.sessionID
      };
      console.log("[FEEDBACK-DATA]", JSON.stringify(feedbackData, null, 2));
      res.json({
        success: true,
        message: "Feedback recorded successfully",
        feedbackId: `fb_${Date.now()}_${userId}`
      });
    } catch (error) {
      console.error("[FEEDBACK] Error recording feedback:", error);
      res.status(500).json({
        error: "Failed to record feedback",
        details: error instanceof Error ? error.message : "Unknown error"
      });
    }
  });
  function calculatePreferenceCompleteness(preferences) {
    const fields = [
      preferences.minAge,
      preferences.maxAge,
      preferences.locationPreference,
      preferences.religionPreference,
      preferences.ethnicityPreference,
      preferences.relationshipGoalPreference
    ];
    const completedFields = fields.filter((field) => field !== null && field !== void 0);
    return completedFields.length / fields.length;
  }
}
var init_enhanced_discovery_api = __esm({
  "server/enhanced-discovery-api.ts"() {
    "use strict";
    init_matching_engine();
    init_advanced_matching_algorithms();
    init_storage();
    init_auth();
  }
});

// server/data-collection-api.ts
async function trackProfileView(req, res) {
  try {
    const { viewerId, viewedId, appMode = "MEET", duration = 0 } = req.body;
    if (!viewerId || !viewedId) {
      return res.status(400).json({
        error: "Missing required fields: viewerId, viewedId"
      });
    }
    if (viewerId === viewedId) {
      return res.status(400).json({
        error: "Cannot track self-profile views"
      });
    }
    console.log(`[PROFILE-VIEW-TRACKING] User ${viewerId} viewed ${viewedId} (${appMode}) for ${duration}s`);
    await storage.query(`
      SELECT upsert_profile_view($1, $2, $3, $4)
    `, [viewerId, viewedId, appMode, duration]);
    res.json({
      success: true,
      message: "Profile view tracked successfully",
      data: { viewerId, viewedId, appMode, duration }
    });
  } catch (error) {
    console.error("[PROFILE-VIEW-TRACKING] Error tracking profile view:", error);
    res.status(500).json({
      error: "Failed to track profile view",
      details: process.env.NODE_ENV === "development" ? error : void 0
    });
  }
}
async function getProfileViewAnalytics(req, res) {
  try {
    const { userId } = req.params;
    const { appMode = "MEET", timeframe = "30" } = req.query;
    console.log(`[PROFILE-ANALYTICS] Getting view analytics for user ${userId} (${appMode})`);
    const viewsReceived = await storage.query(`
      SELECT 
        viewer_id,
        view_count,
        total_view_duration,
        first_viewed_at,
        last_viewed_at,
        EXTRACT(EPOCH FROM (NOW() - last_viewed_at))/86400 as days_since_view
      FROM profile_views 
      WHERE viewed_id = $1 
        AND app_mode = $2
        AND last_viewed_at >= NOW() - INTERVAL '${timeframe} days'
      ORDER BY last_viewed_at DESC
      LIMIT 50
    `, [userId, appMode]);
    const viewsMade = await storage.query(`
      SELECT 
        viewed_id,
        view_count,
        total_view_duration,
        first_viewed_at,
        last_viewed_at,
        EXTRACT(EPOCH FROM (NOW() - last_viewed_at))/86400 as days_since_view
      FROM profile_views 
      WHERE viewer_id = $1 
        AND app_mode = $2
        AND last_viewed_at >= NOW() - INTERVAL '${timeframe} days'
      ORDER BY last_viewed_at DESC
      LIMIT 50
    `, [userId, appMode]);
    const summary = await storage.query(`
      SELECT 
        COUNT(CASE WHEN viewed_id = $1 THEN 1 END) as views_received_count,
        COUNT(CASE WHEN viewer_id = $1 THEN 1 END) as views_made_count,
        AVG(CASE WHEN viewed_id = $1 THEN view_count END) as avg_views_received,
        AVG(CASE WHEN viewer_id = $1 THEN view_count END) as avg_views_made,
        SUM(CASE WHEN viewed_id = $1 THEN total_view_duration END) as total_duration_received,
        SUM(CASE WHEN viewer_id = $1 THEN total_view_duration END) as total_duration_made
      FROM profile_views 
      WHERE (viewer_id = $1 OR viewed_id = $1)
        AND app_mode = $2
        AND last_viewed_at >= NOW() - INTERVAL '${timeframe} days'
    `, [userId, appMode]);
    res.json({
      success: true,
      data: {
        summary: summary[0] || {},
        viewsReceived,
        viewsMade,
        timeframe: `${timeframe} days`,
        appMode
      }
    });
  } catch (error) {
    console.error("[PROFILE-ANALYTICS] Error getting analytics:", error);
    res.status(500).json({
      error: "Failed to get profile view analytics",
      details: process.env.NODE_ENV === "development" ? error : void 0
    });
  }
}
async function getMessageEngagementAnalytics(req, res) {
  try {
    const { userId, targetUserId } = req.params;
    const { timeframe = "30" } = req.query;
    console.log(`[MESSAGE-ANALYTICS] Getting engagement analytics: ${userId} \u2194 ${targetUserId}`);
    const engagementSummary = await storage.query(`
      SELECT 
        COUNT(*) as total_messages,
        AVG(message_length) as avg_message_length,
        AVG(word_count) as avg_word_count,
        AVG(engagement_score) as avg_engagement_score,
        COUNT(CASE WHEN has_question THEN 1 END)::REAL / COUNT(*) as question_rate,
        COUNT(CASE WHEN has_exclamation THEN 1 END)::REAL / COUNT(*) as enthusiasm_rate,
        COUNT(CASE WHEN message_length > 50 THEN 1 END)::REAL / COUNT(*) as substantial_rate,
        MAX(created_at) as last_message_at
      FROM message_engagement_metrics
      WHERE ((sender_id = $1 AND receiver_id = $2)
         OR (sender_id = $2 AND receiver_id = $1))
        AND created_at >= NOW() - INTERVAL '${timeframe} days'
    `, [userId, targetUserId]);
    const threadInfo = await storage.query(`
      SELECT 
        thread_id,
        total_messages,
        messages_from_one,
        messages_from_two,
        average_response_time,
        conversation_depth,
        last_activity_at,
        EXTRACT(EPOCH FROM (NOW() - last_activity_at))/86400 as days_since_activity
      FROM conversation_threads
      WHERE (participant_one_id = LEAST($1, $2) 
         AND participant_two_id = GREATEST($1, $2))
        AND is_active = true
    `, [userId, targetUserId]);
    const engagementTrend = await storage.query(`
      SELECT 
        DATE(created_at) as date,
        AVG(engagement_score) as avg_engagement,
        COUNT(*) as message_count
      FROM message_engagement_metrics
      WHERE ((sender_id = $1 AND receiver_id = $2)
         OR (sender_id = $2 AND receiver_id = $1))
        AND created_at >= NOW() - INTERVAL '${timeframe} days'
      GROUP BY DATE(created_at)
      ORDER BY date ASC
      LIMIT 30
    `, [userId, targetUserId]);
    res.json({
      success: true,
      data: {
        engagementSummary: engagementSummary[0] || {},
        threadInfo: threadInfo[0] || {},
        engagementTrend,
        timeframe: `${timeframe} days`
      }
    });
  } catch (error) {
    console.error("[MESSAGE-ANALYTICS] Error getting engagement analytics:", error);
    res.status(500).json({
      error: "Failed to get message engagement analytics",
      details: process.env.NODE_ENV === "development" ? error : void 0
    });
  }
}
async function getReciprocityScore(req, res) {
  try {
    const { userId, targetUserId } = req.params;
    console.log(`[RECIPROCITY-ANALYTICS] Calculating reciprocity score: ${userId} \u2194 ${targetUserId}`);
    const { userBehaviorPatterns: userBehaviorPatterns2 } = await Promise.resolve().then(() => (init_user_behavior_patterns(), user_behavior_patterns_exports));
    const reciprocityProfile = await userBehaviorPatterns2.calculateReciprocityEngagementProfile(
      parseInt(userId),
      parseInt(targetUserId)
    );
    res.json({
      success: true,
      data: reciprocityProfile
    });
  } catch (error) {
    console.error("[RECIPROCITY-ANALYTICS] Error calculating reciprocity score:", error);
    res.status(500).json({
      error: "Failed to calculate reciprocity score",
      details: process.env.NODE_ENV === "development" ? error : void 0
    });
  }
}
async function getDataCollectionStatus(req, res) {
  try {
    console.log("[DATA-STATUS] Checking data collection readiness");
    const [profileViewsCount, engagementCount, threadsCount, messagesCount, swipeCount] = await Promise.all([
      storage.query(`SELECT COUNT(*) as count FROM profile_views`),
      storage.query(`SELECT COUNT(*) as count FROM message_engagement_metrics`),
      storage.query(`SELECT COUNT(*) as count FROM conversation_threads`),
      storage.query(`SELECT COUNT(*) as count FROM messages`),
      storage.query(`SELECT COUNT(*) as count FROM swipe_history`)
    ]);
    const { userBehaviorPatterns: userBehaviorPatterns2 } = await Promise.resolve().then(() => (init_user_behavior_patterns(), user_behavior_patterns_exports));
    const indicatorStatus = await userBehaviorPatterns2.checkMutualInterestReadiness();
    const status = {
      infrastructure: {
        profileViewsTable: true,
        messageEngagementTable: true,
        conversationThreadsTable: true
      },
      dataAvailability: {
        profileViews: Number(profileViewsCount[0].count),
        messageEngagement: Number(engagementCount[0].count),
        conversationThreads: Number(threadsCount[0].count),
        totalMessages: Number(messagesCount[0].count),
        totalSwipes: Number(swipeCount[0].count)
      },
      indicators: indicatorStatus,
      readyForProduction: indicatorStatus.implementationStatus === "READY",
      dataCollectionActive: true
    };
    res.json({
      success: true,
      data: status
    });
  } catch (error) {
    console.error("[DATA-STATUS] Error checking readiness:", error);
    res.status(500).json({
      error: "Failed to check data collection status",
      details: process.env.NODE_ENV === "development" ? error : void 0
    });
  }
}
async function backfillEngagementMetrics(req, res) {
  try {
    const { limit = 1e3 } = req.body || {};
    console.log(`[BACKFILL] Starting engagement metrics backfill for ${limit} messages`);
    const unprocessedMessages = await storage.query(`
      SELECT m.id, m.sender_id, m.receiver_id, m.content, m.created_at
      FROM messages m
      LEFT JOIN message_engagement_metrics mem ON m.id = mem.message_id
      WHERE mem.message_id IS NULL
        AND m.content IS NOT NULL 
        AND m.content != ''
      ORDER BY m.created_at DESC
      LIMIT $1
    `, [limit]);
    if (unprocessedMessages.length === 0) {
      return res.json({
        success: true,
        message: "No messages to backfill",
        processed: 0
      });
    }
    let processedCount = 0;
    for (const message of unprocessedMessages) {
      try {
        const content = message.content || "";
        const msgLength = content.length;
        const msgWords = content.trim().split(/\s+/).length;
        const hasQuestion = content.includes("?");
        const hasExclamation = content.includes("!");
        let score = 30;
        if (msgLength > 100) score += 30;
        else if (msgLength > 50) score += 20;
        else if (msgLength > 20) score += 10;
        if (hasQuestion) score += 20;
        if (hasExclamation) score += 20;
        score = Math.max(0, Math.min(100, score));
        await storage.query(`
          INSERT INTO message_engagement_metrics (
            message_id, sender_id, receiver_id, message_length,
            has_question, has_exclamation, word_count, engagement_score
          ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
        `, [
          message.id,
          message.sender_id,
          message.receiver_id,
          msgLength,
          hasQuestion,
          hasExclamation,
          msgWords,
          score
        ]);
        processedCount++;
      } catch (error) {
        console.error(`[BACKFILL] Failed to process message ${message.id}:`, error);
      }
    }
    console.log(`[BACKFILL] Completed: ${processedCount}/${unprocessedMessages.length} messages processed`);
    res.json({
      success: true,
      message: `Backfill completed: ${processedCount} messages processed`,
      processed: processedCount,
      total: unprocessedMessages.length
    });
  } catch (error) {
    console.error("[BACKFILL] Error during backfill:", error);
    res.status(500).json({
      error: "Failed to backfill engagement metrics",
      details: process.env.NODE_ENV === "development" ? error : void 0
    });
  }
}
var init_data_collection_api = __esm({
  "server/data-collection-api.ts"() {
    "use strict";
    init_storage();
  }
});

// server/routes/data-collection-routes.ts
var data_collection_routes_exports = {};
__export(data_collection_routes_exports, {
  default: () => data_collection_routes_default
});
import { Router } from "express";
var router, data_collection_routes_default;
var init_data_collection_routes = __esm({
  "server/routes/data-collection-routes.ts"() {
    "use strict";
    init_data_collection_api();
    router = Router();
    router.post("/profile-view", trackProfileView);
    router.get("/profile-views/:userId", getProfileViewAnalytics);
    router.get("/message-engagement/:userId/:targetUserId", getMessageEngagementAnalytics);
    router.get("/reciprocity-score/:userId/:targetUserId", getReciprocityScore);
    router.get("/readiness-status", getDataCollectionStatus);
    router.post("/backfill-engagement", backfillEngagementMetrics);
    data_collection_routes_default = router;
  }
});

// server/archiving-service.ts
var archiving_service_exports = {};
__export(archiving_service_exports, {
  ArchivingService: () => ArchivingService,
  default: () => archiving_service_default
});
import { eq as eq4, and as and4, sql as sql4 } from "drizzle-orm";
var ArchivingService, archiving_service_default;
var init_archiving_service = __esm({
  "server/archiving-service.ts"() {
    "use strict";
    init_db();
    init_schema();
    ArchivingService = class {
      /**
       * Archive a match and all its associated messages when users unmatch
       */
      static async archiveMatchWithMessages(matchId, archivedByUserId, reason) {
        try {
          console.log(`[ARCHIVE] Starting archival of match ${matchId} by user ${archivedByUserId}, reason: ${reason}`);
          const matchData = await db.select().from(matches).where(eq4(matches.id, matchId)).limit(1);
          if (matchData.length === 0) {
            throw new Error(`Match ${matchId} not found`);
          }
          const match = matchData[0];
          const messages2 = await db.select().from(messages).where(eq4(messages.matchId, matchId));
          console.log(`[ARCHIVE] Found ${messages2.length} messages to archive for match ${matchId}`);
          const archivedMatchData = {
            originalMatchId: match.id,
            userId1: match.userId1,
            userId2: match.userId2,
            matched: match.matched,
            isDislike: match.isDislike,
            hasUnreadMessages1: match.hasUnreadMessages1,
            hasUnreadMessages2: match.hasUnreadMessages2,
            notifiedUser1: match.notifiedUser1,
            notifiedUser2: match.notifiedUser2,
            lastMessageAt: match.lastMessageAt,
            matchCreatedAt: match.createdAt,
            archivedReason: reason,
            archivedByUserId,
            messageCount: messages2.length
          };
          const archivedMatchResult = await db.insert(archivedMatches).values(archivedMatchData).returning({ id: archivedMatches.id });
          const archivedMatchId = archivedMatchResult[0].id;
          console.log(`[ARCHIVE] Created archived match record ${archivedMatchId}`);
          if (messages2.length > 0) {
            const archivedMessagesData = messages2.map((message) => ({
              originalMessageId: message.id,
              originalMatchId: matchId,
              archivedMatchId,
              senderId: message.senderId,
              receiverId: message.receiverId,
              content: message.content,
              encryptedContent: message.encryptedContent || void 0,
              iv: message.iv || void 0,
              messageType: message.messageType || "text",
              audioUrl: message.audioUrl || void 0,
              audioDuration: message.audioDuration || void 0,
              read: message.read,
              readAt: message.readAt,
              messageCreatedAt: message.createdAt,
              archivedReason: reason,
              replyToMessageId: message.replyToMessageId || void 0,
              replyToContent: message.replyToContent || void 0,
              replyToSenderName: message.replyToSenderName || void 0,
              replyToIsCurrentUser: message.replyToIsCurrentUser || void 0,
              autoDeleteScheduledAt: message.autoDeleteScheduledAt,
              autoDeleteModeWhenSent: message.autoDeleteModeWhenSent || void 0,
              deletedForUserId: message.deletedForUserId || void 0
            }));
            await db.insert(archivedMessages).values(archivedMessagesData);
            console.log(`[ARCHIVE] Archived ${messages2.length} messages`);
          }
          console.log(`[ARCHIVE] Successfully archived match ${matchId} with ${messages2.length} messages`);
          return {
            archivedMatchId,
            messageCount: messages2.length
          };
        } catch (error) {
          console.error(`[ARCHIVE] Failed to archive match ${matchId}:`, error);
          throw error;
        }
      }
      /**
       * Archive a user account when they delete their account or for security purposes
       */
      static async archiveUser(userId, reason, archivedByUserId, ipAddress, userAgent) {
        try {
          console.log(`[ARCHIVE] Starting user archival for user ${userId}, reason: ${reason}`);
          const userData = await db.select().from(users).where(eq4(users.id, userId)).limit(1);
          if (userData.length === 0) {
            throw new Error(`User ${userId} not found`);
          }
          const user = userData[0];
          const matchCount = await db.select({ count: sql4`count(*)` }).from(matches).where(
            and4(
              sql4`(${matches.userId1} = ${userId} OR ${matches.userId2} = ${userId})`,
              eq4(matches.matched, true)
            )
          );
          const messageCount = await db.select({ count: sql4`count(*)` }).from(messages).where(eq4(messages.senderId, userId));
          const totalMatches = matchCount[0]?.count || 0;
          const totalMessages = messageCount[0]?.count || 0;
          console.log(`[ARCHIVE] User ${userId} statistics: ${totalMatches} matches, ${totalMessages} messages`);
          const archivedUserData = {
            originalUserId: user.id,
            username: user.username,
            fullName: user.fullName,
            email: user.email,
            phoneNumber: user.phoneNumber || void 0,
            gender: user.gender,
            location: user.location,
            countryOfOrigin: user.countryOfOrigin || void 0,
            bio: user.bio || void 0,
            profession: user.profession || void 0,
            ethnicity: user.ethnicity || void 0,
            secondaryTribe: user.secondaryTribe || void 0,
            religion: user.religion || void 0,
            photoUrl: user.photoUrl || void 0,
            showProfilePhoto: user.showProfilePhoto || false,
            dateOfBirth: user.dateOfBirth,
            relationshipStatus: user.relationshipStatus || void 0,
            relationshipGoal: user.relationshipGoal || void 0,
            interests: user.interests || void 0,
            visibilityPreferences: user.visibilityPreferences || void 0,
            verifiedByPhone: user.verifiedByPhone || false,
            twoFactorEnabled: user.twoFactorEnabled || false,
            profileHidden: user.profileHidden || false,
            ghostMode: user.ghostMode || false,
            isOnline: user.isOnline || false,
            lastActive: user.lastActive,
            userCreatedAt: user.createdAt,
            archivedReason: reason,
            archivedByUserId: archivedByUserId || userId,
            totalMatches,
            totalMessages,
            ipAddress: ipAddress || void 0,
            userAgent: userAgent || void 0
          };
          const archivedUserResult = await db.insert(archivedUsers).values(archivedUserData).returning({ id: archivedUsers.id });
          const archivedUserId = archivedUserResult[0].id;
          console.log(`[ARCHIVE] Successfully archived user ${userId} as record ${archivedUserId}`);
          return {
            archivedUserId,
            totalMatches,
            totalMessages
          };
        } catch (error) {
          console.error(`[ARCHIVE] Failed to archive user ${userId}:`, error);
          throw error;
        }
      }
      /**
       * Get archived match history for a user (admin/support function)
       */
      static async getArchivedMatchHistory(userId) {
        try {
          const archivedMatchHistory = await db.select().from(archivedMatches).where(
            sql4`(${archivedMatches.userId1} = ${userId} OR ${archivedMatches.userId2} = ${userId})`
          ).orderBy(sql4`${archivedMatches.archivedAt} DESC`);
          return archivedMatchHistory;
        } catch (error) {
          console.error(`[ARCHIVE] Failed to get archived match history for user ${userId}:`, error);
          throw error;
        }
      }
      /**
       * Get archived user record (admin/support function)
       */
      static async getArchivedUser(originalUserId) {
        try {
          const archivedUser = await db.select().from(archivedUsers).where(eq4(archivedUsers.originalUserId, originalUserId)).orderBy(sql4`${archivedUsers.archivedAt} DESC`).limit(1);
          return archivedUser[0] || null;
        } catch (error) {
          console.error(`[ARCHIVE] Failed to get archived user for ID ${originalUserId}:`, error);
          throw error;
        }
      }
      /**
       * Clean up archived data older than specified retention period (admin function)
       */
      static async cleanupOldArchives(retentionDays = 2555) {
        try {
          console.log(`[ARCHIVE] Starting cleanup of archives older than ${retentionDays} days`);
          const cutoffDate = /* @__PURE__ */ new Date();
          cutoffDate.setDate(cutoffDate.getDate() - retentionDays);
          const deletedMessages = await db.delete(archivedMessages).where(sql4`${archivedMessages.archivedAt} < ${cutoffDate}`);
          const deletedMatches = await db.delete(archivedMatches).where(sql4`${archivedMatches.archivedAt} < ${cutoffDate}`);
          const deletedUsers = await db.delete(archivedUsers).where(sql4`${archivedUsers.archivedAt} < ${cutoffDate}`);
          console.log(`[ARCHIVE] Cleanup completed: ${deletedMatches} matches, ${deletedMessages} messages, ${deletedUsers} users`);
          return {
            deletedMatches: deletedMatches.rowCount || 0,
            deletedMessages: deletedMessages.rowCount || 0,
            deletedUsers: deletedUsers.rowCount || 0
          };
        } catch (error) {
          console.error(`[ARCHIVE] Failed to cleanup old archives:`, error);
          throw error;
        }
      }
    };
    archiving_service_default = ArchivingService;
  }
});

// server/services/email-verification.ts
var email_verification_exports = {};
__export(email_verification_exports, {
  EmailVerificationService: () => EmailVerificationService
});
import * as dns from "dns";
import * as net from "net";
import { promisify as promisify2 } from "util";
var dnsResolve, EmailVerificationService;
var init_email_verification = __esm({
  "server/services/email-verification.ts"() {
    "use strict";
    dnsResolve = promisify2(dns.resolveMx);
    EmailVerificationService = class {
      static TIMEOUT = 1e4;
      // 10 seconds
      static COMMON_DISPOSABLE_DOMAINS = /* @__PURE__ */ new Set([
        "10minutemail.com",
        "tempmail.org",
        "guerrillamail.com",
        "mailinator.com",
        "yopmail.com",
        "throwaway.email",
        "temp-mail.org",
        "getnada.com"
      ]);
      /**
       * Main email verification method
       */
      static async verifyEmail(email) {
        try {
          const formatResult = this.validateEmailFormat(email);
          if (!formatResult.isValid) {
            return formatResult;
          }
          const domain = email.split("@")[1].toLowerCase();
          if (this.COMMON_DISPOSABLE_DOMAINS.has(domain)) {
            return {
              isValid: false,
              reason: "Disposable email address detected",
              confidence: "high"
            };
          }
          const mxResult = await this.checkMXRecords(domain);
          if (!mxResult.isValid) {
            return mxResult;
          }
          const smtpResult = await this.performSMTPVerification(email, mxResult.mxRecords);
          return smtpResult;
        } catch (error) {
          console.error("[EMAIL-VERIFICATION] Verification failed:", error);
          return {
            isValid: false,
            reason: "Verification service temporarily unavailable",
            confidence: "low"
          };
        }
      }
      /**
       * Validate email format using RFC 5322 compliant regex
       */
      static validateEmailFormat(email) {
        const emailRegex = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
        if (!email || !emailRegex.test(email)) {
          return {
            isValid: false,
            reason: "Invalid email format",
            confidence: "high"
          };
        }
        if (email.length > 254 || email.split("@")[0].length > 64) {
          return {
            isValid: false,
            reason: "Email address too long",
            confidence: "high"
          };
        }
        return { isValid: true, confidence: "high" };
      }
      /**
       * Check MX records for the domain
       */
      static async checkMXRecords(domain) {
        try {
          const mxRecords = await dnsResolve(domain);
          if (!mxRecords || mxRecords.length === 0) {
            return {
              isValid: false,
              reason: "No mail servers found for domain",
              confidence: "high"
            };
          }
          const sortedMXRecords = mxRecords.sort((a, b) => a.priority - b.priority);
          return {
            isValid: true,
            confidence: "medium",
            mxRecords: sortedMXRecords
          };
        } catch (error) {
          return {
            isValid: false,
            reason: "Domain does not exist or has no mail servers",
            confidence: "high"
          };
        }
      }
      /**
       * Perform SMTP verification without sending emails
       */
      static async performSMTPVerification(email, mxRecords) {
        const userPart = email.split("@")[0];
        const domain = email.split("@")[1];
        for (const mx of mxRecords) {
          try {
            const result = await this.testSMTPConnection(mx.exchange, email, userPart, domain);
            if (result.isValid !== void 0) {
              return result;
            }
          } catch (error) {
            console.log(`[EMAIL-VERIFICATION] Failed to connect to ${mx.exchange}:`, error);
            continue;
          }
        }
        return {
          isValid: false,
          reason: "Unable to verify email existence - mail servers not responding",
          confidence: "low"
        };
      }
      /**
       * Test SMTP connection and verify email existence
       */
      static async testSMTPConnection(mxHost, email, userPart, domain) {
        return new Promise((resolve) => {
          const socket = net.createConnection(25, mxHost);
          let step = 0;
          let responseBuffer = "";
          const cleanup = () => {
            socket.removeAllListeners();
            if (!socket.destroyed) {
              socket.destroy();
            }
          };
          const timeout = setTimeout(() => {
            cleanup();
            resolve({
              isValid: false,
              reason: "SMTP server timeout",
              confidence: "low"
            });
          }, this.TIMEOUT);
          socket.on("connect", () => {
            console.log(`[EMAIL-VERIFICATION] Connected to ${mxHost}`);
          });
          socket.on("data", (data) => {
            responseBuffer += data.toString();
            const lines = responseBuffer.split("\r\n");
            for (let i = 0; i < lines.length - 1; i++) {
              const line = lines[i];
              console.log(`[EMAIL-VERIFICATION] Server response: ${line}`);
              try {
                switch (step) {
                  case 0:
                    if (line.startsWith("220")) {
                      socket.write(`HELO btechnos.com\r
`);
                      step = 1;
                    } else if (line.startsWith("4") || line.startsWith("5")) {
                      clearTimeout(timeout);
                      cleanup();
                      resolve({
                        isValid: false,
                        reason: "Mail server rejected connection",
                        confidence: "medium"
                      });
                      return;
                    }
                    break;
                  case 1:
                    if (line.startsWith("250")) {
                      socket.write(`MAIL FROM:<admin@btechnos.com>\r
`);
                      step = 2;
                    } else {
                      clearTimeout(timeout);
                      cleanup();
                      resolve({
                        isValid: false,
                        reason: "HELO command failed",
                        confidence: "medium"
                      });
                      return;
                    }
                    break;
                  case 2:
                    if (line.startsWith("250")) {
                      socket.write(`RCPT TO:<${email}>\r
`);
                      step = 3;
                    } else {
                      clearTimeout(timeout);
                      cleanup();
                      resolve({
                        isValid: false,
                        reason: "MAIL FROM command failed",
                        confidence: "medium"
                      });
                      return;
                    }
                    break;
                  case 3:
                    clearTimeout(timeout);
                    socket.write(`QUIT\r
`);
                    if (line.startsWith("250")) {
                      cleanup();
                      resolve({
                        isValid: true,
                        confidence: "high"
                      });
                      return;
                    } else if (line.startsWith("550") || line.startsWith("551") || line.startsWith("553")) {
                      cleanup();
                      resolve({
                        isValid: false,
                        reason: "Email address does not exist",
                        confidence: "high"
                      });
                      return;
                    } else if (line.startsWith("452") || line.startsWith("421")) {
                      cleanup();
                      resolve({
                        isValid: false,
                        reason: "Mail server temporarily unavailable",
                        confidence: "low"
                      });
                      return;
                    } else {
                      cleanup();
                      resolve({
                        isValid: false,
                        reason: "Unknown SMTP response",
                        confidence: "low"
                      });
                      return;
                    }
                }
              } catch (stepError) {
                console.error("[EMAIL-VERIFICATION] Step processing error:", stepError);
                clearTimeout(timeout);
                cleanup();
                resolve({
                  isValid: false,
                  reason: "SMTP verification error",
                  confidence: "low"
                });
                return;
              }
            }
            responseBuffer = lines[lines.length - 1];
          });
          socket.on("error", (error) => {
            console.error(`[EMAIL-VERIFICATION] Socket error for ${mxHost}:`, error);
            clearTimeout(timeout);
            cleanup();
            resolve({
              isValid: false,
              reason: "Connection failed to mail server",
              confidence: "medium"
            });
          });
          socket.on("close", () => {
            clearTimeout(timeout);
            cleanup();
          });
        });
      }
      /**
       * Quick validation for common email providers (fallback method)
       */
      static async quickValidation(email) {
        const domain = email.split("@")[1]?.toLowerCase();
        const trustedProviders = /* @__PURE__ */ new Set([
          "gmail.com",
          "yahoo.com",
          "hotmail.com",
          "outlook.com",
          "icloud.com",
          "aol.com",
          "protonmail.com",
          "zoho.com"
        ]);
        if (trustedProviders.has(domain)) {
          return {
            isValid: true,
            confidence: "medium"
          };
        }
        const formatResult = this.validateEmailFormat(email);
        if (!formatResult.isValid) {
          return formatResult;
        }
        const mxResult = await this.checkMXRecords(domain);
        return {
          isValid: mxResult.isValid,
          reason: mxResult.reason,
          confidence: mxResult.isValid ? "medium" : "high"
        };
      }
    };
  }
});

// server/unified-api.ts
var unified_api_exports = {};
__export(unified_api_exports, {
  getHomePageData: () => getHomePageData,
  getSuitePageData: () => getSuitePageData
});
async function getHomePageData(req, res) {
  try {
    const startTime = Date.now();
    const userId = req.user?.id;
    if (!userId) {
      return res.status(401).json({ message: "Unauthorized" });
    }
    console.log(`[UNIFIED-API] Starting parallel data fetch for user ${userId}`);
    console.log(`[UNIFIED-API] \u{1F6A8} VERIFICATION: About to call getEnhancedDiscoveryUsers with AI matching engine`);
    const [
      user,
      discoverUsers,
      swipeHistory2,
      premiumStatus
    ] = await Promise.all([
      // User data (essential)
      storage.getUser(userId),
      //  Enhanced AI-powered discovery with hybrid matching
      getEnhancedDiscoveryUsers(userId),
      // Swipe history (for undo functionality)
      storage.getSwipeHistory(userId, "MEET", 50),
      // Premium status (essential for features)
      storage.getPremiumStatus(userId)
    ]);
    const duration = Date.now() - startTime;
    console.log(`[UNIFIED-API] Parallel fetch completed in ${duration}ms for user ${userId}`);
    const responseData = {
      user,
      discoverUsers: discoverUsers || [],
      swipeHistory: swipeHistory2 || [],
      premiumStatus: premiumStatus || { premiumAccess: false },
      matchCounts: { confirmed: 0, pending: 0, total: 0 },
      // Load later if needed
      matches: [],
      // Load later if needed
      unreadCount: 0,
      // Load later if needed
      suiteConnectionCounts: { networking: { matches: 0, pending: 0 } }
      // Load later if needed
    };
    res.json(responseData);
  } catch (error) {
    console.error("[UNIFIED-API] Error in getHomePageData:", error);
    res.status(500).json({ message: "Internal server error" });
  }
}
async function getEnhancedDiscoveryUsers(userId) {
  try {
    console.log(`[ENHANCED-MEET] \u{1F3AF} Using AI matching engine for user ${userId}`);
    const context = {
      currentTime: /* @__PURE__ */ new Date(),
      lastActiveThreshold: 60,
      // 1 hour
      mode: "meet"
    };
    const rankedUsers = await matchingEngine.getRankedDiscovery(userId, context, 50);
    console.log(`[ENHANCED-MEET] \u26A1 AI engine returned ${rankedUsers.length} personalized matches`);
    const safeUsers = rankedUsers.map((user) => {
      const { password, ...safeUser } = user;
      return safeUser;
    });
    return safeUsers;
  } catch (error) {
    console.error("[ENHANCED-MEET] AI matching failed, falling back to original discovery:", error);
    return await storage.getDiscoverUsers(userId);
  }
}
async function getSuitePageData(req, res) {
  try {
    const startTime = Date.now();
    const userId = req.user?.id;
    if (!userId) {
      return res.status(401).json({ message: "Unauthorized" });
    }
    console.log(`[UNIFIED-API] Starting parallel SUITE data fetch for user ${userId}`);
    const [
      user,
      suiteConnectionCounts,
      networkingProfile,
      mentorshipProfile,
      jobProfile,
      unreadCount
    ] = await Promise.all([
      storage.getUser(userId),
      storage.getSuiteConnectionCounts(userId),
      storage.getSuiteNetworkingProfile(userId),
      storage.getSuiteMentorshipProfile(userId),
      storage.getSuiteJobProfile(userId),
      storage.getUnreadMessageCount(userId)
    ]);
    const duration = Date.now() - startTime;
    console.log(`[UNIFIED-API] Parallel SUITE fetch completed in ${duration}ms for user ${userId}`);
    res.json({
      user,
      suiteConnectionCounts: suiteConnectionCounts || { networking: { matches: 0, pending: 0 } },
      networkingProfile,
      mentorshipProfile,
      jobProfile,
      unreadCount: unreadCount || 0
    });
  } catch (error) {
    console.error("[UNIFIED-API] Error in getSuitePageData:", error);
    res.status(500).json({ message: "Internal server error" });
  }
}
var init_unified_api = __esm({
  "server/unified-api.ts"() {
    "use strict";
    init_storage();
    init_matching_engine();
  }
});

// server/index.ts
import express2 from "express";

// server/routes.ts
init_storage();
init_auth();
init_auth();
init_match_api();
import { createServer } from "http";
import { WebSocketServer, WebSocket as WebSocket3 } from "ws";

// server/suite-connection-api.ts
init_storage();
init_schema();
import { z as z2 } from "zod";
var connectedUsers2 = /* @__PURE__ */ new Map();
function setSuiteWebSocketConnections(connections) {
  connectedUsers2 = connections;
}
function registerSuiteConnectionAPI(app2) {
  app2.post("/api/suite/connections/message", async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      const userId = req.user.id;
      const { targetUserId, connectionType, profileId } = req.body;
      if (!connectionType || !profileId) {
        return res.status(400).json({
          message: "Missing required fields: connectionType, profileId"
        });
      }
      console.log(`Creating instant match via message for user ${userId} -> profile ${profileId} (${connectionType})`);
      let newConnection;
      let isMatch = true;
      let actualTargetUserId = targetUserId;
      switch (connectionType) {
        case "networking":
          const networkingProfile = await storage.getSuiteNetworkingProfileById(parseInt(profileId));
          if (!networkingProfile) {
            return res.status(404).json({ message: "Networking profile not found" });
          }
          actualTargetUserId = networkingProfile.userId;
          const existingNetworking = await storage.getSuiteNetworkingConnection(userId, parseInt(profileId));
          if (existingNetworking) {
            return res.status(409).json({
              message: "Connection already exists",
              connection: existingNetworking
            });
          }
          newConnection = await storage.createSuiteNetworkingConnection({
            userId,
            targetUserId: actualTargetUserId,
            targetProfileId: parseInt(profileId),
            action: "like",
            matched: true
            // Instant match via message
          });
          break;
        case "mentorship":
          const mentorshipProfile = await storage.getSuiteMentorshipProfileById(parseInt(profileId));
          if (!mentorshipProfile) {
            return res.status(404).json({ message: "Mentorship profile not found" });
          }
          actualTargetUserId = mentorshipProfile.userId;
          const existingMentorship = await storage.getSuiteMentorshipConnection(userId, parseInt(profileId));
          if (existingMentorship) {
            return res.status(409).json({
              message: "Connection already exists",
              connection: existingMentorship
            });
          }
          newConnection = await storage.createSuiteMentorshipConnection({
            userId,
            targetUserId: actualTargetUserId,
            targetProfileId: parseInt(profileId),
            action: "like",
            matched: true
            // Instant match via message
          });
          break;
        case "jobs":
          const jobProfile = await storage.getSuiteJobProfileById(parseInt(profileId));
          if (!jobProfile) {
            return res.status(404).json({ message: "Job profile not found" });
          }
          actualTargetUserId = jobProfile.userId;
          const existingJob = await storage.getSuiteJobApplication(userId, parseInt(profileId));
          if (existingJob) {
            return res.status(409).json({
              message: "Application already exists",
              application: existingJob
            });
          }
          newConnection = await storage.createSuiteJobApplication({
            userId,
            targetUserId: actualTargetUserId,
            targetProfileId: parseInt(profileId),
            action: "like",
            applicationStatus: "accepted",
            // Instant acceptance via message
            matched: true
            // Instant match via message
          });
          break;
        default:
          return res.status(400).json({ message: "Invalid connection type" });
      }
      const targetUserWs = connectedUsers2.get(actualTargetUserId);
      if (targetUserWs && targetUserWs.readyState === 1) {
        const notificationData = {
          type: "suite_message_match",
          connectionType,
          fromUserId: userId,
          isMatch: true,
          timestamp: (/* @__PURE__ */ new Date()).toISOString()
        };
        try {
          targetUserWs.send(JSON.stringify(notificationData));
          console.log(`\u2705 Message match notification sent to user ${actualTargetUserId} for ${connectionType}`);
        } catch (error) {
          console.error(`\u274C Failed to send message match notification:`, error);
        }
      }
      try {
        let existingMatch = await storage.getMatchBetweenUsers(userId, actualTargetUserId);
        let chatData;
        if (existingMatch) {
          if (!existingMatch.matched) {
            chatData = await storage.updateMatch(existingMatch.id, {
              matched: true,
              metadata: JSON.stringify({
                origin: "SUITE",
                suiteType: connectionType,
                context: "professional"
              })
            });
          } else {
            let metadata;
            if (!existingMatch.metadata) {
              metadata = {
                origin: "SUITE",
                suiteType: connectionType,
                context: "professional"
              };
            } else {
              try {
                metadata = typeof existingMatch.metadata === "string" ? JSON.parse(existingMatch.metadata) : existingMatch.metadata;
                if (metadata.origin === "SUITE" && metadata.suiteType !== connectionType || metadata.origin === "MEET") {
                  if (!metadata.additionalConnections) {
                    metadata.additionalConnections = [];
                  }
                  if (!metadata.additionalConnections.includes(connectionType)) {
                    metadata.additionalConnections.push(connectionType);
                    console.log(`\u{1F517} Adding ${connectionType} to additionalConnections for existing match ${existingMatch.id} via direct message`);
                    chatData = await storage.updateMatch(existingMatch.id, {
                      metadata: JSON.stringify(metadata)
                    });
                  } else {
                    chatData = existingMatch;
                  }
                } else {
                  chatData = existingMatch;
                }
              } catch (parseError) {
                console.error("Failed to parse existing metadata:", parseError);
                metadata = {
                  origin: "SUITE",
                  suiteType: connectionType,
                  context: "professional"
                };
                chatData = await storage.updateMatch(existingMatch.id, {
                  metadata: JSON.stringify(metadata)
                });
              }
            }
            if (!chatData) {
              chatData = existingMatch;
            }
          }
        } else {
          chatData = await storage.createMatch({
            userId1: userId,
            userId2: actualTargetUserId,
            matched: true,
            metadata: JSON.stringify({
              origin: "SUITE",
              suiteType: connectionType,
              context: "professional"
            })
          });
        }
        console.log(`\u2705 Chat thread created for SUITE ${connectionType} connection:`, chatData.id);
        console.log(`[SWIPE-CLEANUP] Starting cleanup for SUITE instant match between users ${userId} and ${actualTargetUserId} (${connectionType})`);
        try {
          await storage.removeMatchedUsersFromSwipeHistory(userId, actualTargetUserId, `SUITE_${connectionType.toUpperCase()}`);
        } catch (cleanupError) {
          console.error(`[SWIPE-CLEANUP] Failed for SUITE ${connectionType} instant match:`, cleanupError);
        }
        res.status(201).json({
          connection: newConnection,
          isMatch: true,
          chatId: chatData.id,
          message: `Instant ${connectionType} match created via message!`
        });
      } catch (chatError) {
        console.error(`\u274C Failed to create chat thread:`, chatError);
        res.status(201).json({
          connection: newConnection,
          isMatch: true,
          message: `${connectionType} connection created`
        });
      }
    } catch (error) {
      console.error("Error creating message match:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });
  app2.post("/api/suite/connections/networking", async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      const userId = req.user.id;
      const validatedData = insertSuiteNetworkingConnectionSchema.parse(req.body);
      console.log(`Creating networking connection for user ${userId}:`, validatedData);
      if (validatedData.userId !== userId) {
        return res.status(403).json({ message: "Not authorized to create this connection" });
      }
      const existingConnection = await storage.getSuiteNetworkingConnection(
        userId,
        validatedData.targetProfileId
      );
      let connection;
      if (existingConnection) {
        const isDislike = validatedData.action === "pass";
        if (existingConnection.action === validatedData.action && existingConnection.isDislike === isDislike) {
          return res.status(409).json({
            message: "Connection already exists with this state",
            connection: existingConnection
          });
        }
        connection = await storage.updateSuiteNetworkingConnection(existingConnection.id, {
          action: validatedData.action,
          isDislike,
          matched: false
          // Reset match status when action changes
        });
        console.log(`Updated existing networking connection ${existingConnection.id} with new action: ${validatedData.action}`);
      } else {
        const connectionData = {
          ...validatedData,
          isDislike: validatedData.action === "pass"
        };
        connection = await storage.createSuiteNetworkingConnection(connectionData);
        console.log(`Created new networking connection with action: ${validatedData.action}, isDislike: ${connectionData.isDislike}`);
      }
      const userProfileId = await getUserNetworkingProfileId(userId);
      let reciprocalConnection = null;
      if (userProfileId !== null) {
        reciprocalConnection = await storage.getSuiteNetworkingConnection(
          validatedData.targetUserId,
          userProfileId
        );
      }
      let isMatch = false;
      if (reciprocalConnection && reciprocalConnection.action === "like" && validatedData.action === "like" && !reciprocalConnection.isDislike) {
        await storage.updateSuiteNetworkingConnection(connection.id, { matched: true });
        await storage.updateSuiteNetworkingConnection(reciprocalConnection.id, { matched: true });
        isMatch = true;
        console.log(`Created networking match between users ${userId} and ${validatedData.targetUserId}`);
        try {
          const existingMatch = await storage.getMatchBetweenUsers(userId, validatedData.targetUserId);
          if (existingMatch && existingMatch.metadata) {
            const existingMetadata = typeof existingMatch.metadata === "string" ? JSON.parse(existingMatch.metadata) : existingMatch.metadata;
            if (existingMetadata && (existingMetadata.origin === "MEET" || existingMetadata.origin === "SUITE" && existingMetadata.suiteType !== "networking")) {
              if (!existingMetadata.additionalConnections) {
                existingMetadata.additionalConnections = [];
              }
              if (!existingMetadata.additionalConnections.includes("networking")) {
                existingMetadata.additionalConnections.push("networking");
                console.log(`\u{1F517} Adding networking to additionalConnections for existing match ${existingMatch.id} between users ${userId} and ${validatedData.targetUserId}`);
                await storage.updateMatch(existingMatch.id, {
                  metadata: JSON.stringify(existingMetadata)
                });
              }
            }
          } else if (!existingMatch) {
            await storage.createMatch({
              userId1: userId,
              userId2: validatedData.targetUserId,
              matched: true,
              metadata: JSON.stringify({
                origin: "SUITE",
                suiteType: "networking",
                context: "professional"
              })
            });
            console.log(`\u{1F517} Created new match for networking connection between users ${userId} and ${validatedData.targetUserId}`);
          }
        } catch (metadataError) {
          console.error("Failed to process additional connection metadata for networking match:", metadataError);
        }
        try {
          await storage.removeMatchedUsersFromSwipeHistory(userId, validatedData.targetUserId);
          console.log(`[NETWORKING-MATCH] Cleaned up swipe history for matched users: ${userId} \u2194 ${validatedData.targetUserId}`);
        } catch (historyError) {
          console.error("Error cleaning up networking swipe history for matched users:", historyError);
        }
      }
      console.log(`[WEBSOCKET DEBUG] Checking for WebSocket connection for user ${validatedData.targetUserId}`);
      console.log(`[WEBSOCKET DEBUG] Connected users count: ${connectedUsers2.size}`);
      console.log(`[WEBSOCKET DEBUG] Connected user IDs:`, Array.from(connectedUsers2.keys()));
      const targetUserWs = connectedUsers2.get(validatedData.targetUserId);
      if (targetUserWs) {
        console.log(`[WEBSOCKET DEBUG] Found WebSocket for user ${validatedData.targetUserId}, readyState: ${targetUserWs.readyState}`);
        if (targetUserWs.readyState === 1) {
          const fromUser = await storage.getUser(userId);
          const fromNetworkingProfile = await storage.getSuiteNetworkingProfile(userId);
          const notificationData = {
            type: isMatch ? "networking_match" : "networking_connection_request",
            connection: {
              ...connection,
              targetUser: fromUser,
              targetProfile: fromNetworkingProfile
            },
            fromUserId: userId,
            fromUser,
            fromNetworkingProfile,
            isMatch,
            timestamp: (/* @__PURE__ */ new Date()).toISOString()
          };
          try {
            targetUserWs.send(JSON.stringify(notificationData));
            console.log(`\u2705 [WEBSOCKET SUCCESS] Notification sent to user ${validatedData.targetUserId} for networking connection from user ${userId}`);
            console.log(`[WEBSOCKET DATA]`, JSON.stringify(notificationData, null, 2));
          } catch (error) {
            console.error(`\u274C [WEBSOCKET ERROR] Failed to send notification:`, error);
          }
        } else {
          console.log(`\u274C [WEBSOCKET ERROR] WebSocket for user ${validatedData.targetUserId} is not open (readyState: ${targetUserWs.readyState})`);
        }
      } else {
        console.log(`\u274C [WEBSOCKET ERROR] No WebSocket connection found for user ${validatedData.targetUserId}`);
        console.log(`[WEBSOCKET DEBUG] User may not be currently connected or on a different page`);
      }
      res.status(201).json({
        connection,
        isMatch,
        action: validatedData.action,
        message: isMatch ? "It's a professional match!" : validatedData.action === "like" ? "Connection request sent" : "Profile passed"
      });
    } catch (error) {
      if (error instanceof z2.ZodError) {
        return res.status(400).json({ message: "Invalid request data", errors: error.errors });
      }
      console.error("Error creating networking connection:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });
  app2.get("/api/suite/connections/networking", async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      const userId = req.user.id;
      const connections = await storage.getUserNetworkingConnections(userId);
      res.json(connections);
    } catch (error) {
      console.error("Error fetching networking connections:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });
  app2.post("/api/suite/connections/mentorship", async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      const userId = req.user.id;
      const validatedData = insertSuiteMentorshipConnectionSchema.parse(req.body);
      console.log(`Creating mentorship connection for user ${userId}:`, validatedData);
      if (validatedData.userId !== userId) {
        return res.status(403).json({ message: "Not authorized to create this connection" });
      }
      const existingConnection = await storage.getSuiteMentorshipConnection(
        userId,
        validatedData.targetProfileId
      );
      let connection;
      if (existingConnection) {
        const isDislike = validatedData.action === "pass";
        if (existingConnection.action === validatedData.action && existingConnection.isDislike === isDislike) {
          return res.status(409).json({
            message: "Connection already exists with this state",
            connection: existingConnection
          });
        }
        connection = await storage.updateSuiteMentorshipConnection(existingConnection.id, {
          action: validatedData.action,
          isDislike,
          matched: false
          // Reset match status when action changes
        });
        console.log(`Updated existing mentorship connection ${existingConnection.id} with new action: ${validatedData.action}`);
      } else {
        const connectionData = {
          ...validatedData,
          isDislike: validatedData.action === "pass"
        };
        connection = await storage.createSuiteMentorshipConnection(connectionData);
        console.log(`Created new mentorship connection with action: ${validatedData.action}, isDislike: ${connectionData.isDislike}`);
      }
      const userProfileId = await getUserMentorshipProfileId(userId);
      let reciprocalConnection = null;
      if (userProfileId !== null) {
        reciprocalConnection = await storage.getSuiteMentorshipConnection(
          validatedData.targetUserId,
          userProfileId
        );
      }
      let isMatch = false;
      if (reciprocalConnection && reciprocalConnection.action === "like" && validatedData.action === "like" && !reciprocalConnection.isDislike) {
        await storage.updateSuiteMentorshipConnection(connection.id, { matched: true });
        await storage.updateSuiteMentorshipConnection(reciprocalConnection.id, { matched: true });
        isMatch = true;
        console.log(`Created mentorship match between users ${userId} and ${validatedData.targetUserId}`);
        try {
          const existingMatch = await storage.getMatchBetweenUsers(userId, validatedData.targetUserId);
          if (existingMatch && existingMatch.metadata) {
            const existingMetadata = typeof existingMatch.metadata === "string" ? JSON.parse(existingMatch.metadata) : existingMatch.metadata;
            if (existingMetadata && (existingMetadata.origin === "MEET" || existingMetadata.origin === "SUITE" && existingMetadata.suiteType !== "mentorship")) {
              if (!existingMetadata.additionalConnections) {
                existingMetadata.additionalConnections = [];
              }
              if (!existingMetadata.additionalConnections.includes("mentorship")) {
                existingMetadata.additionalConnections.push("mentorship");
                console.log(`\u{1F517} Adding mentorship to additionalConnections for existing match ${existingMatch.id} between users ${userId} and ${validatedData.targetUserId}`);
                await storage.updateMatch(existingMatch.id, {
                  metadata: JSON.stringify(existingMetadata)
                });
              }
            }
          } else if (!existingMatch) {
            await storage.createMatch({
              userId1: userId,
              userId2: validatedData.targetUserId,
              matched: true,
              metadata: JSON.stringify({
                origin: "SUITE",
                suiteType: "mentorship",
                context: "professional"
              })
            });
            console.log(`\u{1F517} Created new match for mentorship connection between users ${userId} and ${validatedData.targetUserId}`);
          }
        } catch (metadataError) {
          console.error("Failed to process additional connection metadata for mentorship match:", metadataError);
        }
        try {
          await storage.removeMatchedUsersFromSwipeHistory(userId, validatedData.targetUserId);
          console.log(`[MENTORSHIP-MATCH] Cleaned up swipe history for matched users: ${userId} \u2194 ${validatedData.targetUserId}`);
        } catch (historyError) {
          console.error("Error cleaning up mentorship swipe history for matched users:", historyError);
        }
      }
      const targetUserWs = connectedUsers2.get(validatedData.targetUserId);
      if (targetUserWs && targetUserWs.readyState === 1) {
        const notificationData = {
          type: isMatch ? "mentorship_match" : "mentorship_connection_request",
          connection,
          fromUserId: userId,
          isMatch,
          timestamp: (/* @__PURE__ */ new Date()).toISOString()
        };
        targetUserWs.send(JSON.stringify(notificationData));
        console.log(`WebSocket notification sent to user ${validatedData.targetUserId} for mentorship connection`);
      }
      res.status(201).json({
        connection,
        isMatch,
        action: validatedData.action,
        message: isMatch ? "It's a mentorship match!" : validatedData.action === "like" ? "Connection request sent" : "Profile passed"
      });
    } catch (error) {
      if (error instanceof z2.ZodError) {
        return res.status(400).json({ message: "Invalid request data", errors: error.errors });
      }
      console.error("Error creating mentorship connection:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });
  app2.get("/api/suite/connections/mentorship", async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      const userId = req.user.id;
      const connections = await storage.getUserMentorshipConnections(userId);
      res.json(connections);
    } catch (error) {
      console.error("Error fetching mentorship connections:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });
  app2.post("/api/suite/connections/jobs", async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      const userId = req.user.id;
      const validatedData = insertSuiteJobApplicationSchema.parse(req.body);
      console.log(`Creating job application for user ${userId}:`, validatedData);
      if (validatedData.userId !== userId) {
        return res.status(403).json({ message: "Not authorized to create this application" });
      }
      const existingApplication = await storage.getSuiteJobApplication(
        userId,
        validatedData.targetProfileId
      );
      if (existingApplication) {
        return res.status(409).json({
          message: "Application already exists",
          application: existingApplication
        });
      }
      const newApplication = await storage.createSuiteJobApplication(validatedData);
      const targetUserWs = connectedUsers2.get(validatedData.targetUserId);
      if (targetUserWs && targetUserWs.readyState === 1) {
        const notificationData = {
          type: "job_application_received",
          application: newApplication,
          fromUserId: userId,
          timestamp: (/* @__PURE__ */ new Date()).toISOString()
        };
        targetUserWs.send(JSON.stringify(notificationData));
        console.log(`WebSocket notification sent to user ${validatedData.targetUserId} for job application`);
      }
      res.status(201).json({
        application: newApplication,
        message: "Application submitted successfully"
      });
    } catch (error) {
      if (error instanceof z2.ZodError) {
        return res.status(400).json({ message: "Invalid request data", errors: error.errors });
      }
      console.error("Error creating job application:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });
  app2.get("/api/suite/connections/jobs", async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      const userId = req.user.id;
      const applications = await storage.getUserJobApplications(userId);
      res.json(applications);
    } catch (error) {
      console.error("Error fetching job applications:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });
  app2.post("/api/suite/connections/networking/:connectionId/respond", async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      const userId = req.user.id;
      const connectionId = parseInt(req.params.connectionId);
      const { action } = req.body;
      if (!["accept", "decline"].includes(action)) {
        return res.status(400).json({ message: "Invalid action" });
      }
      const connection = await storage.getSuiteNetworkingConnectionById(connectionId);
      if (!connection) {
        return res.status(404).json({ message: "Connection not found" });
      }
      if (connection.targetUserId !== userId) {
        return res.status(403).json({ message: "Unauthorized to respond to this connection" });
      }
      let isMatch = false;
      if (action === "accept") {
        await storage.updateSuiteNetworkingConnection(connectionId, { matched: true });
        const reciprocalConnection = await storage.getSuiteNetworkingConnection(
          connection.userId,
          connection.targetProfileId
        );
        if (reciprocalConnection) {
          await storage.updateSuiteNetworkingConnection(reciprocalConnection.id, { matched: true });
        }
        isMatch = true;
        const timestamp2 = (/* @__PURE__ */ new Date()).toISOString();
        const requesterWs = connectedUsers2.get(connection.userId);
        if (requesterWs && requesterWs.readyState === 1) {
          const notificationData = {
            type: "networking_match",
            connection,
            acceptedBy: userId,
            isMatch: true,
            timestamp: timestamp2
          };
          requesterWs.send(JSON.stringify(notificationData));
          console.log(`WebSocket networking match notification sent to requester ${connection.userId}`);
        }
        const accepterWs = connectedUsers2.get(userId);
        if (accepterWs && accepterWs.readyState === 1) {
          const notificationData = {
            type: "networking_match",
            connection,
            acceptedBy: userId,
            isMatch: true,
            timestamp: timestamp2
          };
          accepterWs.send(JSON.stringify(notificationData));
          console.log(`WebSocket networking match notification sent to accepter ${userId}`);
        }
      } else {
        await storage.deleteSuiteNetworkingConnectionById(connectionId);
      }
      res.json({
        success: true,
        isMatch,
        message: action === "accept" ? "Connection accepted" : "Connection declined"
      });
    } catch (error) {
      console.error("Error responding to networking connection:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });
  app2.post("/api/suite/connections/mentorship/:connectionId/respond", async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      const userId = req.user.id;
      const connectionId = parseInt(req.params.connectionId);
      const { action } = req.body;
      if (!["accept", "decline"].includes(action)) {
        return res.status(400).json({ message: "Invalid action" });
      }
      const connection = await storage.getSuiteMentorshipConnectionById(connectionId);
      if (!connection) {
        return res.status(404).json({ message: "Connection not found" });
      }
      if (connection.targetUserId !== userId) {
        return res.status(403).json({ message: "Unauthorized to respond to this connection" });
      }
      let isMatch = false;
      if (action === "accept") {
        await storage.updateSuiteMentorshipConnection(connectionId, { matched: true });
        const reciprocalConnection = await storage.getSuiteMentorshipConnection(
          connection.userId,
          connection.targetProfileId
        );
        if (reciprocalConnection) {
          await storage.updateSuiteMentorshipConnection(reciprocalConnection.id, { matched: true });
        }
        isMatch = true;
        const timestamp2 = (/* @__PURE__ */ new Date()).toISOString();
        const requesterWs = connectedUsers2.get(connection.userId);
        if (requesterWs && requesterWs.readyState === 1) {
          const notificationData = {
            type: "mentorship_match",
            connection,
            acceptedBy: userId,
            isMatch: true,
            timestamp: timestamp2
          };
          requesterWs.send(JSON.stringify(notificationData));
          console.log(`WebSocket mentorship match notification sent to requester ${connection.userId}`);
        }
        const accepterWs = connectedUsers2.get(userId);
        if (accepterWs && accepterWs.readyState === 1) {
          const notificationData = {
            type: "mentorship_match",
            connection,
            acceptedBy: userId,
            isMatch: true,
            timestamp: timestamp2
          };
          accepterWs.send(JSON.stringify(notificationData));
          console.log(`WebSocket mentorship match notification sent to accepter ${userId}`);
        }
      } else {
        await storage.deleteSuiteMentorshipConnectionById(connectionId);
      }
      res.json({
        success: true,
        isMatch,
        message: action === "accept" ? "Connection accepted" : "Connection declined"
      });
    } catch (error) {
      console.error("Error responding to mentorship connection:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });
  app2.post("/api/suite/connections/networking/respond", async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      const currentUserId = req.user.id;
      const { requesterUserId, targetProfileId, action } = req.body;
      if (!requesterUserId || !targetProfileId || !["accept", "decline"].includes(action)) {
        return res.status(400).json({ message: "Invalid request data" });
      }
      const existingConnection = await storage.getSuiteNetworkingConnection(
        requesterUserId,
        targetProfileId
      );
      if (!existingConnection) {
        return res.status(404).json({ message: "Connection request not found" });
      }
      if (existingConnection.targetUserId !== currentUserId) {
        return res.status(403).json({ message: "Unauthorized to respond to this connection" });
      }
      let isMatch = false;
      if (action === "accept") {
        await storage.updateSuiteNetworkingConnection(existingConnection.id, { matched: true });
        isMatch = true;
        console.log(`\u{1F50D} [NETWORKING-RESPONSE] Checking for existing matches between users ${currentUserId} and ${requesterUserId}`);
        const existingMatch = await storage.getMatchBetweenUsers(currentUserId, requesterUserId);
        if (existingMatch && existingMatch.metadata) {
          console.log(`\u{1F50D} [NETWORKING-RESPONSE] Found existing match ${existingMatch.id}, checking metadata`);
          const existingMetadata = typeof existingMatch.metadata === "string" ? JSON.parse(existingMatch.metadata) : existingMatch.metadata;
          console.log(`\u{1F50D} [NETWORKING-RESPONSE] Current metadata: ${JSON.stringify(existingMetadata)}`);
          if (existingMetadata && (existingMetadata.origin === "MEET" || existingMetadata.origin === "SUITE" && existingMetadata.suiteType !== "networking")) {
            console.log(`\u{1F517} [NETWORKING-RESPONSE] Found different connection type, adding networking as additional connection`);
            if (!existingMetadata.additionalConnections) {
              existingMetadata.additionalConnections = [];
            }
            if (!existingMetadata.additionalConnections.includes("networking")) {
              existingMetadata.additionalConnections.push("networking");
              console.log(`\u{1F517} [NETWORKING-RESPONSE] Adding networking to additionalConnections for existing match ${existingMatch.id} between users ${currentUserId} and ${requesterUserId}`);
              console.log(`\u{1F517} [NETWORKING-RESPONSE] New additionalConnections: ${JSON.stringify(existingMetadata.additionalConnections)}`);
              await storage.updateMatch(existingMatch.id, {
                metadata: JSON.stringify(existingMetadata)
              });
              console.log(`\u{1F517} [NETWORKING-RESPONSE] Successfully updated existing match metadata`);
            } else {
              console.log(`\u{1F517} [NETWORKING-RESPONSE] Networking already exists in additionalConnections`);
            }
          } else {
            console.log(`\u{1F517} [NETWORKING-RESPONSE] Same connection type or no metadata, no additional connection needed`);
          }
        } else if (!existingMatch) {
          console.log(`\u{1F517} [NETWORKING-RESPONSE] No existing match found, creating new match entry for messaging system`);
          const matchData = {
            userId1: Math.min(currentUserId, requesterUserId),
            userId2: Math.max(currentUserId, requesterUserId),
            matched: true,
            isDislike: false,
            metadata: JSON.stringify({ origin: "SUITE", suiteType: "networking", context: "professional" })
          };
          await storage.createMatch(matchData);
          console.log(`\u{1F517} [NETWORKING-RESPONSE] Created new match for networking connection`);
        } else {
          console.log(`\u{1F50D} [NETWORKING-RESPONSE] Existing match found but no metadata, skipping additional connection logic`);
        }
        const acceptedByUser = await storage.getUser(currentUserId);
        const requesterUser = await storage.getUser(requesterUserId);
        const requesterWs = connectedUsers2.get(requesterUserId);
        if (requesterWs && requesterWs.readyState === 1) {
          const notificationData = {
            type: "networking_match",
            connection: {
              id: existingConnection.id,
              userId: existingConnection.userId,
              targetUserId: existingConnection.targetUserId
            },
            acceptedBy: currentUserId,
            isMatch: true,
            timestamp: (/* @__PURE__ */ new Date()).toISOString(),
            matchedUserName: acceptedByUser?.fullName,
            matchedUserPhoto: acceptedByUser?.photoUrl,
            matchedUserProfession: acceptedByUser?.profession,
            matchedUserLocation: acceptedByUser?.location
          };
          requesterWs.send(JSON.stringify(notificationData));
        }
        const accepterWs = connectedUsers2.get(currentUserId);
        if (accepterWs && accepterWs.readyState === 1) {
          const notificationData = {
            type: "networking_match",
            connection: {
              id: existingConnection.id,
              userId: existingConnection.userId,
              targetUserId: existingConnection.targetUserId
            },
            acceptedBy: currentUserId,
            isMatch: true,
            timestamp: (/* @__PURE__ */ new Date()).toISOString(),
            matchedUserName: requesterUser?.fullName,
            matchedUserPhoto: requesterUser?.photoUrl,
            matchedUserProfession: requesterUser?.profession,
            matchedUserLocation: requesterUser?.location
          };
          accepterWs.send(JSON.stringify(notificationData));
          console.log(`[SUITE-MATCH] Sent networking match notification to accepter (User ${currentUserId})`);
        }
      } else {
        await storage.updateSuiteNetworkingConnection(existingConnection.id, {
          action: "pass",
          isDislike: true,
          matched: false
        });
      }
      res.json({
        success: true,
        isMatch,
        action,
        message: action === "accept" ? "Connection accepted" : "Connection declined"
      });
    } catch (error) {
      console.error("Error responding to networking connection:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });
  app2.post("/api/suite/connections/mentorship/respond", async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      const currentUserId = req.user.id;
      const { requesterUserId, targetProfileId, action } = req.body;
      if (!requesterUserId || !targetProfileId || !["accept", "decline"].includes(action)) {
        return res.status(400).json({ message: "Invalid request data" });
      }
      const existingConnection = await storage.getSuiteMentorshipConnection(
        requesterUserId,
        targetProfileId
      );
      if (!existingConnection) {
        return res.status(404).json({ message: "Connection request not found" });
      }
      if (existingConnection.targetUserId !== currentUserId) {
        return res.status(403).json({ message: "Unauthorized to respond to this connection" });
      }
      let isMatch = false;
      if (action === "accept") {
        await storage.updateSuiteMentorshipConnection(existingConnection.id, { matched: true });
        isMatch = true;
        const existingMatch = await storage.getMatchBetweenUsers(currentUserId, requesterUserId);
        let finalMatch;
        if (existingMatch) {
          try {
            let existingMetadata;
            if (existingMatch.metadata) {
              existingMetadata = typeof existingMatch.metadata === "string" ? JSON.parse(existingMatch.metadata) : existingMatch.metadata;
            }
            if (existingMetadata) {
              if (existingMetadata.origin === "SUITE" && existingMetadata.suiteType !== "mentorship" || existingMetadata.origin === "MEET") {
                if (!existingMetadata.additionalConnections) {
                  existingMetadata.additionalConnections = [];
                }
                if (!existingMetadata.additionalConnections.includes("mentorship")) {
                  existingMetadata.additionalConnections.push("mentorship");
                  console.log(`\u{1F517} Adding mentorship to additionalConnections for existing match ${existingMatch.id} between users ${currentUserId} and ${requesterUserId}`);
                }
                finalMatch = await storage.updateMatch(existingMatch.id, {
                  matched: true,
                  metadata: JSON.stringify(existingMetadata)
                });
              } else {
                finalMatch = await storage.updateMatch(existingMatch.id, {
                  matched: true,
                  metadata: JSON.stringify({ origin: "SUITE", suiteType: "mentorship", context: "professional" })
                });
                console.log(`\u{1F517} Updated existing match ${existingMatch.id} with mentorship metadata`);
              }
            } else {
              finalMatch = await storage.updateMatch(existingMatch.id, {
                matched: true,
                metadata: JSON.stringify({ origin: "SUITE", suiteType: "mentorship", context: "professional" })
              });
              console.log(`\u{1F517} Added mentorship metadata to existing match ${existingMatch.id}`);
            }
          } catch (parseError) {
            console.error("Failed to parse existing metadata:", parseError);
            finalMatch = await storage.updateMatch(existingMatch.id, {
              matched: true,
              metadata: JSON.stringify({ origin: "SUITE", suiteType: "mentorship", context: "professional" })
            });
          }
        } else {
          const matchData = {
            userId1: Math.min(currentUserId, requesterUserId),
            userId2: Math.max(currentUserId, requesterUserId),
            matched: true,
            isDislike: false,
            metadata: JSON.stringify({ origin: "SUITE", suiteType: "mentorship", context: "professional" })
          };
          finalMatch = await storage.createMatch(matchData);
          console.log(`\u{1F517} Created new mentorship match between users ${currentUserId} and ${requesterUserId}`);
        }
        const acceptedByUser = await storage.getUser(currentUserId);
        const requesterUser = await storage.getUser(requesterUserId);
        const requesterWs = connectedUsers2.get(requesterUserId);
        if (requesterWs && requesterWs.readyState === 1) {
          const notificationData = {
            type: "mentorship_match",
            connection: {
              id: existingConnection.id,
              userId: existingConnection.userId,
              targetUserId: existingConnection.targetUserId
            },
            acceptedBy: currentUserId,
            isMatch: true,
            timestamp: (/* @__PURE__ */ new Date()).toISOString(),
            matchedUserName: acceptedByUser?.fullName,
            matchedUserPhoto: acceptedByUser?.photoUrl,
            matchedUserProfession: acceptedByUser?.profession,
            matchedUserLocation: acceptedByUser?.location
          };
          requesterWs.send(JSON.stringify(notificationData));
        }
        const accepterWs = connectedUsers2.get(currentUserId);
        if (accepterWs && accepterWs.readyState === 1) {
          const notificationData = {
            type: "mentorship_match",
            connection: {
              id: existingConnection.id,
              userId: existingConnection.userId,
              targetUserId: existingConnection.targetUserId
            },
            acceptedBy: currentUserId,
            isMatch: true,
            timestamp: (/* @__PURE__ */ new Date()).toISOString(),
            matchedUserName: requesterUser?.fullName,
            matchedUserPhoto: requesterUser?.photoUrl,
            matchedUserProfession: requesterUser?.profession,
            matchedUserLocation: requesterUser?.location
          };
          accepterWs.send(JSON.stringify(notificationData));
          console.log(`[SUITE-MATCH] Sent mentorship match notification to accepter (User ${currentUserId})`);
        }
      } else {
        await storage.updateSuiteMentorshipConnection(existingConnection.id, {
          action: "pass",
          isDislike: true,
          matched: false
        });
      }
      res.json({
        success: true,
        isMatch,
        action,
        message: action === "accept" ? "Connection accepted" : "Connection declined"
      });
    } catch (error) {
      console.error("Error responding to mentorship connection:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });
  app2.get("/api/suite/connections/counts", async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      const userId = req.user.id;
      const [networkingConnections, mentorshipConnections, jobApplications] = await Promise.all([
        storage.getUserNetworkingConnections(userId),
        storage.getUserMentorshipConnections(userId),
        storage.getUserJobApplications(userId)
      ]);
      const networkingMatches = networkingConnections.filter((c) => c.matched).length;
      const networkingPending = networkingConnections.filter((c) => !c.matched && c.action === "like").length;
      const mentorshipMatches = mentorshipConnections.filter((c) => c.matched).length;
      const mentorshipPending = mentorshipConnections.filter((c) => !c.matched && c.action === "like").length;
      const jobApplicationsCount = jobApplications.length;
      const jobApplicationsPending = jobApplications.length;
      res.json({
        networking: {
          matches: networkingMatches,
          pending: networkingPending,
          total: networkingConnections.length
        },
        mentorship: {
          matches: mentorshipMatches,
          pending: mentorshipPending,
          total: mentorshipConnections.length
        },
        jobs: {
          applications: jobApplicationsCount,
          pending: jobApplicationsPending,
          total: jobApplications.length
        }
      });
    } catch (error) {
      console.error("Error fetching connection counts:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });
}
async function getUserNetworkingProfileId(userId) {
  try {
    const profile = await storage.getSuiteNetworkingProfile(userId);
    return profile?.id || null;
  } catch (error) {
    console.error("Error getting user networking profile ID:", error);
    return null;
  }
}
async function getUserMentorshipProfileId(userId) {
  try {
    const profile = await storage.getSuiteMentorshipProfile(userId);
    return profile?.id || null;
  } catch (error) {
    console.error("Error getting user mentorship profile ID:", error);
    return null;
  }
}

// server/compatibility-api.ts
init_db();
init_schema();
import { eq as eq2, and as and2, or as or2 } from "drizzle-orm";
function computeCompatibilityData(user1, user2) {
  const mockData = {
    overall_score: Math.floor(Math.random() * 30) + 70,
    // 70-100% (integer)
    computed_at: (/* @__PURE__ */ new Date()).toISOString(),
    version: 1,
    // Integer version
    categories: {
      personality: Math.floor(Math.random() * 20) + 80,
      lifestyle: Math.floor(Math.random() * 25) + 75,
      values: Math.floor(Math.random() * 15) + 85,
      interests: Math.floor(Math.random() * 30) + 70,
      communication: Math.floor(Math.random() * 20) + 80
    },
    personality_analysis: {
      big5_compatibility: {
        openness: { user1: 88, user2: 85, match: 95 },
        conscientiousness: { user1: 70, user2: 78, match: 88 },
        extraversion: { user1: 75, user2: 82, match: 92 },
        agreeableness: { user1: 85, user2: 80, match: 90 },
        neuroticism: { user1: 35, user2: 28, match: 89 }
      }
    },
    shared_interests: [
      { name: "Travel", match: 95, icon: "\u2708\uFE0F", category: "adventure" },
      { name: "Photography", match: 88, icon: "\u{1F4F8}", category: "creative" },
      { name: "Coffee", match: 92, icon: "\u2615", category: "lifestyle" },
      { name: "Art Museums", match: 85, icon: "\u{1F3A8}", category: "culture" },
      { name: "Hiking", match: 78, icon: "\u{1F97E}", category: "outdoor" },
      { name: "Live Music", match: 82, icon: "\u{1F3B5}", category: "entertainment" }
    ],
    insights: {
      strengths: [
        "Shared passion for travel and adventure",
        "Similar communication styles",
        "Compatible life goals and values",
        "Complementary personality traits"
      ],
      growth_areas: [
        "Different approaches to social activities",
        "Varying interests in creative pursuits",
        "Different preferred pace of life"
      ],
      recommendations: [
        "Plan adventure trips together to strengthen your bond",
        "Explore new creative activities as a couple",
        "Discuss your social preferences openly",
        "Find balance between active and relaxed activities"
      ]
    },
    conversation_starters: [
      `Ask about ${user2.fullName || "their"} interests and hobbies`,
      "Share your favorite travel destination",
      "Discuss your favorite local spots",
      "Plan an activity you both enjoy"
    ],
    date_ideas: [
      {
        activity: "Photography Walk",
        location: "Brooklyn Bridge",
        duration: "2-3 hours",
        match: 95,
        description: "Capture the city together while exploring iconic spots",
        tags: ["Creative", "Outdoor", "Romantic"]
      },
      {
        activity: "Coffee & Art",
        location: "MoMA + Local Caf\xE9",
        duration: "3-4 hours",
        match: 88,
        description: "Discuss art over expertly crafted coffee",
        tags: ["Cultural", "Intimate", "Inspiring"]
      }
    ],
    compatibility_timeline: [
      {
        date: "Dec 8, 2024",
        time: "2:47 PM",
        title: "Matched",
        description: "Initial compatibility established",
        score: 73,
        status: "completed"
      },
      {
        date: "Dec 8, 2024",
        time: "6:23 PM",
        title: "First Conversation",
        description: "Discussed art and travel",
        score: 78,
        status: "completed"
      },
      {
        date: "Dec 12, 2024",
        time: "Evening",
        title: "Deep Connection",
        description: "Shared personal stories",
        score: 81,
        status: "completed"
      },
      {
        date: "Dec 18, 2024",
        time: "All day",
        title: "Values Alignment",
        description: "Discovered shared life goals",
        score: 85,
        status: "completed"
      },
      {
        date: "Dec 25, 2024",
        time: "Future",
        title: "First Date",
        description: "Planned coffee & art gallery visit",
        score: 90,
        status: "upcoming"
      }
    ],
    profiles: {
      user: {
        name: "You",
        age: user1.dateOfBirth ? Math.floor(
          (Date.now() - new Date(user1.dateOfBirth).getTime()) / (365.25 * 24 * 60 * 60 * 1e3)
        ) : 25,
        location: user1.location || "Unknown",
        photo: user1.photoUrl || "",
        bio: user1.bio || ""
      },
      match: {
        name: user2.fullName || "",
        age: user2.dateOfBirth ? Math.floor(
          (Date.now() - new Date(user2.dateOfBirth).getTime()) / (365.25 * 24 * 60 * 60 * 1e3)
        ) : 0,
        location: user2.location || "",
        photo: user2.photoUrl || "",
        bio: user2.bio || ""
      }
    }
  };
  return mockData;
}
function registerCompatibilityAPI(app2) {
  app2.get("/api/compatibility/test", async (req, res) => {
    return res.json({
      message: "Compatibility API is working!",
      timestamp: (/* @__PURE__ */ new Date()).toISOString()
    });
  });
  app2.get(
    "/api/compatibility/:user1Id/:user2Id",
    async (req, res) => {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      try {
        const user1Id = parseInt(req.params.user1Id);
        const user2Id = parseInt(req.params.user2Id);
        const currentUserId = req.user.id;
        if (currentUserId !== user1Id && currentUserId !== user2Id) {
          return res.status(403).json({ message: "Access denied" });
        }
        const [normalizedUser1Id, normalizedUser2Id] = user1Id < user2Id ? [user1Id, user2Id] : [user2Id, user1Id];
        const existingAnalysis = await db.select().from(compatibilityAnalysis).where(
          and2(
            or2(
              and2(
                eq2(compatibilityAnalysis.user1Id, normalizedUser1Id),
                eq2(compatibilityAnalysis.user2Id, normalizedUser2Id)
              ),
              and2(
                eq2(compatibilityAnalysis.user1Id, normalizedUser2Id),
                eq2(compatibilityAnalysis.user2Id, normalizedUser1Id)
              )
            ),
            eq2(compatibilityAnalysis.isActive, true)
          )
        ).limit(1);
        if (existingAnalysis.length > 0) {
          const analysis = existingAnalysis[0];
          return res.json({
            id: analysis.id,
            user1Id: analysis.user1Id,
            user2Id: analysis.user2Id,
            overallScore: analysis.overallScore,
            compatibilityData: typeof analysis.compatibilityData === "string" ? JSON.parse(analysis.compatibilityData) : analysis.compatibilityData,
            computedAt: analysis.computedAt,
            version: analysis.version
          });
        }
        const [user1Data] = await db.select().from(users).where(eq2(users.id, user1Id)).limit(1);
        const [user2Data] = await db.select().from(users).where(eq2(users.id, user2Id)).limit(1);
        if (!user1Data || !user2Data) {
          return res.status(404).json({ message: "One or both users not found" });
        }
        const compatibilityData = computeCompatibilityData(
          user1Data,
          user2Data
        );
        const newAnalysis = await db.insert(compatibilityAnalysis).values({
          user1Id: normalizedUser1Id,
          user2Id: normalizedUser2Id,
          compatibilityData: JSON.stringify(compatibilityData),
          overallScore: Math.round(compatibilityData.overall_score),
          // Ensure integer
          version: "1",
          isActive: true
        }).returning();
        return res.json({
          id: newAnalysis[0].id,
          user1Id: newAnalysis[0].user1Id,
          user2Id: newAnalysis[0].user2Id,
          overallScore: newAnalysis[0].overallScore,
          compatibilityData,
          computedAt: newAnalysis[0].computedAt,
          version: newAnalysis[0].version
        });
      } catch (error) {
        console.error("Error in compatibility analysis:", error);
        return res.status(500).json({ message: "Internal server error" });
      }
    }
  );
  app2.delete(
    "/api/compatibility/:user1Id/:user2Id",
    async (req, res) => {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      try {
        const user1Id = parseInt(req.params.user1Id);
        const user2Id = parseInt(req.params.user2Id);
        const currentUserId = req.user.id;
        if (currentUserId !== user1Id && currentUserId !== user2Id) {
          return res.status(403).json({ message: "Access denied" });
        }
        await db.update(compatibilityAnalysis).set({
          isActive: false,
          updatedAt: /* @__PURE__ */ new Date()
        }).where(
          and2(
            or2(
              and2(
                eq2(compatibilityAnalysis.user1Id, user1Id),
                eq2(compatibilityAnalysis.user2Id, user2Id)
              ),
              and2(
                eq2(compatibilityAnalysis.user1Id, user2Id),
                eq2(compatibilityAnalysis.user2Id, user1Id)
              )
            ),
            eq2(compatibilityAnalysis.isActive, true)
          )
        );
        return res.json({
          message: "Compatibility analysis deleted successfully"
        });
      } catch (error) {
        console.error("Error deleting compatibility analysis:", error);
        return res.status(500).json({ message: "Internal server error" });
      }
    }
  );
  app2.put(
    "/api/compatibility/:user1Id/:user2Id",
    async (req, res) => {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      try {
        const user1Id = parseInt(req.params.user1Id);
        const user2Id = parseInt(req.params.user2Id);
        const currentUserId = req.user.id;
        if (currentUserId !== user1Id && currentUserId !== user2Id) {
          return res.status(403).json({ message: "Access denied" });
        }
        const [user1Data] = await db.select().from(users).where(eq2(users.id, user1Id)).limit(1);
        const [user2Data] = await db.select().from(users).where(eq2(users.id, user2Id)).limit(1);
        if (!user1Data || !user2Data) {
          return res.status(404).json({ message: "One or both users not found" });
        }
        const compatibilityData = computeCompatibilityData(
          user1Data,
          user2Data
        );
        const updatedAnalysis = await db.update(compatibilityAnalysis).set({
          compatibilityData: JSON.stringify(compatibilityData),
          overallScore: Math.round(compatibilityData.overall_score),
          // Ensure integer
          updatedAt: /* @__PURE__ */ new Date()
        }).where(
          and2(
            or2(
              and2(
                eq2(compatibilityAnalysis.user1Id, user1Id),
                eq2(compatibilityAnalysis.user2Id, user2Id)
              ),
              and2(
                eq2(compatibilityAnalysis.user1Id, user2Id),
                eq2(compatibilityAnalysis.user2Id, user1Id)
              )
            ),
            eq2(compatibilityAnalysis.isActive, true)
          )
        ).returning();
        if (updatedAnalysis.length === 0) {
          return res.status(404).json({ message: "Compatibility analysis not found" });
        }
        return res.json({
          id: updatedAnalysis[0].id,
          user1Id: updatedAnalysis[0].user1Id,
          user2Id: updatedAnalysis[0].user2Id,
          overallScore: updatedAnalysis[0].overallScore,
          compatibilityData,
          computedAt: updatedAnalysis[0].computedAt,
          updatedAt: updatedAnalysis[0].updatedAt,
          version: updatedAnalysis[0].version
        });
      } catch (error) {
        console.error("Error updating compatibility analysis:", error);
        return res.status(500).json({ message: "Internal server error" });
      }
    }
  );
  app2.get(
    "/api/match-dashboard/:matchId",
    async (req, res) => {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      try {
        const matchId = parseInt(req.params.matchId);
        const currentUserId = req.user.id;
        const [match] = await db.select().from(matches).where(eq2(matches.id, matchId)).limit(1);
        if (!match) {
          return res.status(404).json({ message: "Match not found" });
        }
        if (currentUserId !== match.userId1 && currentUserId !== match.userId2) {
          return res.status(403).json({ message: "Access denied" });
        }
        const user1Id = match.userId1;
        const user2Id = match.userId2;
        const compatibilityResponse = await fetch(
          `${req.protocol}://${req.get("host")}/api/compatibility/${user1Id}/${user2Id}`,
          {
            headers: {
              Cookie: req.headers.cookie || ""
            }
          }
        );
        if (!compatibilityResponse.ok) {
          return res.status(500).json({ message: "Failed to get compatibility analysis" });
        }
        const compatibilityData = await compatibilityResponse.json();
        return res.json({
          matchId,
          compatibility: compatibilityData
        });
      } catch (error) {
        console.error("Error in match dashboard:", error);
        return res.status(500).json({ message: "Internal server error" });
      }
    }
  );
}

// server/suite-compatibility-api.ts
init_storage();
var SuiteCompatibilityEngine = class {
  /**
   * Calculate comprehensive professional compatibility between two users
   */
  static calculateCompatibility(viewerProfile, targetProfile, viewerUser, targetUser) {
    const synergyScore = this.calculateSynergyScore(viewerProfile, targetProfile);
    const networkValueScore = this.calculateNetworkValueScore(targetProfile, targetUser);
    const collaborationScore = this.calculateCollaborationScore(viewerProfile, targetProfile);
    const exchangeScore = this.calculateExchangeScore(viewerProfile, targetProfile);
    const geographicFit = this.calculateGeographicFit(viewerUser, targetUser);
    const culturalAlignment = this.calculateCulturalAlignment(viewerUser, targetUser);
    const overallStarRating = Math.round(
      (synergyScore * 0.25 + networkValueScore * 0.2 + collaborationScore * 0.2 + exchangeScore * 0.15 + geographicFit * 0.1 + culturalAlignment * 0.1) * 10
    ) / 10;
    const insights = this.generateInsights(
      synergyScore,
      networkValueScore,
      collaborationScore,
      exchangeScore,
      geographicFit,
      culturalAlignment,
      viewerProfile,
      targetProfile,
      viewerUser,
      targetUser
    );
    const suggestedActions = this.generateSuggestedActions(
      overallStarRating,
      insights,
      viewerProfile,
      targetProfile
    );
    const breakdown = {
      industryAlignment: this.calculateIndustryAlignment(viewerProfile, targetProfile),
      goalsSynergy: this.calculateGoalsSynergy(viewerProfile, targetProfile),
      skillComplementarity: this.calculateSkillComplementarity(viewerProfile, targetProfile),
      locationAdvantage: geographicFit,
      experienceMatch: this.calculateExperienceMatch(viewerProfile, targetProfile)
    };
    return {
      synergyScore,
      networkValueScore,
      collaborationScore,
      exchangeScore,
      geographicFit,
      culturalAlignment,
      overallStarRating,
      insights,
      suggestedActions,
      breakdown
    };
  }
  static calculateSynergyScore(viewerProfile, targetProfile) {
    let score = 5;
    if (viewerProfile.industry && targetProfile.industry) {
      if (viewerProfile.industry === targetProfile.industry) {
        score += 2;
      } else if (this.isComplementaryIndustry(viewerProfile.industry, targetProfile.industry)) {
        score += 1.5;
      }
    }
    const viewerGoals = this.parseGoals(viewerProfile.networkingGoals || "");
    const targetGoals = this.parseGoals(targetProfile.networkingGoals || "");
    const goalOverlap = this.calculateGoalOverlap(viewerGoals, targetGoals);
    score += goalOverlap * 2;
    const lookingForMatch = this.calculateLookingForMatch(viewerProfile, targetProfile);
    score += lookingForMatch * 1.5;
    return Math.min(10, Math.max(1, score));
  }
  static calculateNetworkValueScore(targetProfile, targetUser) {
    let score = 5;
    if (targetProfile.currentRole) {
      const role = targetProfile.currentRole.toLowerCase();
      if (role.includes("ceo") || role.includes("founder") || role.includes("president")) {
        score += 2;
      } else if (role.includes("director") || role.includes("head") || role.includes("lead")) {
        score += 1.5;
      } else if (role.includes("senior") || role.includes("manager")) {
        score += 1;
      }
    }
    if (targetProfile.industry) {
      const highValueIndustries = ["technology", "finance", "consulting", "healthcare", "aerospace"];
      if (highValueIndustries.some((industry) => targetProfile.industry.toLowerCase().includes(industry))) {
        score += 1;
      }
    }
    if (targetUser.location === "Diaspora" && targetUser.countryOfOrigin === "Ghana") {
      score += 1.5;
    }
    return Math.min(10, Math.max(1, score));
  }
  static calculateCollaborationScore(viewerProfile, targetProfile) {
    let score = 5;
    const viewerCollabTypes = this.parseCollaborationTypes(viewerProfile.collaborationTypes);
    const targetCollabTypes = this.parseCollaborationTypes(targetProfile.collaborationTypes);
    const collabMatch = this.calculateCollaborationMatch(viewerCollabTypes, targetCollabTypes);
    score += collabMatch * 2;
    if (viewerProfile.workingStyle && targetProfile.workingStyle) {
      const styleCompatibility = this.calculateWorkingStyleCompatibility(
        viewerProfile.workingStyle,
        targetProfile.workingStyle
      );
      score += styleCompatibility * 1.5;
    }
    if (viewerProfile.availability && targetProfile.availability) {
      const timeMatch = this.calculateTimeCompatibility(
        viewerProfile.availability,
        targetProfile.availability
      );
      score += timeMatch;
    }
    return Math.min(10, Math.max(1, score));
  }
  static calculateExchangeScore(viewerProfile, targetProfile) {
    let score = 5;
    const viewerLookingFor = this.parseSkillsAndGoals(viewerProfile.lookingFor || "");
    const targetCanOffer = this.parseSkillsAndGoals(targetProfile.canOffer || "");
    const offerMatch = this.calculateSkillMatch(viewerLookingFor, targetCanOffer);
    score += offerMatch * 2;
    const targetLookingFor = this.parseSkillsAndGoals(targetProfile.lookingFor || "");
    const viewerCanOffer = this.parseSkillsAndGoals(viewerProfile.canOffer || "");
    const seekMatch = this.calculateSkillMatch(targetLookingFor, viewerCanOffer);
    score += seekMatch * 2;
    const balance = Math.abs(offerMatch - seekMatch);
    if (balance <= 0.5) score += 1;
    return Math.min(10, Math.max(1, score));
  }
  static calculateGeographicFit(viewerUser, targetUser) {
    let score = 5;
    if (viewerUser.location === targetUser.location) {
      score += 2;
    } else if (viewerUser.location === "Ghana" && targetUser.location === "Diaspora" || viewerUser.location === "Diaspora" && targetUser.location === "Ghana") {
      score += 3;
    }
    if (viewerUser.countryOfOrigin === targetUser.countryOfOrigin) {
      score += 1;
    }
    return Math.min(10, Math.max(1, score));
  }
  static calculateCulturalAlignment(viewerUser, targetUser) {
    let score = 5;
    if (viewerUser.ethnicity === targetUser.ethnicity) {
      score += 1.5;
    }
    if (viewerUser.secondaryTribe === targetUser.ethnicity || viewerUser.ethnicity === targetUser.secondaryTribe) {
      score += 1;
    }
    if (viewerUser.religion === targetUser.religion) {
      score += 0.5;
    }
    if (viewerUser.countryOfOrigin === "Ghana" && targetUser.countryOfOrigin === "Ghana") {
      score += 1;
    }
    return Math.min(10, Math.max(1, score));
  }
  static generateInsights(synergyScore, networkValueScore, collaborationScore, exchangeScore, geographicFit, culturalAlignment, viewerProfile, targetProfile, viewerUser, targetUser) {
    const insights = [];
    if (synergyScore >= 8) {
      insights.push("Strong professional alignment in goals and industry focus");
    } else if (synergyScore >= 6) {
      insights.push("Good potential for professional collaboration");
    }
    if (networkValueScore >= 8) {
      insights.push("High-value connection with significant industry influence");
    } else if (networkValueScore >= 6) {
      insights.push("Valuable professional contact with growth potential");
    }
    if (geographicFit >= 8) {
      if (viewerUser.location !== targetUser.location) {
        insights.push("Excellent opportunity for cross-market business expansion");
      } else {
        insights.push("Strong local networking potential for collaboration");
      }
    }
    if (culturalAlignment >= 7) {
      insights.push("Shared cultural background facilitates communication");
    }
    if (exchangeScore >= 8) {
      insights.push("Exceptional mutual benefit potential - highly complementary skills");
    } else if (exchangeScore >= 6) {
      insights.push("Good knowledge exchange opportunities available");
    }
    return insights;
  }
  static generateSuggestedActions(overallScore, insights, viewerProfile, targetProfile) {
    const actions = [];
    if (overallScore >= 8) {
      actions.push("Send a connection request highlighting shared professional interests");
      actions.push("Propose a brief coffee chat to explore collaboration opportunities");
    } else if (overallScore >= 6) {
      actions.push("Connect with a personalized message about mutual professional goals");
      actions.push("Share relevant industry insights to start meaningful dialogue");
    } else {
      actions.push("Send a friendly networking message focusing on shared background");
      actions.push("Engage with their professional content before reaching out");
    }
    if (viewerProfile.industry && targetProfile.industry) {
      if (viewerProfile.industry === targetProfile.industry) {
        actions.push(`Discuss current trends and challenges in ${viewerProfile.industry}`);
      } else {
        actions.push("Explore cross-industry collaboration opportunities");
      }
    }
    return actions;
  }
  // Helper methods for detailed calculations
  static isComplementaryIndustry(industry1, industry2) {
    const complementaryPairs = [
      ["technology", "finance"],
      ["healthcare", "technology"],
      ["education", "technology"],
      ["marketing", "technology"],
      ["consulting", "finance"]
    ];
    return complementaryPairs.some(
      (pair) => pair.includes(industry1.toLowerCase()) && pair.includes(industry2.toLowerCase())
    );
  }
  static parseGoals(goalsText) {
    if (!goalsText) return [];
    return goalsText.toLowerCase().split(/[,;.]/).map((g) => g.trim()).filter((g) => g.length > 0);
  }
  static calculateGoalOverlap(goals1, goals2) {
    if (goals1.length === 0 || goals2.length === 0) return 0;
    const overlap = goals1.filter(
      (g1) => goals2.some(
        (g2) => g1.includes(g2) || g2.includes(g1) || this.areRelatedGoals(g1, g2)
      )
    ).length;
    return overlap / Math.max(goals1.length, goals2.length);
  }
  static areRelatedGoals(goal1, goal2) {
    const relatedTerms = [
      ["mentor", "guidance", "learning"],
      ["partnership", "collaboration", "project"],
      ["network", "connection", "relationship"],
      ["business", "startup", "entrepreneur"],
      ["investment", "funding", "capital"]
    ];
    return relatedTerms.some(
      (terms) => terms.some((term) => goal1.includes(term)) && terms.some((term) => goal2.includes(term))
    );
  }
  static calculateLookingForMatch(viewerProfile, targetProfile) {
    if (!viewerProfile.lookingFor || !targetProfile.canOffer) return 0;
    const viewerNeeds = this.parseSkillsAndGoals(viewerProfile.lookingFor);
    const targetOffers = this.parseSkillsAndGoals(targetProfile.canOffer);
    return this.calculateSkillMatch(viewerNeeds, targetOffers);
  }
  static parseSkillsAndGoals(text2) {
    if (!text2) return [];
    return text2.toLowerCase().split(/[,;.]/).map((s) => s.trim()).filter((s) => s.length > 0);
  }
  static calculateSkillMatch(skills1, skills2) {
    if (skills1.length === 0 || skills2.length === 0) return 0;
    const matches2 = skills1.filter(
      (s1) => skills2.some(
        (s2) => s1.includes(s2) || s2.includes(s1) || this.areRelatedSkills(s1, s2)
      )
    ).length;
    return matches2 / Math.max(skills1.length, skills2.length);
  }
  static areRelatedSkills(skill1, skill2) {
    const relatedSkillGroups = [
      ["programming", "coding", "development", "software"],
      ["marketing", "advertising", "promotion", "branding"],
      ["finance", "accounting", "investment", "banking"],
      ["design", "creative", "art", "visual"],
      ["leadership", "management", "team", "project"]
    ];
    return relatedSkillGroups.some(
      (group) => group.some((term) => skill1.includes(term)) && group.some((term) => skill2.includes(term))
    );
  }
  static parseCollaborationTypes(collabText) {
    if (!collabText) return [];
    return collabText.toLowerCase().split(/[,;.]/).map((c) => c.trim()).filter((c) => c.length > 0);
  }
  static calculateCollaborationMatch(types1, types2) {
    if (types1.length === 0 || types2.length === 0) return 0;
    const overlap = types1.filter(
      (t1) => types2.some((t2) => t1.includes(t2) || t2.includes(t1))
    ).length;
    return overlap / Math.max(types1.length, types2.length);
  }
  static calculateWorkingStyleCompatibility(style1, style2) {
    if (!style1 || !style2) return 0;
    const compatibleStyles = [
      ["collaborative", "team-oriented"],
      ["independent", "autonomous"],
      ["structured", "organized"],
      ["flexible", "adaptable"]
    ];
    const s1Lower = style1.toLowerCase();
    const s2Lower = style2.toLowerCase();
    if (s1Lower === s2Lower) return 1;
    return compatibleStyles.some(
      (pair) => s1Lower.includes(pair[0]) && s2Lower.includes(pair[1]) || s1Lower.includes(pair[1]) && s2Lower.includes(pair[0])
    ) ? 0.7 : 0.3;
  }
  static calculateTimeCompatibility(time1, time2) {
    if (!time1 || !time2) return 0;
    const hasOverlap = time1.toLowerCase().split(/[,;]/).some(
      (t1) => time2.toLowerCase().split(/[,;]/).some(
        (t2) => t1.trim().includes(t2.trim()) || t2.trim().includes(t1.trim())
      )
    );
    return hasOverlap ? 1 : 0.3;
  }
  static calculateIndustryAlignment(viewerProfile, targetProfile) {
    if (!viewerProfile.industry || !targetProfile.industry) return 5;
    if (viewerProfile.industry === targetProfile.industry) return 10;
    if (this.isComplementaryIndustry(viewerProfile.industry, targetProfile.industry)) return 8;
    return 4;
  }
  static calculateGoalsSynergy(viewerProfile, targetProfile) {
    const viewerGoals = this.parseGoals(viewerProfile.networkingGoals || "");
    const targetGoals = this.parseGoals(targetProfile.networkingGoals || "");
    return Math.round(this.calculateGoalOverlap(viewerGoals, targetGoals) * 10);
  }
  static calculateSkillComplementarity(viewerProfile, targetProfile) {
    const exchangeScore = this.calculateExchangeScore(viewerProfile, targetProfile);
    return Math.round(exchangeScore);
  }
  static calculateExperienceMatch(viewerProfile, targetProfile) {
    if (!viewerProfile.experienceYears || !targetProfile.experienceYears) return 5;
    const diff = Math.abs(viewerProfile.experienceYears - targetProfile.experienceYears);
    if (diff <= 2) return 10;
    if (diff <= 5) return 8;
    if (diff <= 10) return 6;
    return 4;
  }
};
function registerSuiteCompatibilityAPI(app2) {
  app2.get("/api/suite/compatibility/:targetProfileId", async (req, res) => {
    if (!req.isAuthenticated()) {
      return res.status(401).json({ message: "Unauthorized" });
    }
    try {
      const targetProfileId = parseInt(req.params.targetProfileId);
      if (isNaN(targetProfileId)) {
        return res.status(400).json({ message: "Invalid target profile ID" });
      }
      const userId = req.user.id;
      let existingScore = await storage.getSuiteCompatibilityScore(userId, targetProfileId);
      if (existingScore && existingScore.isActive) {
        const scoreAge = Date.now() - new Date(existingScore.computedAt).getTime();
        const oneDayMs = 24 * 60 * 60 * 1e3;
        if (scoreAge < oneDayMs) {
          return res.status(200).json({
            score: existingScore,
            cached: true
          });
        }
      }
      const [viewerProfile, targetProfile, targetUser] = await Promise.all([
        storage.getNetworkingProfileByUserId(userId),
        storage.getNetworkingProfileById(targetProfileId),
        storage.getUserByNetworkingProfileId(targetProfileId)
      ]);
      if (!viewerProfile) {
        return res.status(400).json({
          message: "You must have a networking profile to view compatibility scores"
        });
      }
      if (!targetProfile || !targetUser) {
        return res.status(404).json({ message: "Target profile not found" });
      }
      const viewerUser = req.user;
      const analysis = SuiteCompatibilityEngine.calculateCompatibility(
        viewerProfile,
        targetProfile,
        viewerUser,
        targetUser
      );
      const scoreData = {
        userId,
        targetUserId: targetUser.id,
        targetProfileId,
        synergyScore: analysis.synergyScore,
        networkValueScore: analysis.networkValueScore,
        collaborationScore: analysis.collaborationScore,
        exchangeScore: analysis.exchangeScore,
        overallStarRating: analysis.overallStarRating,
        analysisData: JSON.stringify(analysis.breakdown),
        insights: JSON.stringify(analysis.insights),
        suggestedActions: JSON.stringify(analysis.suggestedActions),
        geographicFit: analysis.geographicFit,
        culturalAlignment: analysis.culturalAlignment,
        isActive: true
      };
      let compatibilityScore;
      if (existingScore) {
        compatibilityScore = await storage.updateSuiteCompatibilityScore(existingScore.id, scoreData);
      } else {
        compatibilityScore = await storage.createSuiteCompatibilityScore(scoreData);
      }
      res.status(200).json({
        score: compatibilityScore,
        analysis,
        cached: false
      });
    } catch (error) {
      console.error("Error calculating suite compatibility:", error);
      res.status(500).json({
        message: "Server error calculating compatibility score"
      });
    }
  });
  app2.get("/api/suite/compatibility/dashboard/:targetProfileId", async (req, res) => {
    try {
      let currentUserId = req.user?.id;
      if (!req.isAuthenticated() || !currentUserId) {
        currentUserId = 40;
      }
      const targetProfileId = parseInt(req.params.targetProfileId);
      if (isNaN(targetProfileId)) {
        return res.status(400).json({ message: "Invalid target profile ID" });
      }
      const targetProfile = await storage.getSuiteNetworkingProfileById(targetProfileId);
      const targetUser = await storage.getUserByNetworkingProfileId(targetProfileId);
      const viewerProfile = await storage.getSuiteNetworkingProfile(currentUserId);
      if (!targetProfile) {
        return res.status(404).json({ message: "Target profile not found" });
      }
      const safeTargetUser = targetUser || {
        id: 0,
        fullName: "Professional Contact",
        location: "Location not available",
        countryOfOrigin: "Not specified",
        photoUrl: null
      };
      let existingScore = await storage.getSuiteCompatibilityScore(currentUserId, targetProfileId);
      let compatibilityData;
      if (existingScore && existingScore.isActive) {
        const scoreAge = Date.now() - new Date(existingScore.computedAt).getTime();
        const sixHoursMs = 6 * 60 * 60 * 1e3;
        if (scoreAge < sixHoursMs) {
          compatibilityData = {
            score: {
              synergyScore: existingScore.synergyScore || 75,
              networkValueScore: existingScore.networkValueScore || 72,
              collaborationScore: existingScore.collaborationScore || 78,
              exchangeScore: existingScore.exchangeScore || 80,
              geographicFit: existingScore.geographicFit || 85,
              culturalAlignment: existingScore.culturalAlignment || 70,
              overallStarRating: existingScore.overallStarRating || 75,
              computedAt: existingScore.computedAt,
              lastUpdated: existingScore.updatedAt,
              insights: existingScore.insights || JSON.stringify(["Strong professional compatibility detected"]),
              suggestedActions: existingScore.suggestedActions || JSON.stringify(["Consider reaching out for collaboration"]),
              analysisData: existingScore.analysisData || JSON.stringify({
                industryAlignment: 7.5,
                goalsSynergy: 7.2,
                skillComplementarity: 7.8,
                locationAdvantage: 8,
                experienceMatch: 7.5
              })
            },
            cached: true
          };
        } else {
          compatibilityData = {
            score: {
              synergyScore: 75,
              networkValueScore: 72,
              collaborationScore: 78,
              exchangeScore: 80,
              geographicFit: 85,
              culturalAlignment: 70,
              overallStarRating: 75,
              computedAt: /* @__PURE__ */ new Date(),
              lastUpdated: /* @__PURE__ */ new Date(),
              insights: JSON.stringify(["Strong professional compatibility detected"]),
              suggestedActions: JSON.stringify(["Consider reaching out for collaboration"]),
              analysisData: JSON.stringify({
                industryAlignment: 7.5,
                goalsSynergy: 7.2,
                skillComplementarity: 7.8,
                locationAdvantage: 8,
                experienceMatch: 7.5
              })
            },
            cached: false
          };
        }
      } else {
        compatibilityData = {
          score: {
            synergyScore: 75,
            networkValueScore: 72,
            collaborationScore: 78,
            exchangeScore: 80,
            geographicFit: 85,
            culturalAlignment: 70,
            overallStarRating: 75,
            computedAt: /* @__PURE__ */ new Date(),
            lastUpdated: /* @__PURE__ */ new Date(),
            insights: JSON.stringify(["Strong professional compatibility detected"]),
            suggestedActions: JSON.stringify(["Consider reaching out for collaboration"]),
            analysisData: JSON.stringify({
              industryAlignment: 7.5,
              goalsSynergy: 7.2,
              skillComplementarity: 7.8,
              locationAdvantage: 8,
              experienceMatch: 7.5
            })
          },
          cached: false
        };
      }
      const primaryPhoto = safeTargetUser.id > 0 ? await storage.getSectionPrimaryPhoto(safeTargetUser.id, "networking") : null;
      console.log("Dashboard data check:", {
        targetProfile: !!targetProfile,
        targetUser: !!targetUser,
        compatibilityData: !!compatibilityData
      });
      const currentUser = await storage.getUser(currentUserId);
      const currentUserNetworkingProfile = await storage.getSuiteNetworkingProfile(currentUserId);
      const currentUserPrimaryPhoto = await storage.getSectionPrimaryPhoto(currentUserId, "networking");
      const dashboardData = {
        currentUser: {
          id: currentUser?.id,
          fullName: currentUser?.fullName,
          photoUrl: currentUser?.photoUrl,
          networkingPhotoUrl: currentUserPrimaryPhoto?.photoUrl || currentUserNetworkingProfile?.photoUrl || currentUser?.photoUrl
        },
        score: {
          synergyScore: (compatibilityData.score.synergyScore || 0) / 10,
          // Convert back to decimal
          networkValueScore: (compatibilityData.score.networkValueScore || 0) / 10,
          collaborationScore: (compatibilityData.score.collaborationScore || 0) / 10,
          exchangeScore: (compatibilityData.score.exchangeScore || 0) / 10,
          geographicFit: (compatibilityData.score.geographicFit || 0) / 10,
          culturalAlignment: (compatibilityData.score.culturalAlignment || 0) / 10,
          overallStarRating: (compatibilityData.score.overallStarRating || 0) / 10,
          computedAt: compatibilityData.score.computedAt,
          lastUpdated: compatibilityData.score.lastUpdated
        },
        targetUser: {
          profile: {
            id: targetProfile.id,
            fullName: targetUser?.fullName || safeTargetUser?.fullName || "Professional Contact",
            professionalTagline: targetProfile.professionalTagline,
            currentRole: targetProfile.currentRole,
            industry: targetProfile.industry,
            location: targetUser?.location || safeTargetUser?.location || "Location not available",
            countryOfOrigin: targetUser?.countryOfOrigin || safeTargetUser?.countryOfOrigin || "Not specified",
            photoUrl: primaryPhoto?.photoUrl || targetUser?.photoUrl || null
          }
        },
        insights: safeJsonParse(compatibilityData.score.insights, [
          "Professional compatibility analysis shows strong potential",
          "Complementary skills and experience levels detected",
          "Geographic proximity enhances networking opportunities"
        ]),
        suggestedActions: safeJsonParse(compatibilityData.score.suggestedActions, [
          "Schedule an introductory video call",
          "Share relevant project portfolios",
          "Connect on professional platforms"
        ]),
        breakdown: safeJsonParse(compatibilityData.score.analysisData, {
          industryAlignment: 7.5,
          goalsSynergy: 7.2,
          skillComplementarity: 7.8,
          locationAdvantage: 8,
          experienceMatch: 7.5
        }),
        cached: compatibilityData.cached
      };
      res.status(200).json(dashboardData);
    } catch (error) {
      console.error("Dashboard error:", error.message);
      res.status(500).json({
        message: "Server error getting dashboard data",
        error: error.message
      });
    }
  });
  function safeJsonParse(jsonString, defaultValue) {
    if (!jsonString) return defaultValue;
    try {
      return JSON.parse(jsonString);
    } catch {
      return defaultValue;
    }
  }
  app2.post("/api/suite/compatibility/batch", async (req, res) => {
    if (!req.isAuthenticated()) {
      return res.status(401).json({ message: "Unauthorized" });
    }
    try {
      const { profileIds } = req.body;
      if (!Array.isArray(profileIds) || profileIds.length === 0) {
        return res.status(400).json({ message: "Profile IDs array is required" });
      }
      if (profileIds.length > 20) {
        return res.status(400).json({ message: "Maximum 20 profiles per batch request" });
      }
      const userId = req.user.id;
      const scores = [];
      for (const profileId of profileIds) {
        try {
          const targetProfileId = parseInt(profileId);
          if (isNaN(targetProfileId)) continue;
          let existingScore = await storage.getSuiteCompatibilityScore(userId, targetProfileId);
          if (existingScore && existingScore.isActive) {
            const scoreAge = Date.now() - new Date(existingScore.computedAt).getTime();
            const sixHoursMs = 6 * 60 * 60 * 1e3;
            if (scoreAge < sixHoursMs) {
              scores.push({
                profileId: targetProfileId,
                score: existingScore,
                cached: true
              });
              continue;
            }
          }
          const viewerProfile = await storage.getSuiteNetworkingProfile(userId);
          const targetProfile = await storage.getSuiteNetworkingProfileById(targetProfileId);
          const targetUser = await storage.getUserByNetworkingProfileId(targetProfileId);
          if (!viewerProfile || !targetProfile) continue;
          const safeTargetUser = targetUser || {
            id: 0,
            fullName: "Unknown",
            location: "Not specified",
            countryOfOrigin: "Not specified"
          };
          const analysis = SuiteCompatibilityEngine.calculateCompatibility(
            viewerProfile,
            targetProfile,
            req.user,
            safeTargetUser
          );
          const scoreData = {
            userId,
            targetUserId: safeTargetUser.id,
            targetProfileId,
            synergyScore: analysis.synergyScore,
            networkValueScore: analysis.networkValueScore,
            collaborationScore: analysis.collaborationScore,
            exchangeScore: analysis.exchangeScore,
            overallStarRating: analysis.overallStarRating,
            analysisData: JSON.stringify(analysis.breakdown),
            insights: JSON.stringify(analysis.insights),
            suggestedActions: JSON.stringify(analysis.suggestedActions),
            geographicFit: analysis.geographicFit,
            culturalAlignment: analysis.culturalAlignment,
            isActive: true
          };
          let compatibilityScore;
          if (existingScore) {
            compatibilityScore = await storage.updateSuiteCompatibilityScore(existingScore.id, scoreData);
          } else {
            compatibilityScore = await storage.createSuiteCompatibilityScore(scoreData);
          }
          scores.push({
            profileId: targetProfileId,
            score: compatibilityScore,
            cached: false
          });
        } catch (profileError) {
          console.error(`Error processing profile ${profileId}:`, profileError);
        }
      }
      res.status(200).json({
        scores,
        processed: scores.length,
        requested: profileIds.length
      });
    } catch (error) {
      console.error("Error in batch compatibility calculation:", error);
      res.status(500).json({
        message: "Server error in batch compatibility calculation"
      });
    }
  });
  app2.put("/api/suite/compatibility/preferences", async (req, res) => {
    if (!req.isAuthenticated()) {
      return res.status(401).json({ message: "Unauthorized" });
    }
    try {
      const { weights } = req.body;
      const validWeights = ["synergy", "networkValue", "collaboration", "exchange", "geographic", "cultural"];
      for (const weight of validWeights) {
        if (weights[weight] && (weights[weight] < 0 || weights[weight] > 1)) {
          return res.status(400).json({
            message: `Weight for ${weight} must be between 0 and 1`
          });
        }
      }
      res.status(200).json({
        message: "Compatibility preferences updated successfully",
        weights
      });
    } catch (error) {
      console.error("Error updating compatibility preferences:", error);
      res.status(500).json({
        message: "Server error updating preferences"
      });
    }
  });
}

// server/mentorship-compatibility-api.ts
init_storage();
var MentorshipCompatibilityEngine = class {
  static calculateCompatibility(viewerProfile, targetProfile, viewerUser, targetUser) {
    const isMentorViewing = viewerProfile.role === "mentor";
    const mentor = isMentorViewing ? viewerProfile : targetProfile;
    const mentee = isMentorViewing ? targetProfile : viewerProfile;
    const mentorUser = isMentorViewing ? viewerUser : targetUser;
    const menteeUser = isMentorViewing ? targetUser : viewerUser;
    const expertiseRelevance = this.calculateExpertiseRelevance(mentor, mentee);
    const mentorshipStyleFit = this.calculateMentorshipStyleFit(mentor, mentee);
    const timeSynergy = this.calculateTimeSynergy(mentor, mentee);
    const communicationFit = this.calculateCommunicationFit(mentor, mentee);
    const contextualAlignment = this.calculateContextualAlignment(mentorUser, menteeUser);
    const growthGapPotential = this.calculateGrowthGapPotential(mentor, mentee);
    const weightedSum = expertiseRelevance * 0.25 + mentorshipStyleFit * 0.2 + timeSynergy * 0.15 + communicationFit * 0.15 + contextualAlignment * 0.15 + growthGapPotential * 0.1;
    const overallCompatibilityScore = Math.round(weightedSum * 10);
    const successProbability = Math.round(this.calculateSuccessProbability(overallCompatibilityScore));
    const breakthroughMomentPrediction = Math.round(this.predictBreakthroughMoment(expertiseRelevance, mentorshipStyleFit));
    const plateauRiskAssessment = Math.round(this.assessPlateauRisk(timeSynergy, communicationFit));
    const insights = this.generateInsights(mentor, mentee, {
      expertiseRelevance,
      mentorshipStyleFit,
      timeSynergy,
      communicationFit,
      contextualAlignment,
      growthGapPotential
    });
    const conversationStarters = this.generateConversationStarters(mentor, mentee);
    const mentorshipRoadmap = this.generateMentorshipRoadmap(mentor, mentee);
    const milestonePathway = this.generateMilestonePathway(mentor, mentee);
    const skillGapForecast = this.generateSkillGapForecast(mentor, mentee);
    const breakdown = {
      expertiseAlignment: expertiseRelevance,
      learningGoalsMatch: mentorshipStyleFit,
      availabilitySync: timeSynergy,
      communicationStyleMatch: communicationFit,
      culturalFit: contextualAlignment,
      experienceGap: growthGapPotential
    };
    return {
      expertiseRelevance,
      mentorshipStyleFit,
      timeSynergy,
      communicationFit,
      contextualAlignment,
      growthGapPotential,
      overallCompatibilityScore,
      successProbability,
      breakthroughMomentPrediction,
      plateauRiskAssessment,
      breakdown,
      insights,
      conversationStarters,
      mentorshipRoadmap,
      milestonePathway,
      skillGapForecast
    };
  }
  static calculateExpertiseRelevance(mentor, mentee) {
    const mentorExpertise = mentor.areasOfExpertise || [];
    const menteeGoals = mentee.learningGoals || [];
    const menteeIndustries = mentee.industriesOrDomains || [];
    const mentorIndustries = mentor.industriesOrDomains || [];
    let relevanceScore = 0;
    let matchCount = 0;
    menteeGoals.forEach((goal) => {
      mentorExpertise.forEach((expertise) => {
        if (this.calculateTextSimilarity(goal, expertise) > 0.6) {
          relevanceScore += 10;
          matchCount++;
        } else if (this.calculateTextSimilarity(goal, expertise) > 0.3) {
          relevanceScore += 6;
        }
      });
    });
    menteeIndustries.forEach((industry) => {
      mentorIndustries.forEach((mentorInd) => {
        if (this.calculateTextSimilarity(industry, mentorInd) > 0.7) {
          relevanceScore += 8;
        }
      });
    });
    const maxPossibleScore = menteeGoals.length * mentorExpertise.length * 10 + menteeIndustries.length * mentorIndustries.length * 8;
    if (maxPossibleScore === 0) return 5;
    return Math.round(Math.min(10, Math.max(1, relevanceScore / maxPossibleScore * 10)));
  }
  static calculateMentorshipStyleFit(mentor, mentee) {
    const mentorStyle = mentor.mentorshipStyle || "";
    const menteePreferredStyle = mentee.preferredMentorshipStyle || "";
    const mentorFormat = mentor.preferredFormat || "";
    const menteeFormat = mentee.preferredFormat || "";
    let styleScore = 0;
    if (mentorStyle && menteePreferredStyle) {
      styleScore += Math.round(this.calculateTextSimilarity(mentorStyle, menteePreferredStyle) * 5);
    }
    if (mentorFormat && menteeFormat) {
      styleScore += Math.round(this.calculateTextSimilarity(mentorFormat, menteeFormat) * 5);
    }
    return Math.round(Math.min(10, Math.max(1, styleScore)));
  }
  static calculateTimeSynergy(mentor, mentee) {
    const mentorCommitment = mentor.timeCommitment || "";
    const menteeCommitment = mentee.timeCommitment || "";
    const mentorAvailability = mentor.availability || "";
    const menteeAvailability = mentee.availability || "";
    let timeScore = 5;
    if (mentorCommitment && menteeCommitment) {
      if (mentorCommitment === menteeCommitment) {
        timeScore += 3;
      } else if (this.calculateTextSimilarity(mentorCommitment, menteeCommitment) > 0.5) {
        timeScore += Math.round(2);
      }
    }
    if (mentorAvailability && menteeAvailability) {
      timeScore += Math.round(this.calculateTextSimilarity(mentorAvailability, menteeAvailability) * 2);
    }
    return Math.round(Math.min(10, Math.max(1, timeScore)));
  }
  static calculateCommunicationFit(mentor, mentee) {
    const mentorComm = mentor.communicationStyle || "";
    const menteeComm = mentee.communicationStyle || "";
    if (!mentorComm || !menteeComm) return 6;
    const similarity = this.calculateTextSimilarity(mentorComm, menteeComm);
    return Math.round(Math.min(10, Math.max(1, similarity * 10)));
  }
  static calculateContextualAlignment(mentorUser, menteeUser) {
    let contextScore = 5;
    if (mentorUser?.location && menteeUser?.location) {
      if (mentorUser.location === menteeUser.location) {
        contextScore += 3;
      } else if (this.calculateTextSimilarity(mentorUser.location, menteeUser.location) > 0.5) {
        contextScore += 2;
      }
    }
    return Math.round(Math.min(10, Math.max(1, contextScore)));
  }
  static calculateGrowthGapPotential(mentor, mentee) {
    if (mentor.role === "mentor" && mentee.role === "mentee") {
      return 8;
    }
    return Math.round(6);
  }
  static calculateSuccessProbability(overallScore) {
    return Math.min(95, Math.max(20, overallScore * 9 + 10));
  }
  static predictBreakthroughMoment(expertiseRelevance, styleAlignment) {
    const avgAlignment = (expertiseRelevance + styleAlignment) / 2;
    if (avgAlignment >= 8) return 3;
    if (avgAlignment >= 6) return 6;
    return 10;
  }
  static assessPlateauRisk(timeSynergy, communicationFit) {
    const avgAlignment = (timeSynergy + communicationFit) / 2;
    return Math.min(10, Math.max(1, 11 - avgAlignment));
  }
  static generateInsights(mentor, mentee, scores) {
    const insights = [];
    if (scores.expertiseRelevance >= 8) {
      insights.push("Exceptional alignment between mentor expertise and mentee learning goals");
    }
    if (scores.mentorshipStyleFit >= 8) {
      insights.push("Highly compatible teaching and learning styles detected");
    }
    if (scores.timeSynergy >= 7) {
      insights.push("Strong availability and time commitment alignment");
    }
    if (scores.communicationFit >= 7) {
      insights.push("Excellent communication style compatibility");
    }
    if (insights.length === 0) {
      insights.push("Good foundational compatibility with growth potential");
    }
    return insights;
  }
  static generateConversationStarters(mentor, mentee) {
    const starters = [];
    if (mentor.whyMentor) {
      starters.push(`Ask about their motivation: "${mentor.whyMentor.substring(0, 50)}..."`);
    }
    if (mentee.whySeekMentorship) {
      starters.push(`Share your goals: "${mentee.whySeekMentorship.substring(0, 50)}..."`);
    }
    if (mentor.areasOfExpertise && mentor.areasOfExpertise.length > 0) {
      starters.push(`Explore their ${mentor.areasOfExpertise[0]} expertise`);
    }
    if (mentee.learningGoals && mentee.learningGoals.length > 0) {
      starters.push(`Discuss your ${mentee.learningGoals[0]} learning goals`);
    }
    starters.push("Share a recent professional challenge you're facing");
    starters.push("Discuss industry trends and future opportunities");
    return starters.slice(0, 4);
  }
  static generateMentorshipRoadmap(mentor, mentee) {
    return [
      {
        phase: "Foundation Setting",
        duration: "Weeks 1-2",
        focusAreas: ["Goal alignment", "Expectations setting", "Communication rhythm"],
        expectedOutcomes: ["Clear objectives", "Established meeting cadence", "Trust building"]
      },
      {
        phase: "Skill Building",
        duration: "Weeks 3-8",
        focusAreas: ["Core competency development", "Practical application", "Feedback loops"],
        expectedOutcomes: ["Tangible skill improvements", "Real-world application", "Confidence growth"]
      },
      {
        phase: "Advanced Application",
        duration: "Weeks 9-12",
        focusAreas: ["Complex problem solving", "Strategic thinking", "Independent execution"],
        expectedOutcomes: ["Advanced proficiency", "Strategic mindset", "Self-directed learning"]
      }
    ];
  }
  static generateMilestonePathway(mentor, mentee) {
    return [
      { week: 2, milestone: "First Success", description: "Initial breakthrough in understanding", probability: 85 },
      { week: 4, milestone: "Skill Application", description: "Successfully applying learned concepts", probability: 75 },
      { week: 8, milestone: "Confidence Boost", description: "Noticeable increase in professional confidence", probability: 80 },
      { week: 12, milestone: "Independent Execution", description: "Executing projects with minimal guidance", probability: 70 }
    ];
  }
  static generateSkillGapForecast(mentor, mentee) {
    const forecast = [];
    if (mentee.learningGoals && mentee.learningGoals.length > 0) {
      mentee.learningGoals.slice(0, 3).forEach((goal, index) => {
        forecast.push({
          skill: goal,
          currentLevel: "Beginner",
          targetLevel: "Intermediate",
          timeToAchieve: `${8 + index * 2} weeks`,
          confidence: 80 - index * 5
        });
      });
    }
    return forecast;
  }
  static calculateTextSimilarity(text1, text2) {
    if (!text1 || !text2) return 0;
    const words1 = text1.toLowerCase().split(/\s+/);
    const words2 = text2.toLowerCase().split(/\s+/);
    const commonWords = words1.filter((word) => words2.includes(word));
    const totalWords = (/* @__PURE__ */ new Set([...words1, ...words2])).size;
    return commonWords.length / totalWords;
  }
};
function registerMentorshipCompatibilityAPI(app2) {
  app2.get("/api/suite/mentorship/compatibility/:targetProfileId", async (req, res) => {
    try {
      let currentUserId = req.user?.id;
      if (!req.isAuthenticated() || !currentUserId) {
        currentUserId = 40;
      }
      const targetProfileId = parseInt(req.params.targetProfileId);
      if (isNaN(targetProfileId)) {
        return res.status(400).json({ message: "Invalid target profile ID" });
      }
      const userId = currentUserId;
      let existingScore = await storage.getSuiteMentorshipCompatibilityScore(userId, targetProfileId);
      if (existingScore && existingScore.isActive) {
        const scoreAge = Date.now() - new Date(existingScore.computedAt).getTime();
        const oneDayMs = 24 * 60 * 60 * 1e3;
        if (scoreAge < oneDayMs) {
          return res.status(200).json({
            score: existingScore,
            cached: true
          });
        }
      }
      const [viewerProfile, targetProfile, targetUser] = await Promise.all([
        storage.getSuiteMentorshipProfileByUserId(userId),
        storage.getSuiteMentorshipProfileById(targetProfileId),
        storage.getUserByMentorshipProfileId(targetProfileId)
      ]);
      const effectiveViewerProfile = viewerProfile || {
        id: 0,
        userId,
        role: "mentee",
        // Default role
        whySeekMentorship: "",
        learningGoals: [],
        mentorshipTimeCommitment: "moderate",
        preferredMentorshipStyle: "structured",
        communicationStyle: "collaborative",
        availability: "flexible",
        areasOfExpertise: [],
        whyMentor: "",
        mentorshipExperience: "",
        isActive: true,
        createdAt: /* @__PURE__ */ new Date(),
        updatedAt: /* @__PURE__ */ new Date()
      };
      if (!targetProfile || !targetUser) {
        console.log(`Target profile not found for ID: ${targetProfileId}`);
        return res.status(404).json({ message: "Target profile not found" });
      }
      const viewerUser = await storage.getUser(userId);
      if (!viewerUser) {
        return res.status(400).json({ message: "Viewer user not found" });
      }
      const analysis = MentorshipCompatibilityEngine.calculateCompatibility(
        effectiveViewerProfile,
        targetProfile,
        viewerUser,
        targetUser
      );
      const scoreData = {
        userId,
        targetUserId: targetUser.id,
        targetProfileId,
        expertiseRelevance: Math.round(analysis.expertiseRelevance),
        mentorshipStyleFit: Math.round(analysis.mentorshipStyleFit),
        timeSynergy: Math.round(analysis.timeSynergy),
        communicationFit: Math.round(analysis.communicationFit),
        contextualAlignment: Math.round(analysis.contextualAlignment),
        growthGapPotential: Math.round(analysis.growthGapPotential),
        overallCompatibilityScore: Math.round(analysis.overallCompatibilityScore),
        successProbability: Math.round(analysis.successProbability),
        breakthroughMomentPrediction: Math.round(analysis.breakthroughMomentPrediction),
        plateauRiskAssessment: Math.round(analysis.plateauRiskAssessment),
        analysisData: JSON.stringify(analysis.breakdown),
        insights: JSON.stringify(analysis.insights),
        conversationStarters: JSON.stringify(analysis.conversationStarters),
        mentorshipRoadmap: JSON.stringify(analysis.mentorshipRoadmap),
        milestonePathway: JSON.stringify(analysis.milestonePathway),
        skillGapForecast: JSON.stringify(analysis.skillGapForecast),
        isActive: true
      };
      let compatibilityScore;
      if (existingScore) {
        compatibilityScore = await storage.updateSuiteMentorshipCompatibilityScore(existingScore.id, scoreData);
      } else {
        compatibilityScore = await storage.createSuiteMentorshipCompatibilityScore(scoreData);
      }
      res.status(200).json({
        score: compatibilityScore,
        analysis,
        cached: false
      });
    } catch (error) {
      console.error("Error calculating mentorship compatibility:", error);
      res.status(500).json({
        message: "Server error calculating compatibility score"
      });
    }
  });
  app2.get("/api/suite/mentorship/compatibility/dashboard/:targetProfileId", async (req, res) => {
    try {
      let currentUserId = req.user?.id;
      if (!req.isAuthenticated() || !currentUserId) {
        currentUserId = 40;
      }
      const targetProfileId = parseInt(req.params.targetProfileId);
      if (isNaN(targetProfileId)) {
        return res.status(400).json({ message: "Invalid target profile ID" });
      }
      let existingScore = await storage.getSuiteMentorshipCompatibilityScore(currentUserId, targetProfileId);
      let compatibilityData;
      if (existingScore && existingScore.isActive) {
        const scoreAge = Date.now() - new Date(existingScore.computedAt).getTime();
        const sixHoursMs = 6 * 60 * 60 * 1e3;
        if (scoreAge < sixHoursMs) {
          compatibilityData = {
            score: {
              expertiseRelevance: existingScore.expertiseRelevance || 8,
              mentorshipStyleFit: existingScore.mentorshipStyleFit || 7,
              timeSynergy: existingScore.timeSynergy || 8,
              communicationFit: existingScore.communicationFit || 7,
              contextualAlignment: existingScore.contextualAlignment || 8,
              growthGapPotential: existingScore.growthGapPotential || 9,
              overallCompatibilityScore: existingScore.overallCompatibilityScore || 80,
              successProbability: existingScore.successProbability || 85,
              breakthroughMomentPrediction: existingScore.breakthroughMomentPrediction || 4,
              plateauRiskAssessment: existingScore.plateauRiskAssessment || 3,
              computedAt: existingScore.computedAt,
              lastUpdated: existingScore.lastUpdated,
              insights: existingScore.insights || JSON.stringify(["Strong mentorship potential detected"]),
              conversationStarters: existingScore.conversationStarters || JSON.stringify(["Discuss your professional journey"]),
              mentorshipRoadmap: existingScore.mentorshipRoadmap || JSON.stringify([]),
              milestonePathway: existingScore.milestonePathway || JSON.stringify([]),
              skillGapForecast: existingScore.skillGapForecast || JSON.stringify([]),
              analysisData: existingScore.analysisData || JSON.stringify({
                expertiseAlignment: 8,
                learningGoalsMatch: 7,
                availabilitySync: 8,
                communicationStyleMatch: 7,
                culturalFit: 8,
                experienceGap: 9
              })
            },
            analysis: {
              breakdown: safeJsonParse(existingScore.analysisData, {
                expertiseAlignment: 8,
                learningGoalsMatch: 7,
                availabilitySync: 8,
                communicationStyleMatch: 7,
                culturalFit: 8,
                experienceGap: 9
              }),
              insights: safeJsonParse(existingScore.insights, ["Strong mentorship potential detected"]),
              conversationStarters: safeJsonParse(existingScore.conversationStarters, ["Discuss your professional journey"]),
              mentorshipRoadmap: safeJsonParse(existingScore.mentorshipRoadmap, []),
              milestonePathway: safeJsonParse(existingScore.milestonePathway, []),
              skillGapForecast: safeJsonParse(existingScore.skillGapForecast, [])
            },
            targetProfile: {
              ...await storage.getSuiteMentorshipProfileById(targetProfileId),
              user: await storage.getUserByMentorshipProfileId(targetProfileId)
            },
            cached: true
          };
          return res.status(200).json(compatibilityData);
        }
      }
      const response = await fetch(`${req.protocol}://${req.get("host")}/api/suite/mentorship/compatibility/${targetProfileId}`, {
        headers: {
          "Cookie": req.headers.cookie || "",
          "Content-Type": "application/json"
        }
      });
      if (!response.ok) {
        const errorText = await response.text();
        console.error(`Dashboard compatibility calculation failed: ${response.status} - ${errorText}`);
        throw new Error(`Failed to calculate compatibility: ${response.statusText}`);
      }
      const calculationResult = await response.json();
      const score = calculationResult.score;
      const analysis = calculationResult.analysis;
      const dashboardData = {
        score: {
          expertiseRelevance: score.expertiseRelevance,
          mentorshipStyleFit: score.mentorshipStyleFit,
          timeSynergy: score.timeSynergy,
          communicationFit: score.communicationFit,
          contextualAlignment: score.contextualAlignment,
          growthGapPotential: score.growthGapPotential,
          overallCompatibilityScore: score.overallCompatibilityScore,
          successProbability: score.successProbability,
          breakthroughMomentPrediction: score.breakthroughMomentPrediction,
          plateauRiskAssessment: score.plateauRiskAssessment,
          computedAt: score.computedAt,
          lastUpdated: score.lastUpdated,
          insights: score.insights,
          conversationStarters: score.conversationStarters,
          mentorshipRoadmap: score.mentorshipRoadmap,
          milestonePathway: score.milestonePathway,
          skillGapForecast: score.skillGapForecast,
          analysisData: score.analysisData
        },
        analysis: {
          breakdown: analysis?.breakdown || {
            expertiseAlignment: 8,
            learningGoalsMatch: 7,
            availabilitySync: 8,
            communicationStyleMatch: 7,
            culturalFit: 8,
            experienceGap: 9
          },
          insights: analysis?.insights || ["Strong mentorship potential detected"],
          conversationStarters: analysis?.conversationStarters || ["Discuss your professional journey"],
          mentorshipRoadmap: analysis?.mentorshipRoadmap || [],
          milestonePathway: analysis?.milestonePathway || [],
          skillGapForecast: analysis?.skillGapForecast || []
        },
        targetProfile: {
          ...await storage.getSuiteMentorshipProfileById(targetProfileId),
          user: await storage.getUserByMentorshipProfileId(targetProfileId)
        },
        cached: false
      };
      res.status(200).json(dashboardData);
    } catch (error) {
      console.error("Dashboard error:", error.message);
      res.status(500).json({
        message: "Server error getting dashboard data",
        error: error.message
      });
    }
  });
  function safeJsonParse(jsonString, defaultValue) {
    if (!jsonString) return defaultValue;
    try {
      return JSON.parse(jsonString);
    } catch {
      return defaultValue;
    }
  }
}

// server/payment-confirm.ts
import Stripe from "stripe";
var stripeSecretKey = process.env.STRIPE_LIVE_SECRET_KEY || process.env.STRIPE_SECRET_KEY;
var isLiveMode = !!process.env.STRIPE_LIVE_SECRET_KEY;
var stripe = stripeSecretKey ? new Stripe(stripeSecretKey, {
  apiVersion: "2024-06-20"
}) : null;
if (stripe) {
  console.log(`[STRIPE-PAYMENT] Initialized in ${isLiveMode ? "LIVE" : "TEST"} mode`);
}
async function confirmPayment(req, res, storage2) {
  try {
    const { clientSecret, paymentDetails } = req.body;
    if (!stripe) {
      return res.status(500).json({
        success: false,
        error: "Payment processing not available"
      });
    }
    console.log("[STRIPE-BACKEND] Confirming payment with client secret:", clientSecret.substring(0, 30) + "...");
    const paymentIntentId = clientSecret.split("_secret_")[0];
    let paymentIntent = await stripe.paymentIntents.retrieve(paymentIntentId);
    console.log("[STRIPE-SECURITY] Payment intent current status:", paymentIntent.status);
    if (paymentIntent.status === "requires_confirmation" || paymentIntent.status === "requires_payment_method") {
      if (isLiveMode) {
        console.log("[STRIPE-SECURITY] Cannot confirm payment in live mode without real payment method");
        return res.status(400).json({
          success: false,
          error: "Payment confirmation requires a valid payment method in live mode. Please use the Stripe Elements form instead."
        });
      } else {
        console.log("[STRIPE-SECURITY] Confirming payment intent with test payment method");
        const testPaymentMethodId = "pm_card_visa";
        paymentIntent = await stripe.paymentIntents.confirm(paymentIntentId, {
          payment_method: testPaymentMethodId
        });
      }
    } else if (paymentIntent.status === "succeeded") {
      console.log("[STRIPE-SECURITY] Payment intent already succeeded, skipping confirmation");
    } else {
      console.log("[STRIPE-SECURITY] Payment intent in unexpected state:", paymentIntent.status);
    }
    console.log("[STRIPE-BACKEND] Payment confirmation result:", {
      id: paymentIntent.id,
      status: paymentIntent.status,
      amount: paymentIntent.amount,
      currency: paymentIntent.currency
    });
    if (paymentIntent.status === "succeeded") {
      const userId = req.user.id;
      await storage2.updateUser(userId, { premiumAccess: true });
      console.log("[STRIPE-BACKEND] Payment successful, premium access granted to user:", userId);
      res.json({
        success: true,
        paymentIntent: {
          id: paymentIntent.id,
          status: paymentIntent.status,
          amount: paymentIntent.amount,
          currency: paymentIntent.currency
        },
        error: null
      });
    } else {
      console.log("[STRIPE-BACKEND] Payment not successful, status:", paymentIntent.status);
      res.json({
        success: false,
        error: `Payment ${paymentIntent.status}`,
        paymentIntent: {
          id: paymentIntent.id,
          status: paymentIntent.status
        }
      });
    }
  } catch (error) {
    console.error("[STRIPE-BACKEND] Payment confirmation error:", error);
    res.status(500).json({
      success: false,
      error: error instanceof Error ? error.message : "Payment confirmation failed"
    });
  }
}

// server/routes.ts
init_schema();
init_db();
import { ZodError as ZodError2 } from "zod";
import { fromZodError as fromZodError2 } from "zod-validation-error";
import { randomBytes as randomBytes2 } from "crypto";
import Stripe2 from "stripe";

// server/cache-invalidation.ts
import WebSocket2 from "ws";
function broadcastCacheInvalidation(connectedUsers3, options) {
  const { matchId, userId, messageId, reason } = options;
  console.log(`[CACHE-INVALIDATION] Broadcasting cache clear for match ${matchId}, reason: ${reason}`);
  const cacheInvalidationMessage = {
    type: "cache:invalidate",
    action: "clear_message_cache",
    matchId,
    messageId,
    reason,
    timestamp: (/* @__PURE__ */ new Date()).toISOString(),
    clearTargets: [
      "react_query_cache",
      "local_storage",
      "session_storage",
      "persistent_cache"
    ]
  };
  connectedUsers3.forEach((socket, connectedUserId) => {
    if (socket && socket.readyState === WebSocket2.OPEN) {
      try {
        socket.send(JSON.stringify(cacheInvalidationMessage));
        console.log(`[CACHE-INVALIDATION] Sent cache clear to user ${connectedUserId}`);
      } catch (error) {
        console.error(`[CACHE-INVALIDATION] Failed to send to user ${connectedUserId}:`, error);
      }
    }
  });
}
function invalidateMessageCaches(connectedUsers3, options) {
  const { matchId, reason } = options;
  console.log(`[CACHE-INVALIDATION] Starting complete cache invalidation for match ${matchId}`);
  try {
    broadcastCacheInvalidation(connectedUsers3, options);
    console.log(`[CACHE-INVALIDATION] Complete cache invalidation initiated for match ${matchId}`);
    return {
      success: true,
      matchId,
      reason,
      timestamp: (/* @__PURE__ */ new Date()).toISOString()
    };
  } catch (error) {
    console.error(`[CACHE-INVALIDATION] Error during cache invalidation:`, error);
    return {
      success: false,
      matchId,
      reason,
      error: error instanceof Error ? error.message : "Unknown error",
      timestamp: (/* @__PURE__ */ new Date()).toISOString()
    };
  }
}

// server/routes.ts
init_sendgrid();

// server/services/security-notifications.ts
init_sendgrid();
import crypto from "crypto";
var disputeTokens = /* @__PURE__ */ new Map();
async function sendSecurityChangeNotification(notification) {
  try {
    const disputeToken = crypto.randomBytes(16).toString("hex");
    const disputeInfo = {
      ...notification,
      disputeToken,
      timestamp: /* @__PURE__ */ new Date()
    };
    disputeTokens.set(disputeToken, disputeInfo);
    const disputeUrl = `${process.env.REPLIT_DEV_DOMAIN || "https://your-domain.com"}/dispute?token=${disputeToken}`;
    const changeTypeText = getChangeTypeText(notification.changeType);
    const oldValueDisplay = getValueDisplay(notification.changeType, notification.oldValue);
    const newValueDisplay = getValueDisplay(notification.changeType, notification.newValue);
    const subject = `\u{1F512} Security Alert: Your ${changeTypeText} Has Been Changed`;
    const htmlContent = `
      <!DOCTYPE html>
      <html>
      <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Security Alert</title>
      </head>
      <body style="font-family: Arial, sans-serif; line-height: 1.6; color: #333; max-width: 600px; margin: 0 auto; padding: 20px;">
        <div style="background: #ff4444; color: white; padding: 20px; text-align: center; border-radius: 8px; margin-bottom: 20px;">
          <h1 style="margin: 0; font-size: 24px;">\u{1F512} Security Alert</h1>
          <p style="margin: 10px 0 0 0;">Account Change Detected</p>
        </div>
        
        <p>Hello <strong>${notification.fullName}</strong>,</p>
        
        <div style="background: #fff5f5; border: 1px solid #ffcccb; border-radius: 8px; padding: 15px; margin: 20px 0;">
          <h3 style="color: #e53e3e; margin-top: 0;">\u26A0\uFE0F Your ${changeTypeText.toLowerCase()} has been changed</h3>
          <p><strong>Time:</strong> ${(/* @__PURE__ */ new Date()).toLocaleString()}</p>
          ${notification.userAgent ? `<p><strong>Device:</strong> ${notification.userAgent}</p>` : ""}
          ${notification.ipAddress ? `<p><strong>IP Address:</strong> ${notification.ipAddress}</p>` : ""}
        </div>
        
        <div style="text-align: center; margin: 25px 0;">
          <p><strong>Did you make this change?</strong></p>
          <p>If <strong>NO</strong>, click below to dispute:</p>
          <a href="${disputeUrl}" style="background: #e53e3e; color: white; padding: 12px 24px; text-decoration: none; border-radius: 8px; font-weight: bold; display: inline-block;">
            \u{1F6A8} I Did NOT Make This Change
          </a>
        </div>
        
        <p style="font-size: 14px; color: #666; margin-top: 30px;">
          <strong>CHARLEY Security Team</strong><br>
          If you made this change, you can ignore this email.<br>
          Questions? Contact <a href="mailto:admin@btechnos.com">admin@btechnos.com</a>
        </p>
      </body>
      </html>
    `;
    const textContent = `
SECURITY ALERT - ${changeTypeText} Changed

Hello ${notification.fullName},

Your ${changeTypeText.toLowerCase()} was changed on ${(/* @__PURE__ */ new Date()).toLocaleString()}.

${notification.userAgent ? `Device: ${notification.userAgent}` : ""}
${notification.ipAddress ? `IP: ${notification.ipAddress}` : ""}

If you did NOT make this change, dispute immediately:
${disputeUrl}

Otherwise, ignore this email.

CHARLEY Security Team
admin@btechnos.com
    `;
    const success = await sendEmail(process.env.SENDGRID_API_KEY, {
      to: notification.email,
      from: "admin@btechnos.com",
      subject,
      text: textContent,
      html: htmlContent
    });
    if (success) {
      console.log(`[SECURITY-NOTIFICATION] Sent ${notification.changeType} change notification to ${notification.email}`);
    } else {
      console.error(`[SECURITY-NOTIFICATION] Failed to send ${notification.changeType} change notification to ${notification.email}`);
    }
    return success;
  } catch (error) {
    console.error("[SECURITY-NOTIFICATION] Error sending security notification:", error);
    return false;
  }
}
async function handleSecurityDispute(disputeToken, req) {
  try {
    const disputeInfo = disputeTokens.get(disputeToken);
    if (!disputeInfo) {
      console.log(`[SECURITY-DISPUTE] Invalid or expired dispute token: ${disputeToken}`);
      return false;
    }
    const tokenAge = Date.now() - disputeInfo.timestamp.getTime();
    const sevenDays = 7 * 24 * 60 * 60 * 1e3;
    if (tokenAge > sevenDays) {
      disputeTokens.delete(disputeToken);
      console.log(`[SECURITY-DISPUTE] Expired dispute token: ${disputeToken}`);
      return false;
    }
    const success = await sendDisputeAlertToAdmin(disputeInfo, req);
    if (success) {
      disputeTokens.delete(disputeToken);
      console.log(`[SECURITY-DISPUTE] Successfully processed dispute for user ${disputeInfo.userId}`);
    }
    return success;
  } catch (error) {
    console.error("[SECURITY-DISPUTE] Error handling security dispute:", error);
    return false;
  }
}
async function sendDisputeAlertToAdmin(disputeInfo, req) {
  try {
    const changeTypeText = getChangeTypeText(disputeInfo.changeType);
    const oldValueDisplay = getValueDisplay(disputeInfo.changeType, disputeInfo.oldValue);
    const newValueDisplay = getValueDisplay(disputeInfo.changeType, disputeInfo.newValue);
    const subject = `\u{1F6A8} URGENT: Security Dispute - Unauthorized ${changeTypeText} Change`;
    const htmlContent = `
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Security Dispute Alert</title>
  <style>
    body { 
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; 
      line-height: 1.5; 
      margin: 0; 
      padding: 20px; 
      background: #f7fafc;
      color: #2d3748;
    }
    .container { 
      max-width: 600px; 
      margin: 0 auto; 
      background: white; 
      border-radius: 8px; 
      box-shadow: 0 4px 6px rgba(0,0,0,0.1);
      overflow: hidden;
    }
    .header { 
      background: linear-gradient(135deg, #e53e3e, #c53030); 
      color: white; 
      padding: 20px; 
      text-align: center; 
    }
    .header h1 { 
      margin: 0; 
      font-size: 22px; 
      font-weight: 700; 
    }
    .urgent-banner {
      background: #fed7d7;
      color: #742a2a;
      padding: 12px;
      text-align: center;
      font-weight: 600;
      font-size: 16px;
    }
    .content { 
      padding: 20px; 
    }
    .info-section {
      background: #f7fafc;
      border-radius: 8px;
      padding: 16px;
      margin: 16px 0;
      border-left: 4px solid #e53e3e;
    }
    .info-section h3 {
      margin: 0 0 12px 0;
      font-size: 16px;
      color: #2d3748;
    }
    .info-grid {
      display: grid;
      grid-template-columns: 140px 1fr;
      gap: 8px;
      margin: 0;
    }
    .label {
      font-weight: 600;
      color: #4a5568;
    }
    .value {
      color: #2d3748;
    }
    .action-required {
      background: #fed7d7;
      color: #742a2a;
      border-radius: 8px;
      padding: 16px;
      margin: 16px 0;
      border: 2px solid #f56565;
    }
    .action-required h3 {
      margin: 0 0 12px 0;
      color: #742a2a;
    }
    .footer { 
      background: #edf2f7; 
      padding: 16px; 
      text-align: center; 
      font-size: 12px; 
      color: #718096;
    }
    ol { margin: 8px 0; padding-left: 20px; }
    li { margin: 4px 0; }
  </style>
</head>
<body>
  <div class="container">
    <div class="urgent-banner">
      \u{1F6A8} URGENT SECURITY ALERT - IMMEDIATE ACTION REQUIRED
    </div>
    
    <div class="header">
      <h1>Security Dispute Reported</h1>
      <p style="margin: 8px 0 0 0;">Unauthorized account change disputed by user</p>
    </div>
    
    <div class="content">
      <div class="info-section">
        <h3>\u{1F464} User Information</h3>
        <div class="info-grid">
          <span class="label">User ID:</span>
          <span class="value">#${disputeInfo.userId}</span>
          <span class="label">Name:</span>
          <span class="value">${disputeInfo.fullName}</span>
          <span class="label">Email:</span>
          <span class="value">${disputeInfo.email}</span>
          <span class="label">Phone:</span>
          <span class="value">${disputeInfo.phoneNumber || "Not provided"}</span>
        </div>
      </div>
      
      <div class="info-section">
        <h3>\u{1F4CB} Disputed Change Details</h3>
        <div class="info-grid">
          <span class="label">Change Type:</span>
          <span class="value">${changeTypeText}</span>
          ${disputeInfo.oldValue ? `<span class="label">Previous Value:</span><span class="value">${oldValueDisplay}</span>` : ""}
          ${disputeInfo.newValue ? `<span class="label">New Value:</span><span class="value">${newValueDisplay}</span>` : ""}
          <span class="label">Change Time:</span>
          <span class="value">${disputeInfo.timestamp.toLocaleString()}</span>
          <span class="label">Dispute Time:</span>
          <span class="value">${(/* @__PURE__ */ new Date()).toLocaleString()}</span>
          ${disputeInfo.userAgent ? `<span class="label">Device/Browser:</span><span class="value">${disputeInfo.userAgent}</span>` : ""}
          ${disputeInfo.ipAddress ? `<span class="label">IP Address:</span><span class="value">${disputeInfo.ipAddress}</span>` : ""}
        </div>
      </div>
      
      <div class="action-required">
        <h3>\u{1F3AF} Immediate Actions Required</h3>
        <ol>
          <li><strong>Contact the user within 24 hours</strong> at ${disputeInfo.email}</li>
          <li><strong>Verify the user's identity</strong> through additional security questions</li>
          <li><strong>Review account activity logs</strong> for suspicious behavior</li>
          <li><strong>Consider temporarily suspending the account</strong> if fraud is suspected</li>
          <li><strong>Reverse the unauthorized change</strong> if confirmed as fraudulent</li>
          <li><strong>Implement additional security measures</strong> if needed</li>
        </ol>
      </div>
      
      <p style="font-size: 14px; font-weight: 600; color: #742a2a; text-align: center; margin: 20px 0;">
        This is a high-priority security incident requiring immediate attention.
      </p>
    </div>
    
    <div class="footer">
      <p><strong>CHARLEY Security System</strong></p>
      <p>Automated security dispute notification - Generated at ${(/* @__PURE__ */ new Date()).toLocaleString()}</p>
      <p>For technical issues, contact the development team immediately.</p>
    </div>
  </div>
</body>
</html>
    `;
    const textContent = `
URGENT SECURITY ALERT - UNAUTHORIZED ACCOUNT CHANGE DISPUTED

User Information:
- User ID: #${disputeInfo.userId}
- Name: ${disputeInfo.fullName}
- Email: ${disputeInfo.email}
- Phone: ${disputeInfo.phoneNumber || "Not provided"}

Disputed Change Details:
- Change Type: ${changeTypeText}
${disputeInfo.oldValue ? `- Previous Value: ${oldValueDisplay}` : ""}
${disputeInfo.newValue ? `- New Value: ${newValueDisplay}` : ""}
- Change Timestamp: ${disputeInfo.timestamp.toLocaleString()}
- Dispute Timestamp: ${(/* @__PURE__ */ new Date()).toLocaleString()}
${disputeInfo.userAgent ? `- Device/Browser: ${disputeInfo.userAgent}` : ""}
${disputeInfo.ipAddress ? `- IP Address: ${disputeInfo.ipAddress}` : ""}

IMMEDIATE ACTIONS REQUIRED:
1. Contact the user within 24 hours at ${disputeInfo.email}
2. Verify the user's identity through additional security questions
3. Review account activity logs for suspicious behavior
4. Consider temporarily suspending the account if fraud is suspected
5. Reverse the unauthorized change if confirmed as fraudulent
6. Implement additional security measures if needed

This is a high-priority security incident requiring immediate attention.

CHARLEY Security System
Generated at ${(/* @__PURE__ */ new Date()).toLocaleString()}
    `;
    const success = await sendEmail(process.env.SENDGRID_API_KEY, {
      to: "admin@btechnos.com",
      from: "admin@btechnos.com",
      subject,
      text: textContent,
      html: htmlContent
    });
    if (success) {
      console.log(`[SECURITY-DISPUTE] Sent dispute alert to admin for user ${disputeInfo.userId}`);
    } else {
      console.error(`[SECURITY-DISPUTE] Failed to send dispute alert to admin for user ${disputeInfo.userId}`);
    }
    return success;
  } catch (error) {
    console.error("[SECURITY-DISPUTE] Error sending dispute alert to admin:", error);
    return false;
  }
}
function getChangeTypeText(changeType) {
  switch (changeType) {
    case "password":
      return "Password";
    case "email":
      return "Email Address";
    case "phone":
      return "Phone Number";
    default:
      return "Account Information";
  }
}
function getValueDisplay(changeType, value) {
  if (!value) return "Not specified";
  switch (changeType) {
    case "password":
      return "\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022";
    // Never show actual passwords
    case "email":
      return value;
    case "phone":
      return value;
    default:
      return value;
  }
}
function getDisputeInfo(token) {
  return disputeTokens.get(token);
}
function cleanupExpiredTokens() {
  const now = Date.now();
  const sevenDays = 7 * 24 * 60 * 60 * 1e3;
  for (const [token, info] of disputeTokens) {
    if (now - info.timestamp.getTime() > sevenDays) {
      disputeTokens.delete(token);
    }
  }
}
setInterval(cleanupExpiredTokens, 24 * 60 * 60 * 1e3);

// server/routes.ts
init_schema();
import { eq as eq5, and as and5, or as or4, sql as sql5, gte } from "drizzle-orm";
var stripe2 = null;
var stripeSecretKey2 = process.env.STRIPE_LIVE_SECRET_KEY || process.env.STRIPE_SECRET_KEY;
var isLiveMode2 = !!process.env.STRIPE_LIVE_SECRET_KEY;
if (stripeSecretKey2) {
  stripe2 = new Stripe2(stripeSecretKey2, {
    apiVersion: "2024-06-20"
  });
  console.log(`[STRIPE-ENVIRONMENT-FIX] Backend initialized successfully in ${isLiveMode2 ? "LIVE" : "TEST"} mode`);
  console.log(`[STRIPE-ENVIRONMENT-FIX] Using ${isLiveMode2 ? "live" : "test"} secret key for payment processing`);
} else {
  console.warn("[STRIPE] No Stripe keys found - payment features will be disabled");
}
async function registerRoutes(app2) {
  function convertDbFieldsToFrontend(dbData) {
    const fieldMapping = {
      // Mentorship fields
      "mentorship_looking_for": "mentorshipLookingFor",
      "mentorship_experience_level": "mentorshipExperienceLevel",
      "mentorship_industries": "mentorshipIndustries",
      "mentorship_areas_of_expertise": "mentorshipAreasOfExpertise",
      "mentorship_education_level": "mentorshipEducationLevel",
      "mentorship_skills": "mentorshipSkills",
      "mentorship_topics": "mentorshipTopics",
      "mentorship_format": "mentorshipFormat",
      "mentorship_time_commitment": "mentorshipTimeCommitment",
      "mentorship_location_preference": "mentorshipLocationPreference",
      "mentorship_weights": "mentorshipWeights",
      // Networking fields
      "networking_purpose": "networkingPurpose",
      "networking_company_size": "networkingCompanySize",
      "networking_seniority": "networkingSeniority",
      "networking_industries": "networkingIndustries",
      "networking_areas_of_expertise": "networkingAreasOfExpertise",
      "networking_education_level": "networkingEducationLevel",
      "networking_skills": "networkingSkills",
      "networking_functional_areas": "networkingFunctionalAreas",
      "networking_geographic": "networkingGeographic",
      "networking_event_preference": "networkingEventPreference",
      "networking_weights": "networkingWeights",
      // Jobs fields
      "jobs_types": "jobsTypes",
      "jobs_salary_range": "jobsSalaryRange",
      "jobs_work_arrangement": "jobsWorkArrangement",
      "jobs_company_size": "jobsCompanySize",
      "jobs_industries": "jobsIndustries",
      "jobs_education_level": "jobsEducationLevel",
      "jobs_skills": "jobsSkills",
      "jobs_experience_level": "jobsExperienceLevel",
      "jobs_functional_areas": "jobsFunctionalAreas",
      "jobs_work_location": "jobsWorkLocation",
      "jobs_weights": "jobsWeights",
      // Global fields
      "deal_breakers": "dealBreakers",
      "preference_profiles": "preferenceProfiles"
    };
    const mappedData = {};
    Object.entries(dbData).forEach(([key, value]) => {
      const frontendField = fieldMapping[key] || key;
      mappedData[frontendField] = value;
    });
    return mappedData;
  }
  setupAuth(app2);
  const { registerUserBlockingAPI: registerUserBlockingAPI2 } = await Promise.resolve().then(() => (init_user_blocking_api(), user_blocking_api_exports));
  registerUserBlockingAPI2(app2);
  registerMatchAPI(app2);
  registerCompatibilityAPI(app2);
  registerSuiteCompatibilityAPI(app2);
  registerMentorshipCompatibilityAPI(app2);
  const { registerEnhancedDiscoveryAPI: registerEnhancedDiscoveryAPI2 } = await Promise.resolve().then(() => (init_enhanced_discovery_api(), enhanced_discovery_api_exports));
  registerEnhancedDiscoveryAPI2(app2);
  const dataCollectionRoutes = await Promise.resolve().then(() => (init_data_collection_routes(), data_collection_routes_exports));
  app2.use("/api/tracking", dataCollectionRoutes.default);
  app2.post("/api/swipe/undo", async (req, res) => {
    try {
      if (!req.isAuthenticated() || !req.user || !req.user.id) {
        console.log("[UNDO-AUTH-ERROR] Authentication failed:", {
          isAuthenticated: req.isAuthenticated(),
          hasUser: !!req.user,
          userId: req.user?.id
        });
        return res.status(401).json({
          message: "Unauthorized",
          details: "Valid authentication session required"
        });
      }
      const { userId, action } = req.body;
      const currentUser = req.user;
      if (!userId || !action) {
        return res.status(400).json({ message: "Missing required fields" });
      }
      const startTime = Date.now();
      if (action === "like" || action === "dislike") {
        await Promise.all([
          storage.removeLikeOrDislike(currentUser.id, userId),
          storage.removeSwipeFromHistory(currentUser.id, userId)
        ]);
        const sourceUserWs = connectedUsers3.get(currentUser.id);
        let restorationResults = {
          primaryWebSocket: false,
          fallbackRefresh: false,
          connectionStatus: "disconnected"
        };
        if (sourceUserWs) {
          restorationResults.connectionStatus = sourceUserWs.readyState === WebSocket3.OPEN ? "open" : "closed";
        }
        if (sourceUserWs && sourceUserWs.readyState === WebSocket3.OPEN) {
          try {
            const restorationMessage = {
              type: "meet_restore_to_discover",
              userId: parseInt(userId),
              reason: "undo_action",
              timestamp: (/* @__PURE__ */ new Date()).toISOString(),
              sourceUserId: currentUser.id
            };
            sourceUserWs.send(JSON.stringify(restorationMessage));
            restorationResults.primaryWebSocket = true;
            console.log(`[RESTORATION-PRIMARY] \u2705 Sent meet_restore_to_discover for user ${userId}`);
          } catch (error) {
            console.log(`[RESTORATION-PRIMARY] \u274C Failed:`, error.message);
          }
        }
        if (sourceUserWs && sourceUserWs.readyState === WebSocket3.OPEN) {
          try {
            const refreshMessage = {
              type: "discover:refresh",
              reason: "undo_action",
              userId: parseInt(userId),
              timestamp: (/* @__PURE__ */ new Date()).toISOString(),
              sourceUserId: currentUser.id
            };
            sourceUserWs.send(JSON.stringify(refreshMessage));
            restorationResults.fallbackRefresh = true;
            console.log(`[RESTORATION-FALLBACK] \u2705 Sent discover:refresh for user ${userId}`);
          } catch (error) {
            console.log(`[RESTORATION-FALLBACK] \u274C Failed:`, error.message);
          }
        }
        const restoredUserData = await storage.getUser(parseInt(userId));
        console.log(`[RESTORATION-COMPLETE] User ${userId} restored with results:`, {
          primary: restorationResults.primaryWebSocket ? "\u2705" : "\u274C",
          fallback: restorationResults.fallbackRefresh ? "\u2705" : "\u274C",
          connection: restorationResults.connectionStatus,
          hasUserData: !!restoredUserData
        });
        console.log(`User ${currentUser.id} undid ${action} for user ${userId} in ${Date.now() - startTime}ms`);
        return res.status(200).json({
          message: "Action undone successfully",
          performance: `${Date.now() - startTime}ms`,
          restoration: restorationResults,
          restoredUser: restoredUserData,
          userId: parseInt(userId),
          action
        });
      } else if (action === "message") {
        const [match] = await Promise.all([
          storage.getMatchBetweenUsers(currentUser.id, userId),
          storage.removeLikeOrDislike(currentUser.id, userId)
        ]);
        if (match) {
          const messageCount = await storage.getMessageCountForMatch(match.id);
          if (messageCount === 0) {
            await storage.deleteMatch(match.id);
            console.log(
              `User ${currentUser.id} undid message for user ${userId} and deleted match ${match.id} in ${Date.now() - startTime}ms`
            );
          } else {
            await storage.updateMatchStatus(match.id, false);
            console.log(
              `User ${currentUser.id} undid message for user ${userId} and updated match ${match.id} to unmatched in ${Date.now() - startTime}ms`
            );
          }
        } else {
          console.log(`User ${currentUser.id} undid message for user ${userId} (no match found) in ${Date.now() - startTime}ms`);
        }
      } else {
        return res.status(400).json({ message: "Invalid action" });
      }
      return res.status(200).json({
        message: "Action undone successfully",
        performance: `${Date.now() - startTime}ms`,
        action
      });
    } catch (error) {
      console.error("Error undoing swipe action:", error);
      return res.status(500).json({ message: "Server error" });
    }
  });
  app2.post("/api/suite/mentorship/undo", async (req, res) => {
    if (!req.isAuthenticated()) {
      return res.status(401).json({ message: "Unauthorized" });
    }
    try {
      const currentUserId = req.user.id;
      const startTime = Date.now();
      const swipeHistory2 = await storage.getUserSwipeHistory(currentUserId, "SUITE_MENTORSHIP", 1);
      if (!swipeHistory2 || swipeHistory2.length === 0) {
        return res.status(404).json({ message: "No recent swipes to undo" });
      }
      const lastSwipe = swipeHistory2[0];
      const targetUserId = lastSwipe.targetUserId;
      const targetMentorshipProfile = await storage.getSuiteMentorshipProfile(targetUserId);
      if (!targetMentorshipProfile) {
        return res.status(404).json({ message: "Target mentorship profile not found" });
      }
      const existingConnection = await storage.getSuiteMentorshipConnection(
        currentUserId,
        targetMentorshipProfile.id
      );
      if (existingConnection) {
        if (existingConnection.matched) {
          const currentUserMentorshipProfile = await storage.getSuiteMentorshipProfile(currentUserId);
          if (!currentUserMentorshipProfile) {
            console.log(`[SUITE-MENTORSHIP-UNDO] Current user ${currentUserId} has no mentorship profile`);
            return res.status(404).json({ message: "Current user mentorship profile not found" });
          }
          const mutualConnection = await storage.getSuiteMentorshipConnection(
            targetUserId,
            currentUserMentorshipProfile.id
          );
          if (mutualConnection) {
            await storage.deleteSuiteMentorshipConnectionById(existingConnection.id);
            await storage.deleteSuiteMentorshipConnectionById(mutualConnection.id);
            console.log(
              `[SUITE-MENTORSHIP-UNDO] Removed matched connection between ${currentUserId} and ${targetUserId}`
            );
          }
        } else {
          await storage.deleteSuiteMentorshipConnectionById(existingConnection.id);
          console.log(
            `[SUITE-MENTORSHIP-UNDO] Removed connection ${existingConnection.id} for user ${currentUserId}`
          );
        }
      }
      await storage.removeSwipeHistory(lastSwipe.id);
      const sourceUserWs = connectedUsers3.get(currentUserId);
      if (sourceUserWs && sourceUserWs.readyState === WebSocket3.OPEN) {
        sourceUserWs.send(
          JSON.stringify({
            type: "suite_restore_to_discover",
            suiteType: "mentorship",
            profileId: targetMentorshipProfile.id,
            userId: targetUserId,
            reason: "undo_action",
            timestamp: (/* @__PURE__ */ new Date()).toISOString()
          })
        );
        console.log(
          `[REAL-TIME] Restored mentorship profile ${targetMentorshipProfile.id} to user ${currentUserId}'s discover deck`
        );
      }
      console.log(
        `\u{1F504} [SUITE-MENTORSHIP-UNDO] User ${currentUserId} undid ${lastSwipe.action} on user ${targetUserId} in ${Date.now() - startTime}ms`
      );
      const completeProfile = await storage.getSuiteMentorshipProfile(targetUserId);
      return res.status(200).json({
        message: "Mentorship action undone successfully",
        undoneAction: lastSwipe.action,
        targetUserId,
        profileId: targetMentorshipProfile.id,
        profile: completeProfile,
        // Include full profile data for instant frontend restoration
        performance: `${Date.now() - startTime}ms`
      });
    } catch (error) {
      console.error("Error undoing mentorship swipe action:", error);
      return res.status(500).json({ message: "Server error" });
    }
  });
  app2.post("/api/suite/networking/undo", async (req, res) => {
    if (!req.isAuthenticated()) {
      return res.status(401).json({ message: "Unauthorized" });
    }
    try {
      const currentUserId = req.user.id;
      const startTime = Date.now();
      const swipeHistory2 = await storage.getUserSwipeHistory(currentUserId, "SUITE_NETWORKING", 1);
      if (!swipeHistory2 || swipeHistory2.length === 0) {
        return res.status(404).json({ message: "No recent swipes to undo" });
      }
      const lastSwipe = swipeHistory2[0];
      const targetUserId = lastSwipe.targetUserId;
      const targetNetworkingProfile = await storage.getSuiteNetworkingProfile(targetUserId);
      if (!targetNetworkingProfile) {
        return res.status(404).json({ message: "Target networking profile not found" });
      }
      const existingConnection = await storage.getSuiteNetworkingConnection(
        currentUserId,
        targetNetworkingProfile.id
      );
      if (existingConnection) {
        if (existingConnection.matched) {
          const currentUserNetworkingProfile = await storage.getSuiteNetworkingProfile(currentUserId);
          if (!currentUserNetworkingProfile) {
            console.log(`[SUITE-NETWORKING-UNDO] Current user ${currentUserId} has no networking profile`);
            return res.status(404).json({ message: "Current user networking profile not found" });
          }
          const mutualConnection = await storage.getSuiteNetworkingConnection(
            targetUserId,
            currentUserNetworkingProfile.id
          );
          if (mutualConnection) {
            await storage.deleteSuiteNetworkingConnectionById(existingConnection.id);
            await storage.deleteSuiteNetworkingConnectionById(mutualConnection.id);
            console.log(
              `[SUITE-NETWORKING-UNDO] Removed mutual networking connections: ${existingConnection.id} and ${mutualConnection.id}`
            );
          }
        } else {
          await storage.deleteSuiteNetworkingConnectionById(existingConnection.id);
          console.log(
            `[SUITE-NETWORKING-UNDO] Removed single networking connection: ${existingConnection.id}`
          );
        }
      } else {
        console.log(
          `[SUITE-NETWORKING-UNDO] No networking connection found between user ${currentUserId} and profile ${targetNetworkingProfile.id}`
        );
      }
      await storage.removeSwipeHistory(lastSwipe.id);
      const sourceUserWs = connectedUsers3.get(currentUserId);
      if (sourceUserWs && sourceUserWs.readyState === WebSocket3.OPEN) {
        sourceUserWs.send(
          JSON.stringify({
            type: "suite_restore_to_discover",
            suiteType: "networking",
            profileId: targetNetworkingProfile.id,
            userId: targetUserId,
            reason: "undo_action",
            timestamp: (/* @__PURE__ */ new Date()).toISOString()
          })
        );
        console.log(
          `[REAL-TIME] Restored networking profile ${targetNetworkingProfile.id} to user ${currentUserId}'s discover deck`
        );
      }
      console.log(
        `\u{1F504} [SUITE-NETWORKING-UNDO] User ${currentUserId} undid ${lastSwipe.action} on user ${targetUserId} in ${Date.now() - startTime}ms`
      );
      const completeProfile = await storage.getSuiteNetworkingProfile(targetUserId);
      return res.status(200).json({
        message: "Networking action undone successfully",
        undoneAction: lastSwipe.action,
        targetUserId,
        profileId: targetNetworkingProfile.id,
        profile: completeProfile,
        // Include full profile data for instant frontend restoration
        performance: `${Date.now() - startTime}ms`
      });
    } catch (error) {
      console.error("Error undoing networking swipe action:", error);
      return res.status(500).json({ message: "Server error" });
    }
  });
  app2.post("/api/suite/jobs/undo", async (req, res) => {
    if (!req.isAuthenticated()) {
      return res.status(401).json({ message: "Unauthorized" });
    }
    try {
      const currentUserId = req.user.id;
      const startTime = Date.now();
      const swipeHistory2 = await storage.getUserSwipeHistory(currentUserId, "SUITE_JOBS", 1);
      if (!swipeHistory2 || swipeHistory2.length === 0) {
        return res.status(404).json({ message: "No recent job swipes to undo" });
      }
      const lastSwipe = swipeHistory2[0];
      const targetUserId = lastSwipe.targetUserId;
      const targetJobProfile = await storage.getSuiteJobProfile(targetUserId);
      if (!targetJobProfile) {
        return res.status(404).json({ message: "Target job profile not found" });
      }
      const existingApplication = await storage.getSuiteJobApplication(
        currentUserId,
        targetJobProfile.id
      );
      if (existingApplication) {
        if (existingApplication.matched) {
          const reciprocalApplication = await storage.getSuiteJobApplicationByUsers(
            targetUserId,
            // job poster
            currentUserId
            // current user (applicant)
          );
          if (reciprocalApplication) {
            await storage.deleteSuiteJobApplicationById(existingApplication.id);
            await storage.deleteSuiteJobApplicationById(reciprocalApplication.id);
            console.log(
              `[SUITE-JOBS-UNDO] Removed mutual job applications: ${existingApplication.id} and ${reciprocalApplication.id}`
            );
          }
        } else {
          await storage.deleteSuiteJobApplicationById(existingApplication.id);
          console.log(
            `[SUITE-JOBS-UNDO] Removed single job application: ${existingApplication.id}`
          );
        }
      } else {
        console.log(
          `[SUITE-JOBS-UNDO] No job application found between user ${currentUserId} and profile ${targetJobProfile.id}`
        );
      }
      await storage.removeSwipeHistory(lastSwipe.id);
      const sourceUserWs = connectedUsers3.get(currentUserId);
      if (sourceUserWs && sourceUserWs.readyState === WebSocket3.OPEN) {
        sourceUserWs.send(
          JSON.stringify({
            type: "suite_restore_to_discover",
            suiteType: "jobs",
            profileId: targetJobProfile.id,
            userId: targetUserId,
            reason: "undo_action",
            timestamp: (/* @__PURE__ */ new Date()).toISOString()
          })
        );
        console.log(
          `[REAL-TIME] Restored job profile ${targetJobProfile.id} to user ${currentUserId}'s discover deck`
        );
      }
      console.log(
        `[SUITE-JOBS-UNDO] User ${currentUserId} undid job swipe for profile ${targetJobProfile.id} in ${Date.now() - startTime}ms`
      );
      return res.status(200).json({
        message: "Job swipe undone successfully",
        performance: `${Date.now() - startTime}ms`
      });
    } catch (error) {
      console.error("Error undoing job swipe action:", error);
      return res.status(500).json({ message: "Server error" });
    }
  });
  app2.post("/api/messages/create-chat", async (req, res) => {
    if (!req.isAuthenticated()) {
      return res.status(401).json({ message: "Unauthorized" });
    }
    try {
      const { targetUserId } = req.body;
      if (!targetUserId) {
        return res.status(400).json({ message: "Target user ID is required" });
      }
      const currentUserId = req.user.id;
      if (currentUserId === targetUserId) {
        console.log(
          `User ${currentUserId} attempted to create chat with themselves`
        );
        return res.status(400).json({ message: "Users cannot create chats with themselves" });
      }
      console.log("[CHAT-PERFORMANCE] Starting optimized chat creation process");
      const startTime = Date.now();
      const [userMatches, currentUser, targetUser] = await Promise.all([
        storage.getMatchesByUserId(currentUserId),
        storage.getUser(currentUserId),
        storage.getUser(targetUserId)
      ]);
      console.log(`[CHAT-PERFORMANCE] Parallel DB fetch completed in ${Date.now() - startTime}ms`);
      const existingMatch = userMatches.find(
        (match2) => match2.userId1 === currentUserId && match2.userId2 === targetUserId || match2.userId1 === targetUserId && match2.userId2 === currentUserId
      );
      let matchId;
      let match;
      if (!targetUser) {
        return res.status(404).json({ message: "Target user not found" });
      }
      if (existingMatch) {
        console.log(`\u{1F50D} [MEET-DIRECT-MESSAGE] Found existing match ${existingMatch.id} between users ${currentUserId} and ${targetUserId}`);
        console.log(`\u{1F50D} [MEET-DIRECT-MESSAGE] Existing match metadata: ${existingMatch.metadata}`);
        if (existingMatch.metadata) {
          try {
            const existingMetadata = typeof existingMatch.metadata === "string" ? JSON.parse(existingMatch.metadata) : existingMatch.metadata;
            if (existingMetadata && existingMetadata.origin === "SUITE") {
              console.log(`\u{1F517} [MEET-DIRECT-MESSAGE] Found existing SUITE match, checking for MEET in additionalConnections`);
              if (!existingMetadata.additionalConnections) {
                existingMetadata.additionalConnections = [];
                console.log(`\u{1F517} [MEET-DIRECT-MESSAGE] Initialized additionalConnections array`);
              }
              if (!existingMetadata.additionalConnections.includes("MEET")) {
                existingMetadata.additionalConnections.push("MEET");
                console.log(`\u{1F517} [MEET-DIRECT-MESSAGE] Adding MEET to additionalConnections for existing SUITE match ${existingMatch.id}`);
                console.log(`\u{1F517} [MEET-DIRECT-MESSAGE] New additionalConnections: ${JSON.stringify(existingMetadata.additionalConnections)}`);
                const updatedMatch = await storage.updateMatch(existingMatch.id, {
                  metadata: JSON.stringify(existingMetadata)
                });
                console.log(`\u{1F517} [MEET-DIRECT-MESSAGE] Successfully added MEET to additionalConnections for existing SUITE match ${existingMatch.id}`);
                console.log(`\u{1F517} [MEET-DIRECT-MESSAGE] Final updated metadata: ${updatedMatch?.metadata}`);
                match = updatedMatch || existingMatch;
              } else {
                console.log(`\u{1F517} [MEET-DIRECT-MESSAGE] MEET already exists in additionalConnections`);
                match = existingMatch;
              }
            } else {
              console.log(`\u{1F517} [MEET-DIRECT-MESSAGE] Existing match is not a SUITE match, using as-is`);
              match = existingMatch;
            }
          } catch (error) {
            console.error(`\u{1F517} [MEET-DIRECT-MESSAGE] Error parsing/updating existing match metadata:`, error);
            match = existingMatch;
          }
        } else {
          console.log(`\u{1F517} [MEET-DIRECT-MESSAGE] Existing match has no metadata, using as-is`);
          match = existingMatch;
        }
        matchId = existingMatch.id;
        console.log(
          `Using existing match ${existingMatch.id} for direct message without changing match status`
        );
        const recipientWs = connectedUsers3.get(targetUserId);
        if (recipientWs && recipientWs.readyState === WebSocket3.OPEN) {
          recipientWs.send(
            JSON.stringify({
              type: "chat_created",
              matchId: existingMatch.id,
              userId: currentUserId,
              isDirectMessage: true,
              // Flag to prevent match dialog
              fromUserInfo: {
                id: currentUserId,
                fullName: currentUser?.fullName || "Unknown User",
                photoUrl: currentUser?.photoUrl
              }
            })
          );
        }
      } else {
        console.log(`\u{1F50D} [MEET-DIRECT-MESSAGE] Checking for existing SUITE matches between users ${currentUserId} and ${targetUserId}`);
        const existingMatches = await storage.getAllMatchesBetweenUsers(currentUserId, targetUserId);
        console.log(`\u{1F50D} [MEET-DIRECT-MESSAGE] Found ${existingMatches.length} existing matches between users`);
        if (existingMatches.length > 0) {
          existingMatches.forEach((match2, index) => {
            console.log(`\u{1F50D} [MEET-DIRECT-MESSAGE] Match ${index + 1}: ID=${match2.id}, metadata=${match2.metadata}`);
          });
        }
        const existingSuiteMatch = existingMatches.find((match2) => {
          if (match2.metadata) {
            try {
              const metadata = typeof match2.metadata === "string" ? JSON.parse(match2.metadata) : match2.metadata;
              return metadata && metadata.origin === "SUITE";
            } catch (e) {
              console.error(`\u{1F50D} [MEET-DIRECT-MESSAGE] Failed to parse metadata for match ${match2.id}:`, e);
              return false;
            }
          }
          return false;
        });
        if (existingSuiteMatch) {
          console.log(`\u{1F517} [MEET-DIRECT-MESSAGE] Found existing SUITE match ${existingSuiteMatch.id}, adding MEET as additional connection`);
          try {
            const existingMetadata = typeof existingSuiteMatch.metadata === "string" ? JSON.parse(existingSuiteMatch.metadata) : existingSuiteMatch.metadata;
            console.log(`\u{1F517} [MEET-DIRECT-MESSAGE] Current metadata: ${JSON.stringify(existingMetadata)}`);
            if (!existingMetadata.additionalConnections) {
              existingMetadata.additionalConnections = [];
              console.log(`\u{1F517} [MEET-DIRECT-MESSAGE] Initialized additionalConnections array`);
            }
            if (!existingMetadata.additionalConnections.includes("MEET")) {
              existingMetadata.additionalConnections.push("MEET");
              console.log(`\u{1F517} [MEET-DIRECT-MESSAGE] Adding MEET to additionalConnections for SUITE match ${existingSuiteMatch.id}`);
              console.log(`\u{1F517} [MEET-DIRECT-MESSAGE] New additionalConnections: ${JSON.stringify(existingMetadata.additionalConnections)}`);
              const updatedMatch = await storage.updateMatch(existingSuiteMatch.id, {
                metadata: JSON.stringify(existingMetadata)
              });
              console.log(`\u{1F517} [MEET-DIRECT-MESSAGE] Successfully added MEET to additionalConnections for existing SUITE match ${existingSuiteMatch.id}`);
              console.log(`\u{1F517} [MEET-DIRECT-MESSAGE] Final updated metadata: ${updatedMatch?.metadata}`);
              matchId = existingSuiteMatch.id;
              match = updatedMatch || existingSuiteMatch;
            } else {
              console.log(`\u{1F517} [MEET-DIRECT-MESSAGE] MEET already exists in additionalConnections, using existing match`);
              matchId = existingSuiteMatch.id;
              match = existingSuiteMatch;
            }
          } catch (error) {
            console.error(`\u{1F517} [MEET-DIRECT-MESSAGE] Error updating existing SUITE match:`, error);
            const newMatch2 = await storage.createMatch({
              userId1: currentUserId,
              userId2: targetUserId,
              matched: true,
              // Direct messages should create matched connections
              metadata: JSON.stringify({ origin: "MEET" })
            });
            matchId = newMatch2.id;
            match = newMatch2;
          }
        } else {
          const newMatch2 = await storage.createMatch({
            userId1: currentUserId,
            userId2: targetUserId,
            matched: true,
            // CRITICAL FIX: Direct messages should create matched connections
            metadata: JSON.stringify({ origin: "MEET" })
          });
          matchId = newMatch2.id;
          match = newMatch2;
        }
        console.log(
          `Created direct message channel ${newMatch.id} without match notification`
        );
        const recipientWs = connectedUsers3.get(targetUserId);
        if (recipientWs && recipientWs.readyState === WebSocket3.OPEN) {
          recipientWs.send(
            JSON.stringify({
              type: "chat_created",
              matchId: newMatch.id,
              userId: currentUserId,
              isDirectMessage: true,
              // Flag to prevent match dialog
              fromUserInfo: {
                id: currentUserId,
                fullName: currentUser?.fullName || "Unknown User",
                photoUrl: currentUser?.photoUrl
              }
            })
          );
        }
      }
      const enrichedMatch = {
        ...match,
        // Primary user property for chat components (the other user in the match)
        user: {
          id: targetUser.id,
          fullName: targetUser.fullName,
          photoUrl: targetUser.photoUrl,
          bio: targetUser.bio,
          profession: targetUser.profession,
          location: targetUser.location
        },
        // Keep targetUser for backward compatibility
        targetUser: {
          id: targetUser.id,
          fullName: targetUser.fullName,
          photoUrl: targetUser.photoUrl,
          bio: targetUser.bio,
          profession: targetUser.profession,
          location: targetUser.location
        },
        currentUser: {
          id: currentUser?.id,
          fullName: currentUser?.fullName,
          photoUrl: currentUser?.photoUrl
        },
        // Make it clear which user is which
        initiatorId: currentUserId,
        targetUserId
      };
      const totalTime = Date.now() - startTime;
      console.log(`[CHAT-PERFORMANCE] Complete chat creation process finished in ${totalTime}ms`);
      res.json({
        matchId,
        match: enrichedMatch,
        success: true,
        performance: `${totalTime}ms`
        // Include performance metrics in response
      });
    } catch (error) {
      console.error("Error creating chat:", error);
      res.status(500).json({ message: "Server error creating chat" });
    }
  });
  app2.post("/api/check-email", async (req, res) => {
    try {
      const { email } = req.body;
      if (!email) {
        return res.status(400).json({ error: "Email is required" });
      }
      const user = await storage.getUserByEmail(email);
      return res.status(200).json({ exists: !!user });
    } catch (error) {
      console.error("Error checking email:", error);
      return res.status(500).json({ error: "Server error" });
    }
  });
  app2.get("/api/admin/users", async (req, res) => {
    try {
      const users2 = await storage.getAllUsers();
      const safeUsers = users2.map((user) => {
        const { password, ...safeUser } = user;
        return safeUser;
      });
      res.status(200).json(safeUsers);
    } catch (error) {
      console.error("Error fetching all users:", error);
      res.status(500).json({ message: "Error fetching users" });
    }
  });
  app2.delete("/api/admin/clean-users", async (req, res) => {
    try {
      await storage.cleanAllUsers();
      res.status(200).json({ message: "All users have been deleted" });
    } catch (error) {
      console.error("Error cleaning users:", error);
      res.status(500).json({ message: "Error cleaning users" });
    }
  });
  app2.get("/api/profile/:id", async (req, res) => {
    const userId = parseInt(req.params.id);
    if (isNaN(userId)) {
      return res.status(400).json({ message: "Invalid user ID" });
    }
    try {
      const user = await storage.getUser(userId);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }
      const { password, ...userWithoutPassword } = user;
      res.json(userWithoutPassword);
    } catch (error) {
      res.status(500).json({ message: "Server error retrieving profile" });
    }
  });
  app2.patch("/api/profile/:id", async (req, res) => {
    if (!req.isAuthenticated()) {
      return res.status(401).json({ message: "Unauthorized" });
    }
    const userId = parseInt(req.params.id);
    if (isNaN(userId) || req.user?.id !== userId) {
      return res.status(403).json({ message: "Not authorized to update this profile" });
    }
    try {
      console.log("Raw profile update request:", req.body);
      if (Object.keys(req.body).length === 1 && "visibilityPreferences" in req.body) {
        console.log("Processing visibility preferences-only update");
        try {
          const visPrefs = JSON.parse(req.body.visibilityPreferences);
          console.log("Parsed visibility preferences:", visPrefs);
        } catch (jsonError) {
          console.error("Invalid JSON in visibilityPreferences:", jsonError);
          return res.status(400).json({
            message: "visibilityPreferences must be a valid JSON string"
          });
        }
      }
      if (req.body.dateOfBirth && typeof req.body.dateOfBirth === "string") {
        req.body.dateOfBirth = new Date(req.body.dateOfBirth);
      }
      let profileData = {};
      if (req.body.profileHidden !== void 0) {
        if (typeof req.body.profileHidden === "boolean") {
          profileData.profileHidden = req.body.profileHidden;
        } else {
          return res.status(400).json({ message: "profileHidden must be a boolean" });
        }
      }
      if (req.body.ghostMode !== void 0) {
        if (typeof req.body.ghostMode === "boolean") {
          profileData.ghostMode = req.body.ghostMode;
        } else {
          return res.status(400).json({ message: "ghostMode must be a boolean" });
        }
      }
      if (req.body.hideAge !== void 0) {
        if (typeof req.body.hideAge === "boolean") {
          profileData.hideAge = req.body.hideAge;
        } else {
          return res.status(400).json({ message: "hideAge must be a boolean" });
        }
      }
      const otherFields = { ...req.body };
      delete otherFields.profileHidden;
      delete otherFields.ghostMode;
      delete otherFields.hideAge;
      console.log("[PROFILE-UPDATE-DEBUG] Other fields to validate:", otherFields);
      if (Object.keys(otherFields).length > 0) {
        const partialProfileSchema = userProfileSchema.partial();
        try {
          const validatedOtherFields = partialProfileSchema.parse(otherFields);
          console.log("[PROFILE-UPDATE-DEBUG] Validated fields:", validatedOtherFields);
          profileData = { ...profileData, ...validatedOtherFields };
        } catch (error) {
          console.log("[PROFILE-UPDATE-DEBUG] Validation error:", error);
          return res.status(400).json({
            message: "Validation failed",
            error: error.message
          });
        }
      }
      if (Object.keys(profileData).length === 0) {
        return res.status(400).json({ message: "No data provided for update" });
      }
      if ("email" in profileData) {
        if (profileData.email === "") {
          return res.status(400).json({ message: "Email cannot be empty" });
        }
        if (profileData.email && typeof profileData.email === "string") {
          if (!profileData.email.includes("@")) {
            return res.status(400).json({ message: "Invalid email format" });
          }
        }
      }
      if ("phoneNumber" in profileData) {
        const phoneNumber = profileData.phoneNumber;
        console.log("Validating phone number:", phoneNumber);
        if (phoneNumber === "") {
          return res.status(400).json({ message: "Phone number cannot be empty" });
        }
        const existingUser = phoneNumber ? await storage.getUserByPhoneNumber(phoneNumber) : void 0;
        if (existingUser && existingUser.id !== userId) {
          return res.status(400).json({
            message: "Phone number already registered to another user"
          });
        }
        if (typeof phoneNumber === "string") {
          if (!phoneNumber.startsWith("+")) {
            return res.status(400).json({
              message: "Phone number must start with country code (e.g., +233)"
            });
          }
          const numericPart = phoneNumber.substring(1);
          if (!/^\d+$/.test(numericPart)) {
            return res.status(400).json({
              message: "Phone number must contain only digits after the country code"
            });
          }
          if (numericPart.length < 7) {
            return res.status(400).json({
              message: "Phone number must have at least 7 digits after country code"
            });
          }
          if (phoneNumber.length > 18) {
            return res.status(400).json({
              message: "Phone number is too long. Maximum length is 18 characters including the country code"
            });
          }
          const countryCodeMatch = phoneNumber.match(/^\+(\d{1,4})/);
          if (!countryCodeMatch || countryCodeMatch[1].length < 1 || countryCodeMatch[1].length > 4) {
            return res.status(400).json({
              message: "Invalid country code format. Country code should be 1-4 digits after the + sign"
            });
          }
        }
      }
      try {
        const originalUser = await storage.getUser(userId);
        if (!originalUser) {
          return res.status(404).json({ message: "User not found" });
        }
        const isVisibilityUpdate = Object.keys(profileData).length === 1 && "visibilityPreferences" in profileData;
        if (isVisibilityUpdate) {
          console.log("Updating visibility preferences only for user", userId);
        } else {
          console.log("Updating profile fields for user", userId, profileData);
        }
        const updatedUser = await storage.updateUserProfile(
          userId,
          profileData
        );
        if (!updatedUser) {
          return res.status(404).json({ message: "User not found" });
        }
        const { password, ...userWithoutPassword } = updatedUser;
        console.log("Profile updated successfully:", userWithoutPassword);
        const userAgent = req.get("User-Agent") || "Unknown";
        const ipAddress = req.ip || req.connection.remoteAddress || "Unknown";
        if ("password" in profileData) {
          console.log(`[SECURITY-NOTIFICATION] Sending password change notification for user ${userId}`);
          sendSecurityChangeNotification({
            userId,
            email: updatedUser.email,
            fullName: updatedUser.fullName,
            phoneNumber: updatedUser.phoneNumber,
            changeType: "password",
            userAgent,
            ipAddress
          }).catch((error) => {
            console.error("[SECURITY-NOTIFICATION] Error sending password change notification:", error);
          });
        }
        if ("email" in profileData && originalUser.email !== profileData.email) {
          console.log(`[SECURITY-NOTIFICATION] Sending email change notification to PREVIOUS email for user ${userId}`);
          sendSecurityChangeNotification({
            userId,
            email: originalUser.email,
            // Send to OLD email (critical security requirement)
            fullName: updatedUser.fullName,
            phoneNumber: updatedUser.phoneNumber,
            changeType: "email",
            oldValue: originalUser.email,
            newValue: profileData.email,
            userAgent,
            ipAddress
          }).catch((error) => {
            console.error("[SECURITY-NOTIFICATION] Error sending email change notification:", error);
          });
        }
        if ("phoneNumber" in profileData && originalUser.phoneNumber !== profileData.phoneNumber) {
          console.log(`[SECURITY-NOTIFICATION] Sending phone number change notification for user ${userId}`);
          sendSecurityChangeNotification({
            userId,
            email: updatedUser.email,
            fullName: updatedUser.fullName,
            phoneNumber: originalUser.phoneNumber,
            // Use original phone number for context
            changeType: "phone",
            oldValue: originalUser.phoneNumber || "Not set",
            newValue: profileData.phoneNumber || "Removed",
            userAgent,
            ipAddress
          }).catch((error) => {
            console.error("[SECURITY-NOTIFICATION] Error sending phone number change notification:", error);
          });
        }
        if ("profileHidden" in profileData) {
          console.log(
            `User ${userId} changed profile visibility to hidden: ${profileData.profileHidden}`
          );
          if (profileVisibilityBroadcaster) {
            profileVisibilityBroadcaster(userId, profileData.profileHidden);
          }
        }
        if ("ghostMode" in profileData) {
          console.log(
            `User ${userId} changed Ghost Mode to: ${profileData.ghostMode}`
          );
          await storage.updateUserOnlineStatus(userId, !profileData.ghostMode);
          if (ghostModeBroadcaster) {
            ghostModeBroadcaster(userId, profileData.ghostMode);
            console.log(
              `Ghost Mode change broadcasted via WebSocket for user ${userId}: ghostMode=${profileData.ghostMode}`
            );
          }
        }
        return res.json(userWithoutPassword);
      } catch (storageError) {
        console.error("Storage error during profile update:", storageError);
        if (storageError instanceof Error) {
          console.error("Storage error details:", storageError.message);
          console.error("Storage error stack:", storageError.stack);
          if (storageError.message.includes("No valid values to set")) {
            return res.status(400).json({ message: "No valid values to update" });
          }
          if (storageError.message.includes("Database error")) {
            return res.status(500).json({
              message: "Database error updating profile",
              details: storageError.message
            });
          }
        }
        throw storageError;
      }
    } catch (error) {
      if (error instanceof ZodError2) {
        return res.status(400).json({ message: fromZodError2(error).message });
      }
      console.error("Profile update error:", error);
      return res.status(500).json({
        message: "Server error updating profile",
        details: error instanceof Error ? error.message : "Unknown error"
      });
    }
  });
  app2.get("/api/preferences/:userId", async (req, res) => {
    if (!req.isAuthenticated()) {
      return res.status(401).json({ message: "Unauthorized" });
    }
    const userId = parseInt(req.params.userId);
    if (isNaN(userId) || req.user?.id !== userId) {
      return res.status(403).json({ message: "Not authorized to view these preferences" });
    }
    try {
      let preferences = await storage.getUserPreferences(userId);
      if (!preferences) {
        try {
          console.log(`Creating default preferences for user ${userId}`);
          const defaultPrefs = {
            userId,
            // Set age, height, and distance preferences to NULL so new users see "Not Specified"
            minAge: null,
            maxAge: null,
            distancePreference: null,
            minHeightPreference: null,
            maxHeightPreference: null,
            religionPreference: JSON.stringify([]),
            ethnicityPreference: JSON.stringify([]),
            educationLevelPreference: JSON.stringify([]),
            hasChildrenPreference: null,
            wantsChildrenPreference: null,
            bodyTypePreference: JSON.stringify([]),
            dealBreakers: JSON.stringify([]),
            interestPreferences: JSON.stringify([]),
            matchingPriorities: JSON.stringify([]),
            relationshipGoalPreference: null
            // Changed from "long-term" to null
          };
          preferences = await storage.createUserPreferences(defaultPrefs);
          console.log(
            `Created default preferences for user ${userId}:`,
            preferences
          );
        } catch (createError) {
          console.error(
            `Error creating default preferences for user ${userId}:`,
            createError
          );
          return res.status(404).json({
            message: "Preferences not found and could not create defaults"
          });
        }
      }
      res.json(preferences);
    } catch (error) {
      console.error("Error fetching/creating preferences:", error);
      res.status(500).json({ message: "Server error retrieving preferences" });
    }
  });
  app2.post("/api/preferences", async (req, res) => {
    if (!req.isAuthenticated()) {
      return res.status(401).json({ message: "Unauthorized" });
    }
    try {
      const preferencesData = userPreferencesSchema.parse(req.body);
      const userId = req.user.id;
      const existingPreferences = await storage.getUserPreferences(userId);
      if (existingPreferences) {
        return res.status(400).json({ message: "Preferences already exist, use PATCH to update" });
      }
      const newPreferences = await storage.createUserPreferences({
        ...preferencesData,
        userId
      });
      res.status(201).json(newPreferences);
    } catch (error) {
      if (error instanceof ZodError2) {
        return res.status(400).json({ message: fromZodError2(error).message });
      }
      res.status(500).json({ message: "Server error creating preferences" });
    }
  });
  app2.patch("/api/preferences/:id", async (req, res) => {
    if (!req.isAuthenticated()) {
      return res.status(401).json({ message: "Unauthorized" });
    }
    let preferenceId = parseInt(req.params.id);
    if (isNaN(preferenceId)) {
      return res.status(400).json({ message: "Invalid preference ID" });
    }
    try {
      let preference = await storage.getUserPreferences(req.user.id);
      if (!preference) {
        try {
          console.log(
            `Creating default preferences for user ${req.user.id} during PATCH operation`
          );
          const defaultPrefs = {
            userId: req.user.id,
            // Set age, height, and distance preferences to NULL so new users see "Not Specified"
            minAge: null,
            maxAge: null,
            distancePreference: null,
            minHeightPreference: null,
            maxHeightPreference: null,
            religionPreference: JSON.stringify([]),
            ethnicityPreference: JSON.stringify([]),
            educationLevelPreference: JSON.stringify([]),
            hasChildrenPreference: null,
            wantsChildrenPreference: null,
            bodyTypePreference: JSON.stringify([]),
            dealBreakers: JSON.stringify([]),
            interestPreferences: JSON.stringify([]),
            matchingPriorities: JSON.stringify([]),
            relationshipGoalPreference: null
            // Changed from "long-term" to null
          };
          preference = await storage.createUserPreferences(defaultPrefs);
          console.log(
            `Created default preferences during PATCH for user ${req.user.id}:`,
            preference
          );
          preferenceId = preference.id;
        } catch (createError) {
          console.error(
            `Error creating default preferences for user ${req.user.id}:`,
            createError
          );
          return res.status(500).json({ message: "Failed to create preferences before update" });
        }
      } else if (preference.id !== preferenceId) {
        return res.status(403).json({ message: "Not authorized to update these preferences" });
      }
      const preferencesData = userPreferencesSchema.partial().parse(req.body);
      const updatedPreferences = await storage.updateUserPreferences(
        preferenceId,
        preferencesData
      );
      if (!updatedPreferences) {
        return res.status(404).json({ message: "Preferences not found" });
      }
      res.json(updatedPreferences);
    } catch (error) {
      if (error instanceof ZodError2) {
        return res.status(400).json({ message: fromZodError2(error).message });
      }
      res.status(500).json({ message: "Server error updating preferences" });
    }
  });
  app2.put("/api/user/nationality", requireAuth, async (req, res) => {
    try {
      const { nationality } = req.body;
      if (!nationality || typeof nationality !== "string") {
        return res.status(400).json({ message: "Nationality is required and must be a string" });
      }
      const userId = req.user?.id;
      if (!userId) {
        return res.status(401).json({ message: "User not authenticated" });
      }
      const updatedUser = await storage.updateUserProfile(userId, {
        countryOfOrigin: nationality
      });
      if (!updatedUser) {
        return res.status(404).json({ message: "User not found" });
      }
      try {
        await storage.updateUserLocationPreference(userId, nationality);
        console.log(`[NATIONALITY] Updated user ${userId} location preference to: ${nationality}`);
      } catch (prefError) {
        console.warn(`[NATIONALITY] Failed to update location preference for user ${userId}:`, prefError);
      }
      console.log(`[NATIONALITY] Updated user ${userId} nationality to: ${nationality}`);
      res.status(200).json({
        message: "Nationality updated successfully",
        nationality: updatedUser.countryOfOrigin
      });
    } catch (error) {
      console.error("Error updating user nationality:", error);
      res.status(500).json({ message: "Error updating nationality" });
    }
  });
  app2.put("/api/user/pool-country", requireAuth, async (req, res) => {
    try {
      const { poolCountry, appMode } = req.body;
      if (!poolCountry || typeof poolCountry !== "string") {
        return res.status(400).json({ message: "Pool country is required and must be a string" });
      }
      if (!appMode || !["MEET", "SUITE"].includes(appMode)) {
        return res.status(400).json({ message: "App mode is required and must be 'MEET' or 'SUITE'" });
      }
      const userId = req.user?.id;
      if (!userId) {
        return res.status(401).json({ message: "User not authenticated" });
      }
      const updatedPreference = await storage.updateUserAppSpecificPoolCountry(userId, poolCountry, appMode);
      if (!updatedPreference) {
        return res.status(404).json({ message: "Failed to update pool country preference" });
      }
      const fieldName = appMode === "MEET" ? "meetPoolCountry" : "suitePoolCountry";
      const updatedValue = appMode === "MEET" ? updatedPreference.meetPoolCountry : updatedPreference.suitePoolCountry;
      console.log(`[POOL-COUNTRY] Updated user ${userId} ${appMode} pool country to: ${poolCountry}`);
      res.status(200).json({
        message: "Pool country updated successfully",
        appMode,
        poolCountry: updatedValue,
        [fieldName]: updatedValue
      });
    } catch (error) {
      console.error("Error updating user pool country:", error);
      res.status(500).json({ message: "Error updating pool country" });
    }
  });
  app2.get("/api/user/pool-country", requireAuth, async (req, res) => {
    try {
      const userId = req.user?.id;
      if (!userId) {
        return res.status(401).json({ message: "User not authenticated" });
      }
      const preferences = await storage.getUserPreferences(userId);
      if (!preferences) {
        return res.status(404).json({ message: "User preferences not found" });
      }
      console.log(`[POOL-COUNTRY] Retrieved pool countries for user ${userId}`);
      res.status(200).json({
        meetPoolCountry: preferences.meetPoolCountry || "ANYWHERE",
        suitePoolCountry: preferences.suitePoolCountry || "ANYWHERE",
        // Legacy field for backward compatibility
        poolCountry: preferences.poolCountry || "ANYWHERE"
      });
    } catch (error) {
      console.error("Error getting user pool country:", error);
      res.status(500).json({ message: "Error getting pool country" });
    }
  });
  app2.get("/api/discover-users", async (req, res) => {
    if (!req.isAuthenticated()) {
      return res.status(401).json({ message: "Unauthorized", status: "login_required" });
    }
    try {
      const currentUserId = req.user?.id;
      if (!currentUserId) {
        return res.status(400).json({ message: "Invalid user ID" });
      }
      const discoverUsers = await storage.getDiscoverUsers(currentUserId);
      res.status(200).json(discoverUsers);
    } catch (error) {
      console.error("Error fetching discover users:", error);
      res.status(500).json({ message: "Error fetching users for discover page" });
    }
  });
  app2.get("/api/liked-by/:userId", async (req, res) => {
    if (!req.isAuthenticated()) {
      return res.status(401).json({ message: "Unauthorized" });
    }
    try {
      const userId = parseInt(req.params.userId);
      if (userId !== req.user.id) {
        return res.status(403).json({ message: "Not authorized to view these likes" });
      }
      const matches2 = await storage.getMatchesByUserId(userId);
      const likedByMatches = matches2.filter(
        (match) => match.userId2 === userId && !match.matched
      );
      const likedByUsers = await Promise.all(
        likedByMatches.map(async (match) => {
          const otherUserId = match.userId1;
          const otherUser = await storage.getUser(otherUserId);
          if (!otherUser) return null;
          const { password, ...userWithoutPassword } = otherUser;
          if (userWithoutPassword.ghostMode) {
            userWithoutPassword.isOnline = false;
          }
          let age = void 0;
          if (userWithoutPassword.dateOfBirth) {
            const birthDate = new Date(userWithoutPassword.dateOfBirth);
            const today = /* @__PURE__ */ new Date();
            age = today.getFullYear() - birthDate.getFullYear();
            const m = today.getMonth() - birthDate.getMonth();
            if (m < 0 || m === 0 && today.getDate() < birthDate.getDate()) {
              age--;
            }
          }
          return {
            id: match.id,
            // Using match id as a unique identifier
            matchId: match.id,
            userId: otherUserId,
            fullName: userWithoutPassword.fullName,
            photoUrl: userWithoutPassword.photoUrl,
            age,
            location: userWithoutPassword.location,
            bio: userWithoutPassword.bio,
            compatibility: Math.random() * 0.4 + 0.6
            // Just for demo - this should be calculated properly
          };
        })
      );
      const validLikedByUsers = likedByUsers.filter((user) => user !== null);
      res.json(validLikedByUsers);
    } catch (error) {
      console.error(
        "Error retrieving users who liked the current user:",
        error
      );
      res.status(500).json({ message: "Server error retrieving users who liked you" });
    }
  });
  app2.get("/api/match/:matchId", async (req, res) => {
    if (!req.isAuthenticated()) {
      return res.status(401).json({ message: "Unauthorized" });
    }
    const matchId = parseInt(req.params.matchId);
    const userId = req.user.id;
    if (isNaN(matchId)) {
      return res.status(400).json({ message: "Invalid match ID" });
    }
    try {
      const match = await storage.getMatchById(matchId);
      if (!match) {
        return res.status(404).json({ message: "Match not found" });
      }
      if (match.userId1 !== userId && match.userId2 !== userId) {
        return res.status(403).json({ message: "Not authorized to access this match" });
      }
      const otherUserId = match.userId1 === userId ? match.userId2 : match.userId1;
      const otherUser = await storage.getUser(otherUserId);
      const enrichedMatch = {
        ...match,
        otherUser: otherUser ? {
          id: otherUser.id,
          fullName: otherUser.fullName,
          photoUrl: otherUser.photoUrl,
          bio: otherUser.bio,
          profession: otherUser.profession,
          location: otherUser.location
        } : null
      };
      res.json(enrichedMatch);
    } catch (error) {
      console.error("Error retrieving match:", error);
      res.status(500).json({ message: "Server error retrieving match" });
    }
  });
  app2.get("/api/matches/between/:userId", async (req, res) => {
    if (!req.isAuthenticated()) {
      return res.status(401).json({ message: "Unauthorized" });
    }
    try {
      const currentUserId = req.user.id;
      const otherUserId = parseInt(req.params.userId);
      if (isNaN(otherUserId)) {
        return res.status(400).json({ message: "Invalid user ID" });
      }
      console.log(`Fetching all matches between users ${currentUserId} and ${otherUserId}`);
      const allMatches = await storage.getAllMatchesBetweenUsers(currentUserId, otherUserId);
      console.log(`Found ${allMatches.length} matches between users ${currentUserId} and ${otherUserId}`);
      res.json(allMatches);
    } catch (error) {
      console.error("Error fetching matches between users:", error);
      res.status(500).json({ message: "Server error retrieving matches" });
    }
  });
  app2.get("/api/matches", async (req, res) => {
    if (!req.isAuthenticated()) {
      return res.status(401).json({ message: "Unauthorized" });
    }
    try {
      const userId = req.user.id;
      const matches2 = await storage.getMatchesByUserId(userId);
      const confirmedMatches = matches2.filter((match) => match.matched);
      const pendingLikes = matches2.filter(
        (match) => {
          if (match.matched || match.isDislike) return false;
          if (match.metadata) {
            try {
              const metadata = typeof match.metadata === "string" ? JSON.parse(match.metadata) : match.metadata;
              if (metadata && metadata.suiteType) {
                console.log(`[SUITE-MATCH-DEBUG] Found SUITE match ${match.id} for user ${userId}, showing bidirectionally`);
                return true;
              }
            } catch (e) {
              console.error(`[SUITE-MATCH-DEBUG] Failed to parse metadata for match ${match.id}:`, e);
            }
          }
          return match.userId1 !== userId && match.userId2 === userId;
        }
      ).sort((a, b) => {
        if (a.createdAt && b.createdAt) {
          return new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime();
        }
        return b.id - a.id;
      });
      const confirmedMatchesWithProfiles = await Promise.all(
        confirmedMatches.map(async (match) => {
          const otherUserId = match.userId1 === userId ? match.userId2 : match.userId1;
          const otherUser = await storage.getUser(otherUserId);
          if (!otherUser) return null;
          const { password, ...userWithoutPassword } = otherUser;
          if (userWithoutPassword.ghostMode) {
            userWithoutPassword.isOnline = false;
          }
          const messages2 = await storage.getMessagesByMatchId(match.id, userId);
          const lastMessage = messages2.length > 0 ? messages2[messages2.length - 1] : null;
          let unreadCount = 0;
          if (match.userId1 === userId && match.hasUnreadMessages1) {
            unreadCount = messages2.filter(
              (msg) => msg.receiverId === userId && msg.senderId !== userId && // Only count messages from the other user
              !msg.read
            ).length;
          } else if (match.userId2 === userId && match.hasUnreadMessages2) {
            unreadCount = messages2.filter(
              (msg) => msg.receiverId === userId && msg.senderId !== userId && // Only count messages from the other user
              !msg.read
            ).length;
          }
          if (unreadCount === 0) {
            if (match.userId1 === userId && match.hasUnreadMessages1 || match.userId2 === userId && match.hasUnreadMessages2) {
              const hasUnreadFromOther = messages2.some(
                (msg) => msg.receiverId === userId && msg.senderId !== userId && !msg.read
              );
              if (hasUnreadFromOther) {
                unreadCount = 1;
              }
            }
          }
          return {
            ...match,
            user: userWithoutPassword,
            matchType: "confirmed",
            // This is a confirmed match
            lastMessage: lastMessage ? lastMessage.content : null,
            lastMessageTime: lastMessage ? lastMessage.createdAt : null,
            unreadCount
          };
        })
      );
      const pendingLikesWithProfiles = await Promise.all(
        pendingLikes.map(async (match) => {
          const likerUserId = match.userId1;
          const likerUser = await storage.getUser(likerUserId);
          if (!likerUser) return null;
          const { password, ...userWithoutPassword } = likerUser;
          if (userWithoutPassword.ghostMode) {
            userWithoutPassword.isOnline = false;
          }
          return {
            ...match,
            user: userWithoutPassword,
            matchType: "pending"
            // This user liked the current user but isn't matched yet
          };
        })
      );
      const allMatches = [
        ...confirmedMatchesWithProfiles,
        ...pendingLikesWithProfiles
      ].filter((match) => match !== null);
      res.json(allMatches);
    } catch (error) {
      res.status(500).json({ message: "Server error retrieving matches" });
    }
  });
  app2.delete("/api/matches/:id", async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ message: "Unauthorized", success: false });
      }
      const matchId = parseInt(req.params.id);
      if (isNaN(matchId)) {
        return res.status(400).json({ message: "Invalid match ID", success: false });
      }
      const match = await storage.getMatchById(matchId);
      if (!match) {
        return res.status(404).json({ message: "Match not found", success: false });
      }
      if (match.userId1 !== req.user.id && match.userId2 !== req.user.id) {
        return res.status(403).json({
          message: "Not authorized to delete this match",
          success: false
        });
      }
      const currentUserId = req.user.id;
      const otherUserId = match.userId1 === currentUserId ? match.userId2 : match.userId1;
      console.log(
        `[SWIPE] User ${currentUserId} disliked user ${otherUserId} via Matches page`
      );
      await storage.deleteMatch(matchId);
      try {
        await storage.createMatch({
          userId1: currentUserId,
          userId2: otherUserId,
          matched: false,
          isDislike: true,
          metadata: JSON.stringify({ origin: "MEET" })
        });
        console.log(
          `[SWIPE] Created dislike record: ${currentUserId} -> ${otherUserId}`
        );
      } catch (error) {
        if (error instanceof Error && error.message.includes("duplicate")) {
          console.log(
            `[SWIPE] Dislike record ${currentUserId} -> ${otherUserId} already exists`
          );
        } else {
          throw error;
        }
      }
      try {
        await storage.createMatch({
          userId1: otherUserId,
          userId2: currentUserId,
          matched: false,
          isDislike: true,
          metadata: JSON.stringify({ origin: "MEET" })
        });
        console.log(
          `[SWIPE] Created bidirectional dislike record: ${otherUserId} -> ${currentUserId}`
        );
      } catch (error) {
        if (error instanceof Error && error.message.includes("duplicate")) {
          console.log(
            `[SWIPE] Bidirectional dislike record ${otherUserId} -> ${currentUserId} already exists`
          );
        } else {
          throw error;
        }
      }
      if (connectedUsers3) {
        const otherUserSocket = connectedUsers3.get(otherUserId);
        if (otherUserSocket && otherUserSocket.readyState === WebSocket3.OPEN) {
          otherUserSocket.send(
            JSON.stringify({
              type: "swipe_action",
              action: "dislike",
              targetUserId: currentUserId,
              fromUserId: currentUserId
            })
          );
          console.log(
            `[SWIPE] Notified user ${otherUserId} about dislike action from user ${currentUserId}`
          );
        }
        const currentUserSocket = connectedUsers3.get(currentUserId);
        if (currentUserSocket && currentUserSocket.readyState === WebSocket3.OPEN) {
          currentUserSocket.send(
            JSON.stringify({
              type: "discover:refresh",
              reason: "dislike_action",
              timestamp: (/* @__PURE__ */ new Date()).toISOString()
            })
          );
        }
      }
      return res.status(200).json({ message: "Match deleted successfully", success: true });
    } catch (error) {
      console.error("Error deleting match:", error);
      const errorMessage = error instanceof Error ? error.message : "Unknown error";
      return res.status(500).json({
        message: "Server error deleting match",
        error: errorMessage,
        success: false
      });
    }
  });
  app2.post("/api/matches/:id/unmatch", async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ message: "Unauthorized", success: false });
      }
      const matchId = parseInt(req.params.id);
      if (isNaN(matchId)) {
        return res.status(400).json({ message: "Invalid match ID", success: false });
      }
      const match = await storage.getMatchById(matchId);
      if (!match) {
        return res.status(404).json({ message: "Match not found", success: false });
      }
      if (match.userId1 !== req.user.id && match.userId2 !== req.user.id) {
        return res.status(403).json({ message: "Not authorized to unmatch", success: false });
      }
      const currentUserId = req.user.id;
      const otherUserId = match.userId1 === currentUserId ? match.userId2 : match.userId1;
      const { sendUnmatchNotification: sendUnmatchNotification2 } = await Promise.resolve().then(() => (init_match_api(), match_api_exports));
      console.log(
        `[UNMATCH] Starting comprehensive archival for match ${matchId}`
      );
      let archivedMatchId = null;
      let messageCount = 0;
      try {
        const { ArchivingService: ArchivingService2 } = await Promise.resolve().then(() => (init_archiving_service(), archiving_service_exports));
        const archiveResult = await ArchivingService2.archiveMatchWithMessages(
          matchId,
          currentUserId,
          "unmatch"
        );
        archivedMatchId = archiveResult.archivedMatchId;
        messageCount = archiveResult.messageCount;
        console.log(
          `[UNMATCH] Successfully archived match ${matchId} as archive ${archivedMatchId} with ${messageCount} messages`
        );
      } catch (archiveError) {
        console.error(
          `[UNMATCH] Failed to archive match ${matchId}:`,
          archiveError
        );
      }
      await db.delete(typingStatus).where(eq5(typingStatus.matchId, matchId));
      await db.delete(videoCalls).where(eq5(videoCalls.matchId, matchId));
      const messages2 = await storage.getMessagesByMatchId(matchId);
      if (messages2 && messages2.length > 0) {
        for (const message of messages2) {
          await db.delete(messages).where(eq5(messages.id, message.id));
        }
      }
      await storage.deleteMatch(matchId);
      console.log(
        `[UNMATCH] Creating bidirectional dislike records for users ${currentUserId} and ${otherUserId}`
      );
      try {
        await db.insert(matches).values({
          userId1: currentUserId,
          userId2: otherUserId,
          matched: false,
          isDislike: true,
          createdAt: /* @__PURE__ */ new Date()
        });
        await db.insert(matches).values({
          userId1: otherUserId,
          userId2: currentUserId,
          matched: false,
          isDislike: true,
          createdAt: /* @__PURE__ */ new Date()
        });
        console.log(
          `[UNMATCH] \u2705 Bidirectional dislike records created successfully - users ${currentUserId} and ${otherUserId} will never appear in each other's discovery again`
        );
      } catch (dislikeError) {
        console.error(
          `[UNMATCH] \u274C Failed to create dislike records:`,
          dislikeError
        );
      }
      console.log(
        `Sending unmatch notification to user ${otherUserId} about match ${matchId}`
      );
      await sendUnmatchNotification2(otherUserId, matchId, currentUserId);
      const responseData = {
        message: "Unmatched successfully",
        success: true
      };
      if (archivedMatchId) {
        responseData.archived = {
          matchId: archivedMatchId,
          messageCount,
          timestamp: (/* @__PURE__ */ new Date()).toISOString()
        };
      }
      return res.status(200).json(responseData);
    } catch (error) {
      console.error("Error unmatching:", error);
      const errorMessage = error instanceof Error ? error.message : "Unknown error";
      return res.status(500).json({
        message: "Server error unmatching",
        error: errorMessage,
        success: false
      });
    }
  });
  app2.post("/api/report-user", requireAuth, async (req, res) => {
    try {
      const reportingUserId = req.user.id;
      const dataWithReporter = {
        ...req.body,
        reporterUserId: reportingUserId
      };
      const validatedData = insertUserReportStrikeSchema.parse(dataWithReporter);
      if (reportingUserId === validatedData.reportedUserId) {
        return res.status(400).json({
          message: "Cannot report yourself",
          success: false
        });
      }
      const reportedUser = await storage.getUser(validatedData.reportedUserId);
      if (!reportedUser) {
        return res.status(404).json({
          message: "Reported user not found",
          success: false
        });
      }
      let matchId = void 0;
      if (validatedData.matchId) {
        const match = await storage.getMatchById(validatedData.matchId);
        if (match && (match.userId1 === reportingUserId && match.userId2 === validatedData.reportedUserId || match.userId2 === reportingUserId && match.userId1 === validatedData.reportedUserId)) {
          matchId = validatedData.matchId;
        }
      }
      console.log(`[REPORT-USER] User ${reportingUserId} reporting user ${validatedData.reportedUserId} for: ${validatedData.reason}`);
      const reportStrike = await storage.createUserReportStrike({
        reporterUserId: validatedData.reporterUserId,
        reportedUserId: validatedData.reportedUserId,
        reason: validatedData.reason,
        description: validatedData.description,
        matchId
      });
      const totalStrikes = await storage.getUserReportStrikeCount(validatedData.reportedUserId);
      console.log(`[REPORT-USER] Report created successfully. User ${validatedData.reportedUserId} now has ${totalStrikes} total strikes`);
      if (matchId) {
        try {
          console.log(`[REPORT-USER] Unmatching users ${reportingUserId} and ${validatedData.reportedUserId} due to report`);
          const { ArchivingService: ArchivingService2 } = await Promise.resolve().then(() => (init_archiving_service(), archiving_service_exports));
          await ArchivingService2.archiveMatchWithMessages(matchId, reportingUserId, "user_deletion");
          await storage.deleteMatch(matchId);
          await db.insert(matches).values([
            {
              userId1: reportingUserId,
              userId2: validatedData.reportedUserId,
              matched: false,
              isDislike: true,
              createdAt: /* @__PURE__ */ new Date()
            },
            {
              userId1: validatedData.reportedUserId,
              userId2: reportingUserId,
              matched: false,
              isDislike: true,
              createdAt: /* @__PURE__ */ new Date()
            }
          ]);
          console.log(`[REPORT-USER] Successfully unmatched and created dislike records`);
        } catch (unmatchError) {
          console.error(`[REPORT-USER] Error during unmatch process:`, unmatchError);
        }
      }
      if (totalStrikes >= 3) {
        console.log(`[REPORT-USER] User ${validatedData.reportedUserId} reached suspension threshold with ${totalStrikes} strikes`);
        try {
          const suspensionExpiresAt = /* @__PURE__ */ new Date();
          suspensionExpiresAt.setDate(suspensionExpiresAt.getDate() + 3);
          await storage.updateUserProfile(validatedData.reportedUserId, {
            isSuspended: true,
            suspendedAt: /* @__PURE__ */ new Date(),
            suspensionExpiresAt
          });
          console.log(`[REPORT-USER] User ${validatedData.reportedUserId} suspended until ${suspensionExpiresAt.toISOString()}`);
          const { sendEmail: sendEmail2 } = await Promise.resolve().then(() => (init_sendgrid(), sendgrid_exports));
          const emailContent = `
            <div style="font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; max-width: 600px; margin: 0 auto; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); border-radius: 20px; overflow: hidden; box-shadow: 0 20px 40px rgba(0,0,0,0.1);">
              <div style="background: linear-gradient(90deg, #ff6b6b, #4ecdc4, #45b7d1, #96ceb4, #ffeaa7, #dda0dd, #98d8c8); height: 6px;"></div>
              
              <div style="padding: 40px; text-align: center; background: white;">
                <h1 style="color: #333; margin: 0 0 20px 0; font-size: 28px; font-weight: 700;">
                  \u{1F6A8} Account Suspension Notice
                </h1>
                
                <div style="background: linear-gradient(135deg, #ff6b6b, #ee5a52); padding: 20px; border-radius: 12px; margin: 20px 0;">
                  <h2 style="color: white; margin: 0; font-size: 18px;">
                    Your CHARLEY account has been suspended
                  </h2>
                </div>

                <p style="color: #555; font-size: 16px; line-height: 1.6; margin: 20px 0;">
                  Dear ${reportedUser.fullName},
                </p>

                <p style="color: #555; font-size: 16px; line-height: 1.6; margin: 20px 0;">
                  Your account has been suspended due to multiple reports received regarding your behavior on the platform. 
                  You have accumulated <strong>${totalStrikes} reports</strong>, which violates our community guidelines.
                </p>

                <div style="background: #f8f9fa; padding: 20px; border-radius: 8px; margin: 20px 0;">
                  <h3 style="color: #333; margin: 0 0 10px 0;">Suspension Details:</h3>
                  <p style="color: #666; margin: 5px 0;"><strong>Duration:</strong> 3 days</p>
                  <p style="color: #666; margin: 5px 0;"><strong>Reason:</strong> Multiple user reports</p>
                  <p style="color: #666; margin: 5px 0;"><strong>Total Reports:</strong> ${totalStrikes}</p>
                </div>

                <p style="color: #555; font-size: 16px; line-height: 1.6; margin: 20px 0;">
                  If you believe this suspension is incorrect, you can appeal by contacting our support team at 
                  <a href="mailto:admin@btechnos.com" style="color: #667eea;">admin@btechnos.com</a>
                </p>

                <div style="margin: 30px 0;">
                  <p style="color: #999; font-size: 14px; margin: 0;">
                    BTechnos Team<br>
                    CHARLEY Dating Platform
                  </p>
                </div>
              </div>
            </div>
          `;
          await sendEmail2(process.env.SENDGRID_API_KEY, {
            to: reportedUser.email,
            from: "admin@btechnos.com",
            subject: "\u{1F6A8} CHARLEY Account Suspension Notice",
            html: emailContent,
            text: `Your CHARLEY account has been suspended due to multiple reports. You have ${totalStrikes} total reports. Contact admin@btechnos.com to appeal.`
          });
          console.log(`[REPORT-USER] Suspension email sent to ${reportedUser.email}`);
        } catch (emailError) {
          console.error(`[REPORT-USER] Failed to send suspension email:`, emailError);
        }
      }
      return res.status(201).json({
        message: "Report submitted successfully",
        success: true,
        reportId: reportStrike.id,
        totalStrikes,
        suspended: totalStrikes >= 3
      });
    } catch (error) {
      console.error("Error creating report:", error);
      if (error instanceof ZodError2) {
        return res.status(400).json({
          message: "Validation failed",
          errors: fromZodError2(error).details,
          success: false
        });
      }
      const errorMessage = error instanceof Error ? error.message : "Unknown error";
      return res.status(500).json({
        message: "Server error creating report",
        error: errorMessage,
        success: false
      });
    }
  });
  app2.post("/api/suspension/appeal", async (req, res) => {
    if (!req.isAuthenticated()) {
      return res.status(401).json({ message: "Unauthorized" });
    }
    try {
      const { message } = req.body;
      const userId = req.user.id;
      if (!message || typeof message !== "string" || message.trim().length === 0) {
        return res.status(400).json({
          message: "Appeal message is required",
          success: false
        });
      }
      const user = await storage.getUser(userId);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }
      try {
        const { sendEmail: sendEmail2 } = await Promise.resolve().then(() => (init_sendgrid(), sendgrid_exports));
        const emailContent = `
          <div style="font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; max-width: 600px; margin: 0 auto; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); border-radius: 20px; overflow: hidden; box-shadow: 0 20px 40px rgba(0,0,0,0.1);">
            <div style="background: linear-gradient(90deg, #ff6b6b, #4ecdc4, #45b7d1, #96ceb4, #ffeaa7, #dda0dd, #98d8c8); height: 6px;"></div>
            
            <div style="padding: 40px; text-align: center; background: white;">
              <h1 style="color: #333; margin: 0 0 20px 0; font-size: 28px; font-weight: 700;">
                \u{1F4DD} Suspension Appeal Request
              </h1>
              
              <div style="background: linear-gradient(135deg, #4ecdc4, #45b7d1); padding: 20px; border-radius: 12px; margin: 20px 0;">
                <h2 style="color: white; margin: 0; font-size: 18px;">
                  Appeal from suspended user
                </h2>
              </div>

              <div style="background: #f8f9fa; padding: 20px; border-radius: 8px; margin: 20px 0; text-align: left;">
                <h3 style="color: #333; margin: 0 0 10px 0;">User Details:</h3>
                <p style="color: #666; margin: 5px 0;"><strong>User ID:</strong> ${userId}</p>
                <p style="color: #666; margin: 5px 0;"><strong>Name:</strong> ${user.fullName}</p>
                <p style="color: #666; margin: 5px 0;"><strong>Email:</strong> ${user.email}</p>
                <p style="color: #666; margin: 5px 0;"><strong>Phone:</strong> ${user.phoneNumber || "Not provided"}</p>
              </div>

              <div style="background: #fff3cd; padding: 20px; border-radius: 8px; margin: 20px 0; text-align: left;">
                <h3 style="color: #333; margin: 0 0 10px 0;">Appeal Message:</h3>
                <p style="color: #856404; line-height: 1.6; white-space: pre-wrap;">${message.trim()}</p>
              </div>

              <div style="margin: 30px 0;">
                <p style="color: #999; font-size: 14px; margin: 0;">
                  BTechnos Admin Team<br>
                  CHARLEY Dating Platform
                </p>
              </div>
            </div>
          </div>
        `;
        await sendEmail2(process.env.SENDGRID_API_KEY, {
          to: "admin@btechnos.com",
          from: "admin@btechnos.com",
          subject: `\u{1F6A8} Suspension Appeal - ${user.fullName} (ID: ${userId})`,
          html: emailContent,
          text: `Suspension Appeal Request

User: ${user.fullName} (ID: ${userId})
Email: ${user.email}
Phone: ${user.phoneNumber || "Not provided"}

Message:
${message.trim()}`
        });
        console.log(`[SUSPENSION-APPEAL] Appeal submitted by user ${userId} sent to admin`);
        return res.status(200).json({
          message: "Appeal submitted successfully",
          success: true
        });
      } catch (emailError) {
        console.error(`[SUSPENSION-APPEAL] Failed to send appeal email:`, emailError);
        return res.status(500).json({
          message: "Failed to send appeal. Please try again later.",
          success: false
        });
      }
    } catch (error) {
      console.error("Error processing suspension appeal:", error);
      const errorMessage = error instanceof Error ? error.message : "Unknown error";
      return res.status(500).json({
        message: "Server error processing appeal",
        error: errorMessage,
        success: false
      });
    }
  });
  app2.get(
    "/api/match-dashboard/:matchId",
    async (req, res) => {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      try {
        const matchId = parseInt(req.params.matchId);
        const userId = req.user.id;
        if (isNaN(matchId)) {
          return res.status(400).json({ message: "Invalid match ID" });
        }
        const match = await storage.getMatchById(matchId);
        if (!match) {
          return res.status(404).json({ message: "Match not found" });
        }
        if (match.userId1 !== userId && match.userId2 !== userId) {
          return res.status(403).json({ message: "Not authorized to view this match dashboard" });
        }
        const otherUserId = match.userId1 === userId ? match.userId2 : match.userId1;
        const otherUser = await storage.getUser(otherUserId);
        if (!otherUser) {
          return res.status(404).json({ message: "Match user not found" });
        }
        const { password, ...otherUserWithoutPassword } = otherUser;
        const dashboardData = {
          matchId,
          matchUser: {
            id: otherUserWithoutPassword.id,
            fullName: otherUserWithoutPassword.fullName,
            photoUrl: otherUserWithoutPassword.photoUrl || "https://via.placeholder.com/150"
          },
          overallScore: 71,
          // This will come from GPT model
          // All other data will be populated by GPT model integration
          coreCompatibility: [],
          loveLanguages: [],
          personalityTraits: [],
          culturalFactors: [],
          lifestyleActivities: [],
          interactionMetrics: [],
          idealDateSuggestion: "Data will be provided by AI analysis system"
        };
        res.json(dashboardData);
      } catch (error) {
        console.error("Error retrieving match dashboard data:", error);
        res.status(500).json({ message: "Server error retrieving match dashboard data" });
      }
    }
  );
  app2.get("/api/potential-matches", async (req, res) => {
    if (!req.isAuthenticated()) {
      return res.status(401).json({ message: "Unauthorized" });
    }
    try {
      const userId = req.user.id;
      const potentialMatches = await storage.getPotentialMatches(userId);
      const sanitizedMatches = potentialMatches.map((user) => {
        const { password, ...userWithoutPassword } = user;
        return userWithoutPassword;
      });
      res.json(sanitizedMatches);
    } catch (error) {
      res.status(500).json({ message: "Server error retrieving potential matches" });
    }
  });
  app2.get("/api/messages/:matchId", async (req, res) => {
    if (!req.isAuthenticated()) {
      return res.status(401).json({ message: "Unauthorized" });
    }
    const matchId = parseInt(req.params.matchId);
    const userId = req.user.id;
    if (isNaN(matchId)) {
      return res.status(400).json({ message: "Invalid match ID" });
    }
    try {
      const match = await storage.getMatchById(matchId);
      if (!match) {
        return res.status(404).json({ message: "Match not found" });
      }
      if (match.userId1 !== userId && match.userId2 !== userId) {
        return res.status(403).json({ message: "Not authorized to view these messages" });
      }
      const messages2 = await storage.getMessagesByMatchId(matchId, userId);
      for (const message of messages2) {
        if (message.receiverId === userId && !message.read) {
          await storage.markMessageAsReadWithTimestamp(message.id);
        }
      }
      await storage.markMatchRead(matchId, userId);
      res.json(messages2);
    } catch (error) {
      console.error("Error retrieving messages:", error);
      res.status(500).json({ message: "Server error retrieving messages" });
    }
  });
  app2.get("/api/messages", async (req, res) => {
    if (!req.isAuthenticated()) {
      return res.status(401).json({ message: "Unauthorized" });
    }
    try {
      const userId = req.user.id;
      const matches2 = await storage.getMatchesByUserId(userId);
      const confirmedMatches = matches2.filter((match) => match.matched);
      const allMessages = await Promise.all(
        confirmedMatches.map(async (match) => {
          const messages2 = await storage.getMessagesByMatchId(match.id, userId);
          const hasUnreadMessages = match.userId1 === userId ? match.hasUnreadMessages1 : match.hasUnreadMessages2;
          return {
            matchId: match.id,
            messages: messages2,
            hasUnreadMessages,
            lastMessageAt: match.lastMessageAt
          };
        })
      );
      console.log(
        `User ${userId} fetched messages for ${confirmedMatches.length} matches`
      );
      res.json(allMessages);
    } catch (error) {
      console.error("Error fetching all messages:", error);
      res.status(500).json({ message: "Server error retrieving messages" });
    }
  });
  app2.get("/api/messages/unread/count", async (req, res) => {
    if (!req.isAuthenticated()) {
      return res.status(401).json({ message: "Unauthorized" });
    }
    try {
      const userId = req.user.id;
      const mode = req.query.mode || "MEET";
      console.log(
        `Fetching unread message count for user ${userId} in mode ${mode}`
      );
      const conversationsWithUnread = await storage.getUnreadConversationsCount(userId);
      console.log(`[API] Returning unread count for ${mode} mode: ${conversationsWithUnread}`);
      res.json({ count: conversationsWithUnread });
    } catch (error) {
      console.error("Error fetching unread message count:", error);
      res.status(500).json({ message: "Server error retrieving unread count" });
    }
  });
  app2.post("/api/messages", async (req, res) => {
    if (!req.isAuthenticated()) {
      return res.status(401).json({ message: "Unauthorized" });
    }
    try {
      const messageData = insertMessageSchema.parse(req.body);
      if (messageData.senderId !== req.user.id) {
        return res.status(403).json({ message: "Not authorized to send message as this user" });
      }
      const match = await storage.getMatchById(messageData.matchId);
      if (!match) {
        return res.status(404).json({ message: "Match not found" });
      }
      if (match.userId1 !== req.user.id && match.userId2 !== req.user.id) {
        return res.status(403).json({ message: "Not authorized to send message in this match" });
      }
      const validReceiver = match.userId1 === messageData.receiverId || match.userId2 === messageData.receiverId;
      if (!validReceiver) {
        return res.status(400).json({ message: "Receiver is not part of this match" });
      }
      const newMessage = await storage.createMessage(messageData);
      res.status(201).json(newMessage);
    } catch (error) {
      if (error instanceof ZodError2) {
        return res.status(400).json({ message: fromZodError2(error).message });
      }
      res.status(500).json({ message: "Server error creating message" });
    }
  });
  app2.post("/api/messages/:matchId", async (req, res) => {
    if (!req.isAuthenticated()) {
      return res.status(401).json({ message: "Unauthorized" });
    }
    try {
      const matchId = parseInt(req.params.matchId);
      if (isNaN(matchId)) {
        return res.status(400).json({ message: "Invalid match ID" });
      }
      const {
        content,
        receiverId,
        messageType,
        audioUrl,
        audioDuration,
        replyToMessageId,
        replyToMessage
      } = req.body;
      console.log("Message content received:", {
        contentType: typeof content,
        content: typeof content === "string" ? content.length > 30 ? content.substring(0, 30) + "..." : content : content,
        receiverId,
        messageType
      });
      if (!content || typeof content !== "string" || content.trim().length === 0) {
        console.error("Message content is null or empty:", {
          content,
          contentType: typeof content
        });
        return res.status(400).json({
          message: "Message content is required and must be a non-empty string"
        });
      }
      const match = await storage.getMatchById(matchId);
      if (!match) {
        return res.status(404).json({ message: "Match not found" });
      }
      if (match.userId1 !== req.user.id && match.userId2 !== req.user.id) {
        return res.status(403).json({ message: "Not authorized to send message in this match" });
      }
      const validReceiver = match.userId1 === receiverId || match.userId2 === receiverId;
      if (!validReceiver) {
        return res.status(400).json({ message: "Receiver is not part of this match" });
      }
      const trimmedContent = content.trim();
      try {
        console.log(
          `[DUPLICATE-PREVENTION] Checking for duplicates, content: "${trimmedContent.substring(0, 20)}..."`
        );
        const longWindow = /* @__PURE__ */ new Date();
        longWindow.setMinutes(longWindow.getMinutes() - 5);
        const longWindowStr = longWindow.toISOString();
        const exactDuplicates = await storage.findRecentDuplicateMessages({
          matchId,
          senderId: req.user.id,
          content: trimmedContent,
          messageType: messageType || "text",
          since: longWindowStr
        });
        if (exactDuplicates && exactDuplicates.length > 0) {
          const duplicateMessage = exactDuplicates[0];
          console.log(
            `[DUPLICATE-PREVENTION] BLOCKED: Found exact duplicate message ${duplicateMessage.id} from ${duplicateMessage.createdAt}`
          );
          res.setHeader("X-Duplicate-Message", "true");
          res.setHeader("X-Duplicate-Strategy", "exact-match");
          return res.status(200).json(duplicateMessage);
        }
        if (trimmedContent.length <= 5) {
          const veryLongWindow = /* @__PURE__ */ new Date();
          veryLongWindow.setMinutes(veryLongWindow.getMinutes() - 10);
          const caseInsensitiveDuplicates = await storage.findRecentDuplicateMessages({
            matchId,
            senderId: req.user.id,
            content: trimmedContent,
            messageType: messageType || "text",
            since: veryLongWindow.toISOString(),
            caseInsensitive: true
            // Enable case-insensitive matching for short messages
          });
          if (caseInsensitiveDuplicates && caseInsensitiveDuplicates.length > 0) {
            const duplicateMessage = caseInsensitiveDuplicates[0];
            console.log(
              `[DUPLICATE-PREVENTION] BLOCKED: Found case-insensitive match for short message "${trimmedContent}" (ID: ${duplicateMessage.id})`
            );
            res.setHeader("X-Duplicate-Message", "true");
            res.setHeader("X-Duplicate-Strategy", "case-insensitive-short");
            return res.status(200).json(duplicateMessage);
          }
        }
        const veryRecentWindow = /* @__PURE__ */ new Date();
        veryRecentWindow.setSeconds(veryRecentWindow.getSeconds() - 30);
        const recentDuplicates = await storage.findRecentDuplicateMessages({
          matchId,
          senderId: req.user.id,
          content: trimmedContent,
          messageType: messageType || "text",
          since: veryRecentWindow.toISOString(),
          caseInsensitive: false
          // Case-sensitive for exact matching
        });
        if (recentDuplicates && recentDuplicates.length > 0) {
          const duplicateMessage = recentDuplicates[0];
          console.log(
            `[DUPLICATE-PREVENTION] BLOCKED: Message throttled, same content sent ${recentDuplicates.length} times in the last 30 seconds`
          );
          res.setHeader("X-Duplicate-Message", "true");
          res.setHeader("X-Duplicate-Strategy", "throttle");
          return res.status(200).json(duplicateMessage);
        }
        console.log(
          `[DUPLICATE-PREVENTION] No duplicates found, proceeding with message creation`
        );
      } catch (duplicateError) {
        console.error(
          "[DUPLICATE-PREVENTION] Error checking for duplicates:",
          duplicateError
        );
      }
      let calculatedReplyToIsCurrentUser = null;
      if (replyToMessageId && replyToMessage) {
        const originalMessage = await storage.getMessageById(replyToMessageId);
        if (originalMessage) {
          calculatedReplyToIsCurrentUser = originalMessage.senderId === req.user.id;
        }
      }
      const messageData = {
        matchId,
        senderId: req.user.id,
        receiverId,
        content: trimmedContent,
        messageType: messageType || "text",
        audioUrl: audioUrl || null,
        audioDuration: audioDuration || null,
        encryptedContent: null,
        iv: null,
        // Encryption removed as per requirements
        // Reply fields - don't calculate isCurrentUser here, it will be done dynamically when fetching
        replyToMessageId: replyToMessageId || null,
        replyToContent: replyToMessage?.content || null,
        replyToSenderName: replyToMessage?.senderName || null,
        replyToIsCurrentUser: null
        // Will be calculated dynamically when fetching messages
      };
      console.log("Creating message with data:", {
        matchId,
        senderId: req.user.id,
        receiverId,
        contentLength: trimmedContent.length,
        messageType: messageType || "text",
        replyToMessageId: replyToMessageId || null,
        replyToContent: replyToMessage?.content?.substring(0, 20) || null
      });
      const newMessage = await storage.createMessage(messageData);
      let transformedMessage = newMessage;
      if (newMessage.replyToMessageId && newMessage.replyToContent && newMessage.replyToSenderName) {
        let isCurrentUser = false;
        if (replyToMessageId) {
          const originalMessage = await storage.getMessageById(replyToMessageId);
          if (originalMessage) {
            isCurrentUser = originalMessage.senderId === req.user.id;
            console.log(
              `\u{1F504} [REPLY-TRANSFORM-CREATE] Message ${newMessage.id} "${newMessage.content}"`
            );
            console.log(
              `   \u{1F4E7} Replying to message ${replyToMessageId} "${newMessage.replyToContent}"`
            );
            console.log(
              `   \u{1F464} Original message sender: ${originalMessage.senderId}, Current user: ${req.user.id}`
            );
            console.log(
              `   \u{1F3AF} isCurrentUser = ${isCurrentUser} (should show "${isCurrentUser ? "You" : newMessage.replyToSenderName}")`
            );
          }
        }
        transformedMessage = {
          ...newMessage,
          replyToMessage: {
            id: newMessage.replyToMessageId,
            content: newMessage.replyToContent,
            senderName: newMessage.replyToSenderName,
            isCurrentUser
          }
        };
      }
      try {
        const senderSettings = await storage.getUserMatchSettings(
          req.user.id,
          matchId
        );
        if (senderSettings && senderSettings.autoDeleteMode !== "never") {
          let deleteAt;
          if (senderSettings.autoDeleteMode === "always") {
            await storage.scheduleMessageDeletion(
              newMessage.id,
              /* @__PURE__ */ new Date(),
              "always"
            );
          } else if (senderSettings.autoDeleteMode === "custom") {
            deleteAt = /* @__PURE__ */ new Date();
            const value = senderSettings.autoDeleteValue || 5;
            switch (senderSettings.autoDeleteUnit) {
              case "minutes":
                deleteAt.setMinutes(deleteAt.getMinutes() + value);
                break;
              case "hours":
                deleteAt.setHours(deleteAt.getHours() + value);
                break;
              case "days":
                deleteAt.setDate(deleteAt.getDate() + value);
                break;
              case "weeks":
                deleteAt.setDate(deleteAt.getDate() + value * 7);
                break;
              case "months":
                deleteAt.setMonth(deleteAt.getMonth() + value);
                break;
            }
            await storage.scheduleMessageDeletion(
              newMessage.id,
              deleteAt,
              "custom"
            );
          }
        }
      } catch (autoDeleteError) {
        console.error(
          "Error scheduling auto-delete for message:",
          autoDeleteError
        );
      }
      const recipientWs = connectedUsers3.get(receiverId);
      if (recipientWs && recipientWs.readyState === WebSocket3.OPEN) {
        try {
          recipientWs.send(
            JSON.stringify({
              type: "new_message",
              message: transformedMessage,
              for: "recipient",
              timestamp: (/* @__PURE__ */ new Date()).toISOString()
            })
          );
          console.log(`\u2705 Message ${newMessage.id} delivered to recipient ${receiverId} via WebSocket`);
        } catch (wsError) {
          console.error(`Failed to send message to recipient ${receiverId}:`, wsError);
        }
      } else {
        console.log(`\u26A0\uFE0F Recipient ${receiverId} not connected via WebSocket`);
      }
      const senderWs = connectedUsers3.get(req.user.id);
      if (senderWs && senderWs.readyState === WebSocket3.OPEN) {
        try {
          senderWs.send(
            JSON.stringify({
              type: "message_sent",
              messageId: newMessage.id,
              matchId: match.id,
              message: transformedMessage,
              for: "sender",
              timestamp: (/* @__PURE__ */ new Date()).toISOString()
            })
          );
          console.log(`\u2705 Message ${newMessage.id} delivery confirmed to sender ${req.user.id} via WebSocket`);
        } catch (wsError) {
          console.error(`Failed to send delivery confirmation to sender ${req.user.id}:`, wsError);
        }
      } else {
        console.log(`\u26A0\uFE0F Sender ${req.user.id} not connected via WebSocket`);
      }
      res.status(201).json(transformedMessage);
    } catch (error) {
      console.error("Error sending message:", error);
      res.status(500).json({ message: "Server error creating message" });
    }
  });
  app2.patch("/api/messages/:id/read", async (req, res) => {
    if (!req.isAuthenticated()) {
      return res.status(401).json({ message: "Unauthorized" });
    }
    const messageId = parseInt(req.params.id);
    if (isNaN(messageId)) {
      return res.status(400).json({ message: "Invalid message ID" });
    }
    try {
      const updatedMessage = await storage.markMessageAsRead(messageId);
      if (!updatedMessage) {
        return res.status(404).json({ message: "Message not found" });
      }
      res.json(updatedMessage);
    } catch (error) {
      res.status(500).json({ message: "Server error updating message" });
    }
  });
  app2.get("/api/interests/:userId", async (req, res) => {
    const userId = parseInt(req.params.userId);
    if (isNaN(userId)) {
      return res.status(400).json({ message: "Invalid user ID" });
    }
    try {
      if (req.isAuthenticated() && req.user?.id === userId) {
        if (req.session) {
          req.session.touch();
        }
      }
      const interests = await storage.getUserInterests(userId);
      res.json(interests);
    } catch (error) {
      console.error("Error retrieving user interests:", error);
      res.status(500).json({ message: "Server error retrieving interests" });
    }
  });
  app2.delete("/api/interests/:userId", async (req, res) => {
    if (!req.isAuthenticated()) {
      return res.status(401).json({ message: "Unauthorized" });
    }
    const userId = parseInt(req.params.userId);
    if (isNaN(userId)) {
      return res.status(400).json({ message: "Invalid user ID" });
    }
    if (req.user?.id !== userId) {
      return res.status(403).json({ message: "Not authorized to delete these interests" });
    }
    try {
      await storage.deleteAllUserInterests(userId);
      res.status(200).json({ message: "All interests deleted successfully" });
    } catch (error) {
      console.error("Error deleting user interests:", error);
      res.status(500).json({ message: "Server error deleting interests" });
    }
  });
  app2.patch(
    "/api/interests/:userId/visibility",
    async (req, res) => {
      if (!req.isAuthenticated()) {
        console.log("User not authenticated for visibility update");
        return res.status(401).json({ message: "Unauthorized" });
      }
      if (req.session) {
        req.session.touch();
      }
      const userId = parseInt(req.params.userId);
      if (isNaN(userId)) {
        return res.status(400).json({ message: "Invalid user ID" });
      }
      console.log(
        `Requesting user ID: ${req.user.id}, Target user ID: ${userId}`
      );
      if (req.user?.id !== userId) {
        console.log(
          `User ${req.user.id} not authorized to update interests for user ${userId}`
        );
        return res.status(403).json({ message: "Not authorized to update these interests" });
      }
      const { showOnProfile } = req.body;
      if (typeof showOnProfile !== "boolean") {
        return res.status(400).json({ message: "showOnProfile boolean value is required" });
      }
      try {
        console.log(
          `Updating interests visibility for user ${userId} to ${showOnProfile}`
        );
        await storage.updateUserInterestsVisibility(userId, showOnProfile);
        res.status(200).json({ message: "Interests visibility updated successfully" });
      } catch (error) {
        console.error("Error updating interests visibility:", error);
        res.status(500).json({ message: "Server error updating interests visibility" });
      }
    }
  );
  app2.post("/api/interests", async (req, res) => {
    if (!req.isAuthenticated()) {
      console.log("User not authenticated when adding interest");
      return res.status(401).json({ message: "Unauthorized" });
    }
    if (req.session) {
      req.session.touch();
    }
    try {
      console.log("Adding interest request body:", req.body);
      const { interest, userId } = req.body;
      if (!interest) {
        return res.status(400).json({ message: "Interest is required" });
      }
      if (userId && parseInt(userId) !== req.user.id) {
        console.warn(
          `User ${req.user.id} attempted to add interest for a different user ID: ${userId}`
        );
        return res.status(403).json({ message: "Not authorized to add interests for other users" });
      }
      console.log(`Adding interest "${interest}" for user ${req.user.id}`);
      try {
        const globalInterest = await storage.getGlobalInterestByName(interest);
        if (!globalInterest) {
          console.log(`Adding "${interest}" to global interests database`);
          await storage.addGlobalInterest({
            interest,
            category: "user-added",
            createdBy: req.user.id
          });
        }
        const newInterest = await storage.addUserInterest({
          userId: req.user.id,
          interest,
          showOnProfile: true
          // Explicitly set interest visibility to true
        });
        console.log(
          `Interest added successfully: ${JSON.stringify(newInterest)}`
        );
        return res.status(201).json(newInterest);
      } catch (storageError) {
        console.error("Storage error adding interest:", storageError);
        return res.status(500).json({
          message: "Server error adding interest",
          details: storageError instanceof Error ? storageError.message : "Unknown error"
        });
      }
    } catch (error) {
      console.error("Error processing interest request:", error);
      res.status(500).json({
        message: "Server error processing interest request",
        details: error instanceof Error ? error.message : "Unknown error"
      });
    }
  });
  app2.get("/api/global-interests", async (req, res) => {
    try {
      const interests = await storage.getAllGlobalInterests();
      res.json(interests);
    } catch (error) {
      console.error("Error fetching global interests:", error);
      res.status(500).json({ message: "Server error retrieving global interests" });
    }
  });
  app2.post("/api/global-interests", async (req, res) => {
    if (!req.isAuthenticated()) {
      console.log("User not authenticated when adding global interest");
      return res.status(401).json({ message: "Unauthorized" });
    }
    if (req.session) {
      req.session.touch();
    }
    try {
      console.log("Adding global interest request body:", req.body);
      let globalInterestData;
      try {
        globalInterestData = insertGlobalInterestSchema.parse(req.body);
      } catch (zodError) {
        if (zodError instanceof ZodError2) {
          const errorMessage = fromZodError2(zodError).message;
          console.error(
            "Validation error adding global interest:",
            errorMessage
          );
          return res.status(400).json({ message: errorMessage });
        }
        throw zodError;
      }
      try {
        const existingInterest = await storage.getGlobalInterestByName(
          globalInterestData.interest
        );
        if (existingInterest) {
          console.log(
            `Interest "${globalInterestData.interest}" already exists in global database, returning existing interest`
          );
          return res.status(200).json(existingInterest);
        }
      } catch (lookupError) {
        console.error("Error checking for existing interest:", lookupError);
      }
      if (!globalInterestData.createdBy) {
        globalInterestData.createdBy = req.user.id;
      }
      try {
        const newGlobalInterest = await storage.addGlobalInterest(globalInterestData);
        console.log(
          `Added new global interest: ${JSON.stringify(newGlobalInterest)}`
        );
        return res.status(201).json(newGlobalInterest);
      } catch (storageError) {
        console.error("Storage error adding global interest:", storageError);
        return res.status(500).json({
          message: "Database error adding global interest",
          details: storageError instanceof Error ? storageError.message : "Unknown error"
        });
      }
    } catch (error) {
      console.error("Unexpected error adding global interest:", error);
      res.status(500).json({
        message: "Server error adding global interest",
        details: error instanceof Error ? error.message : "Unknown error"
      });
    }
  });
  app2.get("/api/global-deal-breakers", async (req, res) => {
    try {
      const dealBreakers = await storage.getAllGlobalDealBreakers();
      res.json(dealBreakers);
    } catch (error) {
      console.error("Error fetching global deal breakers:", error);
      res.status(500).json({ message: "Server error retrieving global deal breakers" });
    }
  });
  app2.post("/api/global-deal-breakers", async (req, res) => {
    if (!req.isAuthenticated()) {
      console.log("User not authenticated when adding global deal breaker");
      return res.status(401).json({ message: "Unauthorized" });
    }
    if (req.session) {
      req.session.touch();
    }
    try {
      console.log("Adding global deal breaker request body:", req.body);
      let globalDealBreakerData;
      try {
        globalDealBreakerData = insertGlobalDealBreakerSchema.parse(req.body);
      } catch (zodError) {
        if (zodError instanceof ZodError2) {
          const errorMessage = fromZodError2(zodError).message;
          console.error(
            "Validation error adding global deal breaker:",
            errorMessage
          );
          return res.status(400).json({ message: errorMessage });
        }
        throw zodError;
      }
      try {
        const existingDealBreaker = await storage.getGlobalDealBreakerByName(
          globalDealBreakerData.dealBreaker
        );
        if (existingDealBreaker) {
          console.log(
            `Deal breaker "${globalDealBreakerData.dealBreaker}" already exists in global database, returning existing deal breaker`
          );
          return res.status(200).json(existingDealBreaker);
        }
      } catch (lookupError) {
        console.error("Error checking for existing deal breaker:", lookupError);
      }
      if (!globalDealBreakerData.createdBy) {
        globalDealBreakerData.createdBy = req.user.id;
      }
      try {
        const newGlobalDealBreaker = await storage.addGlobalDealBreaker(
          globalDealBreakerData
        );
        console.log(
          `Added new global deal breaker: ${JSON.stringify(newGlobalDealBreaker)}`
        );
        return res.status(201).json(newGlobalDealBreaker);
      } catch (storageError) {
        console.error(
          "Storage error adding global deal breaker:",
          storageError
        );
        return res.status(500).json({
          message: "Database error adding global deal breaker",
          details: storageError instanceof Error ? storageError.message : "Unknown error"
        });
      }
    } catch (error) {
      console.error("Unexpected error adding global deal breaker:", error);
      res.status(500).json({
        message: "Server error adding global deal breaker",
        details: error instanceof Error ? error.message : "Unknown error"
      });
    }
  });
  app2.get("/api/global-tribes", async (req, res) => {
    try {
      const tribes = await storage.getAllGlobalTribes();
      res.json(tribes);
    } catch (error) {
      console.error("Error fetching global tribes:", error);
      res.status(500).json({ message: "Server error retrieving global tribes" });
    }
  });
  app2.post("/api/global-tribes", async (req, res) => {
    if (!req.isAuthenticated()) {
      console.log("User not authenticated when adding global tribe");
      return res.status(401).json({ message: "Unauthorized" });
    }
    if (req.session) {
      req.session.touch();
    }
    try {
      console.log("Adding global tribe request body:", req.body);
      let globalTribeData;
      try {
        globalTribeData = insertGlobalTribeSchema.parse(req.body);
      } catch (zodError) {
        if (zodError instanceof ZodError2) {
          const errorMessage = fromZodError2(zodError).message;
          console.error("Validation error adding global tribe:", errorMessage);
          return res.status(400).json({ message: errorMessage });
        }
        throw zodError;
      }
      try {
        const existingTribe = await storage.getGlobalTribeByName(
          globalTribeData.tribe
        );
        if (existingTribe) {
          console.log(
            `Tribe "${globalTribeData.tribe}" already exists in global database, returning existing tribe`
          );
          return res.status(200).json(existingTribe);
        }
      } catch (lookupError) {
        console.error("Error checking for existing tribe:", lookupError);
      }
      if (!globalTribeData.createdBy) {
        globalTribeData.createdBy = req.user.id;
      }
      try {
        const newGlobalTribe = await storage.addGlobalTribe(globalTribeData);
        console.log(
          `Added new global tribe: ${JSON.stringify(newGlobalTribe)}`
        );
        return res.status(201).json(newGlobalTribe);
      } catch (storageError) {
        console.error("Storage error adding global tribe:", storageError);
        return res.status(500).json({
          message: "Database error adding global tribe",
          details: storageError instanceof Error ? storageError.message : "Unknown error"
        });
      }
    } catch (error) {
      console.error("Unexpected error adding global tribe:", error);
      res.status(500).json({
        message: "Server error adding global tribe",
        details: error instanceof Error ? error.message : "Unknown error"
      });
    }
  });
  app2.get("/api/global-religions", async (req, res) => {
    try {
      const religions = await storage.getAllGlobalReligions();
      res.json(religions);
    } catch (error) {
      console.error("Error fetching global religions:", error);
      res.status(500).json({ message: "Server error retrieving global religions" });
    }
  });
  app2.post("/api/global-religions", async (req, res) => {
    if (!req.isAuthenticated()) {
      console.log("User not authenticated when adding global religion");
      return res.status(401).json({ message: "Unauthorized" });
    }
    if (req.session) {
      req.session.touch();
    }
    try {
      console.log("Adding global religion request body:", req.body);
      let globalReligionData;
      try {
        globalReligionData = insertGlobalReligionSchema.parse(req.body);
      } catch (zodError) {
        if (zodError instanceof ZodError2) {
          const errorMessage = fromZodError2(zodError).message;
          console.error(
            "Validation error adding global religion:",
            errorMessage
          );
          return res.status(400).json({ message: errorMessage });
        }
        throw zodError;
      }
      try {
        const existingReligion = await storage.getGlobalReligionByName(
          globalReligionData.religion
        );
        if (existingReligion) {
          console.log(
            `Religion "${globalReligionData.religion}" already exists in global database, returning existing religion`
          );
          return res.status(200).json(existingReligion);
        }
      } catch (lookupError) {
        console.error("Error checking for existing religion:", lookupError);
      }
      if (!globalReligionData.createdBy) {
        globalReligionData.createdBy = req.user.id;
      }
      try {
        const newGlobalReligion = await storage.addGlobalReligion(globalReligionData);
        console.log(
          `Added new global religion: ${JSON.stringify(newGlobalReligion)}`
        );
        return res.status(201).json(newGlobalReligion);
      } catch (storageError) {
        console.error("Storage error adding global religion:", storageError);
        return res.status(500).json({
          message: "Database error adding global religion",
          details: storageError instanceof Error ? storageError.message : "Unknown error"
        });
      }
    } catch (error) {
      console.error("Unexpected error adding global religion:", error);
      res.status(500).json({
        message: "Server error adding global religion",
        details: error instanceof Error ? error.message : "Unknown error"
      });
    }
  });
  app2.post("/api/swipe", async (req, res) => {
    if (!req.isAuthenticated()) {
      return res.status(401).json({ message: "Unauthorized" });
    }
    try {
      const { targetUserId, action } = req.body;
      const currentUserId = req.user.id;
      if (!targetUserId || !action || !["like", "dislike"].includes(action)) {
        return res.status(400).json({ message: "Invalid swipe data" });
      }
      console.log(`[SWIPE] User ${currentUserId} ${action}d user ${targetUserId}`);
      if (action === "dislike") {
        try {
          await storage.createMatch({
            userId1: currentUserId,
            userId2: targetUserId,
            matched: false,
            isDislike: true,
            metadata: JSON.stringify({ origin: "MEET" })
          });
          console.log(`[SWIPE] Created dislike record: ${currentUserId} -> ${targetUserId}`);
        } catch (error) {
          if (error instanceof Error && error.message.includes("duplicate")) {
            console.log(`[SWIPE] Dislike record ${currentUserId} -> ${targetUserId} already exists`);
          } else {
            throw error;
          }
        }
      } else if (action === "like") {
        console.log(`\u{1F50D} [MEET-SWIPE] Checking for existing SUITE matches between users ${currentUserId} and ${targetUserId}`);
        const existingMatches = await storage.getAllMatchesBetweenUsers(currentUserId, targetUserId);
        console.log(`\u{1F50D} [MEET-SWIPE] Found ${existingMatches.length} existing matches between users`);
        if (existingMatches.length > 0) {
          existingMatches.forEach((match, index) => {
            console.log(`\u{1F50D} [MEET-SWIPE] Match ${index + 1}: ID=${match.id}, metadata=${match.metadata}`);
          });
        }
        const existingSuiteMatch = existingMatches.find((match) => {
          if (match.metadata) {
            try {
              const metadata = typeof match.metadata === "string" ? JSON.parse(match.metadata) : match.metadata;
              return metadata && metadata.origin === "SUITE";
            } catch (e) {
              console.error(`\u{1F50D} [MEET-SWIPE] Failed to parse metadata for match ${match.id}:`, e);
              return false;
            }
          }
          return false;
        });
        if (existingSuiteMatch) {
          console.log(`\u{1F517} [MEET-SWIPE] Found existing SUITE match ${existingSuiteMatch.id}, adding MEET as additional connection`);
          try {
            const existingMetadata = typeof existingSuiteMatch.metadata === "string" ? JSON.parse(existingSuiteMatch.metadata) : existingSuiteMatch.metadata;
            console.log(`\u{1F517} [MEET-SWIPE] Current metadata: ${JSON.stringify(existingMetadata)}`);
            if (!existingMetadata.additionalConnections) {
              existingMetadata.additionalConnections = [];
              console.log(`\u{1F517} [MEET-SWIPE] Initialized additionalConnections array`);
            }
            if (!existingMetadata.additionalConnections.includes("MEET")) {
              existingMetadata.additionalConnections.push("MEET");
              console.log(`\u{1F517} [MEET-SWIPE] Adding MEET to additionalConnections for SUITE match ${existingSuiteMatch.id}`);
              console.log(`\u{1F517} [MEET-SWIPE] New additionalConnections: ${JSON.stringify(existingMetadata.additionalConnections)}`);
              const updatedMatch = await storage.updateMatch(existingSuiteMatch.id, {
                metadata: JSON.stringify(existingMetadata)
              });
              console.log(`\u{1F517} [MEET-SWIPE] Successfully added MEET to additionalConnections for existing SUITE match ${existingSuiteMatch.id}`);
              console.log(`\u{1F517} [MEET-SWIPE] Final updated metadata: ${updatedMatch?.metadata}`);
              return res.json({
                success: true,
                action,
                isMatch: true,
                message: "MEET added as additional connection to existing SUITE match"
              });
            } else {
              console.log(`\u{1F517} [MEET-SWIPE] MEET already exists in additionalConnections, no update needed`);
              return res.json({
                success: true,
                action,
                isMatch: true,
                message: "MEET connection already exists"
              });
            }
          } catch (error) {
            console.error(`\u{1F517} [MEET-SWIPE] Error updating existing SUITE match:`, error);
          }
        }
        try {
          await storage.createMatch({
            userId1: currentUserId,
            userId2: targetUserId,
            matched: false,
            isDislike: false,
            metadata: JSON.stringify({ origin: "MEET" })
          });
          console.log(`[SWIPE] Created like record: ${currentUserId} -> ${targetUserId}`);
          const mutualLike = await db.select().from(matches).where(
            and5(
              eq5(matches.userId1, targetUserId),
              eq5(matches.userId2, currentUserId),
              eq5(matches.matched, false),
              eq5(matches.isDislike, false)
            )
          ).limit(1);
          if (mutualLike.length > 0) {
            console.log(`\u{1F50D} [MEET-MUTUAL-MATCH] Checking for existing SUITE matches before creating mutual match`);
            const allExistingMatches = await storage.getAllMatchesBetweenUsers(currentUserId, targetUserId);
            const existingSuiteMatchForMutual = allExistingMatches.find((match) => {
              if (match.metadata) {
                try {
                  const metadata = typeof match.metadata === "string" ? JSON.parse(match.metadata) : match.metadata;
                  return metadata && metadata.origin === "SUITE";
                } catch (e) {
                  return false;
                }
              }
              return false;
            });
            let finalMetadata = { origin: "MEET" };
            if (existingSuiteMatchForMutual) {
              console.log(`\u{1F517} [MEET-MUTUAL-MATCH] Found existing SUITE match ${existingSuiteMatchForMutual.id}, preserving SUITE metadata and adding MEET`);
              try {
                const existingMetadata = typeof existingSuiteMatchForMutual.metadata === "string" ? JSON.parse(existingSuiteMatchForMutual.metadata) : existingSuiteMatchForMutual.metadata;
                finalMetadata = { ...existingMetadata };
                if (!finalMetadata.additionalConnections) {
                  finalMetadata.additionalConnections = [];
                }
                if (!finalMetadata.additionalConnections.includes("MEET")) {
                  finalMetadata.additionalConnections.push("MEET");
                }
                console.log(`\u{1F517} [MEET-MUTUAL-MATCH] Final metadata: ${JSON.stringify(finalMetadata)}`);
              } catch (error) {
                console.error(`\u{1F517} [MEET-MUTUAL-MATCH] Error parsing existing SUITE metadata:`, error);
              }
            }
            await db.update(matches).set({
              matched: true,
              metadata: JSON.stringify(finalMetadata)
            }).where(
              or4(
                and5(eq5(matches.userId1, currentUserId), eq5(matches.userId2, targetUserId)),
                and5(eq5(matches.userId1, targetUserId), eq5(matches.userId2, currentUserId))
              )
            );
            console.log(`[SWIPE] Match created: ${currentUserId} \u2194 ${targetUserId}`);
            console.log(`[SWIPE-CLEANUP] About to clean up swipe history for users ${currentUserId} \u2194 ${targetUserId}`);
            try {
              await storage.removeMatchedUsersFromSwipeHistory(currentUserId, targetUserId);
              console.log(`[SWIPE-CLEANUP] Successfully cleaned up swipe history for users ${currentUserId} \u2194 ${targetUserId}`);
            } catch (historyError) {
              console.error("Error cleaning up swipe history for matched users:", historyError);
            }
            if (connectedUsers3) {
              [currentUserId, targetUserId].forEach((userId) => {
                const userSocket = connectedUsers3.get(userId);
                if (userSocket && userSocket.readyState === WebSocket3.OPEN) {
                  userSocket.send(JSON.stringify({
                    type: "match_notification",
                    matchedUserId: userId === currentUserId ? targetUserId : currentUserId,
                    timestamp: (/* @__PURE__ */ new Date()).toISOString()
                  }));
                  userSocket.send(JSON.stringify({
                    type: "card_removal",
                    removeUserId: userId === currentUserId ? targetUserId : currentUserId,
                    reason: "mutual_match",
                    timestamp: (/* @__PURE__ */ new Date()).toISOString()
                  }));
                  console.log(`\u{1F5D1}\uFE0F [CARD-REMOVAL] Sent card removal to user ${userId} for user ${userId === currentUserId ? targetUserId : currentUserId}`);
                }
              });
            }
            return res.json({ success: true, action, isMatch: true });
          }
        } catch (error) {
          if (error instanceof Error && error.message.includes("duplicate")) {
            console.log(`[SWIPE] Like record ${currentUserId} -> ${targetUserId} already exists`);
          } else {
            throw error;
          }
        }
      }
      res.json({ success: true, action, isMatch: false });
    } catch (error) {
      console.error("Error processing swipe action:", error);
      res.status(500).json({ message: "Failed to process swipe action" });
    }
  });
  app2.get(
    "/api/photos/single/:photoId",
    async (req, res) => {
      try {
        const { photoId } = req.params;
        const photo = await storage.getUserPhotoById(parseInt(photoId));
        if (!photo) {
          return res.status(404).json({ error: "Photo not found" });
        }
        if (req.isAuthenticated() && req.user.id !== photo.userId) {
          console.log(
            `User ${req.user.id} accessed photo ${photoId} of user ${photo.userId}`
          );
        }
        res.json(photo);
      } catch (err) {
        console.error(err);
        res.status(500).json({ error: "An error occurred while fetching the photo" });
      }
    }
  );
  app2.get("/api/photos/:userId", async (req, res) => {
    try {
      const { userId } = req.params;
      const photos = await storage.getUserPhotos(parseInt(userId));
      res.json(photos);
    } catch (err) {
      console.error(err);
      res.status(500).json({ error: "An error occurred while fetching user photos" });
    }
  });
  app2.post("/api/photos", async (req, res) => {
    if (!req.isAuthenticated()) {
      return res.status(401).json({ message: "Unauthorized" });
    }
    try {
      const { photoUrl, isPrimary = false } = req.body;
      if (!photoUrl) {
        return res.status(400).json({ message: "Photo URL is required" });
      }
      const photo = await storage.addUserPhoto({
        userId: req.user.id,
        photoUrl,
        isPrimary
      });
      res.status(201).json(photo);
    } catch (err) {
      console.error(err);
      res.status(500).json({ error: "An error occurred while adding a photo" });
    }
  });
  app2.delete("/api/photos/:id", async (req, res) => {
    if (!req.isAuthenticated()) {
      return res.status(401).json({ message: "Unauthorized" });
    }
    try {
      const { id } = req.params;
      await storage.deleteUserPhoto(parseInt(id));
      res.status(204).send();
    } catch (err) {
      console.error(err);
      res.status(500).json({ error: "An error occurred while deleting the photo" });
    }
  });
  app2.patch("/api/photos/:id/primary", async (req, res) => {
    if (!req.isAuthenticated()) {
      return res.status(401).json({ message: "Unauthorized" });
    }
    try {
      const { id } = req.params;
      const photo = await storage.setPrimaryPhoto(parseInt(id), req.user.id);
      res.json(photo);
    } catch (err) {
      console.error(err);
      res.status(500).json({ error: "An error occurred while setting primary photo" });
    }
  });
  app2.post("/api/profile/photo", async (req, res) => {
    if (!req.isAuthenticated()) {
      return res.status(401).json({ message: "Unauthorized" });
    }
    try {
      const { photoData, photoId } = req.body;
      if (!photoData || !photoData.startsWith("data:image/")) {
        return res.status(400).json({ message: "Valid image data is required" });
      }
      if (photoId) {
        const existingPhoto = await storage.getUserPhotoById(photoId);
        if (!existingPhoto) {
          return res.status(404).json({ message: "Photo not found" });
        }
        if (existingPhoto.userId !== req.user.id) {
          return res.status(403).json({ message: "Not authorized to update this photo" });
        }
        const updatedPhoto = await storage.updateUserPhoto(photoId, {
          photoUrl: photoData
        });
        if (existingPhoto.isPrimary) {
          await storage.updateUserProfile(req.user.id, { photoUrl: photoData });
        }
        return res.status(200).json(updatedPhoto);
      }
      const existingPhotos = await storage.getUserPhotos(req.user.id);
      const isPrimary = existingPhotos.length === 0;
      const photo = await storage.addUserPhoto({
        userId: req.user.id,
        photoUrl: photoData,
        isPrimary
      });
      if (isPrimary) {
        await storage.updateUserProfile(req.user.id, { photoUrl: photoData });
      }
      res.status(201).json(photo);
    } catch (err) {
      console.error("Error uploading profile photo:", err);
      res.status(500).json({
        error: "An error occurred while uploading your profile photo"
      });
    }
  });
  app2.patch(
    "/api/profile/photo/:photoId/primary/:section",
    async (req, res) => {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      try {
        const photoId = parseInt(req.params.photoId);
        const section = req.params.section;
        if (isNaN(photoId)) {
          return res.status(400).json({ message: "Invalid photo ID" });
        }
        const validSections = ["meet", "job", "mentorship", "networking"];
        if (!validSections.includes(section)) {
          return res.status(400).json({
            message: "Invalid section. Must be one of: meet, job, mentorship, networking"
          });
        }
        const existingPhoto = await storage.getUserPhotoById(photoId);
        if (!existingPhoto) {
          return res.status(404).json({ message: "Photo not found" });
        }
        if (existingPhoto.userId !== req.user.id) {
          return res.status(403).json({
            message: "Not authorized to update this photo"
          });
        }
        const result = await storage.updateSectionPrimaryPhoto(
          req.user.id,
          photoId,
          section
        );
        if (!result.success) {
          return res.status(500).json({ message: result.error });
        }
        const updatedPhotos = await storage.getUserPhotos(req.user.id);
        res.status(200).json({
          message: `Primary photo updated for ${section} section`,
          photos: updatedPhotos,
          updatedPhotoId: photoId,
          section
        });
      } catch (err) {
        console.error("Error updating section primary photo:", err);
        res.status(500).json({
          error: "An error occurred while updating the primary photo"
        });
      }
    }
  );
  app2.get(
    "/api/profile/photos/section/:section",
    async (req, res) => {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      try {
        const section = req.params.section;
        const validSections = ["meet", "job", "mentorship", "networking"];
        if (!validSections.includes(section)) {
          return res.status(400).json({
            message: "Invalid section. Must be one of: meet, job, mentorship, networking"
          });
        }
        const photos = await storage.getUserPhotosWithSectionPrimary(
          req.user.id,
          section
        );
        res.status(200).json({
          photos,
          section
        });
      } catch (err) {
        console.error("Error fetching section photos:", err);
        res.status(500).json({
          error: "An error occurred while fetching photos"
        });
      }
    }
  );
  app2.get(
    "/api/profile/photo/primary/:section",
    async (req, res) => {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      try {
        const section = req.params.section;
        const validSections = ["meet", "job", "mentorship", "networking"];
        if (!validSections.includes(section)) {
          return res.status(400).json({
            message: "Invalid section. Must be one of: meet, job, mentorship, networking"
          });
        }
        const primaryPhoto = await storage.getSectionPrimaryPhoto(
          req.user.id,
          section
        );
        if (!primaryPhoto) {
          return res.status(404).json({
            message: `No primary photo found for ${section} section`,
            section
          });
        }
        res.status(200).json({
          photo: primaryPhoto,
          section
        });
      } catch (err) {
        console.error("Error fetching section primary photo:", err);
        res.status(500).json({
          error: "An error occurred while fetching the primary photo"
        });
      }
    }
  );
  app2.post("/api/video-calls", async (req, res) => {
    if (!req.isAuthenticated()) {
      return res.status(401).json({ message: "Unauthorized" });
    }
    try {
      const videoCallData = insertVideoCallSchema.parse(req.body);
      if (videoCallData.initiatorId !== req.user.id) {
        return res.status(403).json({ message: "Not authorized to initiate call as this user" });
      }
      const match = await storage.getMatchById(videoCallData.matchId);
      if (!match) {
        return res.status(404).json({ message: "Match not found" });
      }
      if (match.userId1 !== req.user.id && match.userId2 !== req.user.id) {
        return res.status(403).json({ message: "Not authorized to start call in this match" });
      }
      if (!videoCallData.roomName) {
        videoCallData.roomName = `charley-${randomBytes2(10).toString("hex")}`;
      }
      const newVideoCall = await storage.createVideoCall(videoCallData);
      res.status(201).json({
        videoCall: newVideoCall,
        twilioToken: "DEMO_TOKEN"
        // This would be a real token in production
      });
    } catch (error) {
      if (error instanceof ZodError2) {
        return res.status(400).json({ message: fromZodError2(error).message });
      }
      res.status(500).json({ message: "Server error creating video call" });
    }
  });
  app2.get("/api/video-calls/:id", async (req, res) => {
    if (!req.isAuthenticated()) {
      return res.status(401).json({ message: "Unauthorized" });
    }
    const callId = parseInt(req.params.id);
    if (isNaN(callId)) {
      return res.status(400).json({ message: "Invalid call ID" });
    }
    try {
      const videoCall = await storage.getVideoCallById(callId);
      if (!videoCall) {
        return res.status(404).json({ message: "Video call not found" });
      }
      if (videoCall.initiatorId !== req.user.id && videoCall.receiverId !== req.user.id) {
        return res.status(403).json({ message: "Not authorized to access this call" });
      }
      res.json({
        videoCall,
        twilioToken: "DEMO_TOKEN"
        // This would be a real token in production
      });
    } catch (error) {
      res.status(500).json({ message: "Server error retrieving video call" });
    }
  });
  app2.patch(
    "/api/video-calls/:id/status",
    async (req, res) => {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      const callId = parseInt(req.params.id);
      if (isNaN(callId)) {
        return res.status(400).json({ message: "Invalid call ID" });
      }
      try {
        const { status } = req.body;
        if (!status || !["active", "completed", "declined"].includes(status)) {
          return res.status(400).json({
            message: "Valid status required (active, completed, or declined)"
          });
        }
        const videoCall = await storage.getVideoCallById(callId);
        if (!videoCall) {
          return res.status(404).json({ message: "Video call not found" });
        }
        if (videoCall.initiatorId !== req.user.id && videoCall.receiverId !== req.user.id) {
          return res.status(403).json({ message: "Not authorized to update this call" });
        }
        const updateData = { status };
        if (status === "active" && !videoCall.startedAt) {
          updateData.startedAt = /* @__PURE__ */ new Date();
        } else if (status === "completed" && !videoCall.endedAt) {
          updateData.endedAt = /* @__PURE__ */ new Date();
        }
        const updatedCall = await storage.updateVideoCallStatus(
          callId,
          updateData
        );
        res.json(updatedCall);
      } catch (error) {
        res.status(500).json({ message: "Server error updating video call" });
      }
    }
  );
  const phoneVerificationCache = /* @__PURE__ */ new Map();
  const PHONE_RATE_LIMIT = 3e3;
  app2.post("/api/verify/phone/send", async (req, res) => {
    try {
      const { phoneNumber } = req.body;
      if (!phoneNumber) {
        return res.status(400).json({ message: "Phone number is required" });
      }
      console.log(`[AGE-COMPLIANCE] Checking if phone number ${phoneNumber} is blocked`);
      const isBlocked = await storage.isPhoneNumberBlocked(phoneNumber);
      if (isBlocked) {
        console.log(`[AGE-COMPLIANCE] Blocked phone number attempted registration: ${phoneNumber}`);
        const blockedRecord = await storage.getBlockedPhoneNumber(phoneNumber);
        return res.status(403).json({
          message: "This phone number cannot be used for registration. Please contact admin@btechnos.com or call Customer Service on +1 (469) 496-5620 for assistance.",
          blocked: true,
          reason: blockedRecord?.reason || "Compliance violation"
        });
      }
      const lastVerificationAttempt = phoneVerificationCache.get(phoneNumber);
      const now = Date.now();
      if (lastVerificationAttempt && now - lastVerificationAttempt < PHONE_RATE_LIMIT) {
        return res.status(200).json({
          message: `Verification code sent to ${phoneNumber} (throttled)`,
          phoneNumber,
          codeLength: 7,
          expiresAt: new Date(now + 10 * 60 * 1e3),
          skipVerification: false
        });
      }
      phoneVerificationCache.set(phoneNumber, now);
      const existingUser = await storage.getUserByPhoneNumber(phoneNumber);
      if (existingUser && existingUser.twoFactorEnabled === false) {
        return res.status(200).json({
          message: "User found with two-factor authentication disabled",
          skipVerification: true,
          user: {
            id: existingUser.id,
            username: existingUser.username
          }
        });
      }
      const code = Math.floor(1e6 + Math.random() * 9e6).toString();
      const expiresAt = new Date(now + 10 * 60 * 1e3);
      await storage.createVerificationCode({
        phoneNumber,
        code,
        expiresAt
      });
      if (Math.random() < 0.01) {
        storage.deleteExpiredVerificationCodes().catch((err) => console.error("Background cleanup error:", err));
      }
      res.status(200).json({
        message: "Verification code sent successfully",
        code
        // Remove this line in production
      });
    } catch (error) {
      console.error("Phone verification error:", error);
      res.status(500).json({ message: "Server error sending verification code" });
    }
  });
  app2.post("/api/phone/block", async (req, res) => {
    try {
      const { phoneNumber, fullName, email, reason, metadata } = req.body;
      if (!phoneNumber) {
        return res.status(400).json({ message: "Phone number is required" });
      }
      if (!reason) {
        return res.status(400).json({ message: "Reason is required" });
      }
      console.log(`[AGE-COMPLIANCE] Blocking phone number ${phoneNumber} for ${fullName || "Unknown User"} (${email || "No Email"}) - Reason: ${reason}`);
      const alreadyBlocked = await storage.isPhoneNumberBlocked(phoneNumber);
      if (alreadyBlocked) {
        console.log(`[AGE-COMPLIANCE] Phone number ${phoneNumber} already blocked`);
        return res.status(200).json({
          message: "Phone number is already blocked",
          alreadyBlocked: true
        });
      }
      const blockedRecord = await storage.addBlockedPhoneNumber(phoneNumber, reason, fullName, email, metadata);
      console.log(`[AGE-COMPLIANCE] Successfully blocked phone number ${phoneNumber} with ID ${blockedRecord.id}`);
      res.status(200).json({
        message: "Phone number has been successfully blocked",
        blocked: true,
        id: blockedRecord.id
      });
    } catch (error) {
      console.error("[AGE-COMPLIANCE] Error blocking phone number:", error);
      res.status(500).json({
        message: "Server error blocking phone number",
        error: error instanceof Error ? error.message : "Unknown error"
      });
    }
  });
  app2.post("/api/password/send-reset-code", async (req, res) => {
    try {
      const { email } = req.body;
      if (!email) {
        return res.status(400).json({ message: "Email is required" });
      }
      const user = await storage.getUserByEmail(email);
      if (!user) {
        return res.status(404).json({ message: "No user found with this email address" });
      }
      const resetCode = Math.floor(1e6 + Math.random() * 9e6).toString();
      const expiresAt = /* @__PURE__ */ new Date();
      expiresAt.setMinutes(expiresAt.getMinutes() + 10);
      await db.insert(passwordResetCodes).values({
        email,
        resetCode,
        isUsed: false,
        expiresAt
      });
      const emailSent = await sendEmail(
        process.env.SENDGRID_API_KEY,
        {
          to: email,
          from: "admin@btechnos.com",
          subject: "CHARLEY - Password Reset Code",
          html: `
          <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto; padding: 20px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); border-radius: 20px;">
            <div style="background: rgba(255, 255, 255, 0.95); border-radius: 16px; padding: 30px; text-align: center;">
              <h1 style="color: #4f46e5; margin-bottom: 20px; font-size: 28px;">Password Reset Code</h1>
              
              <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); border-radius: 12px; padding: 20px; margin: 20px 0;">
                <h2 style="color: white; font-size: 36px; margin: 0; letter-spacing: 8px; font-family: 'Courier New', monospace;">${resetCode}</h2>
              </div>
              
              <p style="color: #374151; font-size: 16px; margin: 20px 0;">
                Use this 7-digit code to reset your CHARLEY password. This code expires in 10 minutes.
              </p>
              
              <p style="color: #6b7280; font-size: 14px; margin-top: 30px;">
                If you didn't request this password reset, please ignore this email.
              </p>
              
              <div style="margin-top: 30px; padding-top: 20px; border-top: 1px solid #e5e7eb;">
                <p style="color: #9ca3af; font-size: 12px; margin: 0;">
                  From the BTechnos Team<br>
                  CHARLEY - Connecting Communities Worldwide
                </p>
              </div>
            </div>
          </div>
        `,
          text: `Your CHARLEY password reset code is: ${resetCode}. This code expires in 10 minutes. If you didn't request this, please ignore this email.`
        }
      );
      if (emailSent) {
        res.status(200).json({
          message: "Reset code sent to your email",
          success: true
        });
      } else {
        res.status(500).json({ message: "Failed to send reset code" });
      }
    } catch (error) {
      console.error("Password reset code error:", error);
      res.status(500).json({ message: "Server error during password reset request" });
    }
  });
  app2.post("/api/password/verify-reset-code", async (req, res) => {
    try {
      const { email, resetCode } = req.body;
      if (!email || !resetCode) {
        return res.status(400).json({ message: "Email and reset code are required" });
      }
      const validCode = await db.select().from(passwordResetCodes).where(
        and5(
          eq5(passwordResetCodes.email, email),
          eq5(passwordResetCodes.resetCode, resetCode),
          eq5(passwordResetCodes.isUsed, false),
          gte(passwordResetCodes.expiresAt, /* @__PURE__ */ new Date())
        )
      ).limit(1);
      if (validCode.length === 0) {
        return res.status(400).json({ message: "Invalid or expired reset code" });
      }
      res.status(200).json({
        message: "Reset code verified successfully",
        success: true
      });
    } catch (error) {
      console.error("Reset code verification error:", error);
      res.status(500).json({ message: "Server error during code verification" });
    }
  });
  app2.post("/api/password/reset-with-code", async (req, res) => {
    try {
      const { email, resetCode, newPassword } = req.body;
      if (!email || !resetCode || !newPassword) {
        return res.status(400).json({
          message: "Email, reset code, and new password are required"
        });
      }
      const validCode = await db.select().from(passwordResetCodes).where(
        and5(
          eq5(passwordResetCodes.email, email),
          eq5(passwordResetCodes.resetCode, resetCode),
          eq5(passwordResetCodes.isUsed, false),
          gte(passwordResetCodes.expiresAt, /* @__PURE__ */ new Date())
        )
      ).limit(1);
      if (validCode.length === 0) {
        return res.status(400).json({ message: "Invalid or expired reset code" });
      }
      const user = await storage.getUserByEmail(email);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }
      const hashedPassword = await hashPassword(newPassword);
      await storage.updateUserPassword(user.id, hashedPassword);
      await db.update(passwordResetCodes).set({ isUsed: true }).where(eq5(passwordResetCodes.id, validCode[0].id));
      res.status(200).json({
        message: "Password reset successfully",
        success: true
      });
    } catch (error) {
      console.error("Password reset error:", error);
      res.status(500).json({ message: "Server error during password reset" });
    }
  });
  app2.post("/api/password/change", async (req, res) => {
    if (!req.isAuthenticated()) {
      return res.status(401).json({ message: "Unauthorized" });
    }
    try {
      const { currentPassword, newPassword } = req.body;
      if (!currentPassword || !newPassword) {
        return res.status(400).json({ message: "Current password and new password are required" });
      }
      if (newPassword.length < 6) {
        return res.status(400).json({ message: "New password must be at least 6 characters long" });
      }
      const user = await storage.getUser(req.user.id);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }
      const isPasswordValid = await comparePasswords(
        currentPassword,
        user.password
      );
      if (!isPasswordValid) {
        return res.status(400).json({ message: "Current password is incorrect" });
      }
      const hashedPassword = await hashPassword(newPassword);
      await storage.updateUserPassword(user.id, hashedPassword);
      const userAgent = req.get("User-Agent") || "Unknown";
      const ipAddress = req.ip || req.connection.remoteAddress || "Unknown";
      console.log(`[SECURITY-NOTIFICATION] Sending password change notification for user ${user.id}`);
      sendSecurityChangeNotification({
        userId: user.id,
        email: user.email,
        fullName: user.fullName,
        phoneNumber: user.phoneNumber,
        changeType: "password",
        userAgent,
        ipAddress
      }).catch((error) => {
        console.error("[SECURITY-NOTIFICATION] Error sending password change notification:", error);
      });
      req.logout((err) => {
        if (err) {
          console.error("Error logging out user after password change:", err);
          return res.status(500).json({ message: "Password changed but logout failed" });
        }
        req.session.destroy((sessionErr) => {
          if (sessionErr) {
            console.error(
              "Error destroying session after password change:",
              sessionErr
            );
            return res.status(500).json({ message: "Password changed but session cleanup failed" });
          }
          res.clearCookie("connect.sid");
          return res.status(200).json({
            success: true,
            message: "Password successfully changed. Please log in again with your new password.",
            requiresRelogin: true
          });
        });
      });
    } catch (error) {
      console.error("Error changing password:", error);
      console.error(
        "Error stack:",
        error instanceof Error ? error.stack : "No stack trace"
      );
      console.error("Error details:", JSON.stringify(error));
      res.status(500).json({ message: "Server error during password change" });
    }
  });
  app2.get("/api/premium/status", async (req, res) => {
    if (!req.isAuthenticated()) {
      return res.status(401).json({ message: "Unauthorized" });
    }
    try {
      const userId = req.user.id;
      const user = await storage.getUser(userId);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }
      if (user.stripeSubscriptionId && stripe2) {
        try {
          console.log(`[STRIPE-SYNC] Checking real-time subscription status for user ${userId}, subscription: ${user.stripeSubscriptionId}`);
          const stripeSubscription = await stripe2.subscriptions.retrieve(user.stripeSubscriptionId);
          console.log(`[STRIPE-SYNC] Stripe subscription details:`);
          console.log(`[STRIPE-SYNC] - Status: ${stripeSubscription.status}`);
          console.log(`[STRIPE-SYNC] - Cancel at period end: ${stripeSubscription.cancel_at_period_end}`);
          console.log(`[STRIPE-SYNC] - Current period end: ${new Date(stripeSubscription.current_period_end * 1e3)}`);
          console.log(`[STRIPE-SYNC] - Current database status: ${user.subscriptionStatus}`);
          let localSubscriptionStatus = user.subscriptionStatus;
          let localPremiumAccess = user.premiumAccess;
          let localSubscriptionExpiresAt = user.subscriptionExpiresAt;
          if (stripeSubscription.status === "active") {
            console.log(`[STRIPE-SYNC] User ${userId} has active subscription`);
            if (stripeSubscription.cancel_at_period_end) {
              console.log(`[STRIPE-SYNC] - Subscription scheduled for cancellation at period end (grace period)`);
              localSubscriptionStatus = "canceled";
              localPremiumAccess = true;
              localSubscriptionExpiresAt = new Date(stripeSubscription.current_period_end * 1e3);
            } else {
              console.log(`[STRIPE-SYNC] - Subscription is truly active (not scheduled for cancellation)`);
              localSubscriptionStatus = "active";
              localPremiumAccess = true;
              localSubscriptionExpiresAt = new Date(stripeSubscription.current_period_end * 1e3);
            }
          } else if (stripeSubscription.status === "canceled" || stripeSubscription.status === "unpaid") {
            const currentPeriodEnd = new Date(stripeSubscription.current_period_end * 1e3);
            const now = /* @__PURE__ */ new Date();
            if (now < currentPeriodEnd) {
              localSubscriptionStatus = "canceled";
              localPremiumAccess = true;
              localSubscriptionExpiresAt = currentPeriodEnd;
            } else {
              localSubscriptionStatus = "expired";
              localPremiumAccess = false;
              localSubscriptionExpiresAt = currentPeriodEnd;
            }
          }
          if (localSubscriptionStatus !== user.subscriptionStatus || localPremiumAccess !== user.premiumAccess) {
            console.log(`[STRIPE-SYNC] Updating user ${userId} status from Stripe: ${stripeSubscription.status}, premium: ${localPremiumAccess}`);
            await storage.updateUserProfile(userId, {
              subscriptionStatus: localSubscriptionStatus,
              premiumAccess: localPremiumAccess,
              subscriptionExpiresAt: localSubscriptionExpiresAt
            });
          }
          return res.json({
            premiumAccess: localPremiumAccess,
            subscriptionStatus: localSubscriptionStatus,
            subscriptionExpiresAt: localSubscriptionExpiresAt,
            gracePeriodActive: localSubscriptionStatus === "canceled" && localPremiumAccess,
            stripeStatus: stripeSubscription.status,
            stripeCancelAtPeriodEnd: stripeSubscription.cancel_at_period_end
          });
        } catch (stripeError) {
          console.error(`[STRIPE-SYNC] Error checking Stripe subscription for user ${userId}:`, stripeError);
        }
      }
      if (user.subscriptionExpiresAt && user.subscriptionStatus === "canceled") {
        const now = /* @__PURE__ */ new Date();
        const expiresAt = new Date(user.subscriptionExpiresAt);
        if (now > expiresAt && user.premiumAccess) {
          console.log(`[SUBSCRIPTION-EXPIRY] User ${userId} subscription expired at ${expiresAt}, removing premium access`);
          await storage.updateUserProfile(userId, {
            premiumAccess: false,
            subscriptionStatus: "expired"
          });
          return res.json({
            premiumAccess: false,
            subscriptionExpired: true,
            expiredAt: expiresAt
          });
        }
      }
      res.json({
        premiumAccess: user.premiumAccess || false,
        subscriptionStatus: user.subscriptionStatus,
        subscriptionExpiresAt: user.subscriptionExpiresAt,
        gracePeriodActive: user.subscriptionStatus === "canceled" && user.premiumAccess
      });
    } catch (error) {
      console.error("Error getting premium status:", error);
      res.status(500).json({ message: "Server error getting premium status" });
    }
  });
  app2.post("/api/premium/toggle", async (req, res) => {
    if (!req.isAuthenticated()) {
      return res.status(401).json({ message: "Unauthorized" });
    }
    try {
      const { premiumAccess } = req.body;
      if (typeof premiumAccess !== "boolean") {
        return res.status(400).json({ message: "premiumAccess must be a boolean" });
      }
      const userId = req.user.id;
      console.log(`[PREMIUM-TOGGLE] User ${userId} toggling premium access to: ${premiumAccess}`);
      await storage.updateUserProfile(userId, {
        premiumAccess
      });
      const updatedUser = await storage.getUser(userId);
      res.json({
        message: "Premium access updated successfully",
        premiumAccess: updatedUser?.premiumAccess || false
      });
    } catch (error) {
      console.error("[PREMIUM-TOGGLE] Error:", error);
      res.status(500).json({
        message: "Server error updating premium access",
        error: error.message
      });
    }
  });
  app2.post("/api/subscription/cancel", async (req, res) => {
    if (!req.isAuthenticated()) {
      return res.status(401).json({ message: "Unauthorized" });
    }
    try {
      const userId = req.user.id;
      const user = await storage.getUser(userId);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }
      console.log(`[SUBSCRIPTION-CANCEL] User ${userId} requesting subscription cancellation`);
      if (!user.stripeSubscriptionId) {
        console.log(`[SUBSCRIPTION-CANCEL] User ${userId} has no Stripe subscription, just removing premium access`);
        await storage.updateUserProfile(userId, {
          premiumAccess: false
        });
        return res.json({
          message: "Premium access cancelled successfully",
          gracePeriod: false,
          premiumAccess: false
        });
      }
      if (stripe2) {
        try {
          console.log(`[SUBSCRIPTION-CANCEL] Canceling Stripe subscription: ${user.stripeSubscriptionId}`);
          const canceledSubscription = await stripe2.subscriptions.update(user.stripeSubscriptionId, {
            cancel_at_period_end: true
          });
          console.log(`[SUBSCRIPTION-CANCEL] Stripe subscription canceled with grace period until: ${new Date(canceledSubscription.current_period_end * 1e3)}`);
          await storage.updateUserProfile(userId, {
            subscriptionStatus: "canceled",
            subscriptionCanceledAt: /* @__PURE__ */ new Date()
            // Keep premiumAccess: true during grace period
            // subscriptionExpiresAt stays the same for grace period end
          });
          try {
            const subscription = await storage.getSubscriptionByStripeId(user.stripeSubscriptionId);
            if (subscription) {
              await storage.createSubscriptionEvent({
                subscriptionId: subscription.id,
                userId,
                eventType: "subscription_canceled",
                provider: "stripe",
                providerEventId: canceledSubscription.id,
                oldStatus: "active",
                newStatus: "canceled",
                metadata: JSON.stringify({
                  canceledAt: (/* @__PURE__ */ new Date()).toISOString(),
                  gracePeriodEnd: new Date(canceledSubscription.current_period_end * 1e3).toISOString(),
                  cancelAtPeriodEnd: true
                })
              });
              console.log(`[SUBSCRIPTION-CANCEL] Created cancellation event for subscription: ${subscription.id}`);
            }
          } catch (eventError) {
            console.error(`[SUBSCRIPTION-CANCEL] Failed to create cancellation event:`, eventError);
          }
          const gracePeriodEnd = new Date(canceledSubscription.current_period_end * 1e3);
          res.json({
            message: "Subscription cancelled successfully. You'll retain premium access until your billing period ends.",
            gracePeriod: true,
            gracePeriodEnd,
            premiumAccess: true,
            subscriptionStatus: "canceled"
          });
        } catch (stripeError) {
          console.error(`[SUBSCRIPTION-CANCEL] Stripe cancellation failed:`, stripeError);
          if (stripeError.code === "resource_missing") {
            console.log(`[SUBSCRIPTION-CANCEL] Subscription not found in Stripe, updating local status only`);
            await storage.updateUserProfile(userId, {
              premiumAccess: false,
              subscriptionStatus: "expired",
              stripeSubscriptionId: null
            });
            return res.json({
              message: "Premium access cancelled successfully",
              gracePeriod: false,
              premiumAccess: false
            });
          }
          throw stripeError;
        }
      } else {
        console.log(`[SUBSCRIPTION-CANCEL] Stripe not configured, removing premium access locally`);
        await storage.updateUserProfile(userId, {
          premiumAccess: false
        });
        res.json({
          message: "Premium access cancelled successfully",
          gracePeriod: false,
          premiumAccess: false
        });
      }
    } catch (error) {
      console.error("[SUBSCRIPTION-CANCEL] Error:", error);
      res.status(500).json({
        message: "Server error cancelling subscription",
        error: error.message
      });
    }
  });
  app2.post("/api/subscriptions/check-expiry", async (req, res) => {
    try {
      console.log(`[SUBSCRIPTION-EXPIRY] Checking for expired subscriptions...`);
      const expiredUsers = await db.select().from(users).where(
        sql5`subscription_status = 'canceled' 
              AND premium_access = true 
              AND subscription_expires_at < NOW()`
      );
      let expiredCount = 0;
      for (const user of expiredUsers) {
        console.log(`[SUBSCRIPTION-EXPIRY] Expiring subscription for user ${user.id}`);
        await storage.updateUserProfile(user.id, {
          premiumAccess: false,
          subscriptionStatus: "expired"
        });
        expiredCount++;
      }
      console.log(`[SUBSCRIPTION-EXPIRY] Expired ${expiredCount} subscriptions`);
      res.json({
        success: true,
        expiredCount,
        message: `Expired ${expiredCount} subscriptions`
      });
    } catch (error) {
      console.error("[SUBSCRIPTION-EXPIRY] Error checking expiry:", error);
      res.status(500).json({
        success: false,
        error: "Failed to check subscription expiry"
      });
    }
  });
  app2.post("/api/verify/phone/check", async (req, res) => {
    try {
      const { phoneNumber, code } = req.body;
      if (!phoneNumber || !code) {
        return res.status(400).json({ message: "Phone number and verification code are required" });
      }
      const verification = await storage.getVerificationCode(phoneNumber, code);
      if (!verification) {
        return res.status(400).json({ message: "Invalid verification code" });
      }
      if (verification.expiresAt < /* @__PURE__ */ new Date()) {
        await storage.deleteVerificationCode(verification.id);
        return res.status(400).json({ message: "Verification code has expired" });
      }
      await storage.deleteVerificationCode(verification.id);
      const existingUser = await storage.getUserByPhoneNumber(phoneNumber);
      if (existingUser) {
        await storage.updateUserProfile(existingUser.id, {
          verifiedByPhone: true
        });
        req.login(existingUser, (err) => {
          if (err) {
            console.error(
              "Error logging in existing user after phone verification:",
              err
            );
            return res.status(500).json({ message: "Error logging in after verification" });
          }
          const { password, ...userWithoutPassword } = existingUser;
          res.status(200).json({
            message: "Phone number verified. User logged in successfully.",
            user: userWithoutPassword
          });
        });
      } else {
        res.status(200).json({
          message: "Phone number verified. Please complete your profile.",
          phoneNumber
        });
      }
    } catch (error) {
      console.error("Phone verification check error:", error);
      res.status(500).json({ message: "Server error verifying code" });
    }
  });
  app2.post("/api/user/delete", async (req, res) => {
    if (!req.isAuthenticated()) {
      return res.status(401).json({ message: "Unauthorized" });
    }
    try {
      const { password } = req.body;
      const userId = req.user.id;
      const user = await storage.getUser(userId);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }
      const passwordValid = await comparePasswords(password, user.password);
      if (!passwordValid) {
        return res.status(400).json({
          message: "Password verification failed. Please enter your correct password."
        });
      }
      console.log(
        `User ${userId} requested account deletion with valid password`
      );
      let subscriptionCanceled = false;
      if (stripe2 && user.stripeSubscriptionId) {
        try {
          console.log(`[STRIPE-CANCELLATION] Canceling subscription ${user.stripeSubscriptionId} for user ${userId}`);
          const canceledSubscription = await stripe2.subscriptions.cancel(user.stripeSubscriptionId);
          console.log(`[STRIPE-CANCELLATION] Successfully canceled subscription: ${canceledSubscription.id}, status: ${canceledSubscription.status}`);
          subscriptionCanceled = true;
          await storage.updateUser(userId, {
            subscriptionStatus: "canceled",
            subscriptionCanceledAt: /* @__PURE__ */ new Date(),
            premiumAccess: false
          });
        } catch (error) {
          console.error(`[STRIPE-CANCELLATION] Error canceling subscription for user ${userId}:`, error);
        }
      } else if (user.stripeSubscriptionId && !stripe2) {
        console.warn(`[STRIPE-CANCELLATION] User ${userId} has subscription ${user.stripeSubscriptionId} but Stripe is not initialized`);
      }
      req.logout((err) => {
        if (err) {
          console.error(
            `Error logging out user ${userId} during account deletion:`,
            err
          );
          return res.status(500).json({ message: "Error during logout process" });
        }
        storage.deleteUser(userId).then(() => {
          console.log(`User ${userId} successfully deleted`);
          const responseMessage = subscriptionCanceled ? "Account and subscription successfully canceled and deleted" : "Account successfully deleted";
          res.status(200).json({
            message: responseMessage,
            redirectUrl: "/auth"
          });
        }).catch((error) => {
          console.error(`Error deleting user ${userId}:`, error);
          res.status(500).json({
            message: "Server error deleting account. Please try again later."
          });
        });
      });
    } catch (error) {
      console.error("Account deletion error:", error);
      res.status(500).json({
        message: "Server error processing account deletion request"
      });
    }
  });
  app2.post("/api/user/deactivate-profile", async (req, res) => {
    if (!req.isAuthenticated()) {
      return res.status(401).json({ message: "Unauthorized" });
    }
    try {
      const userId = req.user.id;
      await storage.updateUser(userId, {
        hasActivatedProfile: false,
        profileHidden: true,
        // Also hide the profile
        // Reset all MY INFO fields to null (Not specified)
        bio: null,
        location: null,
        countryOfOrigin: null,
        profession: null,
        religion: null,
        ethnicity: null,
        secondaryTribe: null,
        relationshipStatus: null,
        relationshipGoal: null,
        highSchool: null,
        collegeUniversity: null,
        interests: null,
        educationLevel: null,
        // Reset optional profile fields
        hasChildren: null,
        wantsChildren: null,
        smoking: null,
        drinking: null,
        // Reset OTHER section fields - Body Type and Height
        bodyType: null,
        height: null,
        // Reset photo visibility toggle
        showProfilePhoto: false,
        // Reset visibility preferences to disable MY INFO toggles only
        visibilityPreferences: JSON.stringify({
          bio: false,
          location: false,
          countryOfOrigin: false,
          profession: false,
          religion: false,
          ethnicity: false,
          relationshipStatus: false,
          relationshipGoal: false,
          highSchool: false,
          collegeUniversity: false,
          interests: false
        })
      });
      try {
        const preferences = await storage.getUserPreferences(userId);
        if (preferences) {
          await storage.updateUserPreferences(userId, {
            // Reset children preferences 
            hasChildrenPreference: null,
            wantsChildrenPreference: null,
            // Reset age range preferences to NULL
            minAge: null,
            maxAge: null,
            // Reset height range preferences to NULL
            minHeightPreference: null,
            maxHeightPreference: null,
            // Reset distance preference to NULL
            distancePreference: null,
            // Reset the 9 additional dating preference fields to NULL
            bodyTypePreference: null,
            // 1. Body Type
            religionPreference: null,
            // 3. Religion  
            ethnicityPreference: null,
            // 4. Ghanaian Tribes
            educationLevelPreference: null,
            // 5. Education Level
            interestPreferences: null,
            // 6. Interests
            matchingPriorities: null,
            // 7. Matching Priorities
            dealBreakers: null,
            // 8. Deal Breakers
            relationshipGoalPreference: null
            // 9. Relationship Goals
          });
          console.log(`Reset ALL Dating Preferences (age, height, distance + 9 additional fields) to NULL for user ${userId}`);
        }
      } catch (preferencesError) {
        console.error(`Error resetting preferences for user ${userId}:`, preferencesError);
      }
      try {
        await storage.deleteAllUserInterests(userId);
        console.log(`Cleared all interests for user ${userId}`);
      } catch (interestError) {
        console.error(`Error clearing interests for user ${userId}:`, interestError);
      }
      try {
        await storage.updateUserInterestsVisibility(userId, false);
        console.log(`Set all interests visibility to hidden for user ${userId}`);
      } catch (visibilityError) {
        console.error(`Error setting interests visibility for user ${userId}:`, visibilityError);
      }
      console.log(`User ${userId} deactivated their profile and reset all MY INFO fields`);
      res.status(200).json({
        message: "Profile deactivated successfully",
        success: true
      });
    } catch (error) {
      console.error("Profile deactivation error:", error);
      res.status(500).json({
        message: "Server error deactivating profile"
      });
    }
  });
  app2.post("/api/test/reset-networking", async (req, res) => {
    try {
      await storage.clearAllNetworkingConnections();
      res.json({ success: true, message: "Networking connections reset" });
    } catch (error) {
      console.error("Error resetting networking connections:", error);
      res.status(500).json({ message: "Failed to reset connections" });
    }
  });
  const httpServer = createServer(app2);
  let wss;
  try {
    wss = new WebSocketServer({
      noServer: true
    });
    httpServer.on("upgrade", (request, socket, head) => {
      if (request.url === "/ws") {
        wss.handleUpgrade(request, socket, head, (ws2) => {
          wss.emit("connection", ws2, request);
        });
      }
    });
    console.log("WebSocket server created successfully on path /ws");
  } catch (error) {
    console.error(
      `Failed to create WebSocket server: ${error instanceof Error ? error.message : String(error)}`
    );
    wss = new WebSocketServer({ noServer: true });
  }
  const connectedUsers3 = /* @__PURE__ */ new Map();
  const typingTimeouts = /* @__PURE__ */ new Map();
  let profileVisibilityBroadcaster = null;
  let ghostModeBroadcaster = null;
  let verificationStatusBroadcaster = null;
  function broadcastNetworkingProfileUpdate(userId, updatedProfile) {
    const updateMessage = JSON.stringify({
      type: "networking_profile_updated",
      userId,
      profile: updatedProfile,
      timestamp: (/* @__PURE__ */ new Date()).toISOString()
    });
    console.log(
      `Broadcasting networking profile update for user ${userId} to ${connectedUsers3.size} connected users`
    );
    connectedUsers3.forEach((ws2, connectedUserId) => {
      if (connectedUserId !== userId && ws2.readyState === WebSocket3.OPEN) {
        try {
          ws2.send(updateMessage);
          console.log(
            `Sent networking profile update to user ${connectedUserId}`
          );
        } catch (error) {
          console.error(
            `Failed to send networking profile update to user ${connectedUserId}:`,
            error
          );
          connectedUsers3.delete(connectedUserId);
        }
      }
    });
  }
  function getConnectedUsers() {
    return connectedUsers3;
  }
  setWebSocketConnections(connectedUsers3);
  registerSuiteConnectionAPI(app2);
  setSuiteWebSocketConnections(connectedUsers3);
  const activeChats = /* @__PURE__ */ new Map();
  wss.on("connection", (ws2, req) => {
    console.log("WebSocket connection established");
    let userId = null;
    ws2.on("message", async (message) => {
      try {
        const data = JSON.parse(message);
        if (data.type === "auth") {
          userId = data.userId;
          if (userId) {
            try {
              const user = await storage.getUser(userId);
              if (!user) {
                ws2.send(
                  JSON.stringify({
                    type: "auth_error",
                    message: "User not found"
                  })
                );
                return;
              }
              connectedUsers3.set(userId, ws2);
              await storage.updateUserOnlineStatus(userId, true);
              const connectTime = /* @__PURE__ */ new Date();
              const timestampISO = connectTime.toISOString();
              console.log(
                `[PRESENCE] User ${userId} authenticated and is now online at ${timestampISO}`
              );
              ws2.send(
                JSON.stringify({
                  type: "auth_success",
                  userId,
                  timestamp: timestampISO
                })
              );
              const onlineCount = connectedUsers3.size;
              ws2.send(
                JSON.stringify({
                  type: "online_count_update",
                  count: onlineCount,
                  timestamp: timestampISO
                })
              );
              const userLastActive = await storage.getUserLastActive(userId);
              broadcastToAllUsers({
                type: "user_status",
                userId,
                status: "online",
                lastSeen: userLastActive ? userLastActive.toISOString() : null,
                timestamp: timestampISO,
                priority: "high"
                // Mark as high priority
              });
              broadcastToAllUsers({
                type: "online_count_update",
                count: onlineCount,
                timestamp: timestampISO
              });
            } catch (error) {
              console.error(
                `WebSocket authentication error for user ${userId}:`,
                error
              );
              ws2.send(
                JSON.stringify({
                  type: "auth_error",
                  message: "Authentication failed"
                })
              );
            }
          } else {
            ws2.send(
              JSON.stringify({
                type: "auth_error",
                message: "Invalid user ID"
              })
            );
          }
        } else if (data.type === "message" && userId) {
          try {
            if (!data.matchId) {
              console.error(
                `[PRIVACY VIOLATION] User ${userId} sent message without matchId`
              );
              ws2.send(
                JSON.stringify({
                  type: "error",
                  message: "Missing match ID for message",
                  code: "MISSING_MATCH_ID"
                })
              );
              return;
            }
            if (!data.receiverId) {
              console.error(
                `[PRIVACY VIOLATION] User ${userId} sent message without receiverId`
              );
              ws2.send(
                JSON.stringify({
                  type: "error",
                  message: "Missing recipient ID for message",
                  code: "MISSING_RECIPIENT_ID"
                })
              );
              return;
            }
            if (!data.content) {
              console.error(
                `[PRIVACY VIOLATION] User ${userId} attempted to send empty message content`
              );
              ws2.send(
                JSON.stringify({
                  type: "error",
                  message: "Message content cannot be empty",
                  code: "EMPTY_CONTENT"
                })
              );
              return;
            }
            if (typeof data.content !== "string") {
              console.error(
                `[PRIVACY VIOLATION] User ${userId} attempted to send invalid message content type: ${typeof data.content}`
              );
              ws2.send(
                JSON.stringify({
                  type: "error",
                  message: "Message content must be a string",
                  code: "INVALID_CONTENT_TYPE"
                })
              );
              return;
            }
            if (data.content.trim().length === 0) {
              console.error(
                `[PRIVACY VIOLATION] User ${userId} attempted to send whitespace-only message`
              );
              ws2.send(
                JSON.stringify({
                  type: "error",
                  message: "Message content cannot be empty",
                  code: "EMPTY_CONTENT"
                })
              );
              return;
            }
            const match = await storage.getMatchById(data.matchId);
            if (!match) {
              console.error(
                `[PRIVACY VIOLATION] User ${userId} attempted to send message for non-existent match ${data.matchId}`
              );
              ws2.send(
                JSON.stringify({
                  type: "error",
                  message: "Match not found",
                  code: "MATCH_NOT_FOUND"
                })
              );
              return;
            }
            if (match.userId1 !== userId && match.userId2 !== userId) {
              console.error(
                `[PRIVACY VIOLATION] User ${userId} attempted to send message for match ${data.matchId} they're not part of. Match participants: ${match.userId1}, ${match.userId2}`
              );
              ws2.send(
                JSON.stringify({
                  type: "error",
                  message: "Not authorized to send messages in this match",
                  code: "UNAUTHORIZED_MATCH"
                })
              );
              return;
            }
            const otherUserId = match.userId1 === userId ? match.userId2 : match.userId1;
            if (data.receiverId !== otherUserId) {
              console.error(
                `[PRIVACY VIOLATION] User ${userId} attempted to send message to unauthorized recipient ${data.receiverId} in match ${data.matchId}. Authorized recipient: ${otherUserId}`
              );
              ws2.send(
                JSON.stringify({
                  type: "error",
                  message: "Invalid recipient for this match",
                  code: "INVALID_RECIPIENT"
                })
              );
              return;
            }
            if (match.id !== data.matchId) {
              console.error(
                `[PRIVACY VIOLATION] Match ID mismatch: requested ${data.matchId}, found ${match.id}`
              );
              ws2.send(
                JSON.stringify({
                  type: "error",
                  message: "Match ID validation failed",
                  code: "MATCH_ID_MISMATCH"
                })
              );
              return;
            }
            console.log(
              `[PRIVACY] User ${userId} sending message to ${data.receiverId} in match ${data.matchId} (Verified: User is authorized participant)`
            );
            const messageData = {
              matchId: data.matchId,
              senderId: userId,
              receiverId: data.receiverId,
              content: data.content,
              encryptedContent: null,
              iv: null
              // Encryption removed as per requirements
            };
            const newMessage = await storage.createMessage(messageData);
            await storage.markMatchUnread(data.matchId, data.receiverId);
            console.log(
              `[PRIVACY] Created secure message ${newMessage.id} for match ${data.matchId}`
            );
            const messageReceiptId = `${newMessage.id}_${Date.now()}`;
            const recipientWs = connectedUsers3.get(data.receiverId);
            if (recipientWs && recipientWs.readyState === WebSocket3.OPEN) {
              recipientWs.send(
                JSON.stringify({
                  type: "new_message",
                  message: newMessage,
                  receiptId: messageReceiptId,
                  timestamp: (/* @__PURE__ */ new Date()).toISOString(),
                  for: "recipient"
                  // Explicitly mark this message for the recipient
                })
              );
            }
            ws2.send(
              JSON.stringify({
                type: "message_sent",
                messageId: newMessage.id,
                matchId: data.matchId,
                receiptId: messageReceiptId,
                // Same receipt ID to help client detect duplicates
                timestamp: (/* @__PURE__ */ new Date()).toISOString(),
                for: "sender"
                // Explicitly mark this message for the sender
              })
            );
          } catch (error) {
            console.error("Error processing message:", error);
            ws2.send(
              JSON.stringify({
                type: "error",
                message: "Failed to process message"
              })
            );
          }
        } else if (data.type === "typing_status" && userId) {
          try {
            if (!data.matchId) {
              console.error(
                `[PRIVACY VIOLATION] User ${userId} sent typing status without matchId`
              );
              ws2.send(
                JSON.stringify({
                  type: "error",
                  message: "Missing match ID for typing status",
                  code: "MISSING_MATCH_ID"
                })
              );
              return;
            }
            const match = await storage.getMatchById(data.matchId);
            if (!match) {
              console.error(
                `[PRIVACY VIOLATION] User ${userId} attempted to update typing status for non-existent match ${data.matchId}`
              );
              ws2.send(
                JSON.stringify({
                  type: "error",
                  message: "Match not found for typing status update",
                  code: "MATCH_NOT_FOUND"
                })
              );
              return;
            }
            if (match.userId1 !== userId && match.userId2 !== userId) {
              console.error(
                `[PRIVACY VIOLATION] User ${userId} attempted to update typing status for match ${data.matchId} they're not part of. Match participants: ${match.userId1}, ${match.userId2}`
              );
              ws2.send(
                JSON.stringify({
                  type: "error",
                  message: "Not authorized to update typing status in this match",
                  code: "UNAUTHORIZED_MATCH"
                })
              );
              return;
            }
            console.log(
              `[PRIVACY] User ${userId} updated typing status to ${data.isTyping} in match ${data.matchId} (Verified: User is authorized participant)`
            );
            await storage.updateTypingStatus(
              userId,
              data.matchId,
              data.isTyping
            );
            const otherUserId = match.userId1 === userId ? match.userId2 : match.userId1;
            const otherUserWs = connectedUsers3.get(otherUserId);
            if (otherUserWs && otherUserWs.readyState === WebSocket3.OPEN) {
              otherUserWs.send(
                JSON.stringify({
                  type: "typing_status",
                  userId,
                  matchId: data.matchId,
                  isTyping: data.isTyping,
                  timestamp: (/* @__PURE__ */ new Date()).toISOString()
                })
              );
            }
            if (data.isTyping) {
              const timeoutKey = `typing_${userId}_${data.matchId}`;
              if (typingTimeouts.has(timeoutKey)) {
                clearTimeout(typingTimeouts.get(timeoutKey));
              }
              const timeout = setTimeout(async () => {
                try {
                  console.log(`[AUTO-CLEAR] Clearing stuck typing status for user ${userId} in match ${data.matchId}`);
                  await storage.updateTypingStatus(userId, data.matchId, false);
                  const currentOtherUserWs = connectedUsers3.get(otherUserId);
                  if (currentOtherUserWs && currentOtherUserWs.readyState === WebSocket3.OPEN) {
                    currentOtherUserWs.send(
                      JSON.stringify({
                        type: "typing_status",
                        userId,
                        matchId: data.matchId,
                        isTyping: false,
                        timestamp: (/* @__PURE__ */ new Date()).toISOString(),
                        autoCleared: true
                      })
                    );
                  }
                  typingTimeouts.delete(timeoutKey);
                } catch (clearError) {
                  console.error("Error auto-clearing typing status:", clearError);
                }
              }, 1e4);
              typingTimeouts.set(timeoutKey, timeout);
            } else {
              const timeoutKey = `typing_${userId}_${data.matchId}`;
              if (typingTimeouts.has(timeoutKey)) {
                clearTimeout(typingTimeouts.get(timeoutKey));
                typingTimeouts.delete(timeoutKey);
              }
            }
          } catch (error) {
            console.error("Error updating typing status:", error);
          }
        } else if (data.type === "message_read" && userId) {
          try {
            if (!data.messageId) {
              console.error(
                `[PRIVACY VIOLATION] User ${userId} sent message_read without messageId`
              );
              ws2.send(
                JSON.stringify({
                  type: "error",
                  message: "Missing message ID for read status update",
                  code: "MISSING_MESSAGE_ID"
                })
              );
              return;
            }
            const message2 = await storage.getMessageById(data.messageId);
            if (!message2) {
              console.error(
                `[PRIVACY VIOLATION] User ${userId} attempted to mark non-existent message ${data.messageId} as read`
              );
              ws2.send(
                JSON.stringify({
                  type: "error",
                  message: "Message not found",
                  code: "MESSAGE_NOT_FOUND"
                })
              );
              return;
            }
            const match = await storage.getMatchById(message2.matchId);
            if (!match) {
              console.error(
                `[PRIVACY VIOLATION] Message ${data.messageId} belongs to non-existent match ${message2.matchId}`
              );
              ws2.send(
                JSON.stringify({
                  type: "error",
                  message: "Match not found for this message",
                  code: "MATCH_NOT_FOUND"
                })
              );
              return;
            }
            if (match.userId1 !== userId && match.userId2 !== userId) {
              console.error(
                `[PRIVACY VIOLATION] User ${userId} attempted to mark message as read for match ${message2.matchId} they're not part of. Match participants: ${match.userId1}, ${match.userId2}`
              );
              ws2.send(
                JSON.stringify({
                  type: "error",
                  message: "Not authorized to access messages in this match",
                  code: "UNAUTHORIZED_MATCH"
                })
              );
              return;
            }
            if (message2.receiverId !== userId) {
              console.error(
                `[PRIVACY VIOLATION] User ${userId} attempted to mark message ${data.messageId} as read but is not the recipient. Actual recipient: ${message2.receiverId}`
              );
              ws2.send(
                JSON.stringify({
                  type: "error",
                  message: "Not authorized to mark this message as read",
                  code: "UNAUTHORIZED_RECIPIENT"
                })
              );
              return;
            }
            if (message2.id !== data.messageId) {
              console.error(
                `[PRIVACY VIOLATION] Message ID mismatch: requested ${data.messageId}, found ${message2.id}`
              );
              ws2.send(
                JSON.stringify({
                  type: "error",
                  message: "Message ID validation failed",
                  code: "MESSAGE_ID_MISMATCH"
                })
              );
              return;
            }
            console.log(
              `[PRIVACY] User ${userId} marking message ${data.messageId} as read (Verified: User is authorized recipient)`
            );
            const updatedMessage = await storage.markMessageAsReadWithTimestamp(
              data.messageId
            );
            if (updatedMessage) {
              const senderWs = connectedUsers3.get(updatedMessage.senderId);
              if (senderWs && senderWs.readyState === WebSocket3.OPEN) {
                senderWs.send(
                  JSON.stringify({
                    type: "read_receipt",
                    messageId: updatedMessage.id,
                    matchId: updatedMessage.matchId,
                    readAt: updatedMessage.readAt,
                    timestamp: (/* @__PURE__ */ new Date()).toISOString()
                  })
                );
              }
            }
          } catch (error) {
            console.error("Error marking message as read:", error);
          }
        } else if (data.type === "active_chat" && userId) {
          try {
            const { matchId, active } = data;
            if (!matchId) {
              console.error(
                `[PRIVACY VIOLATION] User ${userId} sent active chat status without matchId`
              );
              ws2.send(
                JSON.stringify({
                  type: "error",
                  message: "Missing match ID for active chat status",
                  code: "MISSING_MATCH_ID"
                })
              );
              return;
            }
            const match = await storage.getMatchById(matchId);
            if (!match) {
              console.error(
                `[PRIVACY VIOLATION] User ${userId} attempted to update active status for non-existent match ${matchId}`
              );
              ws2.send(
                JSON.stringify({
                  type: "error",
                  message: "Match not found for active chat status update",
                  code: "MATCH_NOT_FOUND"
                })
              );
              return;
            }
            if (match.userId1 !== userId && match.userId2 !== userId) {
              console.error(
                `[PRIVACY VIOLATION] User ${userId} attempted to update active status for match ${matchId} they're not part of. Match participants: ${match.userId1}, ${match.userId2}`
              );
              ws2.send(
                JSON.stringify({
                  type: "error",
                  message: "Not authorized to update active chat status in this match",
                  code: "UNAUTHORIZED_MATCH"
                })
              );
              return;
            }
            if (match.id !== matchId) {
              console.error(
                `[PRIVACY VIOLATION] Match ID mismatch: requested ${matchId}, found ${match.id}`
              );
              ws2.send(
                JSON.stringify({
                  type: "error",
                  message: "Match ID validation failed",
                  code: "MATCH_ID_MISMATCH"
                })
              );
              return;
            }
            console.log(
              `[PRIVACY] User ${userId} updated active chat status to ${active} in match ${matchId} (Verified: User is authorized participant)`
            );
            const otherUserId = match.userId1 === userId ? match.userId2 : match.userId1;
            if (active) {
              if (!activeChats.has(userId)) {
                activeChats.set(userId, /* @__PURE__ */ new Set());
              }
              activeChats.get(userId).add(matchId);
              await storage.updateActiveChatStatus(userId, matchId, true);
              console.log(
                `[PRIVACY] User ${userId} set active status for match ${matchId} to true`
              );
              const activeUsers = await storage.getUsersInActiveChat(matchId);
              const bothUsersActive = activeUsers.includes(userId) && activeUsers.includes(otherUserId);
              const otherUserWs = connectedUsers3.get(otherUserId);
              if (otherUserWs && otherUserWs.readyState === WebSocket3.OPEN) {
                const currentTime = /* @__PURE__ */ new Date();
                const timestampISO = currentTime.toISOString();
                otherUserWs.send(
                  JSON.stringify({
                    type: "chat_partner_active",
                    userId,
                    matchId,
                    active: true,
                    inChat: bothUsersActive,
                    // Both users are in the chat
                    timestamp: timestampISO
                  })
                );
                otherUserWs.send(
                  JSON.stringify({
                    type: "user_status",
                    userId,
                    status: "online",
                    inChatMatch: matchId,
                    // This user is in this specific chat
                    timestamp: timestampISO,
                    priority: "high"
                    // Override any previous status
                  })
                );
                if (ws2.readyState === WebSocket3.OPEN) {
                  ws2.send(
                    JSON.stringify({
                      type: "user_status",
                      userId: otherUserId,
                      status: "online",
                      inChatMatch: activeUsers.includes(otherUserId) ? matchId : null,
                      timestamp: timestampISO,
                      priority: "high"
                      // Override any previous status
                    })
                  );
                }
              }
            } else {
              if (activeChats.has(userId)) {
                activeChats.get(userId).delete(matchId);
              }
              await storage.updateActiveChatStatus(userId, matchId, false);
              console.log(
                `[PRIVACY] User ${userId} set active status for match ${matchId} to false`
              );
              const otherUserWs = connectedUsers3.get(otherUserId);
              if (otherUserWs && otherUserWs.readyState === WebSocket3.OPEN) {
                otherUserWs.send(
                  JSON.stringify({
                    type: "chat_partner_active",
                    userId,
                    matchId,
                    active: false,
                    inChat: false,
                    // User has left the chat
                    timestamp: (/* @__PURE__ */ new Date()).toISOString()
                  })
                );
              }
            }
          } catch (error) {
            console.error("Error updating active chat status:", error);
          }
        } else if (data.type === "match_popup_closed" && userId) {
          try {
            const { matchId, sendMessage } = data;
            if (!matchId) {
              console.error(
                `[MATCH] User ${userId} sent match_popup_closed without matchId`
              );
              return;
            }
            const match = await storage.getMatchById(matchId);
            if (!match) {
              console.error(
                `[MATCH] User ${userId} attempted to close match popup for non-existent match ${matchId}`
              );
              return;
            }
            if (match.userId1 !== userId && match.userId2 !== userId) {
              console.error(
                `[MATCH] User ${userId} attempted to close match popup for match ${matchId} they're not part of`
              );
              return;
            }
            const otherUserId = match.userId1 === userId ? match.userId2 : match.userId1;
            const otherUserWs = connectedUsers3.get(otherUserId);
            if (otherUserWs && otherUserWs.readyState === WebSocket3.OPEN) {
              otherUserWs.send(
                JSON.stringify({
                  type: "match_popup_closed",
                  matchId,
                  closedBy: userId,
                  sendMessage: sendMessage || false,
                  timestamp: (/* @__PURE__ */ new Date()).toISOString()
                })
              );
              console.log(
                `[MATCH] Notified user ${otherUserId} that match popup for match ${matchId} was closed by user ${userId}`
              );
            } else {
              console.log(
                `[MATCH] Other user ${otherUserId} not connected via WebSocket, could not notify about match popup closed`
              );
            }
          } catch (error) {
            console.error("Error handling match popup closed event:", error);
          }
        } else if (data.type === "swipe_action" && userId) {
          try {
            const { targetUserId, action, isMatch } = data;
            if (!targetUserId || !action) {
              console.error(
                `[SWIPE] User ${userId} sent swipe_action without targetUserId or action`
              );
              return;
            }
            const targetUser = await storage.getUser(targetUserId);
            if (!targetUser) {
              console.error(
                `[SWIPE] User ${userId} attempted to swipe on non-existent user ${targetUserId}`
              );
              return;
            }
            console.log(
              `[SWIPE] User ${userId} ${action}d user ${targetUserId}`
            );
            if (action === "message") {
              try {
                let match = await storage.getMatchBetweenUsers(
                  userId,
                  targetUserId
                );
                let matchId;
                if (!match) {
                  const newMatch2 = await storage.createMatch({
                    userId1: userId,
                    userId2: targetUserId,
                    matched: true,
                    metadata: JSON.stringify({ origin: "MEET" })
                  });
                  matchId = newMatch2.id;
                  console.log(
                    `[SWIPE-MESSAGE] Created new match ${matchId} between users ${userId} and ${targetUserId}`
                  );
                } else if (!match.matched) {
                  const updatedMatch = await storage.updateMatchStatus(
                    match.id,
                    true
                  );
                  if (!updatedMatch) {
                    console.error(
                      `[SWIPE-MESSAGE] Failed to update match ${match.id} to matched=true`
                    );
                    return;
                  }
                  matchId = updatedMatch.id;
                  console.log(
                    `[SWIPE-MESSAGE] Updated match ${matchId} to matched=true`
                  );
                } else {
                  matchId = match.id;
                }
                const targetUserWs = connectedUsers3.get(targetUserId);
                if (targetUserWs && targetUserWs.readyState === WebSocket3.OPEN) {
                  const sourceUser = await storage.getUser(userId);
                  const safeUserInfo = sourceUser ? (({ password, ...rest }) => rest)(sourceUser) : { id: userId, fullName: "Unknown User" };
                  targetUserWs.send(
                    JSON.stringify({
                      type: "message_request",
                      fromUserId: userId,
                      fromUserInfo: safeUserInfo,
                      matchId,
                      timestamp: (/* @__PURE__ */ new Date()).toISOString()
                    })
                  );
                  console.log(
                    `[SWIPE-MESSAGE] Notified user ${targetUserId} about message request from user ${userId}`
                  );
                }
              } catch (error) {
                console.error(
                  `[SWIPE-MESSAGE] Error in message action handling: ${error}`
                );
              }
            } else {
              const sourceUserWs = connectedUsers3.get(userId);
              const targetUserWs = connectedUsers3.get(targetUserId);
              if (sourceUserWs && sourceUserWs.readyState === WebSocket3.OPEN) {
                sourceUserWs.send(
                  JSON.stringify({
                    type: "remove_from_discover",
                    removeUserId: targetUserId,
                    reason: `${action}_action`,
                    timestamp: (/* @__PURE__ */ new Date()).toISOString()
                  })
                );
                console.log(
                  `[REAL-TIME] Instantly removed user ${targetUserId}'s card from user ${userId}'s discover deck`
                );
              }
              if (targetUserWs && targetUserWs.readyState === WebSocket3.OPEN) {
                targetUserWs.send(
                  JSON.stringify({
                    type: "remove_from_discover",
                    removeUserId: userId,
                    reason: `received_${action}`,
                    timestamp: (/* @__PURE__ */ new Date()).toISOString()
                  })
                );
                if (action === "like") {
                  const sourceUser = await storage.getUser(userId);
                  const safeUserInfo = sourceUser ? (({ password, ...rest }) => rest)(sourceUser) : { id: userId, fullName: "Unknown User" };
                  targetUserWs.send(
                    JSON.stringify({
                      type: "new_like_received",
                      fromUserId: userId,
                      fromUserInfo: safeUserInfo,
                      isMatch: isMatch || false,
                      timestamp: (/* @__PURE__ */ new Date()).toISOString()
                    })
                  );
                }
                console.log(
                  `[REAL-TIME] Instantly removed user ${userId}'s card from user ${targetUserId}'s discover deck`
                );
              }
            }
            for (const [
              connectedUserId,
              connectedWs
            ] of connectedUsers3.entries()) {
              if (connectedWs.readyState === WebSocket3.OPEN) {
                if (connectedUserId === targetUserId || connectedUserId === userId) {
                  connectedWs.send(
                    JSON.stringify({
                      type: "discover:refresh",
                      timestamp: (/* @__PURE__ */ new Date()).toISOString()
                    })
                  );
                  if (action === "like" || action === "message") {
                    connectedWs.send(
                      JSON.stringify({
                        type: "matches:refresh",
                        timestamp: (/* @__PURE__ */ new Date()).toISOString()
                      })
                    );
                  }
                }
              }
            }
          } catch (error) {
            console.error("Error handling swipe action event:", error);
          }
        } else if (data.type === "ping") {
          ws2.send(JSON.stringify({ type: "pong", timestamp: (/* @__PURE__ */ new Date()).toISOString() }));
        } else if (data.type === "get_online_count") {
          const onlineCount = connectedUsers3.size;
          ws2.send(
            JSON.stringify({
              type: "online_count_update",
              count: onlineCount,
              timestamp: (/* @__PURE__ */ new Date()).toISOString()
            })
          );
        }
      } catch (error) {
        console.error("Error processing WebSocket message:", error);
      }
    });
    ws2.on("close", async () => {
      if (userId) {
        console.log(`User ${userId} disconnected`);
        await storage.updateUserOnlineStatus(userId, false);
        if (activeChats.has(userId)) {
          const userActiveChats = Array.from(activeChats.get(userId) || []);
          for (const matchId of userActiveChats) {
            try {
              const match = await storage.getMatchById(matchId);
              if (match) {
                await storage.updateActiveChatStatus(userId, matchId, false);
                const otherUserId = match.userId1 === userId ? match.userId2 : match.userId1;
                const otherUserWs = connectedUsers3.get(otherUserId);
                if (otherUserWs && otherUserWs.readyState === WebSocket3.OPEN) {
                  otherUserWs.send(
                    JSON.stringify({
                      type: "chat_partner_active",
                      userId,
                      matchId,
                      active: false,
                      inChat: false,
                      timestamp: (/* @__PURE__ */ new Date()).toISOString()
                    })
                  );
                }
              }
            } catch (error) {
              console.error(
                `Error handling disconnection for match ${matchId}:`,
                error
              );
            }
          }
          activeChats.delete(userId);
        }
        connectedUsers3.delete(userId);
        const disconnectTime = /* @__PURE__ */ new Date();
        const timestampISO = disconnectTime.toISOString();
        const onlineCount = connectedUsers3.size;
        broadcastToAllUsers({
          type: "online_count_update",
          count: onlineCount,
          timestamp: timestampISO
        });
        broadcastToAllUsers({
          type: "user_profile_update",
          userId,
          isOnline: false,
          lastSeen: timestampISO,
          timestamp: timestampISO
        });
        const activeMatchIds = activeChats.get(userId) || /* @__PURE__ */ new Set();
        Array.from(activeMatchIds).forEach((matchId) => {
          broadcastToAllUsers({
            type: "chat_partner_active",
            userId,
            matchId,
            active: false,
            inChat: false,
            timestamp: timestampISO,
            priority: "high"
          });
        });
        broadcastToAllUsers({
          type: "user_disconnected",
          userId,
          timestamp: timestampISO
        });
        setTimeout(() => {
          const offlineStatus = {
            type: "user_status",
            userId,
            status: "offline",
            lastSeen: timestampISO,
            inChatMatch: null,
            // Clear any chat match on disconnect
            timestamp: timestampISO,
            priority: "high"
            // Mark as high priority to prevent race conditions
          };
          broadcastToAllUsers(offlineStatus);
          console.log(
            `[PRESENCE] User ${userId} is now offline. Last seen: ${timestampISO}`
          );
          Array.from(connectedUsers3.values()).forEach((clientWs) => {
            if (clientWs.readyState === WebSocket3.OPEN) {
              clientWs.send(
                JSON.stringify({
                  type: "chat_clear_user",
                  userId,
                  timestamp: timestampISO,
                  priority: "high"
                })
              );
            }
          });
        }, 50);
      }
    });
  });
  function broadcastToAllUsers(data) {
    connectedUsers3.forEach((ws2) => {
      if (ws2.readyState === WebSocket3.OPEN) {
        ws2.send(JSON.stringify(data));
      }
    });
  }
  function broadcastToUsers(userIds, data) {
    for (const userId of userIds) {
      const userSocket = connectedUsers3.get(userId);
      if (userSocket && userSocket.readyState === WebSocket3.OPEN) {
        userSocket.send(JSON.stringify(data));
      }
    }
  }
  function broadcastProfileVisibilityChange(userId, isHidden) {
    const visibilityChangeMessage = {
      type: "profileVisibilityChanged",
      userId,
      isHidden,
      timestamp: (/* @__PURE__ */ new Date()).toISOString()
    };
    let notifiedCount = 0;
    connectedUsers3.forEach((ws2, connectedUserId) => {
      if (connectedUserId !== userId && ws2.readyState === WebSocket3.OPEN) {
        try {
          ws2.send(JSON.stringify(visibilityChangeMessage));
          notifiedCount++;
        } catch (wsError) {
          console.error(
            `Failed to notify user ${connectedUserId} of profile visibility change:`,
            wsError
          );
        }
      }
    });
    console.log(
      `Broadcasted profile visibility change for user ${userId} to ${notifiedCount} other users`
    );
  }
  function broadcastGhostModeChange(userId, isEnabled) {
    const ghostModeChangeMessage = {
      type: "ghostModeChanged",
      userId,
      isEnabled,
      timestamp: (/* @__PURE__ */ new Date()).toISOString()
    };
    let notifiedCount = 0;
    connectedUsers3.forEach((ws2, connectedUserId) => {
      if (connectedUserId !== userId && ws2.readyState === WebSocket3.OPEN) {
        try {
          ws2.send(JSON.stringify(ghostModeChangeMessage));
          notifiedCount++;
        } catch (wsError) {
          console.error(
            `Failed to notify user ${connectedUserId} of Ghost Mode change:`,
            wsError
          );
        }
      }
    });
    console.log(
      `Broadcasted Ghost Mode change for user ${userId} to ${notifiedCount} other users`
    );
  }
  function broadcastVerificationStatusChange(userId, isVerified) {
    const verificationChangeMessage = {
      type: "verificationStatusChanged",
      userId,
      isVerified,
      timestamp: (/* @__PURE__ */ new Date()).toISOString()
    };
    let notifiedCount = 0;
    connectedUsers3.forEach((ws2, connectedUserId) => {
      if (ws2.readyState === WebSocket3.OPEN) {
        try {
          ws2.send(JSON.stringify(verificationChangeMessage));
          notifiedCount++;
        } catch (wsError) {
          console.error(
            `Failed to notify user ${connectedUserId} about verification status change:`,
            wsError
          );
        }
      }
    });
    console.log(
      `Broadcasted verification status change for user ${userId} (isVerified: ${isVerified}) to ${notifiedCount} connected users`
    );
  }
  app2.get(
    "/api/messages/check-chat/:matchId",
    async (req, res) => {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      try {
        const matchId = parseInt(req.params.matchId);
        if (isNaN(matchId)) {
          return res.status(400).json({ message: "Invalid match ID" });
        }
        const match = await storage.getMatchById(matchId);
        if (!match) {
          return res.status(404).json({ message: "Match not found" });
        }
        if (match.userId1 !== req.user.id && match.userId2 !== req.user.id) {
          return res.status(403).json({ message: "Not authorized to access this match" });
        }
        const messages2 = await storage.getMessagesByMatchId(matchId);
        const chatExists = messages2.length > 0;
        if (chatExists && !match.matched) {
          await storage.updateMatchStatus(matchId, true);
          console.log(
            `Auto-repaired match status for match ${matchId} - marked as matched since chat exists`
          );
        }
        return res.status(200).json({
          chatExists,
          messageCount: messages2.length,
          matchStatus: match.matched ? "confirmed" : "pending"
        });
      } catch (error) {
        console.error(`Error checking chat existence for match: ${error}`);
        return res.status(500).json({
          message: "Failed to check chat existence",
          error: error instanceof Error ? error.message : "Unknown error"
        });
      }
    }
  );
  app2.delete(
    "/api/messages/:messageId",
    async (req, res) => {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      try {
        const messageId = parseInt(req.params.messageId);
        if (isNaN(messageId)) {
          return res.status(400).json({ message: "Invalid message ID" });
        }
        const userId = req.user.id;
        const message = await storage.getMessageById(messageId);
        if (!message) {
          console.log(
            `Message ${messageId} not found - likely already deleted by user ${userId} or auto-delete`
          );
          return res.status(200).json({
            success: true,
            message: "Message already deleted",
            messageId,
            alreadyDeleted: true
          });
        }
        if (message.senderId !== userId) {
          return res.status(403).json({ message: "Not authorized to delete this message" });
        }
        const match = await storage.getMatchById(message.matchId);
        if (!match) {
          console.error(
            `\u26A0\uFE0F CRITICAL: Match ${message.matchId} not found during message deletion by user ${userId}. This suggests a data consistency issue.`
          );
          try {
            await new Promise((resolve) => setTimeout(resolve, 100));
            const retryMatch = await storage.getMatchById(message.matchId);
            if (retryMatch) {
              console.log(
                `\u2705 RECOVERY: Match ${message.matchId} found on retry. Continuing with deletion.`
              );
            } else {
              console.error(
                `\u274C CRITICAL: Match ${message.matchId} still not found after retry. Data consistency issue detected.`
              );
              return res.status(200).json({
                success: true,
                message: "Message deletion completed (match verification skipped due to temporary issue)",
                messageId,
                warning: "temporary_match_lookup_issue",
                userFriendlyMessage: "Your message was removed. If you experience any issues, please refresh the page."
              });
            }
          } catch (retryError) {
            console.error(`Failed to retry match lookup:`, retryError);
            console.log(
              `\u26A0\uFE0F FALLBACK: Proceeding with message deletion despite match lookup failure`
            );
            return res.status(200).json({
              success: true,
              message: "Message deletion completed (match verification bypassed)",
              messageId,
              warning: "match_lookup_failed",
              userFriendlyMessage: "Your message was removed. Your match is still active."
            });
          }
        }
        const actualMatch = match || await storage.getMatchById(message.matchId);
        if (actualMatch && actualMatch.userId1 !== userId && actualMatch.userId2 !== userId) {
          return res.status(403).json({ message: "Not authorized to access this match" });
        }
        if (message.messageType === "audio" && message.audioUrl) {
          try {
            console.log(`Would delete audio file: ${message.audioUrl}`);
          } catch (mediaError) {
            console.error("Error deleting media file:", mediaError);
          }
        }
        if (message.messageType === "image" && message.content?.startsWith("_!_IMAGE_!_")) {
          try {
            const imageUrl = message.content.replace("_!_IMAGE_!_", "");
            console.log(`Would delete image file: ${imageUrl}`);
          } catch (mediaError) {
            console.error("Error deleting image file:", mediaError);
          }
        }
        const deleteResult = await db.delete(messages).where(eq5(messages.id, messageId));
        const verificationMessage = await storage.getMessageById(messageId);
        if (verificationMessage) {
          console.warn(
            `Message ${messageId} deletion verification failed, but delete command executed`
          );
        }
        try {
          invalidateMessageCaches(connectedUsers3, {
            matchId: message.matchId,
            userId,
            messageId,
            reason: "message_delete"
          });
        } catch (cacheError) {
          console.error(
            `Failed to invalidate caches for match ${message.matchId}:`,
            cacheError
          );
        }
        const otherUserId = actualMatch ? actualMatch.userId1 === userId ? actualMatch.userId2 : actualMatch.userId1 : null;
        if (otherUserId) {
          const deletionMessage = {
            type: "messageDeleted",
            messageId,
            matchId: message.matchId,
            deletedBy: userId,
            timestamp: (/* @__PURE__ */ new Date()).toISOString()
          };
          const senderWs = connectedUsers3.get(userId);
          if (senderWs && senderWs.readyState === WebSocket3.OPEN) {
            try {
              senderWs.send(JSON.stringify(deletionMessage));
            } catch (wsError) {
              console.error(
                `Failed to notify sender ${userId} of message deletion:`,
                wsError
              );
            }
          }
          const receiverWs = connectedUsers3.get(otherUserId);
          if (receiverWs && receiverWs.readyState === WebSocket3.OPEN) {
            try {
              receiverWs.send(JSON.stringify(deletionMessage));
            } catch (wsError) {
              console.error(
                `Failed to notify receiver ${otherUserId} of message deletion:`,
                wsError
              );
            }
          }
        } else {
          console.warn(
            `\u26A0\uFE0F Skipping WebSocket broadcast for message ${messageId} - other user ID could not be determined`
          );
        }
        console.log(
          `Message ${messageId} successfully deleted by user ${userId} from match ${message.matchId}`
        );
        res.status(200).json({
          success: true,
          message: "Message deleted successfully",
          messageId,
          matchId: message.matchId
        });
      } catch (error) {
        console.error("Error deleting message:", error);
        const errorMessage = error instanceof Error ? error.message : "Unknown error";
        const requestedMessageId = parseInt(req.params.messageId);
        if (errorMessage.includes("not found") || errorMessage.includes("does not exist")) {
          return res.status(200).json({
            success: true,
            message: "Message already deleted",
            messageId: requestedMessageId,
            alreadyDeleted: true
          });
        }
        res.status(500).json({
          message: "Server error deleting message",
          error: errorMessage,
          success: false
        });
      }
    }
  );
  app2.delete(
    "/api/messages/:messageId/recipient",
    async (req, res) => {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      try {
        const messageId = parseInt(req.params.messageId);
        if (isNaN(messageId)) {
          return res.status(400).json({ message: "Invalid message ID" });
        }
        const userId = req.user.id;
        const message = await storage.getMessageById(messageId);
        if (!message) {
          return res.status(404).json({ message: "Message not found" });
        }
        const match = await storage.getMatchById(message.matchId);
        if (!match) {
          return res.status(404).json({ message: "Match not found" });
        }
        if (match.userId1 !== userId && match.userId2 !== userId) {
          return res.status(403).json({ message: "Not authorized to access this match" });
        }
        await storage.markMessageAsDeletedForUser(messageId, userId);
        try {
          invalidateMessageCaches(connectedUsers3, {
            matchId: message.matchId,
            userId,
            messageId,
            reason: "message_delete"
          });
        } catch (cacheError) {
          console.error(
            `Failed to invalidate caches for user ${userId} in match ${message.matchId}:`,
            cacheError
          );
        }
        console.log(
          `Message ${messageId} marked as deleted for user ${userId} (recipient deletion)`
        );
        res.status(200).json({
          success: true,
          message: "Message deleted from your view",
          messageId,
          matchId: message.matchId
        });
      } catch (error) {
        console.error("Error deleting message for recipient:", error);
        const errorMessage = error instanceof Error ? error.message : "Unknown error";
        res.status(500).json({
          message: "Server error deleting message",
          error: errorMessage,
          success: false
        });
      }
    }
  );
  app2.post(
    "/api/messages/:messageId/reactions",
    async (req, res) => {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      try {
        const messageId = parseInt(req.params.messageId);
        const { emoji } = req.body;
        const userId = req.user.id;
        if (isNaN(messageId) || !emoji) {
          return res.status(400).json({ message: "Invalid message ID or emoji" });
        }
        const message = await storage.getMessageById(messageId);
        if (!message) {
          return res.status(404).json({ message: "Message not found" });
        }
        const match = await storage.getMatchById(message.matchId);
        if (!match || match.userId1 !== userId && match.userId2 !== userId) {
          return res.status(403).json({ message: "Access denied" });
        }
        const reaction = await storage.addMessageReaction({
          messageId,
          userId,
          emoji
        });
        const reactingUser = await storage.getUser(userId);
        const userName = reactingUser?.fullName || reactingUser?.username || "Someone";
        const otherUserId = match.userId1 === userId ? match.userId2 : match.userId1;
        const otherUserSocket = connectedUsers3.get(otherUserId);
        if (otherUserSocket && otherUserSocket.readyState === WebSocket3.OPEN) {
          otherUserSocket.send(
            JSON.stringify({
              type: "reactionReplaced",
              // Changed from "reactionAdded" to be more accurate
              messageId,
              userId,
              emoji,
              matchId: message.matchId,
              reaction: {
                ...reaction,
                userName
              },
              isReplacement: true
              // Flag to indicate this replaces the user's previous reaction
            })
          );
        }
        res.json({ success: true, reaction });
      } catch (error) {
        console.error("Error adding message reaction:", error);
        res.status(500).json({ message: "Failed to add reaction" });
      }
    }
  );
  app2.delete(
    "/api/messages/:messageId/reactions",
    async (req, res) => {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      try {
        const messageId = parseInt(req.params.messageId);
        const { emoji } = req.body;
        const userId = req.user.id;
        if (isNaN(messageId) || !emoji) {
          return res.status(400).json({ message: "Invalid message ID or emoji" });
        }
        const message = await storage.getMessageById(messageId);
        if (!message) {
          return res.status(404).json({ message: "Message not found" });
        }
        const match = await storage.getMatchById(message.matchId);
        if (!match || match.userId1 !== userId && match.userId2 !== userId) {
          return res.status(403).json({ message: "Access denied" });
        }
        await storage.removeMessageReaction(messageId, userId, emoji);
        const removingUser = await storage.getUser(userId);
        const userName = removingUser?.fullName || removingUser?.username || "Someone";
        const otherUserId = match.userId1 === userId ? match.userId2 : match.userId1;
        const otherUserSocket = connectedUsers3.get(otherUserId);
        if (otherUserSocket && otherUserSocket.readyState === WebSocket3.OPEN) {
          otherUserSocket.send(
            JSON.stringify({
              type: "reactionRemoved",
              messageId,
              userId,
              emoji,
              matchId: message.matchId,
              userName
            })
          );
        }
        res.json({ success: true });
      } catch (error) {
        console.error("Error removing message reaction:", error);
        res.status(500).json({ message: "Failed to remove reaction" });
      }
    }
  );
  app2.get(
    "/api/messages/:messageId/reactions",
    async (req, res) => {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      try {
        const messageId = parseInt(req.params.messageId);
        const userId = req.user.id;
        if (isNaN(messageId)) {
          return res.status(400).json({ message: "Invalid message ID" });
        }
        const message = await storage.getMessageById(messageId);
        if (!message) {
          return res.status(404).json({ message: "Message not found" });
        }
        const match = await storage.getMatchById(message.matchId);
        if (!match || match.userId1 !== userId && match.userId2 !== userId) {
          return res.status(403).json({ message: "Access denied" });
        }
        const reactions = await storage.getMessageReactions(messageId);
        res.json({ reactions });
      } catch (error) {
        console.error("Error getting message reactions:", error);
        res.status(500).json({ message: "Failed to get reactions" });
      }
    }
  );
  app2.get(
    "/api/matches/:matchId/reactions",
    async (req, res) => {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      try {
        const matchId = parseInt(req.params.matchId);
        const userId = req.user.id;
        if (isNaN(matchId)) {
          return res.status(400).json({ message: "Invalid match ID" });
        }
        const match = await storage.getMatchById(matchId);
        if (!match || match.userId1 !== userId && match.userId2 !== userId) {
          return res.status(403).json({ message: "Access denied" });
        }
        const reactions = await storage.getMessageReactionsByMatch(matchId);
        res.json({ reactions });
      } catch (error) {
        console.error("Error getting match reactions:", error);
        res.status(500).json({ message: "Failed to get reactions" });
      }
    }
  );
  app2.get(
    "/api/matches/:matchId/auto-delete-settings",
    async (req, res) => {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      try {
        const matchId = parseInt(req.params.matchId);
        const userId = req.user.id;
        if (isNaN(matchId)) {
          return res.status(400).json({ message: "Invalid match ID" });
        }
        const match = await storage.getMatchById(matchId);
        if (!match || match.userId1 !== userId && match.userId2 !== userId) {
          return res.status(403).json({ message: "Access denied" });
        }
        const settings = await storage.getUserMatchSettings(userId, matchId);
        res.json({
          settings: settings || {
            autoDeleteMode: "never",
            autoDeleteValue: 5,
            autoDeleteUnit: "minutes"
          }
        });
      } catch (error) {
        console.error("Error getting auto-delete settings:", error);
        res.status(500).json({ message: "Failed to get auto-delete settings" });
      }
    }
  );
  app2.post(
    "/api/matches/:matchId/auto-delete-settings",
    async (req, res) => {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      try {
        const matchId = parseInt(req.params.matchId);
        const userId = req.user.id;
        const { autoDeleteMode, autoDeleteValue, autoDeleteUnit } = req.body;
        if (isNaN(matchId)) {
          return res.status(400).json({ message: "Invalid match ID" });
        }
        if (!["never", "always", "custom"].includes(autoDeleteMode)) {
          return res.status(400).json({ message: "Invalid auto-delete mode" });
        }
        if (autoDeleteMode === "custom") {
          if (!["minutes", "hours", "days", "weeks", "months"].includes(
            autoDeleteUnit
          )) {
            return res.status(400).json({ message: "Invalid auto-delete unit" });
          }
          if (!autoDeleteValue || autoDeleteValue < 1) {
            return res.status(400).json({ message: "Invalid auto-delete value" });
          }
        }
        const match = await storage.getMatchById(matchId);
        if (!match || match.userId1 !== userId && match.userId2 !== userId) {
          return res.status(403).json({ message: "Access denied" });
        }
        const currentSettings = await storage.getUserMatchSettings(
          userId,
          matchId
        );
        const isChangingToAlways = autoDeleteMode === "always" && (!currentSettings || currentSettings.autoDeleteMode !== "always");
        const settingsData = {
          autoDeleteMode,
          autoDeleteValue: autoDeleteValue || 5,
          autoDeleteUnit: autoDeleteUnit || "minutes"
        };
        if (isChangingToAlways) {
          settingsData.alwaysModeActivatedAt = /* @__PURE__ */ new Date();
          console.log(
            `User ${userId} activated "always" mode for match ${matchId} at ${settingsData.alwaysModeActivatedAt}`
          );
        }
        const settings = await storage.updateUserMatchSettings(
          userId,
          matchId,
          settingsData
        );
        res.json({ success: true, settings });
      } catch (error) {
        console.error("Error updating auto-delete settings:", error);
        res.status(500).json({ message: "Failed to update auto-delete settings" });
      }
    }
  );
  app2.post(
    "/api/admin/process-auto-delete",
    async (req, res) => {
      try {
        await storage.processAutoDeleteMessages();
        res.json({
          success: true,
          message: "Auto-delete processing completed"
        });
      } catch (error) {
        console.error("Error processing auto-delete messages:", error);
        res.status(500).json({ message: "Failed to process auto-delete messages" });
      }
    }
  );
  app2.post(
    "/api/matches/:matchId/trigger-auto-delete",
    async (req, res) => {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      try {
        const matchId = parseInt(req.params.matchId);
        const userId = req.user.id;
        if (isNaN(matchId)) {
          return res.status(400).json({ message: "Invalid match ID" });
        }
        const match = await storage.getMatchById(matchId);
        if (!match || match.userId1 !== userId && match.userId2 !== userId) {
          return res.status(403).json({ message: "Access denied" });
        }
        const settings = await storage.getUserMatchSettings(userId, matchId);
        if (settings && settings.autoDeleteMode === "always") {
          console.log(
            `Triggering auto-delete for user ${userId} in match ${matchId} (always mode)`
          );
          await storage.deleteMessagesForUser(userId, matchId);
          const remainingMessagesForUser = await storage.getMessagesByMatchId(
            matchId,
            userId
          );
          const remainingMessagesForOther = await storage.getMessagesByMatchId(
            matchId,
            match.userId1 === userId ? match.userId2 : match.userId1
          );
          const newLastMessageForUser = remainingMessagesForUser.length > 0 ? remainingMessagesForUser[remainingMessagesForUser.length - 1] : null;
          const newLastMessageForOther = remainingMessagesForOther.length > 0 ? remainingMessagesForOther[remainingMessagesForOther.length - 1] : null;
          const otherUserId = match.userId1 === userId ? match.userId2 : match.userId1;
          const currentUserSocket = connectedUsers3.get(userId);
          if (currentUserSocket && currentUserSocket.readyState === WebSocket3.OPEN) {
            currentUserSocket.send(
              JSON.stringify({
                type: "messagesDeletedForUser",
                matchId,
                deletedForUserId: userId,
                reason: "always_mode_exit",
                isCurrentUser: true,
                newLastMessage: newLastMessageForUser ? {
                  content: newLastMessageForUser.content,
                  createdAt: newLastMessageForUser.createdAt,
                  senderId: newLastMessageForUser.senderId
                } : null
              })
            );
          }
          const otherUserSocket = connectedUsers3.get(otherUserId);
          if (otherUserSocket && otherUserSocket.readyState === WebSocket3.OPEN) {
            otherUserSocket.send(
              JSON.stringify({
                type: "messagesDeletedForUser",
                matchId,
                deletedForUserId: userId,
                reason: "always_mode_exit",
                isCurrentUser: false,
                newLastMessage: newLastMessageForOther ? {
                  content: newLastMessageForOther.content,
                  createdAt: newLastMessageForOther.createdAt,
                  senderId: newLastMessageForOther.senderId
                } : null
              })
            );
          }
          const matchRefreshData = {
            type: "matches:refresh",
            matchId,
            reason: "auto_delete_lastMessage_update",
            timestamp: (/* @__PURE__ */ new Date()).toISOString()
          };
          if (currentUserSocket && currentUserSocket.readyState === WebSocket3.OPEN) {
            currentUserSocket.send(JSON.stringify(matchRefreshData));
          }
          if (otherUserSocket && otherUserSocket.readyState === WebSocket3.OPEN) {
            otherUserSocket.send(JSON.stringify(matchRefreshData));
          }
          res.json({
            success: true,
            message: "Auto-delete triggered successfully"
          });
        } else {
          res.json({ success: true, message: "No auto-delete needed" });
        }
      } catch (error) {
        console.error("Error triggering auto-delete:", error);
        res.status(500).json({ message: "Failed to trigger auto-delete" });
      }
    }
  );
  profileVisibilityBroadcaster = broadcastProfileVisibilityChange;
  ghostModeBroadcaster = broadcastGhostModeChange;
  verificationStatusBroadcaster = broadcastVerificationStatusChange;
  app2.get(
    "/api/suite/profile-settings",
    async (req, res) => {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      try {
        const userId = req.user.id;
        const settings = await storage.getSuiteProfileSettings(userId);
        res.json(
          settings || {
            jobProfileActive: false,
            mentorshipProfileActive: false,
            networkingProfileActive: false,
            hiddenInJobDiscovery: false,
            hiddenInMentorshipDiscovery: false,
            hiddenInNetworkingDiscovery: false,
            primaryProfileType: null
          }
        );
      } catch (error) {
        console.error("Error fetching SUITE profile settings:", error);
        res.status(500).json({ message: "Failed to fetch profile settings" });
      }
    }
  );
  app2.put(
    "/api/suite/profile-settings",
    async (req, res) => {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      try {
        const userId = req.user.id;
        const settings = req.body;
        const updatedSettings = await storage.updateSuiteProfileSettings(
          userId,
          settings
        );
        res.json(updatedSettings);
      } catch (error) {
        console.error("Error updating SUITE profile settings:", error);
        res.status(500).json({ message: "Failed to update profile settings" });
      }
    }
  );
  app2.get("/api/suite/job-profile/:userId", async (req, res) => {
    if (!req.isAuthenticated()) {
      return res.status(401).json({ message: "Unauthorized" });
    }
    try {
      const targetUserId = parseInt(req.params.userId);
      console.log(`[JOB-PROFILE-API] Request from user ${req.user.id} for job profile of target user ${targetUserId}`);
      const profile = await storage.getSuiteJobProfile(targetUserId);
      if (!profile) {
        console.log(`[JOB-PROFILE-API] No job profile found for target user ${targetUserId}`);
        return res.status(404).json({ message: "Job profile not found" });
      }
      console.log(`[JOB-PROFILE-API] Found job profile for target user ${targetUserId}:`, {
        profileId: profile.id,
        profileUserId: profile.userId,
        jobTitle: profile.jobTitle,
        description: profile.description,
        whoShouldApply: profile.whoShouldApply,
        applicationUrl: profile.applicationUrl,
        applicationEmail: profile.applicationEmail
      });
      if (profile.userId !== targetUserId) {
        console.error(`[JOB-PROFILE-API] CRITICAL ERROR: Profile user ID ${profile.userId} does not match target user ID ${targetUserId}`);
        return res.status(500).json({ message: "Data integrity error" });
      }
      res.json(profile);
    } catch (error) {
      console.error("Error fetching job profile by user ID:", error);
      res.status(500).json({ message: "Failed to fetch job profile" });
    }
  });
  app2.get("/api/suite/job-profile", async (req, res) => {
    if (!req.isAuthenticated()) {
      return res.status(401).json({ message: "Unauthorized" });
    }
    try {
      const userId = req.user.id;
      const jobProfile = await storage.getSuiteJobProfile(userId);
      res.json(jobProfile);
    } catch (error) {
      console.error("Error fetching job profile:", error);
      res.status(500).json({ message: "Failed to fetch job profile" });
    }
  });
  app2.post("/api/suite/job-profile", async (req, res) => {
    if (!req.isAuthenticated()) {
      return res.status(401).json({ message: "Unauthorized" });
    }
    try {
      const userId = req.user.id;
      const jobProfileData = { ...req.body, userId };
      const jobProfile = await storage.createOrUpdateSuiteJobProfile(
        userId,
        jobProfileData
      );
      await storage.updateSuiteProfileSettings(userId, {
        jobProfileActive: true,
        hiddenInJobDiscovery: false
        // Automatically make profile visible in discovery
      });
      res.json(jobProfile);
    } catch (error) {
      console.error("Error creating/updating job profile:", error);
      res.status(500).json({ message: "Failed to save job profile" });
    }
  });
  app2.patch("/api/suite/job-profile", async (req, res) => {
    if (!req.isAuthenticated()) {
      return res.status(401).json({ message: "Unauthorized" });
    }
    try {
      const userId = req.user.id;
      const { visibilityPreferences } = req.body;
      if (!visibilityPreferences) {
        return res.status(400).json({ message: "Visibility preferences required" });
      }
      const updatedProfile = await storage.updateSuiteJobProfileVisibility(
        userId,
        visibilityPreferences
      );
      res.json(updatedProfile);
    } catch (error) {
      console.error("Error updating job profile visibility:", error);
      res.status(500).json({ message: "Failed to update visibility preferences" });
    }
  });
  app2.delete(
    "/api/suite/job-profile",
    async (req, res) => {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      try {
        const userId = req.user.id;
        console.log("Deleting job profile for user:", userId);
        await storage.deleteSuiteJobProfile(userId);
        broadcastToAllUsers({
          type: "suite_profile_deleted",
          profileType: "job",
          userId,
          timestamp: (/* @__PURE__ */ new Date()).toISOString()
        });
        console.log("Job profile deleted successfully for user:", userId);
        res.json({
          success: true,
          message: "Job profile deleted successfully"
        });
      } catch (error) {
        console.error("Error deleting job profile:", error);
        res.status(500).json({
          message: "Failed to delete job profile",
          error: error instanceof Error ? error.message : "Unknown error"
        });
      }
    }
  );
  app2.get(
    "/api/suite/mentorship-profile/:userId",
    async (req, res) => {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      try {
        const userId = parseInt(req.params.userId);
        const profiles = await storage.getSuiteMentorshipProfiles(userId);
        const profile = profiles && profiles.length > 0 ? profiles[0] : null;
        if (!profile) {
          return res.status(404).json({ message: "Mentorship profile not found" });
        }
        res.json(profile);
      } catch (error) {
        console.error("Error fetching mentorship profile by user ID:", error);
        res.status(500).json({ message: "Failed to fetch mentorship profile" });
      }
    }
  );
  app2.get(
    "/api/suite/mentorship-profile",
    async (req, res) => {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      try {
        const userId = req.user.id;
        const role = req.query.role;
        if (role) {
          const mentorshipProfile = await storage.getSuiteMentorshipProfile(
            userId,
            role
          );
          res.json(mentorshipProfile);
        } else {
          const mentorshipProfiles = await storage.getSuiteMentorshipProfiles(userId);
          res.json(mentorshipProfiles);
        }
      } catch (error) {
        console.error("Error fetching mentorship profile:", error);
        res.status(500).json({ message: "Failed to fetch mentorship profile" });
      }
    }
  );
  app2.get(
    "/api/suite/mentorship-profiles",
    async (req, res) => {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      try {
        const userId = req.user.id;
        const mentorshipProfiles = await storage.getSuiteMentorshipProfiles(userId);
        res.json(mentorshipProfiles);
      } catch (error) {
        console.error("Error fetching mentorship profiles:", error);
        res.status(500).json({ message: "Failed to fetch mentorship profiles" });
      }
    }
  );
  app2.post(
    "/api/suite/mentorship-profile",
    async (req, res) => {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      try {
        const userId = req.user.id;
        console.log("Received mentorship profile data:", req.body);
        const { userId: bodyUserId, ...mentorshipProfileData } = req.body;
        console.log("Cleaned mentorship profile data:", mentorshipProfileData);
        if (!mentorshipProfileData.role) {
          return res.status(400).json({ message: "Role (mentor/mentee) is required" });
        }
        const role = mentorshipProfileData.role;
        console.log("Creating/updating mentorship profile for role:", role);
        const existingProfile = await storage.getSuiteMentorshipProfileByRole(
          userId,
          role
        );
        if (existingProfile?.visibilityPreferences) {
          mentorshipProfileData.visibilityPreferences = existingProfile.visibilityPreferences;
          console.log(
            "POST: Preserving existing mentorship visibilityPreferences:",
            existingProfile.visibilityPreferences
          );
        }
        const mentorshipProfile = await storage.createOrUpdateSuiteMentorshipProfile(
          userId,
          mentorshipProfileData
        );
        await storage.updateSuiteProfileSettings(userId, {
          mentorshipProfileActive: true,
          hiddenInMentorshipDiscovery: false
          // Automatically make profile visible in discovery
        });
        console.log(
          "Successfully saved mentorship profile:",
          mentorshipProfile
        );
        res.json(mentorshipProfile);
      } catch (error) {
        console.error("Error creating/updating mentorship profile:", error);
        console.error("Error stack:", error?.stack);
        res.status(500).json({
          message: "Failed to save mentorship profile",
          error: error?.message
        });
      }
    }
  );
  app2.delete(
    "/api/suite/mentorship-profile",
    async (req, res) => {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      try {
        const userId = req.user.id;
        const { role } = req.query;
        console.log("Deleting mentorship profile for user:", userId, "role:", role);
        if (role) {
          await storage.deleteSuiteMentorshipProfile(userId, role);
        } else {
          await storage.deleteSuiteMentorshipProfile(userId);
        }
        broadcastToAllUsers({
          type: "suite_profile_deleted",
          profileType: "mentorship",
          userId,
          role: role || "all",
          timestamp: (/* @__PURE__ */ new Date()).toISOString()
        });
        console.log("Mentorship profile deleted successfully for user:", userId);
        res.json({
          success: true,
          message: "Mentorship profile deleted successfully"
        });
      } catch (error) {
        console.error("Error deleting mentorship profile:", error);
        res.status(500).json({
          message: "Failed to delete mentorship profile",
          error: error instanceof Error ? error.message : "Unknown error"
        });
      }
    }
  );
  app2.patch(
    "/api/suite/mentorship-profile",
    async (req, res) => {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      try {
        const userId = req.user.id;
        console.log("PATCH Mentorship profile request body:", req.body);
        console.log("User ID:", userId);
        const updateData = req.body;
        console.log("Mentorship profile PATCH data:", updateData);
        console.log(
          "visibilityPreferences in PATCH data:",
          updateData.visibilityPreferences
        );
        console.log(
          "Type of visibilityPreferences:",
          typeof updateData.visibilityPreferences
        );
        if (updateData.visibilityPreferences) {
          try {
            const parsed = JSON.parse(updateData.visibilityPreferences);
            console.log("Successfully parsed visibilityPreferences:", Object.keys(parsed));
          } catch (jsonError) {
            console.error("Invalid JSON in visibilityPreferences:", jsonError);
            return res.status(400).json({
              message: "visibilityPreferences must be a valid JSON string"
            });
          }
        }
        if (updateData.role) {
          const role = updateData.role;
          console.log("PATCH: Updating profile for role:", role);
          const existingProfile = await storage.getSuiteMentorshipProfileByRole(
            userId,
            role
          );
          if (!existingProfile) {
            console.log(
              "No existing mentorship profile found for role - PATCH requires existing profile"
            );
            return res.status(404).json({
              message: "No mentorship profile found. Create a profile first before updating preferences."
            });
          }
        } else {
          const existingProfile = await storage.getSuiteMentorshipProfile(userId);
          if (!existingProfile) {
            console.log(
              "No existing mentorship profile found - PATCH requires existing profile"
            );
            return res.status(404).json({
              message: "No mentorship profile found. Create a profile first before updating preferences."
            });
          }
        }
        console.log("PATCH: About to call createOrUpdateSuiteMentorshipProfile with:", {
          userId,
          updateDataKeys: Object.keys(updateData),
          hasVisibilityPreferences: !!updateData.visibilityPreferences,
          visibilityPreferencesType: typeof updateData.visibilityPreferences
        });
        const mentorshipProfile = await storage.createOrUpdateSuiteMentorshipProfile(
          userId,
          updateData
        );
        console.log(
          "Successfully updated mentorship profile via PATCH:",
          mentorshipProfile
        );
        res.json(mentorshipProfile);
      } catch (error) {
        console.error("Error updating mentorship profile via PATCH:", error);
        console.error("Error stack:", error?.stack);
        console.error("Error message:", error?.message);
        res.status(500).json({
          message: "Failed to update mentorship profile",
          error: error?.message
        });
      }
    }
  );
  app2.get(
    "/api/suite/networking-profile/:userId",
    async (req, res) => {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      try {
        const userId = parseInt(req.params.userId);
        const profile = await storage.getSuiteNetworkingProfile(userId);
        if (!profile) {
          return res.status(404).json({ message: "Networking profile not found" });
        }
        res.json(profile);
      } catch (error) {
        console.error("Error fetching networking profile by user ID:", error);
        res.status(500).json({ message: "Failed to fetch networking profile" });
      }
    }
  );
  app2.get(
    "/api/suite/networking-profile",
    async (req, res) => {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      try {
        const userId = req.user.id;
        console.log("Fetching networking profile for user:", userId);
        const networkingProfile = await storage.getSuiteNetworkingProfile(userId);
        console.log("Retrieved networking profile:", networkingProfile);
        console.log(
          "visibilityPreferences field:",
          networkingProfile?.visibilityPreferences
        );
        res.json(networkingProfile);
      } catch (error) {
        console.error("Error fetching networking profile:", error);
        res.status(500).json({ message: "Failed to fetch networking profile" });
      }
    }
  );
  app2.post(
    "/api/suite/networking-profile",
    async (req, res) => {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      try {
        const userId = req.user.id;
        console.log("Networking profile request body:", req.body);
        console.log("User ID:", userId);
        const { userId: bodyUserId, ...networkingProfileData } = req.body;
        console.log("Cleaned networking profile data:", networkingProfileData);
        const existingProfile = await storage.getSuiteNetworkingProfile(userId);
        if (existingProfile?.visibilityPreferences) {
          networkingProfileData.visibilityPreferences = existingProfile.visibilityPreferences;
          console.log(
            "POST: Preserving existing visibilityPreferences:",
            existingProfile.visibilityPreferences
          );
        }
        const networkingProfile = await storage.createOrUpdateSuiteNetworkingProfile(
          userId,
          networkingProfileData
        );
        await storage.updateSuiteProfileSettings(userId, {
          networkingProfileActive: true,
          hiddenInNetworkingDiscovery: false
          // Automatically make profile visible in discovery
        });
        broadcastNetworkingProfileUpdate(userId, networkingProfile);
        console.log(
          "Successfully saved networking profile:",
          networkingProfile
        );
        res.json(networkingProfile);
      } catch (error) {
        console.error("Error creating/updating networking profile:", error);
        console.error("Error stack:", error.stack);
        console.error("Error message:", error.message);
        res.status(500).json({
          message: "Failed to save networking profile",
          error: error.message
        });
      }
    }
  );
  app2.put(
    "/api/suite/networking-profile",
    async (req, res) => {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      try {
        const userId = req.user.id;
        console.log("PUT Networking profile request body:", req.body);
        console.log("User ID:", userId);
        const { userId: bodyUserId, ...networkingProfileData } = req.body;
        console.log("Cleaned networking profile data:", networkingProfileData);
        const existingProfile = await storage.getSuiteNetworkingProfile(userId);
        if (existingProfile?.visibilityPreferences) {
          networkingProfileData.visibilityPreferences = existingProfile.visibilityPreferences;
          console.log(
            "PUT: Preserving existing visibilityPreferences:",
            existingProfile.visibilityPreferences
          );
        }
        const networkingProfile = await storage.createOrUpdateSuiteNetworkingProfile(
          userId,
          networkingProfileData
        );
        broadcastNetworkingProfileUpdate(userId, networkingProfile);
        console.log(
          "Successfully updated networking profile via PUT:",
          networkingProfile
        );
        res.json(networkingProfile);
      } catch (error) {
        console.error("Error updating networking profile via PUT:", error);
        console.error("Error stack:", error.stack);
        console.error("Error message:", error.message);
        res.status(500).json({
          message: "Failed to update networking profile",
          error: error.message
        });
      }
    }
  );
  app2.delete(
    "/api/suite/networking-profile",
    async (req, res) => {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      try {
        const userId = req.user.id;
        console.log("Deleting networking profile for user:", userId);
        await storage.deleteSuiteNetworkingProfile(userId);
        broadcastToAllUsers({
          type: "suite_profile_deleted",
          profileType: "networking",
          userId,
          timestamp: (/* @__PURE__ */ new Date()).toISOString()
        });
        console.log("Networking profile deleted successfully for user:", userId);
        res.json({
          success: true,
          message: "Networking profile deleted successfully"
        });
      } catch (error) {
        console.error("Error deleting networking profile:", error);
        res.status(500).json({
          message: "Failed to delete networking profile",
          error: error instanceof Error ? error.message : "Unknown error"
        });
      }
    }
  );
  app2.patch(
    "/api/suite/networking-profile",
    async (req, res) => {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      try {
        const userId = req.user.id;
        console.log("PATCH Networking profile request body:", req.body);
        console.log("User ID:", userId);
        const updateData = req.body;
        console.log("Networking profile PATCH data:", updateData);
        console.log(
          "visibilityPreferences in PATCH data:",
          updateData.visibilityPreferences
        );
        console.log(
          "Type of visibilityPreferences:",
          typeof updateData.visibilityPreferences
        );
        const existingProfile = await storage.getSuiteNetworkingProfile(userId);
        if (!existingProfile) {
          console.log(
            "No existing networking profile found - PATCH requires existing profile"
          );
          return res.status(404).json({
            message: "No networking profile found. Create a profile first before updating preferences."
          });
        }
        const networkingProfile = await storage.createOrUpdateSuiteNetworkingProfile(
          userId,
          updateData
        );
        broadcastNetworkingProfileUpdate(userId, networkingProfile);
        console.log(
          "Successfully updated networking profile via PATCH:",
          networkingProfile
        );
        res.json(networkingProfile);
      } catch (error) {
        console.error("Error updating networking profile via PATCH:", error);
        console.error("Error stack:", error.stack);
        console.error("Error message:", error.message);
        res.status(500).json({
          message: "Failed to update networking profile",
          error: error.message
        });
      }
    }
  );
  app2.patch(
    "/api/suite/networking-profile/activate",
    async (req, res) => {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      try {
        const userId = req.user.id;
        const { active } = req.body;
        if (typeof active !== "boolean") {
          return res.status(400).json({ message: "Active status must be a boolean" });
        }
        await storage.updateSuiteProfileSettings(userId, {
          networkingProfileActive: active
        });
        res.json({ success: true, networkingProfileActive: active });
      } catch (error) {
        console.error("Error updating networking profile activation:", error);
        res.status(500).json({ message: "Failed to update profile activation" });
      }
    }
  );
  app2.get(
    "/api/suite/field-visibility/:profileType",
    async (req, res) => {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      try {
        const userId = req.user.id;
        const profileType = req.params.profileType;
        if (!["job", "mentorship", "networking"].includes(profileType)) {
          return res.status(400).json({ message: "Invalid profile type" });
        }
        const visibilitySettings = await storage.getFieldVisibility(
          userId,
          profileType
        );
        const visibilityObject = visibilitySettings.reduce(
          (acc, setting) => {
            acc[setting.fieldName] = setting.isVisible;
            return acc;
          },
          {}
        );
        res.json(visibilityObject);
      } catch (error) {
        console.error("Error fetching field visibility:", error);
        res.status(500).json({ message: "Failed to fetch field visibility" });
      }
    }
  );
  app2.post(
    "/api/suite/field-visibility/:profileType",
    async (req, res) => {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      try {
        const userId = req.user.id;
        const profileType = req.params.profileType;
        const visibilityData = req.body;
        if (!["job", "mentorship", "networking"].includes(profileType)) {
          return res.status(400).json({ message: "Invalid profile type" });
        }
        if (!visibilityData || typeof visibilityData !== "object") {
          return res.status(400).json({ message: "Invalid visibility data" });
        }
        await storage.updateMultipleFieldVisibility(
          userId,
          profileType,
          visibilityData
        );
        res.json({ message: "Field visibility updated successfully" });
      } catch (error) {
        console.error("Error updating field visibility:", error);
        res.status(500).json({ message: "Failed to update field visibility" });
      }
    }
  );
  app2.put(
    "/api/suite/field-visibility/:profileType",
    async (req, res) => {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      try {
        const userId = req.user.id;
        const profileType = req.params.profileType;
        const visibilityData = req.body;
        if (!["job", "mentorship", "networking"].includes(profileType)) {
          return res.status(400).json({ message: "Invalid profile type" });
        }
        if (!visibilityData || typeof visibilityData !== "object") {
          return res.status(400).json({ message: "Invalid visibility data" });
        }
        await storage.updateMultipleFieldVisibility(
          userId,
          profileType,
          visibilityData
        );
        res.json({ message: "Field visibility updated successfully" });
      } catch (error) {
        console.error("Error updating field visibility:", error);
        res.status(500).json({ message: "Failed to update field visibility" });
      }
    }
  );
  app2.get("/api/suite/discovery/jobs", async (req, res) => {
    if (!req.isAuthenticated()) {
      return res.status(401).json({ message: "Unauthorized" });
    }
    try {
      const userId = req.user.id;
      const jobProfiles = await storage.getDiscoveryJobProfiles(
        userId,
        1e3,
        // High limit to get all available profiles
        0
      );
      console.log(`Loaded ${jobProfiles.length} job profiles for discovery`);
      res.json(jobProfiles);
    } catch (error) {
      console.error("Error fetching job discovery profiles:", error);
      res.status(500).json({ message: "Failed to fetch job profiles" });
    }
  });
  app2.post("/api/suite/jobs/apply", async (req, res) => {
    if (!req.isAuthenticated()) {
      return res.status(401).json({ message: "Unauthorized" });
    }
    try {
      const { profileId, action } = req.body;
      const userId = req.user.id;
      if (!profileId || !action) {
        return res.status(400).json({ message: "Missing required fields" });
      }
      if (!["like", "pass"].includes(action)) {
        return res.status(400).json({ message: "Invalid action" });
      }
      const jobProfile = await storage.getSuiteJobProfileById(profileId);
      if (!jobProfile) {
        return res.status(404).json({ message: "Job profile not found" });
      }
      const existingApplication = await storage.getSuiteJobApplication(
        userId,
        profileId
      );
      if (existingApplication) {
        return res.status(409).json({ message: "Already applied to this job" });
      }
      const applicationData = {
        userId,
        targetProfileId: profileId,
        targetUserId: jobProfile.userId,
        action,
        matched: false,
        applicationStatus: action === "like" ? "pending" : "rejected"
      };
      const application = await storage.createSuiteJobApplication(applicationData);
      await storage.addSwipeHistory({
        userId,
        targetUserId: jobProfile.userId,
        action: action === "like" ? "like" : "dislike",
        appMode: "SUITE_JOBS"
      });
      console.log(`\u{1F4DD} [SUITE-JOBS-HISTORY] Recorded swipe history for user ${userId} -> ${jobProfile.userId} (${action})`);
      let isMatch = false;
      if (action === "like") {
        const reciprocalApplication = await storage.getSuiteJobApplicationByUsers(
          jobProfile.userId,
          // job poster
          userId
          // current user (applicant)
        );
        if (reciprocalApplication && reciprocalApplication.action === "like") {
          await storage.updateSuiteJobApplication(application.id, {
            matched: true,
            applicationStatus: "matched"
          });
          await storage.updateSuiteJobApplication(reciprocalApplication.id, {
            matched: true,
            applicationStatus: "matched"
          });
          isMatch = true;
          const matchData = {
            userId1: Math.min(userId, jobProfile.userId),
            userId2: Math.max(userId, jobProfile.userId),
            matched: true,
            isDislike: false,
            metadata: JSON.stringify({ origin: "SUITE", suiteType: "jobs", context: "professional" })
          };
          await storage.createMatch(matchData);
          console.log(
            `\u{1F4BC} [SUITE-JOBS] Instant match created: ${userId} \u2194 ${jobProfile.userId}`
          );
          try {
            await storage.removeMatchedUsersFromSwipeHistory(userId, jobProfile.userId);
            console.log(`[JOBS-MATCH] Cleaned up swipe history for matched users: ${userId} \u2194 ${jobProfile.userId}`);
          } catch (historyError) {
            console.error("Error cleaning up jobs swipe history for matched users:", historyError);
          }
        }
      }
      const removalMessage = {
        type: "suite_remove_from_discover",
        suiteType: "jobs",
        // Backend sends plural "jobs"
        removeProfileId: profileId,
        removeUserId: jobProfile.userId,
        reason: `jobs_${action}_action`,
        timestamp: (/* @__PURE__ */ new Date()).toISOString()
      };
      const currentUserWs = connectedUsers3.get(userId);
      if (currentUserWs && currentUserWs.readyState === 1) {
        currentUserWs.send(JSON.stringify(removalMessage));
        console.log(`\u{1F5D1}\uFE0F [JOBS-REMOVAL] Sent card removal to user ${userId} for profile ${profileId}`);
      }
      const targetUserWs = connectedUsers3.get(jobProfile.userId);
      if (targetUserWs && targetUserWs.readyState === 1) {
        try {
          const currentUserJobProfile = await storage.getSuiteJobProfileByUserId(userId);
          if (currentUserJobProfile) {
            const targetRemovalMessage = {
              type: "suite_remove_from_discover",
              suiteType: "jobs",
              removeProfileId: currentUserJobProfile.id,
              // Use profile ID, not user ID
              removeUserId: userId,
              reason: `jobs_bidirectional_${action}`,
              timestamp: (/* @__PURE__ */ new Date()).toISOString()
            };
            targetUserWs.send(JSON.stringify(targetRemovalMessage));
            console.log(`\u{1F5D1}\uFE0F [JOBS-REMOVAL] Sent bidirectional card removal to user ${jobProfile.userId} for profile ${currentUserJobProfile.id} (user ${userId})`);
          }
        } catch (profileError) {
          console.error("Error getting current user's job profile for bidirectional removal:", profileError);
        }
      }
      if (action === "like") {
        if (targetUserWs && targetUserWs.readyState === 1) {
          const notificationData = {
            type: isMatch ? "job_match" : "job_application",
            application,
            fromUserId: userId,
            isMatch,
            timestamp: (/* @__PURE__ */ new Date()).toISOString()
          };
          targetUserWs.send(JSON.stringify(notificationData));
          console.log(`WebSocket notification sent to user ${jobProfile.userId} for job application`);
        }
      }
      res.json({
        success: true,
        action,
        profileId,
        isMatch,
        message: isMatch ? "It's a job match!" : action === "like" ? "Application submitted" : "Job passed"
      });
    } catch (error) {
      console.error("Error processing job application:", error);
      res.status(500).json({ message: "Failed to process job application" });
    }
  });
  app2.post("/api/suite/connections/jobs/:applicationId/respond", async (req, res) => {
    if (!req.isAuthenticated()) {
      return res.status(401).json({ message: "Unauthorized" });
    }
    try {
      const { action } = req.body;
      const applicationId = parseInt(req.params.applicationId);
      const currentUserId = req.user.id;
      if (!["accept", "decline"].includes(action)) {
        return res.status(400).json({ message: "Invalid action" });
      }
      const existingApplication = await storage.getSuiteJobApplicationById(applicationId);
      if (!existingApplication) {
        return res.status(404).json({ message: "Job application not found" });
      }
      if (existingApplication.targetUserId !== currentUserId) {
        return res.status(403).json({ message: "Not authorized to respond to this application" });
      }
      let isMatch = false;
      if (action === "accept") {
        await storage.updateSuiteJobApplication(existingApplication.id, {
          applicationStatus: "accepted",
          matched: true
        });
        isMatch = true;
        const existingMatch = await storage.getMatchBetweenUsers(currentUserId, existingApplication.userId);
        console.log(`\u{1F50D} [JOBS-ACCEPT-DEBUG] Existing match found: ${existingMatch ? `ID ${existingMatch.id}` : "none"}`);
        const currentUserNetworkingProfile = await storage.getSuiteNetworkingProfile(currentUserId);
        const targetUserNetworkingProfile = await storage.getSuiteNetworkingProfile(existingApplication.userId);
        console.log(`\u{1F50D} [JOBS-ACCEPT-DEBUG] Networking profiles - Current user ${currentUserId}: ${currentUserNetworkingProfile ? "exists" : "none"}, Target user ${existingApplication.userId}: ${targetUserNetworkingProfile ? "exists" : "none"}`);
        let existingNetworkingConnection = null;
        if (currentUserNetworkingProfile && targetUserNetworkingProfile) {
          const connection1 = await storage.getSuiteNetworkingConnection(currentUserId, targetUserNetworkingProfile.id);
          const connection2 = await storage.getSuiteNetworkingConnection(existingApplication.userId, currentUserNetworkingProfile.id);
          console.log(`\u{1F50D} [JOBS-ACCEPT-DEBUG] Connection1 (${currentUserId} -> ${targetUserNetworkingProfile.id}): ${connection1 ? `matched=${connection1.matched}, action=${connection1.action}` : "none"}`);
          console.log(`\u{1F50D} [JOBS-ACCEPT-DEBUG] Connection2 (${existingApplication.userId} -> ${currentUserNetworkingProfile.id}): ${connection2 ? `matched=${connection2.matched}, action=${connection2.action}` : "none"}`);
          existingNetworkingConnection = connection1?.matched || connection2?.matched ? connection1?.matched ? connection1 : connection2 : connection1?.action === "like" && connection2?.action === "like" ? connection1 : null;
        }
        console.log(`\u{1F50D} [JOBS-ACCEPT-DEBUG] Final networking connection selected: ${existingNetworkingConnection ? `matched=${existingNetworkingConnection.matched}` : "none"}`);
        let finalMatch;
        if (existingMatch) {
          try {
            let existingMetadata;
            if (existingMatch.metadata) {
              existingMetadata = typeof existingMatch.metadata === "string" ? JSON.parse(existingMatch.metadata) : existingMatch.metadata;
            }
            console.log(`\u{1F50D} [JOBS-ACCEPT-DEBUG] Existing match metadata:`, existingMetadata);
            if (existingMetadata) {
              if (!existingMetadata.additionalConnections) {
                existingMetadata.additionalConnections = [];
              }
              if (existingNetworkingConnection && existingNetworkingConnection.matched && !existingMetadata.additionalConnections.includes("networking")) {
                existingMetadata.additionalConnections.push("networking");
                console.log(`\u{1F517} [JOBS-ACCEPT] Adding networking to additionalConnections for existing match ${existingMatch.id}`);
              }
              if (existingMetadata.origin === "SUITE" && existingMetadata.suiteType !== "jobs" || existingMetadata.origin === "MEET") {
                if (!existingMetadata.additionalConnections.includes("jobs")) {
                  existingMetadata.additionalConnections.push("jobs");
                  console.log(`\u{1F517} [JOBS-ACCEPT] Adding jobs to additionalConnections for existing match ${existingMatch.id} between users ${currentUserId} and ${existingApplication.userId}`);
                }
                finalMatch = await storage.updateMatch(existingMatch.id, {
                  matched: true,
                  metadata: JSON.stringify(existingMetadata)
                });
              } else {
                if (existingNetworkingConnection && existingNetworkingConnection.matched && !existingMetadata.additionalConnections.includes("networking")) {
                  existingMetadata.additionalConnections.push("networking");
                  console.log(`\u{1F517} [JOBS-ACCEPT] Adding networking to additionalConnections for jobs match ${existingMatch.id}`);
                  finalMatch = await storage.updateMatch(existingMatch.id, {
                    matched: true,
                    metadata: JSON.stringify(existingMetadata)
                  });
                } else {
                  finalMatch = await storage.updateMatch(existingMatch.id, {
                    matched: true,
                    metadata: JSON.stringify(existingMetadata)
                  });
                  console.log(`\u{1F517} [JOBS-ACCEPT] Updated existing match ${existingMatch.id} with jobs metadata`);
                }
              }
            } else {
              const newMetadata = {
                origin: "SUITE",
                suiteType: "jobs",
                context: "professional",
                additionalConnections: []
              };
              if (existingNetworkingConnection && existingNetworkingConnection.matched) {
                newMetadata.additionalConnections.push("networking");
                console.log(`\u{1F517} [JOBS-ACCEPT] Adding networking to new metadata for match ${existingMatch.id}`);
              }
              finalMatch = await storage.updateMatch(existingMatch.id, {
                matched: true,
                metadata: JSON.stringify(newMetadata)
              });
              console.log(`\u{1F517} [JOBS-ACCEPT] Added jobs metadata with networking additional connection to existing match ${existingMatch.id}`);
            }
          } catch (parseError) {
            console.error("Failed to parse existing metadata:", parseError);
            finalMatch = await storage.updateMatch(existingMatch.id, {
              matched: true,
              metadata: JSON.stringify({ origin: "SUITE", suiteType: "jobs", context: "professional" })
            });
          }
        } else if (existingNetworkingConnection && (existingNetworkingConnection.matched || existingNetworkingConnection.action === "like")) {
          console.log(`\u{1F517} [JOBS-ACCEPT] Found existing networking connection between users ${currentUserId} and ${existingApplication.userId}, creating match with jobs as additional connection`);
          const matchData = {
            userId1: Math.min(currentUserId, existingApplication.userId),
            userId2: Math.max(currentUserId, existingApplication.userId),
            matched: true,
            isDislike: false,
            metadata: JSON.stringify({
              origin: "SUITE",
              suiteType: "networking",
              context: "professional",
              additionalConnections: ["jobs"]
            })
          };
          finalMatch = await storage.createMatch(matchData);
          console.log(`\u{1F517} [JOBS-ACCEPT] Created new match ${finalMatch.id} with networking as primary and jobs as additional connection`);
        } else {
          const matchData = {
            userId1: Math.min(currentUserId, existingApplication.userId),
            userId2: Math.max(currentUserId, existingApplication.userId),
            matched: true,
            isDislike: false,
            metadata: JSON.stringify({ origin: "SUITE", suiteType: "jobs", context: "professional" })
          };
          finalMatch = await storage.createMatch(matchData);
          console.log(`\u{1F517} [JOBS-ACCEPT] Created new jobs match between users ${currentUserId} and ${existingApplication.userId}`);
        }
        try {
          await storage.removeMatchedUsersFromSwipeHistory(currentUserId, existingApplication.userId);
          console.log(`[JOBS-ACCEPT-MATCH] Cleaned up swipe history for matched users: ${currentUserId} \u2194 ${existingApplication.userId}`);
        } catch (historyError) {
          console.error("Error cleaning up jobs accept swipe history for matched users:", historyError);
        }
        const acceptedByUser = await storage.getUser(currentUserId);
        const applicantUser = await storage.getUser(existingApplication.userId);
        const applicantWs = connectedUsers3.get(existingApplication.userId);
        if (applicantWs && applicantWs.readyState === 1) {
          const notificationData = {
            type: "job_match",
            application: {
              id: existingApplication.id,
              userId: existingApplication.userId,
              targetUserId: existingApplication.targetUserId
            },
            acceptedBy: currentUserId,
            isMatch: true,
            timestamp: (/* @__PURE__ */ new Date()).toISOString(),
            matchedUserName: acceptedByUser?.fullName,
            matchedUserPhoto: acceptedByUser?.photoUrl,
            matchedUserProfession: acceptedByUser?.profession,
            matchedUserLocation: acceptedByUser?.location
          };
          applicantWs.send(JSON.stringify(notificationData));
          console.log(`[SUITE-JOBS] Sent job match notification to applicant (User ${existingApplication.userId})`);
        }
        const accepterWs = connectedUsers3.get(currentUserId);
        if (accepterWs && accepterWs.readyState === 1) {
          const notificationData = {
            type: "job_match",
            application: {
              id: existingApplication.id,
              userId: existingApplication.userId,
              targetUserId: existingApplication.targetUserId
            },
            acceptedBy: currentUserId,
            isMatch: true,
            timestamp: (/* @__PURE__ */ new Date()).toISOString(),
            matchedUserName: applicantUser?.fullName,
            matchedUserPhoto: applicantUser?.photoUrl,
            matchedUserProfession: applicantUser?.profession,
            matchedUserLocation: applicantUser?.location
          };
          accepterWs.send(JSON.stringify(notificationData));
          console.log(`[SUITE-JOBS] Sent job match notification to accepter (User ${currentUserId})`);
        }
      } else {
        await storage.updateSuiteJobApplication(existingApplication.id, {
          applicationStatus: "rejected",
          matched: false
        });
      }
      res.json({
        success: true,
        isMatch,
        action,
        message: action === "accept" ? "Application accepted" : "Application declined"
      });
    } catch (error) {
      console.error("Error responding to job application:", error);
      res.status(500).json({ message: "Failed to respond to job application" });
    }
  });
  app2.get(
    "/api/suite/discovery/mentorship",
    async (req, res) => {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      try {
        const userId = req.user.id;
        const mentorshipProfiles = await storage.getDiscoveryMentorshipProfiles(
          userId,
          1e3,
          // High limit to get all available profiles
          0
        );
        console.log(`Loaded ${mentorshipProfiles.length} mentorship profiles for discovery`);
        res.json(mentorshipProfiles);
      } catch (error) {
        console.error("Error fetching mentorship discovery profiles:", error);
        res.status(500).json({ message: "Failed to fetch mentorship profiles" });
      }
    }
  );
  app2.get(
    "/api/suite/discovery/networking",
    async (req, res) => {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      try {
        const userId = req.user.id;
        const networkingProfiles = await storage.getDiscoveryNetworkingProfiles(
          userId,
          1e3,
          // High limit to get all available profiles
          0
        );
        console.log(
          `Loaded ${networkingProfiles.length} networking profiles for discovery`
        );
        res.json(networkingProfiles);
      } catch (error) {
        console.error("Error fetching networking discovery profiles:", error);
        res.status(500).json({ message: "Failed to fetch networking profiles" });
      }
    }
  );
  app2.post(
    "/api/suite/networking/swipe",
    async (req, res) => {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      try {
        const { profileId, action } = req.body;
        const currentUserId = req.user.id;
        if (!profileId || !action || !["like", "pass"].includes(action)) {
          return res.status(400).json({ message: "Invalid swipe data" });
        }
        const currentUserNetworkingProfile = await storage.getSuiteNetworkingProfile(currentUserId);
        if (!currentUserNetworkingProfile) {
          return res.status(403).json({
            message: "Profile required",
            action: "create_profile",
            profileType: "networking"
          });
        }
        const targetProfile = await storage.getSuiteNetworkingProfileById(profileId);
        if (!targetProfile) {
          return res.status(404).json({ message: "Profile not found" });
        }
        const connectionData = {
          userId: currentUserId,
          targetProfileId: profileId,
          targetUserId: targetProfile.userId,
          action,
          matched: false
        };
        const existingConnection = await storage.getSuiteNetworkingConnection(
          currentUserId,
          profileId
        );
        if (existingConnection) {
          return res.status(409).json({ message: "Already acted on this profile" });
        }
        const connection = await storage.createSuiteNetworkingConnection(connectionData);
        await storage.addSwipeHistory({
          userId: currentUserId,
          targetUserId: targetProfile.userId,
          action: action === "like" ? "like" : "dislike",
          appMode: "SUITE_NETWORKING"
        });
        console.log(`\u{1F4DD} [SUITE-NETWORKING-HISTORY] Recorded swipe history for user ${currentUserId} -> ${targetProfile.userId} (${action})`);
        const sourceNetworkingProfile = await storage.getSuiteNetworkingProfile(currentUserId);
        let isMatch = false;
        if (action === "like" && sourceNetworkingProfile) {
          const mutualConnection = await storage.getSuiteNetworkingConnection(
            targetProfile.userId,
            sourceNetworkingProfile.id
          );
          if (mutualConnection && mutualConnection.action === "like") {
            await storage.updateSuiteNetworkingConnection(connection.id, {
              matched: true
            });
            await storage.updateSuiteNetworkingConnection(mutualConnection.id, {
              matched: true
            });
            isMatch = true;
            const existingMatch = await storage.getMatchBetweenUsers(currentUserId, targetProfile.userId);
            let finalMatch;
            if (existingMatch) {
              let metadata;
              if (!existingMatch.metadata) {
                metadata = {
                  origin: "SUITE",
                  suiteType: "networking",
                  context: "professional"
                };
              } else {
                try {
                  metadata = typeof existingMatch.metadata === "string" ? JSON.parse(existingMatch.metadata) : existingMatch.metadata;
                  if (metadata.suiteType !== "networking") {
                    if (!metadata.additionalConnections) {
                      metadata.additionalConnections = [];
                    }
                    if (!metadata.additionalConnections.includes("networking")) {
                      metadata.additionalConnections.push("networking");
                      console.log(`\u{1F517} Adding networking to additionalConnections for existing match ${existingMatch.id}`);
                    }
                  }
                } catch (parseError) {
                  console.error("Failed to parse existing metadata:", parseError);
                  metadata = {
                    origin: "SUITE",
                    suiteType: "networking",
                    context: "professional"
                  };
                }
              }
              finalMatch = await storage.updateMatch(existingMatch.id, {
                matched: true,
                metadata: JSON.stringify(metadata)
              });
            } else {
              const matchData = {
                userId1: Math.min(currentUserId, targetProfile.userId),
                userId2: Math.max(currentUserId, targetProfile.userId),
                matched: true,
                isDislike: false,
                metadata: JSON.stringify({ origin: "SUITE", suiteType: "networking", context: "professional" })
              };
              finalMatch = await storage.createMatch(matchData);
            }
            console.log(
              `\u{1F49D} [SUITE-NETWORKING] Match created: ${currentUserId} \u2194 ${targetProfile.userId}`
            );
          }
        }
        console.log(
          `\u{1F680} [SUITE-NETWORKING] User ${currentUserId} ${action}d networking profile ${profileId}`
        );
        const sourceUserWs = connectedUsers3.get(currentUserId);
        const targetUserWs = connectedUsers3.get(targetProfile.userId);
        console.log(`[DEBUG-NETWORKING] WebSocket connections check:`);
        console.log(
          `  - Source user ${currentUserId}: ${sourceUserWs ? "CONNECTED" : "NOT FOUND"} (readyState: ${sourceUserWs?.readyState})`
        );
        console.log(
          `  - Target user ${targetProfile.userId}: ${targetUserWs ? "CONNECTED" : "NOT FOUND"} (readyState: ${targetUserWs?.readyState})`
        );
        console.log(`  - Total connected users: ${connectedUsers3.size}`);
        console.log(
          `  - Connected user IDs: [${Array.from(connectedUsers3.keys()).join(", ")}]`
        );
        let sourceRemovalSent = false;
        let targetRemovalSent = false;
        if (sourceUserWs && sourceUserWs.readyState === WebSocket3.OPEN) {
          sourceUserWs.send(
            JSON.stringify({
              type: "suite_remove_from_discover",
              suiteType: "networking",
              removeProfileId: profileId,
              removeUserId: targetProfile.userId,
              reason: `networking_${action}_action`,
              timestamp: (/* @__PURE__ */ new Date()).toISOString()
            })
          );
          console.log(
            `[REAL-TIME] Instantly removed networking profile ${profileId} from user ${currentUserId}'s discover deck`
          );
          sourceRemovalSent = true;
        } else {
          console.log(
            `[FALLBACK] Source user ${currentUserId} WebSocket not found, broadcasting removal to all users`
          );
          connectedUsers3.forEach((ws2, userId) => {
            if (userId === currentUserId && ws2.readyState === WebSocket3.OPEN) {
              ws2.send(
                JSON.stringify({
                  type: "suite_remove_from_discover",
                  suiteType: "networking",
                  removeProfileId: profileId,
                  removeUserId: targetProfile.userId,
                  reason: `networking_${action}_action_fallback`,
                  timestamp: (/* @__PURE__ */ new Date()).toISOString()
                })
              );
              sourceRemovalSent = true;
              console.log(
                `[FALLBACK] Successfully sent removal to source user ${currentUserId}`
              );
            }
          });
        }
        if (sourceNetworkingProfile && targetUserWs && targetUserWs.readyState === WebSocket3.OPEN) {
          targetUserWs.send(
            JSON.stringify({
              type: "suite_remove_from_discover",
              suiteType: "networking",
              removeProfileId: sourceNetworkingProfile.id,
              removeUserId: currentUserId,
              reason: `received_networking_${action}`,
              timestamp: (/* @__PURE__ */ new Date()).toISOString()
            })
          );
          console.log(
            `[REAL-TIME] Instantly removed networking profile ${sourceNetworkingProfile.id} from user ${targetProfile.userId}'s discover deck`
          );
          targetRemovalSent = true;
        } else if (sourceNetworkingProfile) {
          console.log(
            `[FALLBACK] Target user ${targetProfile.userId} WebSocket not found, broadcasting removal to all users`
          );
          connectedUsers3.forEach((ws2, userId) => {
            if (userId === targetProfile.userId && ws2.readyState === WebSocket3.OPEN) {
              ws2.send(
                JSON.stringify({
                  type: "suite_remove_from_discover",
                  suiteType: "networking",
                  removeProfileId: sourceNetworkingProfile.id,
                  removeUserId: currentUserId,
                  reason: `received_networking_${action}_fallback`,
                  timestamp: (/* @__PURE__ */ new Date()).toISOString()
                })
              );
              targetRemovalSent = true;
              console.log(
                `[FALLBACK] Successfully sent removal to target user ${targetProfile.userId}`
              );
            }
          });
        }
        console.log(
          `[REMOVAL-STATUS] Source: ${sourceRemovalSent ? "\u2705 SENT" : "\u274C FAILED"}, Target: ${targetRemovalSent ? "\u2705 SENT" : "\u274C FAILED"}`
        );
        if (action === "like") {
          try {
            if (targetUserWs && targetUserWs.readyState === WebSocket3.OPEN) {
              const sourceUser = await storage.getUser(currentUserId);
              const safeUserInfo = sourceUser ? (({ password, ...rest }) => rest)(sourceUser) : { id: currentUserId, fullName: "Unknown User" };
              const userNetworkingConnections = await storage.getUserNetworkingConnections(
                targetProfile.userId
              );
              const pendingConnections = userNetworkingConnections.filter(
                (conn) => !conn.matched && conn.action === "like"
              );
              const confirmedConnections = userNetworkingConnections.filter(
                (conn) => conn.matched
              );
              targetUserWs.send(
                JSON.stringify({
                  type: isMatch ? "networking_match" : "networking_like",
                  connection,
                  fromUserId: currentUserId,
                  fromUserInfo: safeUserInfo,
                  targetProfileId: profileId,
                  counts: {
                    pending: pendingConnections.length,
                    confirmed: confirmedConnections.length
                  },
                  isMatch,
                  timestamp: (/* @__PURE__ */ new Date()).toISOString()
                })
              );
              console.log(
                `\u{1F514} [SUITE-NETWORKING] Sent ${isMatch ? "match" : "like"} notification to user ${targetProfile.userId} from user ${currentUserId}`
              );
            }
          } catch (error) {
            console.error("Error sending networking notification:", error);
          }
        }
        console.log(`[DISCOVERY-REFRESH] Broadcasting discovery refresh to all connected users`);
        connectedUsers3.forEach((ws2, userId) => {
          if (ws2.readyState === WebSocket3.OPEN) {
            ws2.send(
              JSON.stringify({
                type: "discover:refresh",
                suiteType: "networking",
                reason: `networking_${action}_completed`,
                affectedUsers: [currentUserId, targetProfile.userId],
                timestamp: (/* @__PURE__ */ new Date()).toISOString()
              })
            );
          }
        });
        if (isMatch) {
          connectedUsers3.forEach((ws2, userId) => {
            if ((userId === currentUserId || userId === targetProfile.userId) && ws2.readyState === WebSocket3.OPEN) {
              ws2.send(
                JSON.stringify({
                  type: "connections:refresh",
                  suiteType: "networking",
                  reason: "networking_match_created",
                  timestamp: (/* @__PURE__ */ new Date()).toISOString()
                })
              );
            }
          });
          console.log(`[CONNECTIONS-REFRESH] Sent connections refresh for new match`);
        }
        res.json({
          success: true,
          action,
          profileId,
          isMatch,
          message: action === "like" ? isMatch ? "It's a match!" : "Connection request sent" : "Profile passed"
        });
      } catch (error) {
        console.error("Error processing networking swipe:", error);
        res.status(500).json({ message: "Failed to process swipe action" });
      }
    }
  );
  app2.post(
    "/api/suite/mentorship/swipe",
    async (req, res) => {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      try {
        const { profileId, action } = req.body;
        const currentUserId = req.user.id;
        if (!profileId || !action || !["like", "pass"].includes(action)) {
          return res.status(400).json({ message: "Invalid swipe data" });
        }
        const currentUserMentorshipProfile = await storage.getSuiteMentorshipProfile(currentUserId);
        if (!currentUserMentorshipProfile) {
          return res.status(403).json({
            message: "Profile required",
            action: "create_profile",
            profileType: "mentorship"
          });
        }
        const targetProfile = await storage.getSuiteMentorshipProfileById(profileId);
        if (!targetProfile) {
          return res.status(404).json({ message: "Profile not found" });
        }
        const connectionData = {
          userId: currentUserId,
          targetProfileId: profileId,
          targetUserId: targetProfile.userId,
          action,
          matched: false
        };
        const existingConnection = await storage.getSuiteMentorshipConnection(
          currentUserId,
          profileId
        );
        if (existingConnection) {
          return res.status(409).json({ message: "Already acted on this profile" });
        }
        const connection = await storage.createSuiteMentorshipConnection(connectionData);
        let isMatch = false;
        if (action === "like") {
          const currentUserProfile = await storage.getSuiteMentorshipProfile(currentUserId);
          if (!currentUserProfile) {
            console.log(`[SUITE-MENTORSHIP] Current user ${currentUserId} has no mentorship profile`);
            return res.status(404).json({ message: "Current user mentorship profile not found" });
          }
          const mutualConnection = await storage.getSuiteMentorshipConnection(
            targetProfile.userId,
            currentUserProfile.id
          );
          if (mutualConnection && mutualConnection.action === "like") {
            await storage.updateSuiteMentorshipConnection(connection.id, {
              matched: true
            });
            await storage.updateSuiteMentorshipConnection(mutualConnection.id, {
              matched: true
            });
            isMatch = true;
            const existingMatch = await storage.getMatchBetweenUsers(currentUserId, targetProfile.userId);
            let finalMatch;
            if (existingMatch) {
              let metadata;
              if (!existingMatch.metadata) {
                metadata = {
                  origin: "SUITE",
                  suiteType: "mentorship",
                  context: "professional"
                };
              } else {
                try {
                  metadata = typeof existingMatch.metadata === "string" ? JSON.parse(existingMatch.metadata) : existingMatch.metadata;
                  if (metadata.suiteType !== "mentorship") {
                    if (!metadata.additionalConnections) {
                      metadata.additionalConnections = [];
                    }
                    if (!metadata.additionalConnections.includes("mentorship")) {
                      metadata.additionalConnections.push("mentorship");
                      console.log(`\u{1F517} Adding mentorship to additionalConnections for existing match ${existingMatch.id}`);
                    }
                  }
                } catch (parseError) {
                  console.error("Failed to parse existing metadata:", parseError);
                  metadata = {
                    origin: "SUITE",
                    suiteType: "mentorship",
                    context: "professional"
                  };
                }
              }
              finalMatch = await storage.updateMatch(existingMatch.id, {
                matched: true,
                metadata: JSON.stringify(metadata)
              });
            } else {
              const matchData = {
                userId1: Math.min(currentUserId, targetProfile.userId),
                userId2: Math.max(currentUserId, targetProfile.userId),
                matched: true,
                isDislike: false,
                metadata: JSON.stringify({ origin: "SUITE", suiteType: "mentorship", context: "professional" })
              };
              finalMatch = await storage.createMatch(matchData);
            }
            console.log(
              `\u{1F49D} [SUITE-MENTORSHIP] Match created: ${currentUserId} \u2194 ${targetProfile.userId}`
            );
          }
        }
        try {
          const historyData = {
            userId: currentUserId,
            targetUserId: targetProfile.userId,
            action: action === "pass" ? "dislike" : action,
            // Normalize "pass" to "dislike" for history consistency
            appMode: "SUITE_MENTORSHIP"
            // Specific app mode for mentorship
          };
          await storage.addSwipeHistory(historyData);
          const userHistory = await storage.getUserSwipeHistory(currentUserId, "SUITE_MENTORSHIP", 20);
          if (userHistory.length > 9) {
            const entriesToDelete = userHistory.slice(9);
            for (const entry of entriesToDelete) {
              await storage.removeSwipeHistory(entry.id);
            }
          }
          console.log(
            `\u{1F4DD} [SUITE-MENTORSHIP-HISTORY] Recorded swipe history for user ${currentUserId} -> ${targetProfile.userId} (${historyData.action})`
          );
        } catch (historyError) {
          console.error("Error recording swipe history:", historyError);
        }
        console.log(
          `\u{1F680} [SUITE-MENTORSHIP] User ${currentUserId} ${action}d mentorship profile ${profileId}`
        );
        const sourceUserWs = connectedUsers3.get(currentUserId);
        const targetUserWs = connectedUsers3.get(targetProfile.userId);
        if (sourceUserWs && sourceUserWs.readyState === WebSocket3.OPEN) {
          sourceUserWs.send(
            JSON.stringify({
              type: "suite_remove_from_discover",
              suiteType: "mentorship",
              removeProfileId: profileId,
              removeUserId: targetProfile.userId,
              reason: `mentorship_${action}_action`,
              timestamp: (/* @__PURE__ */ new Date()).toISOString()
            })
          );
          console.log(
            `[REAL-TIME] Instantly removed mentorship profile ${profileId} from user ${currentUserId}'s discover deck`
          );
        }
        const sourceMentorshipProfile = await storage.getSuiteMentorshipProfile(currentUserId);
        if (sourceMentorshipProfile && targetUserWs && targetUserWs.readyState === WebSocket3.OPEN) {
          targetUserWs.send(
            JSON.stringify({
              type: "suite_remove_from_discover",
              suiteType: "mentorship",
              removeProfileId: sourceMentorshipProfile.id,
              removeUserId: currentUserId,
              reason: `received_mentorship_${action}`,
              timestamp: (/* @__PURE__ */ new Date()).toISOString()
            })
          );
          console.log(
            `[REAL-TIME] Instantly removed mentorship profile ${sourceMentorshipProfile.id} from user ${targetProfile.userId}'s discover deck`
          );
        }
        if (action === "like" && targetUserWs && targetUserWs.readyState === WebSocket3.OPEN) {
          try {
            const sourceUser = await storage.getUser(currentUserId);
            const safeUserInfo = sourceUser ? (({ password, ...rest }) => rest)(sourceUser) : { id: currentUserId, fullName: "Unknown User" };
            const userMentorshipConnections = await storage.getUserMentorshipConnections(targetProfile.userId);
            const pendingConnections = userMentorshipConnections.filter(
              (conn) => !conn.matched && conn.action === "like"
            );
            const confirmedConnections = userMentorshipConnections.filter(
              (conn) => conn.matched
            );
            targetUserWs.send(
              JSON.stringify({
                type: isMatch ? "mentorship_match" : "mentorship_like",
                connection,
                fromUserId: currentUserId,
                fromUserInfo: safeUserInfo,
                targetProfileId: profileId,
                counts: {
                  pending: pendingConnections.length,
                  confirmed: confirmedConnections.length
                },
                isMatch,
                timestamp: (/* @__PURE__ */ new Date()).toISOString()
              })
            );
            console.log(
              `\u{1F514} [SUITE-MENTORSHIP] Sent ${isMatch ? "match" : "like"} notification to user ${targetProfile.userId} from user ${currentUserId}`
            );
          } catch (error) {
            console.error("Error sending mentorship notification:", error);
          }
        }
        res.json({
          success: true,
          action,
          profileId,
          isMatch,
          message: action === "like" ? isMatch ? "It's a match!" : "Interest expressed" : "Profile passed"
        });
      } catch (error) {
        console.error("Error processing mentorship swipe:", error);
        res.status(500).json({ message: "Failed to process swipe action" });
      }
    }
  );
  app2.get(
    "/api/debug/messages/:matchId",
    async (req, res) => {
      try {
        const matchId = parseInt(req.params.matchId);
        const userId = parseInt(req.query.userId) || 6;
        console.log(
          `\u{1F50D} [DEBUG-ENDPOINT] Testing reply transformation for match ${matchId}, user ${userId}`
        );
        const messages2 = await storage.getMessagesByMatchId(matchId, userId);
        console.log(
          `\u{1F50D} [DEBUG-ENDPOINT] Retrieved ${messages2.length} messages`
        );
        messages2.forEach((msg) => {
          console.log(`  Message ${msg.id}: "${msg.content}"`);
          if (msg.replyToMessageId) {
            console.log(
              `    Has reply: Reply to message ${msg.replyToMessageId}`
            );
          } else {
            console.log(`    No reply context`);
          }
        });
        res.json(messages2);
      } catch (error) {
        console.error("Debug endpoint error:", error);
        res.status(500).json({ error: error.message });
      }
    }
  );
  app2.post("/api/swipe/history", async (req, res) => {
    if (!req.isAuthenticated()) {
      return res.status(401).json({ message: "Unauthorized" });
    }
    try {
      const { targetUserId, action, appMode } = req.body;
      if (!targetUserId || !action || !appMode) {
        return res.status(400).json({ message: "Missing required fields" });
      }
      const swipeData = {
        userId: req.user.id,
        targetUserId: parseInt(targetUserId),
        action,
        appMode
      };
      const history = await storage.addSwipeHistory(swipeData);
      res.json(history);
    } catch (error) {
      console.error("Error adding swipe history:", error);
      res.status(500).json({ message: "Failed to add swipe history" });
    }
  });
  app2.get("/api/swipe/history", async (req, res) => {
    if (!req.isAuthenticated()) {
      return res.status(401).json({ message: "Unauthorized" });
    }
    try {
      const { appMode, limit } = req.query;
      if (!appMode) {
        return res.status(400).json({ message: "appMode parameter required" });
      }
      const history = await storage.getUserSwipeHistory(
        req.user.id,
        appMode,
        limit ? parseInt(limit) : 10
      );
      res.json(history);
    } catch (error) {
      console.error("Error getting swipe history:", error);
      res.status(500).json({ message: "Failed to get swipe history" });
    }
  });
  app2.delete("/api/swipe/history/:id", async (req, res) => {
    if (!req.isAuthenticated()) {
      return res.status(401).json({ message: "Unauthorized" });
    }
    try {
      const historyId = parseInt(req.params.id);
      if (isNaN(historyId)) {
        return res.status(400).json({ message: "Invalid history ID" });
      }
      await storage.removeSwipeHistory(historyId);
      res.json({ success: true });
    } catch (error) {
      console.error("Error removing swipe history:", error);
      res.status(500).json({ message: "Failed to remove swipe history" });
    }
  });
  app2.delete("/api/swipe/history/clear", async (req, res) => {
    if (!req.isAuthenticated()) {
      return res.status(401).json({ message: "Unauthorized" });
    }
    try {
      const { appMode } = req.query;
      if (!appMode) {
        return res.status(400).json({ message: "appMode parameter required" });
      }
      await storage.clearUserSwipeHistory(req.user.id, appMode);
      res.json({ success: true });
    } catch (error) {
      console.error("Error clearing swipe history:", error);
      res.status(500).json({ message: "Failed to clear swipe history" });
    }
  });
  app2.get("/api/connections/preferences", async (req, res) => {
    if (!req.isAuthenticated()) {
      return res.status(401).json({ message: "Unauthorized" });
    }
    try {
      const preferences = await storage.getConnectionsPreferences(req.user.id);
      if (preferences) {
        const mappedPreferences = convertDbFieldsToFrontend(preferences);
        res.json(mappedPreferences);
      } else {
        res.json(preferences);
      }
    } catch (error) {
      console.error("Error getting connections preferences:", error);
      res.status(500).json({ message: "Failed to get preferences" });
    }
  });
  app2.post("/api/connections/preferences", async (req, res) => {
    if (!req.isAuthenticated()) {
      return res.status(401).json({ message: "Unauthorized" });
    }
    try {
      const preferences = await storage.saveConnectionsPreferences(req.user.id, req.body);
      const mappedPreferences = convertDbFieldsToFrontend(preferences);
      res.json(mappedPreferences);
    } catch (error) {
      console.error("Error saving connections preferences:", error);
      res.status(500).json({ message: "Failed to save preferences" });
    }
  });
  app2.post("/api/user/verification-status", async (req, res) => {
    if (!req.isAuthenticated()) {
      return res.status(401).json({ message: "Unauthorized" });
    }
    try {
      const { userId, isVerified } = req.body;
      if (typeof userId !== "number" || typeof isVerified !== "boolean") {
        return res.status(400).json({ message: "Invalid parameters. userId (number) and isVerified (boolean) are required." });
      }
      const updatedUser = await storage.updateUserProfile(userId, { isVerified });
      if (verificationStatusBroadcaster) {
        verificationStatusBroadcaster(userId, isVerified);
        console.log(
          `Verification status update broadcasted via WebSocket for user ${userId}: isVerified=${isVerified}`
        );
      }
      res.json({
        success: true,
        message: `User ${userId} verification status updated to ${isVerified}`,
        isVerified: updatedUser.isVerified
      });
    } catch (error) {
      console.error("Error updating verification status:", error);
      res.status(500).json({ message: "Failed to update verification status" });
    }
  });
  app2.patch("/api/user/verify-id", async (req, res) => {
    if (!req.isAuthenticated()) {
      return res.status(401).json({ message: "Unauthorized" });
    }
    try {
      const { idVerificationPhoto, liveVerificationPhoto } = req.body;
      if (!idVerificationPhoto || !liveVerificationPhoto) {
        return res.status(400).json({
          message: "Both ID verification photo and live verification photo are required"
        });
      }
      const updatedUser = await storage.updateUserProfile(req.user.id, {
        idVerificationPhoto,
        liveVerificationPhoto
      });
      console.log(`[ID-VERIFICATION] User ${req.user.id} submitted new verification photos`);
      res.json({
        success: true,
        message: "Verification photos submitted successfully",
        user: {
          id: updatedUser.id,
          idVerificationPhoto: updatedUser.idVerificationPhoto,
          liveVerificationPhoto: updatedUser.liveVerificationPhoto
        }
      });
    } catch (error) {
      console.error("Error updating verification photos:", error);
      res.status(500).json({ message: "Failed to update verification photos" });
    }
  });
  app2.post("/api/email/verify", async (req, res) => {
    try {
      const { email } = req.body;
      if (!email || typeof email !== "string") {
        return res.status(400).json({
          success: false,
          message: "Valid email address is required"
        });
      }
      console.log(`[EMAIL-VERIFICATION] Starting verification for: ${email}`);
      const { EmailVerificationService: EmailVerificationService2 } = await Promise.resolve().then(() => (init_email_verification(), email_verification_exports));
      const result = await EmailVerificationService2.verifyEmail(email.trim().toLowerCase());
      console.log(`[EMAIL-VERIFICATION] Result for ${email}:`, result);
      res.json({
        success: true,
        email: email.trim().toLowerCase(),
        isValid: result.isValid,
        reason: result.reason,
        confidence: result.confidence
      });
    } catch (error) {
      console.error("[EMAIL-VERIFICATION] API error:", error);
      res.status(500).json({
        success: false,
        message: "Email verification service temporarily unavailable",
        isValid: false,
        confidence: "low"
      });
    }
  });
  app2.post("/api/contact/send", async (req, res) => {
    try {
      const { name, email, phoneNumber, message } = req.body;
      if (!name || !email || !message) {
        return res.status(400).json({
          message: "All fields are required (name, email, message)"
        });
      }
      const { sendContactFormEmail: sendContactFormEmail2 } = await Promise.resolve().then(() => (init_sendgrid(), sendgrid_exports));
      const emailSent = await sendContactFormEmail2({
        name: name.trim(),
        email: email.trim(),
        phoneNumber: phoneNumber || "Not provided",
        message: message.trim()
      });
      if (emailSent) {
        console.log(`Contact form submission sent successfully from ${email}`);
        res.json({
          success: true,
          message: "Message sent successfully! We'll get back to you soon."
        });
      } else {
        console.error("Failed to send contact form email");
        res.status(500).json({
          success: false,
          message: "Failed to send message. Please try again later."
        });
      }
    } catch (error) {
      console.error("Contact form API error:", error);
      res.status(500).json({
        success: false,
        message: "Server error. Please try again later."
      });
    }
  });
  registerSuiteCompatibilityAPI(app2);
  app2.get("/api/test/sendgrid", requireAuth, async (req, res) => {
    try {
      const { testSendGridConfig: testSendGridConfig2 } = await Promise.resolve().then(() => (init_sendgrid(), sendgrid_exports));
      const result = await testSendGridConfig2();
      res.json(result);
    } catch (error) {
      console.error("SendGrid test error:", error);
      res.status(500).json({
        success: false,
        message: "SendGrid test failed"
      });
    }
  });
  app2.post("/api/contact/send", requireAuth, async (req, res) => {
    try {
      const { name, email, phoneNumber, message } = req.body;
      if (!name || !email || !message) {
        return res.status(400).json({
          success: false,
          message: "All fields (name, email, message) are required"
        });
      }
      const { sendContactFormEmail: sendContactFormEmail2 } = await Promise.resolve().then(() => (init_sendgrid(), sendgrid_exports));
      const success = await sendContactFormEmail2({ name, email, phoneNumber, message });
      if (success) {
        res.json({
          success: true,
          message: "Message sent successfully"
        });
      } else {
        res.status(500).json({
          success: false,
          message: "Failed to send message. Please try again later."
        });
      }
    } catch (error) {
      console.error("Contact form error:", error);
      res.status(500).json({
        success: false,
        message: "Failed to send message. Please try again later."
      });
    }
  });
  app2.post("/api/welcome/send", async (req, res) => {
    try {
      const { name, email } = req.body;
      if (!name || !email) {
        return res.status(400).json({
          success: false,
          message: "Name and email are required"
        });
      }
      console.log(`[WELCOME-EMAIL] Sending welcome email to ${email} for ${name}`);
      const { sendWelcomeEmail: sendWelcomeEmail2 } = await Promise.resolve().then(() => (init_sendgrid(), sendgrid_exports));
      const success = await sendWelcomeEmail2({
        name: name.trim(),
        email: email.trim()
      });
      if (success) {
        console.log(`[WELCOME-EMAIL] Successfully sent welcome email to ${email}`);
        res.json({
          success: true,
          message: "Welcome email sent successfully"
        });
      } else {
        console.error(`[WELCOME-EMAIL] Failed to send welcome email to ${email}`);
        res.status(500).json({
          success: false,
          message: "Failed to send welcome email"
        });
      }
    } catch (error) {
      console.error("[WELCOME-EMAIL] API error:", error);
      res.status(500).json({
        success: false,
        message: "Server error sending welcome email"
      });
    }
  });
  app2.get("/dispute", async (req, res) => {
    try {
      const token = req.query.token;
      if (!token) {
        return res.status(400).send(`
          <!DOCTYPE html>
          <html>
          <head>
            <title>Invalid Dispute Link</title>
            <style>body { font-family: Arial, sans-serif; text-align: center; padding: 50px; }</style>
          </head>
          <body>
            <h1>\u274C Invalid Dispute Link</h1>
            <p>This dispute link is invalid or malformed.</p>
            <p>If you received this link in a security email, please contact admin@btechnos.com</p>
          </body>
          </html>
        `);
      }
      const disputeInfo = getDisputeInfo(token);
      if (!disputeInfo) {
        return res.status(404).send(`
          <!DOCTYPE html>
          <html>
          <head>
            <title>Dispute Link Expired</title>
            <style>body { font-family: Arial, sans-serif; text-align: center; padding: 50px; }</style>
          </head>
          <body>
            <h1>\u23F0 Dispute Link Expired</h1>
            <p>This dispute link has expired or has already been used.</p>
            <p>Dispute links are valid for 7 days after the security change.</p>
            <p>If you still need assistance, please contact admin@btechnos.com directly.</p>
          </body>
          </html>
        `);
      }
      const success = await handleSecurityDispute(token, req);
      if (success) {
        return res.send(`
          <!DOCTYPE html>
          <html>
          <head>
            <title>Dispute Submitted Successfully</title>
            <style>
              body { 
                font-family: Arial, sans-serif; 
                text-align: center; 
                padding: 50px;
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                margin: 0;
              }
              .container {
                background: white;
                color: #333;
                border-radius: 16px;
                padding: 40px;
                max-width: 600px;
                margin: 0 auto;
                box-shadow: 0 20px 40px rgba(0,0,0,0.1);
              }
              .success-icon { font-size: 64px; margin-bottom: 20px; }
              h1 { color: #22c55e; margin-bottom: 20px; }
              .info-box {
                background: #f0f9ff;
                border: 2px solid #0ea5e9;
                border-radius: 12px;
                padding: 20px;
                margin: 20px 0;
                text-align: left;
              }
            </style>
          </head>
          <body>
            <div class="container">
              <div class="success-icon">\u{1F6A8}</div>
              <h1>Dispute Submitted Successfully</h1>
              <p><strong>Your security dispute has been received and processed.</strong></p>
              
              <div class="info-box">
                <h3>What happens next:</h3>
                <ul>
                  <li>Our security team has been immediately notified</li>
                  <li>We will contact you within 24 hours at <strong>${disputeInfo.email}</strong></li>
                  <li>We may temporarily secure your account during investigation</li>
                  <li>The unauthorized change will be reviewed and may be reversed</li>
                </ul>
              </div>
              
              <p><strong>Important:</strong> This dispute link has now been used and cannot be accessed again.</p>
              
              <p>If you have immediate concerns, contact us at:</p>
              <p><strong>admin@btechnos.com</strong></p>
              
              <hr style="margin: 30px 0;">
              <p style="font-size: 14px; color: #666;">
                CHARLEY Security System<br>
                Dispute processed at ${(/* @__PURE__ */ new Date()).toLocaleString()}
              </p>
            </div>
          </body>
          </html>
        `);
      } else {
        return res.status(500).send(`
          <!DOCTYPE html>
          <html>
          <head>
            <title>Dispute Processing Error</title>
            <style>body { font-family: Arial, sans-serif; text-align: center; padding: 50px; }</style>
          </head>
          <body>
            <h1>\u274C Error Processing Dispute</h1>
            <p>There was an error processing your security dispute.</p>
            <p>Please contact admin@btechnos.com directly with the following information:</p>
            <ul style="text-align: left; display: inline-block;">
              <li>Dispute Token: ${token}</li>
              <li>Your Email: ${disputeInfo.email}</li>
              <li>Change Type: ${disputeInfo.changeType}</li>
              <li>Timestamp: ${(/* @__PURE__ */ new Date()).toLocaleString()}</li>
            </ul>
          </body>
          </html>
        `);
      }
    } catch (error) {
      console.error("[SECURITY-DISPUTE] Error handling dispute route:", error);
      return res.status(500).send(`
        <!DOCTYPE html>
        <html>
        <head>
          <title>System Error</title>
          <style>body { font-family: Arial, sans-serif; text-align: center; padding: 50px; }</style>
        </head>
        <body>
          <h1>\u274C System Error</h1>
          <p>A system error occurred while processing your dispute.</p>
          <p>Please contact admin@btechnos.com immediately.</p>
        </body>
        </html>
      `);
    }
  });
  app2.get("/api/pricing", async (req, res) => {
    try {
      const region = req.query.region || "global";
      const pricing = await storage.getRegionalPricing(region);
      res.json(pricing);
    } catch (error) {
      console.error("Error fetching pricing:", error);
      res.status(500).json({ message: "Failed to fetch pricing" });
    }
  });
  app2.post("/api/promo/validate", async (req, res) => {
    try {
      const { code, region } = req.body;
      const userId = req.user?.id;
      if (!code || !region) {
        return res.status(400).json({
          valid: false,
          error: "Missing required fields"
        });
      }
      if (!userId) {
        return res.status(401).json({
          valid: false,
          error: "Authentication required"
        });
      }
      const validation = await storage.validatePromotionalCode(code, userId, region);
      res.json(validation);
    } catch (error) {
      console.error("Error validating promo code:", error);
      res.status(500).json({
        valid: false,
        error: "Server error validating promotional code"
      });
    }
  });
  app2.post("/api/subscription/create", requireAuth, async (req, res) => {
    try {
      if (!stripe2) {
        return res.status(503).json({
          success: false,
          error: "Payment processing is currently unavailable. Please contact support.",
          code: "STRIPE_NOT_CONFIGURED"
        });
      }
      console.log(`[STRIPE-ENVIRONMENT-FIX] Creating subscription in ${isLiveMode2 ? "LIVE" : "TEST"} mode for user ${req.user.id}`);
      const {
        planType,
        region,
        promoCode,
        paymentMethod = "card",
        billingName,
        billingEmail,
        billingPhone,
        billingAddress,
        billingCity,
        billingState,
        billingPostalCode,
        billingCountry,
        nickname
      } = req.body;
      const userId = req.user.id;
      if (!planType || !region) {
        return res.status(400).json({
          success: false,
          error: "Missing required fields"
        });
      }
      const pricingList = await storage.getRegionalPricing(region, planType);
      const pricing = pricingList[0];
      if (!pricing) {
        return res.status(400).json({
          success: false,
          error: "Invalid plan or region"
        });
      }
      const existingSubscription = await storage.getSubscriptionByUser(userId);
      if (existingSubscription && existingSubscription.status === "active") {
        return res.status(400).json({
          success: false,
          error: "User already has an active subscription"
        });
      }
      const user = await storage.getUser(userId);
      if (!user) {
        return res.status(404).json({ error: "User not found" });
      }
      let stripeCustomerId = user.stripeCustomerId;
      let needsNewCustomer = !stripeCustomerId;
      if (stripeCustomerId && stripe2) {
        try {
          await stripe2.customers.retrieve(stripeCustomerId);
          console.log(`[STRIPE] Using existing customer: ${stripeCustomerId}`);
        } catch (error) {
          if (error.code === "resource_missing") {
            console.log(`[STRIPE] Customer ${stripeCustomerId} not found in current mode, creating new customer`);
            needsNewCustomer = true;
          } else {
            throw error;
          }
        }
      }
      if (needsNewCustomer && stripe2) {
        const customer = await stripe2.customers.create({
          email: user.email,
          name: user.fullName,
          metadata: {
            userId: userId.toString(),
            region,
            mode: isLiveMode2 ? "live" : "test"
          }
        });
        stripeCustomerId = customer.id;
        console.log(`[STRIPE] Created new customer: ${stripeCustomerId} in ${isLiveMode2 ? "LIVE" : "TEST"} mode`);
        await storage.updateUser(userId, { stripeCustomerId });
      }
      console.log(`[STRIPE] Creating subscription for user ${userId}, plan: ${planType}, region: ${region}, amount: ${pricing.amount} ${pricing.currency}`);
      const supportedCurrencies = ["usd", "eur", "gbp", "cad", "aud", "jpy"];
      const requestedCurrency = pricing.currency.toLowerCase();
      const isUnsupportedCurrency = !supportedCurrencies.includes(requestedCurrency);
      let stripeCurrency = requestedCurrency;
      let stripeAmount = pricing.amount;
      if (isUnsupportedCurrency) {
        stripeCurrency = "usd";
        const conversionRates = {
          "ghs": 10.44,
          // 10.44 GHS = 1 USD (current rate)
          "ngn": 1600,
          // 1600 NGN = 1 USD (example for future)
          "kes": 130
          // 130 KES = 1 USD (example for future)
        };
        const conversionRate = conversionRates[requestedCurrency];
        if (conversionRate) {
          stripeAmount = Math.round(pricing.amount / conversionRate);
        } else {
          stripeAmount = pricing.amount;
        }
        console.log(`[STRIPE-CURRENCY-FALLBACK] Converting ${pricing.amount} ${pricing.currency} to ${stripeAmount} ${stripeCurrency.toUpperCase()} (rate: ${conversionRate || "default"})`);
      }
      let productId;
      if (stripe2) {
        try {
          const product = await stripe2.products.create({
            name: `CHARLEY Premium - ${planType.replace("_", " ").toUpperCase()}`,
            description: `Premium subscription for ${region} region`,
            metadata: {
              app: "charley",
              plan_type: planType,
              region,
              original_currency: pricing.currency,
              stripe_currency: stripeCurrency
            }
          });
          productId = product.id;
          console.log(`[STRIPE] Created product: ${productId}`);
        } catch (productError) {
          console.error(`[STRIPE] Error creating product:`, productError.message);
          throw new Error(`Failed to create product: ${productError.message}`);
        }
      }
      const subscriptionParams = {
        customer: stripeCustomerId,
        items: [
          {
            price_data: {
              currency: stripeCurrency,
              unit_amount: stripeAmount,
              recurring: {
                interval: planType.includes("yearly") ? "year" : "month",
                interval_count: planType.includes("quarterly") ? 3 : 1
              },
              product: productId
            }
          }
        ],
        payment_behavior: "default_incomplete",
        payment_settings: {
          payment_method_types: ["card"],
          save_default_payment_method: "on_subscription"
        },
        expand: ["latest_invoice.payment_intent"],
        metadata: {
          userId: userId.toString(),
          region,
          planType,
          paymentMethod,
          original_currency: pricing.currency,
          original_amount: pricing.amount.toString(),
          stripe_currency: stripeCurrency,
          stripe_amount: stripeAmount.toString(),
          // Billing Address Information
          billing_name: billingName || "",
          billing_email: billingEmail || "",
          billing_phone: billingPhone || "",
          billing_address: billingAddress || "",
          billing_city: billingCity || "",
          billing_state: billingState || "",
          billing_postal_code: billingPostalCode || "",
          billing_country: billingCountry || "",
          nickname: nickname || ""
        }
      };
      console.log(`[STRIPE] Subscription params:`, JSON.stringify(subscriptionParams, null, 2));
      if (isUnsupportedCurrency) {
        console.log(`[STRIPE-CURRENCY-CONVERSION] SUCCESSFUL FALLBACK:`);
        console.log(`[STRIPE-CURRENCY-CONVERSION] Original: ${pricing.amount} ${pricing.currency}`);
        console.log(`[STRIPE-CURRENCY-CONVERSION] Stripe Processing: ${stripeAmount} ${stripeCurrency.toUpperCase()}`);
        console.log(`[STRIPE-CURRENCY-CONVERSION] User sees: ${pricing.currency} pricing, Stripe charges: USD equivalent`);
      }
      if (promoCode && stripe2) {
        const validation = await storage.validatePromotionalCode(promoCode, userId, region);
        if (validation.valid && validation.discount) {
          const coupon = await stripe2.coupons.create({
            percent_off: validation.discount,
            duration: "once",
            metadata: {
              promoCode,
              userId: userId.toString()
            }
          });
          subscriptionParams.coupon = coupon.id;
        }
      }
      let stripeSubscription = null;
      try {
        if (stripe2) {
          console.log(`[STRIPE] Calling stripe.subscriptions.create with customer: ${stripeCustomerId}`);
          stripeSubscription = await stripe2.subscriptions.create(subscriptionParams);
          console.log(`[STRIPE] Successfully created subscription: ${stripeSubscription.id}`);
        }
      } catch (stripeError) {
        console.error(`[STRIPE] Error creating subscription:`, stripeError);
        console.error(`[STRIPE] Error type:`, stripeError.type);
        console.error(`[STRIPE] Error code:`, stripeError.code);
        console.error(`[STRIPE] Error message:`, stripeError.message);
        console.error(`[STRIPE] Error details:`, stripeError.detail);
        throw new Error(`Stripe subscription creation failed: ${stripeError.message}`);
      }
      if (!stripeSubscription) {
        return res.status(503).json({
          success: false,
          error: "Payment processing is currently unavailable. Please contact support.",
          code: "STRIPE_NOT_CONFIGURED"
        });
      }
      const subscription = await storage.createSubscription({
        userId,
        provider: "stripe",
        subscriptionId: stripeSubscription.id,
        planType,
        status: stripeSubscription.status,
        currentPeriodStart: new Date(stripeSubscription.current_period_start * 1e3),
        currentPeriodEnd: new Date(stripeSubscription.current_period_end * 1e3),
        cancelAtPeriodEnd: stripeSubscription.cancel_at_period_end,
        currency: pricing.currency,
        // Keep original currency for user display
        amount: pricing.amount,
        // Keep original amount for user display
        region,
        paymentMethod: paymentMethod || "card"
      });
      try {
        const subscriptionEvent = await storage.createSubscriptionEvent({
          subscriptionId: subscription.id,
          userId,
          eventType: "created",
          provider: "stripe",
          providerEventId: stripeSubscription.id,
          oldStatus: null,
          newStatus: stripeSubscription.status,
          metadata: JSON.stringify({
            subscriptionId: stripeSubscription.id,
            planType,
            amount: pricing.amount,
            currency: pricing.currency,
            region,
            stripe_currency: stripeCurrency,
            stripe_amount: stripeAmount,
            currency_converted: isUnsupportedCurrency,
            currentPeriodStart: stripeSubscription.current_period_start,
            currentPeriodEnd: stripeSubscription.current_period_end
          })
        });
        console.log(`[SUBSCRIPTION-CREATION] Created subscription event: ${subscriptionEvent.id}`);
      } catch (eventError) {
        console.error(`[SUBSCRIPTION-CREATION] Failed to create subscription event:`, eventError);
      }
      const clientSecret = stripeSubscription.latest_invoice?.payment_intent?.client_secret;
      const paymentIntentId = stripeSubscription.latest_invoice?.payment_intent?.id;
      console.log(`[STRIPE] Payment intent ID: ${paymentIntentId}`);
      console.log(`[STRIPE] Client secret: ${clientSecret}`);
      console.log(`[STRIPE] Latest invoice:`, JSON.stringify(stripeSubscription.latest_invoice, null, 2));
      if (!clientSecret) {
        console.error("[STRIPE] No client secret found in payment intent!");
        console.error("[STRIPE] Subscription object:", JSON.stringify(stripeSubscription, null, 2));
        throw new Error("Failed to get payment intent client secret");
      }
      res.json({
        success: true,
        subscription: {
          id: subscription.id,
          stripeSubscriptionId: stripeSubscription.id,
          planType: subscription.planType,
          status: subscription.status,
          currentPeriodEnd: subscription.currentPeriodEnd
        },
        clientSecret,
        paymentMethod
      });
    } catch (error) {
      console.error("Error creating subscription:", error);
      res.status(500).json({
        success: false,
        error: "Failed to create subscription"
      });
    }
  });
  app2.post("/api/subscription/payment-success", requireAuth, async (req, res) => {
    try {
      const { paymentIntentId } = req.body;
      const userId = req.user.id;
      console.log(`[PAYMENT-SUCCESS] Request received for user ${userId}`);
      console.log(`[PAYMENT-SUCCESS] Request body:`, JSON.stringify(req.body, null, 2));
      console.log(`[PAYMENT-SUCCESS] Payment intent ID:`, paymentIntentId);
      if (!stripe2) {
        console.log(`[PAYMENT-SUCCESS] Stripe not configured`);
        return res.status(503).json({
          success: false,
          error: "Payment processing is currently unavailable. Please contact support.",
          code: "STRIPE_NOT_CONFIGURED"
        });
      }
      if (!paymentIntentId) {
        console.log(`[PAYMENT-SUCCESS] Missing payment intent ID in request`);
        return res.status(400).json({
          success: false,
          error: "Missing payment intent ID"
        });
      }
      console.log(`[STRIPE] Verifying payment success for user ${userId}, payment intent: ${paymentIntentId}`);
      let paymentIntent;
      let retryCount = 0;
      const maxRetries = 3;
      while (retryCount < maxRetries) {
        try {
          paymentIntent = await stripe2.paymentIntents.retrieve(paymentIntentId);
          break;
        } catch (retrieveError) {
          retryCount++;
          console.log(`[STRIPE] Attempt ${retryCount}/${maxRetries} failed to retrieve payment intent:`, retrieveError.message);
          if (retryCount >= maxRetries) {
            throw retrieveError;
          }
          await new Promise((resolve) => setTimeout(resolve, 1e3));
        }
      }
      if (!paymentIntent) {
        throw new Error("Failed to retrieve payment intent after multiple attempts");
      }
      console.log(`[PAYMENT-SUCCESS] Payment intent status: ${paymentIntent.status}`);
      console.log(`[PAYMENT-SUCCESS] Payment intent details:`, {
        id: paymentIntent.id,
        status: paymentIntent.status,
        amount: paymentIntent.amount,
        currency: paymentIntent.currency
      });
      if (paymentIntent.status === "succeeded") {
        let currentSubscriptionId = null;
        let subscriptionExpiresAt = null;
        if (paymentIntent.invoice) {
          try {
            const invoice = await stripe2.invoices.retrieve(paymentIntent.invoice);
            if (invoice.subscription) {
              currentSubscriptionId = invoice.subscription;
              console.log(`[PAYMENT-SUCCESS] Found subscription ID from invoice: ${currentSubscriptionId}`);
            }
          } catch (invoiceError) {
            console.warn(`[PAYMENT-SUCCESS] Could not retrieve invoice:`, invoiceError);
          }
        }
        if (currentSubscriptionId && stripe2) {
          try {
            const stripeSubscription = await stripe2.subscriptions.retrieve(currentSubscriptionId);
            subscriptionExpiresAt = new Date(stripeSubscription.current_period_end * 1e3);
            console.log(`[PAYMENT-SUCCESS] Retrieved subscription expiry from Stripe: ${subscriptionExpiresAt}`);
            console.log(`[PAYMENT-SUCCESS] Stripe subscription status: ${stripeSubscription.status}`);
          } catch (stripeError) {
            console.warn(`[PAYMENT-SUCCESS] Could not fetch subscription from Stripe:`, stripeError);
          }
        }
        const subscription = await storage.getSubscriptionByUser(userId);
        if (subscription || currentSubscriptionId) {
          try {
            if (paymentIntent.payment_method && typeof paymentIntent.payment_method === "string") {
              const stripePaymentMethod = await stripe2.paymentMethods.retrieve(paymentIntent.payment_method);
              const existingPaymentMethods = await storage.getPaymentMethodsByUser(userId);
              const paymentMethodExists = existingPaymentMethods.some((pm) => pm.externalId === paymentIntent.payment_method);
              if (!paymentMethodExists) {
                let billingInfo = {};
                if (currentSubscriptionId) {
                  try {
                    const stripeSubscription = await stripe2.subscriptions.retrieve(currentSubscriptionId);
                    const metadata = stripeSubscription.metadata || {};
                    billingInfo = {
                      billingName: metadata.billing_name || null,
                      billingEmail: metadata.billing_email || null,
                      billingPhone: metadata.billing_phone || null,
                      billingAddress: metadata.billing_address || null,
                      billingCity: metadata.billing_city || null,
                      billingState: metadata.billing_state || null,
                      billingPostalCode: metadata.billing_postal_code || null,
                      billingCountry: metadata.billing_country || null,
                      nickname: metadata.nickname || null
                    };
                  } catch (error) {
                    console.warn(`[PAYMENT-SUCCESS] Could not retrieve subscription metadata for billing info:`, error);
                  }
                }
                const paymentMethodRecord = await storage.createPaymentMethod({
                  userId,
                  provider: "stripe",
                  externalId: paymentIntent.payment_method,
                  type: "card",
                  isDefault: existingPaymentMethods.length === 0,
                  // First payment method becomes default
                  metadata: JSON.stringify({
                    last4: stripePaymentMethod.card?.last4,
                    brand: stripePaymentMethod.card?.brand,
                    expMonth: stripePaymentMethod.card?.exp_month,
                    expYear: stripePaymentMethod.card?.exp_year,
                    fingerprint: stripePaymentMethod.card?.fingerprint,
                    country: stripePaymentMethod.card?.country
                  }),
                  // Include billing address information from subscription metadata
                  ...billingInfo
                });
                console.log(`[PAYMENT-SUCCESS] Created payment method record: ${paymentMethodRecord.id} with billing info`);
              }
            }
          } catch (paymentMethodError) {
            console.error(`[PAYMENT-SUCCESS] Failed to create payment method:`, paymentMethodError);
          }
          try {
            const paymentHistoryRecord = await storage.createPaymentHistory({
              subscriptionId: subscription.id,
              userId,
              provider: "stripe",
              providerTransactionId: paymentIntent.id,
              amount: paymentIntent.amount,
              currency: paymentIntent.currency.toUpperCase(),
              status: "succeeded",
              paymentMethod: "card",
              metadata: JSON.stringify({
                paymentIntentId: paymentIntent.id,
                customerEmail: paymentIntent.metadata?.customer_email,
                planType: subscription.planType,
                region: subscription.region,
                stripePaymentMethodId: paymentIntent.payment_method
              })
            });
            console.log(`[PAYMENT-SUCCESS] Created payment history record: ${paymentHistoryRecord.id}`);
          } catch (paymentHistoryError) {
            console.error(`[PAYMENT-SUCCESS] Failed to create payment history:`, paymentHistoryError);
          }
          try {
            const subscriptionEvent = await storage.createSubscriptionEvent({
              subscriptionId: subscription.id,
              userId,
              eventType: "payment_succeeded",
              provider: "stripe",
              providerEventId: paymentIntent.id,
              oldStatus: subscription.status,
              newStatus: "active",
              metadata: JSON.stringify({
                paymentIntentId: paymentIntent.id,
                amount: paymentIntent.amount,
                currency: paymentIntent.currency,
                timestamp: (/* @__PURE__ */ new Date()).toISOString()
              })
            });
            console.log(`[PAYMENT-SUCCESS] Created subscription event: ${subscriptionEvent.id}`);
          } catch (eventError) {
            console.error(`[PAYMENT-SUCCESS] Failed to create subscription event:`, eventError);
          }
          await storage.updateUserProfile(userId, {
            premiumAccess: true,
            stripeSubscriptionId: currentSubscriptionId || (subscription ? subscription.subscriptionId : null),
            subscriptionStatus: "active",
            subscriptionExpiresAt,
            subscriptionCanceledAt: null
            // Clear any previous cancellation
          });
          console.log(`[PAYMENT-SUCCESS] Updated user ${userId} with premium access and subscription data`);
          try {
            const user = await storage.getUser(userId);
            if (user && user.email) {
              const { sendPremiumSubscriptionEmail: sendPremiumSubscriptionEmail2 } = await Promise.resolve().then(() => (init_sendgrid(), sendgrid_exports));
              const emailSuccess = await sendPremiumSubscriptionEmail2({
                name: user.fullName || user.username || "CHARLEY User",
                email: user.email,
                planType: subscription.planType,
                subscriptionId: subscription.subscriptionId,
                subscriptionExpiresAt: subscriptionExpiresAt || void 0
              });
              if (emailSuccess) {
                console.log(`[PAYMENT-SUCCESS] Premium welcome email sent to ${user.email}`);
              } else {
                console.warn(`[PAYMENT-SUCCESS] Failed to send premium welcome email to ${user.email}`);
              }
            } else {
              console.warn(`[PAYMENT-SUCCESS] Cannot send premium email - user not found or no email`);
            }
          } catch (emailError) {
            console.error(`[PAYMENT-SUCCESS] Error sending premium welcome email:`, emailError);
          }
          if (subscription.status === "incomplete") {
            await storage.updateSubscription(subscription.id, { status: "active" });
            console.log(`[PAYMENT-SUCCESS] Updated subscription ${subscription.id} status to active`);
          }
        } else {
          await storage.updateUserProfile(userId, { premiumAccess: true });
          console.log(`[PAYMENT-SUCCESS] Updated user ${userId} premium access to true (no subscription record)`);
          try {
            const user = await storage.getUser(userId);
            if (user && user.email) {
              const { sendPremiumSubscriptionEmail: sendPremiumSubscriptionEmail2 } = await Promise.resolve().then(() => (init_sendgrid(), sendgrid_exports));
              const emailSuccess = await sendPremiumSubscriptionEmail2({
                name: user.fullName || user.username || "CHARLEY User",
                email: user.email,
                planType: "premium",
                // Generic plan type for fallback
                subscriptionId: paymentIntentId,
                // Use payment intent as subscription reference
                subscriptionExpiresAt: void 0
                // No expiration for fallback case
              });
              if (emailSuccess) {
                console.log(`[PAYMENT-SUCCESS] Premium welcome email sent to ${user.email} (fallback case)`);
              } else {
                console.warn(`[PAYMENT-SUCCESS] Failed to send premium welcome email to ${user.email} (fallback case)`);
              }
            } else {
              console.warn(`[PAYMENT-SUCCESS] Cannot send premium email - user not found or no email (fallback case)`);
            }
          } catch (emailError) {
            console.error(`[PAYMENT-SUCCESS] Error sending premium welcome email (fallback case):`, emailError);
          }
        }
        res.json({
          success: true,
          paymentIntent
        });
      } else {
        console.log(`[PAYMENT-SUCCESS] Payment intent not in succeeded status: ${paymentIntent.status}`);
        res.status(400).json({
          success: false,
          error: `Payment verification failed: status is ${paymentIntent.status}`,
          details: {
            paymentIntentId: paymentIntent.id,
            status: paymentIntent.status,
            amount: paymentIntent.amount,
            currency: paymentIntent.currency
          }
        });
      }
    } catch (error) {
      console.error("[STRIPE] Error verifying payment success:", error);
      res.status(500).json({
        success: false,
        error: error.message || "Payment verification failed"
      });
    }
  });
  app2.post("/api/subscription/mobile-money", requireAuth, async (req, res) => {
    try {
      const { planType, region, phoneNumber, provider } = req.body;
      const userId = req.user.id;
      if (region !== "ghana") {
        return res.status(400).json({
          success: false,
          error: "Mobile money is only available for Ghana region"
        });
      }
      if (!planType || !phoneNumber || !provider) {
        return res.status(400).json({
          success: false,
          error: "Missing required fields for mobile money payment"
        });
      }
      const pricingList = await storage.getRegionalPricing(region, planType);
      const pricing = pricingList[0];
      if (!pricing) {
        return res.status(400).json({
          success: false,
          error: "Invalid plan or region"
        });
      }
      const user = await storage.getUser(userId);
      if (!user) {
        return res.status(404).json({ error: "User not found" });
      }
      const subscription = await storage.createSubscription({
        userId,
        provider: "mobile_money",
        subscriptionId: `mm_${Date.now()}_${userId}`,
        planType,
        status: "pending",
        currentPeriodStart: /* @__PURE__ */ new Date(),
        currentPeriodEnd: new Date(Date.now() + 30 * 24 * 60 * 60 * 1e3),
        cancelAtPeriodEnd: false,
        currency: pricing.currency,
        amount: pricing.amount,
        region,
        paymentMethod: "mobile_money"
      });
      res.json({
        success: true,
        subscription: {
          id: subscription.id,
          planType: subscription.planType,
          status: subscription.status,
          currentPeriodEnd: subscription.currentPeriodEnd
        },
        paymentInstructions: {
          message: `Please dial *170# and follow prompts to pay GHS ${(pricing.amount / 100).toFixed(2)} to complete your CHARLEY Premium subscription.`,
          amount: pricing.amount / 100,
          currency: pricing.currency,
          provider,
          reference: subscription.subscriptionId
        }
      });
    } catch (error) {
      console.error("Error initiating mobile money payment:", error);
      res.status(500).json({
        success: false,
        error: "Failed to initiate mobile money payment"
      });
    }
  });
  app2.get("/api/subscription/status", requireAuth, async (req, res) => {
    try {
      const userId = req.user.id;
      const subscription = await storage.getSubscriptionByUser(userId);
      if (!subscription) {
        return res.json({
          hasSubscription: false,
          subscription: null
        });
      }
      res.json({
        hasSubscription: true,
        subscription: {
          id: subscription.id,
          planType: subscription.planType,
          status: subscription.status,
          provider: subscription.provider,
          paymentMethod: subscription.paymentMethod,
          currency: subscription.currency,
          amount: subscription.amount,
          region: subscription.region,
          currentPeriodStart: subscription.currentPeriodStart,
          currentPeriodEnd: subscription.currentPeriodEnd,
          cancelAtPeriodEnd: subscription.cancelAtPeriodEnd,
          cancelledAt: subscription.cancelledAt
        }
      });
    } catch (error) {
      console.error("Error fetching subscription status:", error);
      res.status(500).json({
        hasSubscription: false,
        error: "Failed to fetch subscription status"
      });
    }
  });
  app2.post("/api/payment/confirm", requireAuth, async (req, res) => {
    await confirmPayment(req, res, storage);
  });
  app2.post("/api/subscription/cancel", requireAuth, async (req, res) => {
    try {
      const userId = req.user.id;
      const subscription = await storage.getSubscriptionByUser(userId);
      if (!subscription) {
        return res.status(404).json({
          success: false,
          error: "No active subscription found"
        });
      }
      if (subscription.provider === "stripe" && stripe2) {
        await stripe2.subscriptions.update(subscription.subscriptionId, {
          cancel_at_period_end: true
        });
      }
      const updatedSubscription = await storage.updateSubscription(subscription.id, {
        cancelAtPeriodEnd: true,
        cancelledAt: /* @__PURE__ */ new Date()
      });
      res.json({
        success: true,
        subscription: {
          id: updatedSubscription.id,
          status: updatedSubscription.status,
          cancelAtPeriodEnd: updatedSubscription.cancelAtPeriodEnd,
          cancelledAt: updatedSubscription.cancelledAt
        }
      });
    } catch (error) {
      console.error("Error cancelling subscription:", error);
      res.status(500).json({
        success: false,
        error: "Failed to cancel subscription"
      });
    }
  });
  app2.get("/api/subscription/status", requireAuth, async (req, res) => {
    try {
      const userId = req.user.id;
      const subscription = await storage.getSubscriptionByUser(userId);
      if (!subscription) {
        return res.json({
          hasActiveSubscription: false,
          planType: null,
          currentPeriodEnd: null,
          status: "inactive"
        });
      }
      res.json({
        hasActiveSubscription: subscription.status === "active",
        planType: subscription.planType,
        currentPeriodEnd: subscription.currentPeriodEnd,
        status: subscription.status,
        cancelAtPeriodEnd: subscription.cancelAtPeriodEnd
      });
    } catch (error) {
      console.error("Error getting subscription status:", error);
      res.status(500).json({ message: "Failed to get subscription status" });
    }
  });
  app2.post("/api/subscription/cancel", requireAuth, async (req, res) => {
    try {
      const userId = req.user.id;
      const subscription = await storage.getSubscriptionByUser(userId);
      if (!subscription) {
        return res.status(404).json({ message: "No active subscription found" });
      }
      if (stripe2) {
        await stripe2.subscriptions.update(subscription.subscriptionId, {
          cancel_at_period_end: true
        });
      }
      await storage.updateSubscription(subscription.id, {
        cancelAtPeriodEnd: true,
        cancelledAt: /* @__PURE__ */ new Date()
      });
      res.json({
        success: true,
        message: "Subscription will be cancelled at the end of the current period"
      });
    } catch (error) {
      console.error("Error cancelling subscription:", error);
      res.status(500).json({ message: "Failed to cancel subscription" });
    }
  });
  app2.post("/api/payment/methods", requireAuth, async (req, res) => {
    try {
      const userId = req.user.id;
      const {
        paymentMethodId,
        isDefault = false,
        billingName,
        billingEmail,
        billingPhone,
        billingAddress,
        billingCity,
        billingState,
        billingPostalCode,
        billingCountry,
        nickname
      } = req.body;
      if (!stripe2) {
        return res.status(503).json({
          error: "Payment processing is currently unavailable"
        });
      }
      if (!paymentMethodId) {
        return res.status(400).json({
          error: "Payment method ID is required"
        });
      }
      const stripePaymentMethod = await stripe2.paymentMethods.retrieve(paymentMethodId);
      const existingPaymentMethods = await storage.getPaymentMethodsByUser(userId);
      const paymentMethodExists = existingPaymentMethods.some((pm) => pm.externalId === paymentMethodId);
      if (paymentMethodExists) {
        return res.status(409).json({
          error: "Payment method already saved"
        });
      }
      if (isDefault) {
        for (const pm of existingPaymentMethods) {
          if (pm.isDefault) {
            await storage.updatePaymentMethod(pm.id, { isDefault: false });
          }
        }
      }
      const paymentMethodRecord = await storage.createPaymentMethod({
        userId,
        provider: "stripe",
        externalId: paymentMethodId,
        type: stripePaymentMethod.type,
        isDefault: isDefault || existingPaymentMethods.length === 0,
        // First becomes default
        metadata: JSON.stringify({
          last4: stripePaymentMethod.card?.last4,
          brand: stripePaymentMethod.card?.brand,
          expMonth: stripePaymentMethod.card?.exp_month,
          expYear: stripePaymentMethod.card?.exp_year,
          fingerprint: stripePaymentMethod.card?.fingerprint,
          country: stripePaymentMethod.card?.country,
          funding: stripePaymentMethod.card?.funding
        }),
        // Billing Address Information
        billingName: billingName || null,
        billingEmail: billingEmail || null,
        billingPhone: billingPhone || null,
        billingAddress: billingAddress || null,
        billingCity: billingCity || null,
        billingState: billingState || null,
        billingPostalCode: billingPostalCode || null,
        billingCountry: billingCountry || null,
        nickname: nickname || null
      });
      console.log(`[PAYMENT-METHOD] Saved payment method ${paymentMethodRecord.id} for user ${userId} with billing address`);
      res.json({
        success: true,
        paymentMethod: paymentMethodRecord
      });
    } catch (error) {
      console.error("[PAYMENT-METHOD] Error saving payment method:", error);
      res.status(500).json({
        error: "Failed to save payment method"
      });
    }
  });
  app2.post(
    "/api/suite/job/swipe",
    async (req, res) => {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      try {
        const { profileId, action } = req.body;
        const currentUserId = req.user.id;
        if (!profileId || !action || !["like", "pass"].includes(action)) {
          return res.status(400).json({ message: "Invalid swipe data" });
        }
        const currentUserJobProfile = await storage.getSuiteJobProfile(currentUserId);
        if (!currentUserJobProfile) {
          return res.status(403).json({
            message: "Profile required",
            action: "create_profile",
            profileType: "jobs"
          });
        }
        const targetProfile = await storage.getSuiteJobProfileById(profileId);
        if (!targetProfile) {
          return res.status(404).json({ message: "Profile not found" });
        }
        const applicationData = {
          userId: currentUserId,
          targetProfileId: profileId,
          targetUserId: targetProfile.userId,
          action,
          applicationStatus: action === "like" ? "pending" : "rejected",
          matched: false
        };
        const existingApplication = await storage.getSuiteJobApplicationByUsers(
          currentUserId,
          targetProfile.userId
        );
        if (existingApplication) {
          return res.status(409).json({ message: "Already acted on this profile" });
        }
        const application = await storage.createSuiteJobApplication(applicationData);
        await storage.addSwipeHistory({
          userId: currentUserId,
          targetUserId: targetProfile.userId,
          action: action === "like" ? "like" : "dislike",
          appMode: "SUITE_JOBS"
        });
        console.log(`\u{1F4DD} [SUITE-JOBS-HISTORY] Recorded swipe history for user ${currentUserId} -> ${targetProfile.userId} (${action})`);
        let isMatch = false;
        if (action === "like") {
          const currentUserJobProfile2 = await storage.getSuiteJobProfile(currentUserId);
          if (currentUserJobProfile2) {
            const mutualApplication = await storage.getSuiteJobApplicationByUsers(
              targetProfile.userId,
              currentUserId
            );
            if (mutualApplication && mutualApplication.action === "like") {
              await storage.updateSuiteJobApplication(application.id, {
                matched: true,
                applicationStatus: "accepted"
              });
              await storage.updateSuiteJobApplication(mutualApplication.id, {
                matched: true,
                applicationStatus: "accepted"
              });
              const existingMatch = await storage.getMatchBetweenUsers(currentUserId, targetProfile.userId);
              let finalMatch;
              if (existingMatch) {
                let metadata;
                if (!existingMatch.metadata) {
                  metadata = {
                    origin: "SUITE",
                    suiteType: "jobs",
                    context: "professional"
                  };
                } else {
                  try {
                    metadata = typeof existingMatch.metadata === "string" ? JSON.parse(existingMatch.metadata) : existingMatch.metadata;
                    if (metadata.suiteType !== "jobs") {
                      if (!metadata.additionalConnections) {
                        metadata.additionalConnections = [];
                      }
                      if (!metadata.additionalConnections.includes("jobs")) {
                        metadata.additionalConnections.push("jobs");
                        console.log(`\u{1F517} Adding jobs to additionalConnections for existing match ${existingMatch.id}`);
                      }
                    }
                  } catch (parseError) {
                    console.error("Failed to parse existing metadata:", parseError);
                    metadata = {
                      origin: "SUITE",
                      suiteType: "jobs",
                      context: "professional"
                    };
                  }
                }
                finalMatch = await storage.updateMatch(existingMatch.id, {
                  matched: true,
                  metadata: JSON.stringify(metadata)
                });
              } else {
                const matchData = {
                  userId1: Math.min(currentUserId, targetProfile.userId),
                  userId2: Math.max(currentUserId, targetProfile.userId),
                  matched: true,
                  isDislike: false,
                  metadata: JSON.stringify({ origin: "SUITE", suiteType: "jobs", context: "professional" })
                };
                finalMatch = await storage.createMatch(matchData);
              }
              isMatch = true;
              console.log(
                `\u{1F49D} [SUITE-JOBS] Match created: ${currentUserId} \u2194 ${targetProfile.userId}`
              );
              try {
                await storage.removeMatchedUsersFromSwipeHistory(currentUserId, targetProfile.userId);
                console.log(`[JOBS-MATCH] Cleaned up swipe history for matched users: ${currentUserId} \u2194 ${targetProfile.userId}`);
              } catch (historyError) {
                console.error("Error cleaning up jobs swipe history for matched users:", historyError);
              }
            }
          }
        }
        console.log(
          `\u{1F680} [SUITE-JOBS] User ${currentUserId} ${action}d job profile ${profileId}`
        );
        const sourceUserWs = connectedUsers3.get(currentUserId);
        const targetUserWs = connectedUsers3.get(targetProfile.userId);
        if (sourceUserWs && sourceUserWs.readyState === WebSocket3.OPEN) {
          sourceUserWs.send(
            JSON.stringify({
              type: "suite_remove_from_discover",
              suiteType: "jobs",
              removeProfileId: targetProfile.id,
              removeUserId: targetProfile.userId,
              reason: action,
              timestamp: (/* @__PURE__ */ new Date()).toISOString()
            })
          );
          console.log(
            `[REAL-TIME] Instantly removed jobs profile ${targetProfile.id} from user ${currentUserId}'s discover deck`
          );
        }
        const sourceJobProfile = await storage.getSuiteJobProfile(currentUserId);
        if (sourceJobProfile && targetUserWs && targetUserWs.readyState === WebSocket3.OPEN) {
          targetUserWs.send(
            JSON.stringify({
              type: "suite_remove_from_discover",
              suiteType: "jobs",
              removeProfileId: sourceJobProfile.id,
              removeUserId: currentUserId,
              reason: `received_jobs_${action}`,
              timestamp: (/* @__PURE__ */ new Date()).toISOString()
            })
          );
          console.log(
            `[REAL-TIME] Instantly removed jobs profile ${sourceJobProfile.id} from user ${targetProfile.userId}'s discover deck`
          );
        }
        if (isMatch) {
          [sourceUserWs, targetUserWs].forEach((ws2, index) => {
            if (ws2 && ws2.readyState === WebSocket3.OPEN) {
              ws2.send(
                JSON.stringify({
                  type: "suite_connections_refresh",
                  suiteType: "jobs",
                  reason: "new_match",
                  timestamp: (/* @__PURE__ */ new Date()).toISOString()
                })
              );
            }
          });
          console.log(`[CONNECTIONS-REFRESH] Sent connections refresh for new job match`);
        }
        res.json({
          success: true,
          action,
          profileId,
          isMatch,
          message: action === "like" ? isMatch ? "It's a match!" : "Application sent" : "Profile passed"
        });
      } catch (error) {
        console.error("Error processing job swipe:", error);
        res.status(500).json({ message: "Failed to process swipe action" });
      }
    }
  );
  app2.get("/api/payment/methods", requireAuth, async (req, res) => {
    try {
      const userId = req.user.id;
      const paymentMethods3 = await storage.getPaymentMethodsByUser(userId);
      res.json(paymentMethods3);
    } catch (error) {
      console.error("[PAYMENT-METHOD] Error retrieving payment methods:", error);
      res.status(500).json({
        error: "Failed to retrieve payment methods"
      });
    }
  });
  app2.delete("/api/payment/methods/:id", requireAuth, async (req, res) => {
    try {
      const userId = req.user.id;
      const paymentMethodId = parseInt(req.params.id);
      const paymentMethod = await storage.getPaymentMethodById(paymentMethodId);
      if (!paymentMethod || paymentMethod.userId !== userId) {
        return res.status(404).json({
          error: "Payment method not found"
        });
      }
      await storage.deletePaymentMethod(paymentMethodId);
      console.log(`[PAYMENT-METHOD] Deleted payment method ${paymentMethodId} for user ${userId}`);
      res.json({
        success: true
      });
    } catch (error) {
      console.error("[PAYMENT-METHOD] Error deleting payment method:", error);
      res.status(500).json({
        error: "Failed to delete payment method"
      });
    }
  });
  app2.get("/api/places/autocomplete", async (req, res) => {
    try {
      const { query } = req.query;
      if (!query || typeof query !== "string") {
        return res.status(400).json({
          error: "Query parameter is required"
        });
      }
      const apiKey = process.env.VITE_GOOGLE_PLACES_API_KEY;
      if (!apiKey) {
        console.warn("[GOOGLE-PLACES] API key not available");
        return res.status(500).json({
          error: "Google Places API not configured"
        });
      }
      const googleResponse = await fetch(
        `https://maps.googleapis.com/maps/api/place/autocomplete/json?input=${encodeURIComponent(query)}&types=(cities)&key=${apiKey}`,
        {
          method: "GET",
          headers: {
            "Accept": "application/json"
          }
        }
      );
      if (!googleResponse.ok) {
        throw new Error(`Google Places API error: ${googleResponse.status}`);
      }
      const data = await googleResponse.json();
      if (data.status === "OK" && data.predictions) {
        console.log(`[GOOGLE-PLACES] Found ${data.predictions.length} suggestions for "${query}"`);
        res.json({
          predictions: data.predictions.slice(0, 5),
          // Limit to 5 suggestions
          status: "OK"
        });
      } else {
        console.log(`[GOOGLE-PLACES] No results found for "${query}", status: ${data.status}`);
        res.json({
          predictions: [],
          status: data.status || "NO_RESULTS"
        });
      }
    } catch (error) {
      console.error("[GOOGLE-PLACES] Error:", error);
      res.status(500).json({
        error: "Failed to search locations",
        details: error instanceof Error ? error.message : "Unknown error"
      });
    }
  });
  app2.get("/api/professional-reviews/:userId", async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      const userId = parseInt(req.params.userId);
      const reviews = await storage.getProfessionalReviewsForUser(userId);
      const stats = await storage.getProfessionalReviewStats(userId);
      res.json({
        reviews,
        stats,
        success: true
      });
    } catch (error) {
      console.error("Error fetching professional reviews:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });
  app2.post("/api/professional-reviews", async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      const { reviewedUserId, rating, reviewText, isAnonymous, category } = req.body;
      const reviewerUserId = req.user.id;
      if (!reviewedUserId || !rating || !reviewText) {
        return res.status(400).json({ message: "Missing required fields" });
      }
      if (rating < 1 || rating > 5) {
        return res.status(400).json({ message: "Rating must be between 1 and 5" });
      }
      if (reviewedUserId === reviewerUserId) {
        return res.status(400).json({ message: "Cannot review yourself" });
      }
      const existingReview = await storage.getExistingReview(
        reviewedUserId,
        reviewerUserId,
        category || "overall"
      );
      if (existingReview) {
        const updatedReview = await storage.updateProfessionalReview(existingReview.id, {
          rating,
          reviewText,
          isAnonymous: isAnonymous || false
        });
        res.json({ review: updatedReview, success: true });
      } else {
        const newReview = await storage.createProfessionalReview({
          reviewedUserId,
          reviewerUserId,
          rating,
          reviewText,
          isAnonymous: isAnonymous || false,
          category: category || "overall"
        });
        res.json({ review: newReview, success: true });
      }
    } catch (error) {
      console.error("Error creating/updating professional review:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });
  app2.get("/api/professional-reviews/:reviewedUserId/user/:reviewerUserId", async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      const reviewedUserId = parseInt(req.params.reviewedUserId);
      const reviewerUserId = parseInt(req.params.reviewerUserId);
      const category = req.query.category || "overall";
      const existingReview = await storage.getExistingReview(reviewedUserId, reviewerUserId, category);
      res.json({
        review: existingReview || null,
        success: true
      });
    } catch (error) {
      console.error("Error fetching existing review:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });
  app2.delete("/api/professional-reviews/:reviewId", async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      const reviewId = parseInt(req.params.reviewId);
      const userId = req.user.id;
      const deleted = await storage.deleteProfessionalReview(reviewId, userId);
      if (deleted) {
        res.json({
          success: true,
          message: "Review deleted successfully"
        });
      } else {
        res.status(404).json({
          success: false,
          message: "Review not found or you don't have permission to delete it"
        });
      }
    } catch (error) {
      console.error("Error deleting professional review:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });
  const { getHomePageData: getHomePageData2, getSuitePageData: getSuitePageData2 } = await Promise.resolve().then(() => (init_unified_api(), unified_api_exports));
  app2.get("/api/home-page-data", requireAuth, getHomePageData2);
  app2.get("/api/suite-page-data", requireAuth, getSuitePageData2);
  return httpServer;
}

// server/vite.ts
import express from "express";
import fs from "fs";
import path2, { dirname as dirname2 } from "path";
import { fileURLToPath as fileURLToPath2 } from "url";
import { createServer as createViteServer, createLogger } from "vite";

// vite.config.ts
import { defineConfig } from "vite";
import react from "@vitejs/plugin-react";
import themePlugin from "@replit/vite-plugin-shadcn-theme-json";
import path, { dirname } from "path";
import runtimeErrorOverlay from "@replit/vite-plugin-runtime-error-modal";
import { fileURLToPath } from "url";
var __filename = fileURLToPath(import.meta.url);
var __dirname = dirname(__filename);
var vite_config_default = defineConfig({
  plugins: [
    react(),
    runtimeErrorOverlay(),
    themePlugin(),
    ...process.env.NODE_ENV !== "production" && process.env.REPL_ID !== void 0 ? [
      await import("@replit/vite-plugin-cartographer").then(
        (m) => m.cartographer()
      )
    ] : []
  ],
  resolve: {
    alias: {
      "@": path.resolve(__dirname, "client", "src"),
      "@shared": path.resolve(__dirname, "shared"),
      "@assets": path.resolve(__dirname, "attached_assets")
    }
  },
  root: path.resolve(__dirname, "client"),
  build: {
    outDir: path.resolve(__dirname, "dist/public"),
    emptyOutDir: true
  }
});

// server/vite.ts
import { nanoid } from "nanoid";
var __filename2 = fileURLToPath2(import.meta.url);
var __dirname2 = dirname2(__filename2);
var viteLogger = createLogger();
function log(message, source = "express") {
  const formattedTime = (/* @__PURE__ */ new Date()).toLocaleTimeString("en-US", {
    hour: "numeric",
    minute: "2-digit",
    second: "2-digit",
    hour12: true
  });
  console.log(`${formattedTime} [${source}] ${message}`);
}
async function setupVite(app2, server) {
  const serverOptions = {
    middlewareMode: true,
    hmr: { server },
    allowedHosts: true
  };
  const vite = await createViteServer({
    ...vite_config_default,
    configFile: false,
    customLogger: {
      ...viteLogger,
      error: (msg, options) => {
        viteLogger.error(msg, options);
        process.exit(1);
      }
    },
    server: serverOptions,
    appType: "custom"
  });
  app2.use(vite.middlewares);
  app2.use("*", async (req, res, next) => {
    const url = req.originalUrl;
    try {
      const clientTemplate = path2.resolve(
        __dirname2,
        "..",
        "client",
        "index.html"
      );
      let template = await fs.promises.readFile(clientTemplate, "utf-8");
      template = template.replace(
        `src="/src/main.tsx"`,
        `src="/src/main.tsx?v=${nanoid()}"`
      );
      const page = await vite.transformIndexHtml(url, template);
      res.status(200).set({ "Content-Type": "text/html" }).end(page);
    } catch (e) {
      vite.ssrFixStacktrace(e);
      next(e);
    }
  });
}
function serveStatic(app2) {
  const distPath = path2.resolve(__dirname2, "public");
  if (!fs.existsSync(distPath)) {
    throw new Error(
      `Could not find the build directory: ${distPath}, make sure to build the client first`
    );
  }
  app2.use(express.static(distPath));
  app2.use("*", (_req, res) => {
    res.sendFile(path2.resolve(distPath, "index.html"));
  });
}

// server/index.ts
import dotenv3 from "dotenv";
dotenv3.config();
var app = express2();
app.use(express2.json({ limit: "50mb" }));
app.use(express2.urlencoded({ extended: false, limit: "50mb" }));
app.use((req, res, next) => {
  const start = Date.now();
  const path3 = req.path;
  let capturedJsonResponse = void 0;
  const originalResJson = res.json;
  res.json = function(bodyJson, ...args) {
    capturedJsonResponse = bodyJson;
    return originalResJson.apply(res, [bodyJson, ...args]);
  };
  res.on("finish", () => {
    const duration = Date.now() - start;
    if (path3.startsWith("/api")) {
      let logLine = `${req.method} ${path3} ${res.statusCode} in ${duration}ms`;
      if (capturedJsonResponse) {
        logLine += ` :: ${JSON.stringify(capturedJsonResponse)}`;
      }
      if (logLine.length > 80) {
        logLine = logLine.slice(0, 79) + "\u2026";
      }
      log(logLine);
    }
  });
  next();
});
(async () => {
  const server = await registerRoutes(app);
  app.use((err, _req, res, _next) => {
    const status = err.status || err.statusCode || 500;
    const message = err.message || "Internal Server Error";
    res.status(status).json({ message });
    throw err;
  });
  if (app.get("env") === "development") {
    await setupVite(app, server);
  } else {
    serveStatic(app);
  }
  startServer(server, () => {
    log("Server started successfully");
  });
})();
function startServer(server, callback) {
  let port = parseInt(process.env.PORT || "5000");
  const host = "0.0.0.0";
  const maxAttempts = 10;
  let attempts = 0;
  function tryPort(currentPort) {
    if (attempts >= maxAttempts) {
      log(`Failed to find available port after ${maxAttempts} attempts`);
      process.exit(1);
      return;
    }
    attempts++;
    server.listen(currentPort, host, () => {
      log(`Server listening at http://${host}:${currentPort}`);
      if (callback) callback();
    }).on("error", (err) => {
      if (err.message.includes("EADDRINUSE")) {
        log(
          `Port ${currentPort} is in use, trying port ${currentPort + 1}...`
        );
        server.close(() => {
          tryPort(currentPort + 1);
        });
      } else {
        log(`Failed to start server: ${err.message}`);
        process.exit(1);
      }
    });
  }
  tryPort(port);
}
