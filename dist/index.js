var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};

// shared/schema.ts
var schema_exports = {};
__export(schema_exports, {
  archivedMatches: () => archivedMatches,
  archivedMessages: () => archivedMessages,
  archivedUsers: () => archivedUsers,
  blockedPhoneNumbers: () => blockedPhoneNumbers,
  compatibilityAnalysis: () => compatibilityAnalysis,
  connectionsPreferences: () => connectionsPreferences,
  conversationThreads: () => conversationThreads,
  globalDealBreakers: () => globalDealBreakers,
  globalInterests: () => globalInterests,
  globalReligions: () => globalReligions,
  globalTribes: () => globalTribes,
  insertArchivedMatchSchema: () => insertArchivedMatchSchema,
  insertArchivedMessageSchema: () => insertArchivedMessageSchema,
  insertArchivedUserSchema: () => insertArchivedUserSchema,
  insertBlockedPhoneNumberSchema: () => insertBlockedPhoneNumberSchema,
  insertCompatibilityAnalysisSchema: () => insertCompatibilityAnalysisSchema,
  insertConnectionsPreferencesSchema: () => insertConnectionsPreferencesSchema,
  insertGlobalDealBreakerSchema: () => insertGlobalDealBreakerSchema,
  insertGlobalInterestSchema: () => insertGlobalInterestSchema,
  insertGlobalReligionSchema: () => insertGlobalReligionSchema,
  insertGlobalTribeSchema: () => insertGlobalTribeSchema,
  insertKwameConversationSchema: () => insertKwameConversationSchema,
  insertMatchSchema: () => insertMatchSchema,
  insertMessageReactionSchema: () => insertMessageReactionSchema,
  insertMessageSchema: () => insertMessageSchema,
  insertPaymentHistorySchema: () => insertPaymentHistorySchema,
  insertPaymentMethodSchema: () => insertPaymentMethodSchema,
  insertProfessionalReviewSchema: () => insertProfessionalReviewSchema,
  insertPromotionalCodeSchema: () => insertPromotionalCodeSchema,
  insertPromotionalCodeUsageSchema: () => insertPromotionalCodeUsageSchema,
  insertRegionalPricingSchema: () => insertRegionalPricingSchema,
  insertSubscriptionEventSchema: () => insertSubscriptionEventSchema,
  insertSubscriptionSchema: () => insertSubscriptionSchema,
  insertSuiteCompatibilityScoreSchema: () => insertSuiteCompatibilityScoreSchema,
  insertSuiteFieldVisibilitySchema: () => insertSuiteFieldVisibilitySchema,
  insertSuiteJobApplicationSchema: () => insertSuiteJobApplicationSchema,
  insertSuiteJobProfileSchema: () => insertSuiteJobProfileSchema,
  insertSuiteMentorshipCompatibilityScoreSchema: () => insertSuiteMentorshipCompatibilityScoreSchema,
  insertSuiteMentorshipConnectionSchema: () => insertSuiteMentorshipConnectionSchema,
  insertSuiteMentorshipProfileSchema: () => insertSuiteMentorshipProfileSchema,
  insertSuiteNetworkingConnectionSchema: () => insertSuiteNetworkingConnectionSchema,
  insertSuiteNetworkingProfileSchema: () => insertSuiteNetworkingProfileSchema,
  insertSuiteProfileSettingsSchema: () => insertSuiteProfileSettingsSchema,
  insertSwipeHistorySchema: () => insertSwipeHistorySchema,
  insertTypingStatusSchema: () => insertTypingStatusSchema,
  insertUserBlockSchema: () => insertUserBlockSchema,
  insertUserInterestSchema: () => insertUserInterestSchema,
  insertUserMatchSettingsSchema: () => insertUserMatchSettingsSchema,
  insertUserPhotoSchema: () => insertUserPhotoSchema,
  insertUserReportStrikeSchema: () => insertUserReportStrikeSchema,
  insertUserSchema: () => insertUserSchema,
  insertVerificationCodeSchema: () => insertVerificationCodeSchema,
  insertVideoCallSchema: () => insertVideoCallSchema,
  kwameConversations: () => kwameConversations,
  matches: () => matches,
  messageEngagementMetrics: () => messageEngagementMetrics,
  messageReactions: () => messageReactions,
  messages: () => messages,
  passwordResetCodes: () => passwordResetCodes,
  paymentHistory: () => paymentHistory,
  paymentMethods: () => paymentMethods,
  professionalReviews: () => professionalReviews,
  profileViews: () => profileViews,
  promotionalCodeUsage: () => promotionalCodeUsage,
  promotionalCodes: () => promotionalCodes,
  regionalPricing: () => regionalPricing,
  subscriptionEvents: () => subscriptionEvents2,
  subscriptions: () => subscriptions,
  suiteCompatibilityScores: () => suiteCompatibilityScores,
  suiteFieldVisibility: () => suiteFieldVisibility,
  suiteJobApplications: () => suiteJobApplications,
  suiteJobProfiles: () => suiteJobProfiles,
  suiteMentorshipCompatibilityScores: () => suiteMentorshipCompatibilityScores,
  suiteMentorshipConnections: () => suiteMentorshipConnections,
  suiteMentorshipProfiles: () => suiteMentorshipProfiles,
  suiteNetworkingConnections: () => suiteNetworkingConnections,
  suiteNetworkingProfiles: () => suiteNetworkingProfiles,
  suiteProfileSettings: () => suiteProfileSettings,
  swipeHistory: () => swipeHistory,
  typingStatus: () => typingStatus,
  updateUserPhotoPrimarySchema: () => updateUserPhotoPrimarySchema,
  userBlocks: () => userBlocks,
  userInterests: () => userInterests,
  userMatchSettings: () => userMatchSettings,
  userPhotos: () => userPhotos,
  userPreferences: () => userPreferences,
  userPreferencesSchema: () => userPreferencesSchema,
  userProfileSchema: () => userProfileSchema,
  userReportStrikes: () => userReportStrikes,
  users: () => users,
  verificationCodes: () => verificationCodes,
  videoCalls: () => videoCalls
});
import {
  pgTable,
  text,
  serial,
  integer,
  boolean,
  timestamp,
  unique
} from "drizzle-orm/pg-core";
import { createInsertSchema } from "drizzle-zod";
import { z } from "zod";
var blockedPhoneNumbers, userReportStrikes, userBlocks, passwordResetCodes, users, userPreferences, matches, messages, userInterests, globalInterests, globalDealBreakers, globalTribes, globalReligions, profileViews, messageEngagementMetrics, conversationThreads, typingStatus, videoCalls, compatibilityAnalysis, suiteCompatibilityScores, verificationCodes, userPhotos, messageReactions, userMatchSettings, suiteJobProfiles, suiteMentorshipProfiles, suiteNetworkingProfiles, suiteProfileSettings, suiteFieldVisibility, connectionsPreferences, insertUserSchema, userProfileSchema, insertBlockedPhoneNumberSchema, insertUserReportStrikeSchema, userPreferencesSchema, insertMatchSchema, insertMessageSchema, insertUserInterestSchema, insertGlobalInterestSchema, insertGlobalDealBreakerSchema, insertGlobalTribeSchema, insertGlobalReligionSchema, insertTypingStatusSchema, insertVideoCallSchema, insertVerificationCodeSchema, insertUserPhotoSchema, updateUserPhotoPrimarySchema, insertMessageReactionSchema, insertUserMatchSettingsSchema, insertCompatibilityAnalysisSchema, insertSuiteCompatibilityScoreSchema, insertUserBlockSchema, insertArchivedMatchSchema, insertArchivedMessageSchema, insertArchivedUserSchema, insertSuiteJobProfileSchema, insertSuiteMentorshipProfileSchema, insertSuiteNetworkingProfileSchema, insertSuiteProfileSettingsSchema, insertSuiteFieldVisibilitySchema, swipeHistory, insertSwipeHistorySchema, archivedMatches, archivedMessages, archivedUsers, suiteNetworkingConnections, suiteMentorshipConnections, suiteJobApplications, professionalReviews, insertSuiteNetworkingConnectionSchema, insertSuiteMentorshipConnectionSchema, insertSuiteJobApplicationSchema, insertProfessionalReviewSchema, subscriptions, paymentMethods, paymentHistory, subscriptionEvents2, regionalPricing, promotionalCodes, promotionalCodeUsage, insertSubscriptionSchema, insertPaymentMethodSchema, insertPaymentHistorySchema, insertSubscriptionEventSchema, insertRegionalPricingSchema, insertPromotionalCodeSchema, insertPromotionalCodeUsageSchema, suiteMentorshipCompatibilityScores, insertSuiteMentorshipCompatibilityScoreSchema, insertConnectionsPreferencesSchema, kwameConversations, insertKwameConversationSchema;
var init_schema = __esm({
  "shared/schema.ts"() {
    "use strict";
    blockedPhoneNumbers = pgTable("blocked_phone_numbers", {
      id: serial("id").primaryKey(),
      phoneNumber: text("phone_number").notNull().unique(),
      fullName: text("full_name"),
      // User's full name when blocked
      email: text("email"),
      // User's email when blocked
      reason: text("reason").notNull(),
      // e.g., "under_14_age_restriction", "user_reports"
      blockedAt: timestamp("blocked_at").defaultNow(),
      metadata: text("metadata")
      // Additional info as JSON string
    });
    userReportStrikes = pgTable("user_report_strikes", {
      id: serial("id").primaryKey(),
      reportedUserId: integer("reported_user_id").notNull(),
      // User being reported
      reporterUserId: integer("reporter_user_id").notNull(),
      // User making the report
      reason: text("reason").notNull(),
      // Reason for report
      description: text("description"),
      // Additional details
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow(),
      matchId: integer("match_id")
      // Associated match that was unmatched
    });
    userBlocks = pgTable(
      "user_blocks",
      {
        id: serial("id").primaryKey(),
        blockerUserId: integer("blocker_user_id").notNull().references(() => users.id),
        // User who is blocking
        blockedUserId: integer("blocked_user_id").notNull().references(() => users.id),
        // User being blocked
        reason: text("reason"),
        // Optional reason for blocking
        createdAt: timestamp("created_at").defaultNow()
        // Prevent duplicate blocks and self-blocking
      },
      (table) => ({
        uniqueBlock: unique().on(table.blockerUserId, table.blockedUserId)
      })
    );
    passwordResetCodes = pgTable("password_reset_codes", {
      id: serial("id").primaryKey(),
      email: text("email").notNull(),
      resetCode: text("reset_code").notNull(),
      // 7-digit code
      isUsed: boolean("is_used").default(false),
      createdAt: timestamp("created_at").defaultNow(),
      expiresAt: timestamp("expires_at").notNull()
      // 10 minutes expiry
    });
    users = pgTable("users", {
      id: serial("id").primaryKey(),
      username: text("username").notNull().unique(),
      password: text("password").notNull(),
      fullName: text("full_name").notNull(),
      email: text("email").notNull().unique(),
      phoneNumber: text("phone_number").unique(),
      gender: text("gender").notNull(),
      location: text("location").notNull(),
      // 'Ghana' or 'Diaspora'
      countryOfOrigin: text("country_of_origin"),
      // User's primary country of origin
      secondaryCountryOfOrigin: text("secondary_country_of_origin"),
      // User's secondary country of origin (dual citizenship)
      bio: text("bio"),
      profession: text("profession"),
      ethnicity: text("ethnicity"),
      // Primary tribe
      secondaryTribe: text("secondary_tribe"),
      // Secondary tribe
      religion: text("religion"),
      photoUrl: text("photo_url"),
      // Avatar system
      avatarPhoto: text("avatar_photo"),
      showAvatar: boolean("show_avatar").default(false),
      showProfilePhoto: boolean("show_profile_photo").default(true),
      // Toggle to show/hide profile picture
      dateOfBirth: timestamp("date_of_birth"),
      relationshipStatus: text("relationship_status"),
      // User's current relationship status
      relationshipGoal: text("relationship_goal"),
      // What they're looking for
      highSchool: text("high_school"),
      // User's high school name
      collegeUniversity: text("college_university"),
      // User's college/university name
      interests: text("interests"),
      // Stored as JSON string of user's interests
      visibilityPreferences: text("visibility_preferences"),
      // Stored as JSON string of field visibility preferences
      // New fields for matching algorithm
      bodyType: text("body_type"),
      // User's actual body type
      height: integer("height"),
      // User's height in centimeters
      smoking: text("smoking"),
      // User's smoking habits: "yes", "no", "occasionally"
      drinking: text("drinking"),
      // User's drinking habits: "yes", "no", "occasionally", "socially"
      hasChildren: text("has_children"),
      // "yes", "no", or null
      wantsChildren: text("wants_children"),
      // "yes", "no", or null
      educationLevel: text("education_level"),
      // User's actual education level
      matchingPriorities: text("matching_priorities"),
      // JSON array of user's matching priorities
      verifiedByPhone: boolean("verified_by_phone").default(false),
      twoFactorEnabled: boolean("two_factor_enabled").default(true),
      // Default to true for security
      profileHidden: boolean("profile_hidden").default(true),
      // Hide profile from discovery (default true for new users)
      hasActivatedProfile: boolean("has_activated_profile").default(false),
      // Tracks if user has ever activated their profile
      ghostMode: boolean("ghost_mode").default(false),
      // Hide online status and typing indicators
      hideAge: boolean("hide_age").default(false),
      // Hide age from swipecard display
      isOnline: boolean("is_online").default(false),
      lastActive: timestamp("last_active"),
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow(),
      showAppModeSelection: boolean("show_app_mode_selection").default(true),
      // Show app selection screen after login
      showNationalitySelection: boolean("show_nationality_selection").default(true),
      // Show nationality selection screen
      lastUsedApp: text("last_used_app"),
      premiumAccess: boolean("premium_access").default(false),
      // Premium subscription status
      stripeCustomerId: text("stripe_customer_id").unique(),
      // Stripe customer ID for payment processing
      stripeSubscriptionId: text("stripe_subscription_id").unique(),
      // Active Stripe subscription ID
      subscriptionStatus: text("subscription_status"),
      // 'active', 'canceled', 'past_due', 'unpaid'
      subscriptionExpiresAt: timestamp("subscription_expires_at"),
      // When current subscription period ends
      subscriptionCanceledAt: timestamp("subscription_canceled_at"),
      // When user requested cancellation
      idVerificationPhoto: text("id_verification_photo"),
      // Government ID photo for verification
      liveVerificationPhoto: text("live_verification_photo"),
      // Live selfie photo for verification
      isVerified: boolean("is_verified").default(false),
      // Manual verification status - shows verification badge
      isSuspended: boolean("is_suspended").default(false),
      // Account suspension status
      suspendedAt: timestamp("suspended_at"),
      // When account was suspended
      suspensionExpiresAt: timestamp("suspension_expires_at"),
      // When suspension expires
      preferredLanguage: text("preferred_language").default("en"),
      // User's preferred language for cross-device sync
      // Godmodel personality system: stores progress + final responses JSON
      personalityRecords: text("personality_records"),
      personalityTestCompleted: boolean("personality_test_completed").default(
        false
      ),
      // Tracks if user has completed the full personality test
      // Big 5 personality analysis results
      big5Profile: text("big5_profile"),
      // JSON with computed Big 5 traits, aspects, and percentiles
      big5ComputedAt: timestamp("big5_computed_at"),
      // When Big 5 analysis was last computed
      personalityModelVersion: text("personality_model_version")
      // Version of scoring model used
    });
    userPreferences = pgTable("user_preferences", {
      id: serial("id").primaryKey(),
      userId: integer("user_id").notNull().references(() => users.id),
      minAge: integer("min_age"),
      maxAge: integer("max_age"),
      locationPreference: text("location_preference"),
      // 'Ghana', 'Diaspora', or 'Both'
      poolCountry: text("pool_country"),
      // Legacy single pool country field (for migration compatibility)
      meetPoolCountry: text("meet_pool_country"),
      // MEET app specific: "WHERE SHOULD LOVE COME FROM?"
      suitePoolCountry: text("suite_pool_country"),
      // SUITE app specific: "WHERE SHOULD CONNECTION COME FROM?"
      ethnicityPreference: text("ethnicity_preference"),
      // Can be JSON array of preferred tribes
      religionPreference: text("religion_preference"),
      // Can be JSON array of preferred religions
      relationshipGoalPreference: text("relationship_goal_preference"),
      distancePreference: integer("distance_preference"),
      // Maximum distance in kilometers
      educationLevelPreference: text("education_level_preference"),
      // Can be JSON array of education levels
      hasChildrenPreference: text("has_children_preference"),
      // 'yes', 'no', 'any'
      wantsChildrenPreference: text("wants_children_preference"),
      // 'yes', 'no', 'any'
      minHeightPreference: integer("min_height_preference"),
      // in cm
      maxHeightPreference: integer("max_height_preference"),
      // in cm
      bodyTypePreference: text("body_type_preference"),
      // Can be JSON array of body types
      dealBreakers: text("deal_breakers"),
      // Can be JSON array of deal breakers
      interestPreferences: text("interest_preferences"),
      // Can be JSON array of preferred interests
      matchingPriorities: text("matching_priorities"),
      // JSON array of matching priorities in order of importance
      smokingPreference: text("smoking_preference"),
      // 'no', 'occasionally', 'yes', 'any'
      drinkingPreference: text("drinking_preference"),
      // 'no', 'socially', 'occasionally', 'yes', 'any'
      highSchoolPreference: text("high_school_preference"),
      // Can be JSON array of preferred high schools (for users under 18)
      updatedAt: timestamp("updated_at").defaultNow()
    });
    matches = pgTable("matches", {
      id: serial("id").primaryKey(),
      userId1: integer("user_id_1").notNull().references(() => users.id),
      userId2: integer("user_id_2").notNull().references(() => users.id),
      matched: boolean("matched").notNull().default(false),
      isDislike: boolean("is_dislike").notNull().default(false),
      // True if this is a dislike (userId1 dislikes userId2)
      hasUnreadMessages1: boolean("has_unread_messages_1").notNull().default(false),
      // User 1 has unread messages
      hasUnreadMessages2: boolean("has_unread_messages_2").notNull().default(false),
      // User 2 has unread messages
      notifiedUser1: boolean("notified_user_1").notNull().default(false),
      // User 1 has been notified of match
      notifiedUser2: boolean("notified_user_2").notNull().default(false),
      // User 2 has been notified of match
      lastMessageAt: timestamp("last_message_at"),
      metadata: text("metadata"),
      // JSON string for additional match data like suiteType
      createdAt: timestamp("created_at").defaultNow()
    });
    messages = pgTable("messages", {
      id: serial("id").primaryKey(),
      matchId: integer("match_id").notNull().references(() => matches.id),
      senderId: integer("sender_id").notNull().references(() => users.id),
      receiverId: integer("receiver_id").notNull().references(() => users.id),
      content: text("content").notNull(),
      encryptedContent: text("encrypted_content"),
      iv: text("initialization_vector"),
      messageType: text("message_type").default("text"),
      // "text", "audio", "image", etc.
      audioUrl: text("audio_url"),
      audioDuration: integer("audio_duration"),
      // Duration in seconds
      read: boolean("read").notNull().default(false),
      readAt: timestamp("read_at"),
      createdAt: timestamp("created_at").defaultNow(),
      // Reply functionality
      replyToMessageId: integer("reply_to_message_id"),
      replyToContent: text("reply_to_content"),
      replyToSenderName: text("reply_to_sender_name"),
      replyToIsCurrentUser: boolean("reply_to_is_current_user"),
      // Auto-delete functionality
      autoDeleteScheduledAt: timestamp("auto_delete_scheduled_at"),
      autoDeleteModeWhenSent: text("auto_delete_mode_when_sent").default("never"),
      deletedForUserId: integer("deleted_for_user_id").references(() => users.id)
    });
    userInterests = pgTable("user_interests", {
      id: serial("id").primaryKey(),
      userId: integer("user_id").notNull().references(() => users.id),
      interest: text("interest").notNull(),
      showOnProfile: boolean("show_on_profile").default(true)
    });
    globalInterests = pgTable("global_interests", {
      id: serial("id").primaryKey(),
      interest: text("interest").notNull().unique(),
      category: text("category"),
      createdAt: timestamp("created_at").defaultNow(),
      createdBy: integer("created_by").references(() => users.id)
    });
    globalDealBreakers = pgTable("global_deal_breakers", {
      id: serial("id").primaryKey(),
      dealBreaker: text("deal_breaker").notNull().unique(),
      createdBy: integer("created_by").references(() => users.id),
      createdAt: timestamp("created_at").defaultNow()
    });
    globalTribes = pgTable("global_tribes", {
      id: serial("id").primaryKey(),
      tribe: text("tribe").notNull().unique(),
      category: text("category"),
      // For grouping tribes by ethnicity (e.g., "Akan", "Ga-Adangbe", etc.)
      createdBy: integer("created_by").references(() => users.id),
      createdAt: timestamp("created_at").defaultNow()
    });
    globalReligions = pgTable("global_religions", {
      id: serial("id").primaryKey(),
      religion: text("religion").notNull().unique(),
      category: text("category"),
      // For grouping religions (e.g., "Christianity", "Islam", etc.)
      createdBy: integer("created_by").references(() => users.id),
      createdAt: timestamp("created_at").defaultNow()
    });
    profileViews = pgTable("profile_views", {
      id: serial("id").primaryKey(),
      viewerId: integer("viewer_id").notNull().references(() => users.id),
      viewedId: integer("viewed_id").notNull().references(() => users.id),
      viewCount: integer("view_count").notNull().default(1),
      firstViewedAt: timestamp("first_viewed_at").defaultNow(),
      lastViewedAt: timestamp("last_viewed_at").defaultNow(),
      totalViewDuration: integer("total_view_duration").default(0),
      // Total seconds spent viewing
      appMode: text("app_mode").notNull().default("MEET"),
      // "MEET", "HEAT", "SUITE_NETWORKING", etc.
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow()
    });
    messageEngagementMetrics = pgTable("message_engagement_metrics", {
      id: serial("id").primaryKey(),
      messageId: integer("message_id").notNull().references(() => messages.id),
      senderId: integer("sender_id").notNull().references(() => users.id),
      receiverId: integer("receiver_id").notNull().references(() => users.id),
      messageLength: integer("message_length").notNull(),
      hasQuestion: boolean("has_question").notNull().default(false),
      hasExclamation: boolean("has_exclamation").notNull().default(false),
      wordCount: integer("word_count").notNull(),
      sentimentScore: integer("sentiment_score").default(0),
      // -100 to 100 sentiment analysis (scaled)
      readTime: integer("read_time"),
      // Seconds to read message
      responseTime: integer("response_time"),
      // Seconds until response
      engagementScore: integer("engagement_score").default(50),
      // 0-100 calculated engagement score
      createdAt: timestamp("created_at").defaultNow()
    });
    conversationThreads = pgTable("conversation_threads", {
      id: serial("id").primaryKey(),
      participantOneId: integer("participant_one_id").notNull().references(() => users.id),
      participantTwoId: integer("participant_two_id").notNull().references(() => users.id),
      threadId: text("thread_id").notNull().unique(),
      // Format: "userId1-userId2" (lower ID first)
      totalMessages: integer("total_messages").notNull().default(0),
      messagesFromOne: integer("messages_from_one").notNull().default(0),
      messagesFromTwo: integer("messages_from_two").notNull().default(0),
      averageResponseTime: integer("average_response_time").default(0),
      // Minutes (scaled from hours)
      conversationDepth: integer("conversation_depth").default(0),
      // Number of back-and-forth exchanges
      lastActivityAt: timestamp("last_activity_at").defaultNow(),
      isActive: boolean("is_active").notNull().default(true),
      appMode: text("app_mode").notNull().default("MEET"),
      // "MEET", "HEAT", "SUITE"
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow()
    });
    typingStatus = pgTable("typing_status", {
      id: serial("id").primaryKey(),
      userId: integer("user_id").notNull().references(() => users.id),
      matchId: integer("match_id").notNull().references(() => matches.id),
      isTyping: boolean("is_typing").notNull().default(false),
      updatedAt: timestamp("updated_at").defaultNow()
    });
    videoCalls = pgTable("video_calls", {
      id: serial("id").primaryKey(),
      matchId: integer("match_id").notNull().references(() => matches.id),
      initiatorId: integer("initiator_id").notNull().references(() => users.id),
      receiverId: integer("receiver_id").notNull().references(() => users.id),
      roomName: text("room_name").notNull().unique(),
      status: text("status").notNull().default("pending"),
      // pending, active, completed, declined
      startedAt: timestamp("started_at"),
      endedAt: timestamp("ended_at"),
      createdAt: timestamp("created_at").defaultNow()
    });
    compatibilityAnalysis = pgTable("compatibility_analysis", {
      id: serial("id").primaryKey(),
      user1Id: integer("user1_id").notNull().references(() => users.id),
      user2Id: integer("user2_id").notNull().references(() => users.id),
      compatibilityData: text("compatibility_data").notNull(),
      // JSON string containing all compatibility analysis
      overallScore: integer("overall_score").notNull(),
      // Overall compatibility percentage (0-100)
      version: text("version").notNull().default("1.0"),
      // Version for future compatibility data format changes
      computedAt: timestamp("computed_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow(),
      isActive: boolean("is_active").notNull().default(true)
      // For soft deletion when user dislikes
    });
    suiteCompatibilityScores = pgTable(
      "suite_compatibility_scores",
      {
        id: serial("id").primaryKey(),
        userId: integer("user_id").notNull().references(() => users.id),
        // Always store smaller user ID first to prevent duplicates
        targetUserId: integer("target_user_id").notNull().references(() => users.id),
        // Always store larger user ID second to prevent duplicates
        targetProfileId: integer("target_profile_id").notNull().references(() => suiteNetworkingProfiles.id),
        // Specific networking profile
        // Multi-dimensional scoring system
        synergyScore: integer("synergy_score").notNull(),
        // Industry/goals alignment (1-10)
        networkValueScore: integer("network_value_score").notNull(),
        // Professional influence potential (1-10)
        collaborationScore: integer("collaboration_score").notNull(),
        // Project partnership likelihood (1-10)
        exchangeScore: integer("exchange_score").notNull(),
        // Mutual benefit potential (1-10)
        overallStarRating: integer("overall_star_rating").notNull(),
        // Final star rating (1-10)
        // Detailed analysis data
        analysisData: text("analysis_data").notNull(),
        // JSON with breakdown details
        insights: text("insights").notNull(),
        // JSON array of key insights
        suggestedActions: text("suggested_actions").notNull(),
        // JSON array of conversation starters
        // Geographic and cultural intelligence
        geographicFit: integer("geographic_fit").notNull(),
        // Location/timezone compatibility (1-10)
        culturalAlignment: integer("cultural_alignment").notNull(),
        // Cross-cultural networking potential (1-10)
        // Metadata
        computedAt: timestamp("computed_at").defaultNow(),
        lastUpdated: timestamp("last_updated").defaultNow(),
        isActive: boolean("is_active").notNull().default(true)
      },
      (table) => {
        return {
          // Ensure one score per unique user pair (bidirectional constraint)
          uniqueUserPair: unique().on(table.userId, table.targetUserId)
        };
      }
    );
    verificationCodes = pgTable("verification_codes", {
      id: serial("id").primaryKey(),
      phoneNumber: text("phone_number").notNull(),
      code: text("code").notNull(),
      expiresAt: timestamp("expires_at").notNull(),
      createdAt: timestamp("created_at").defaultNow()
    });
    userPhotos = pgTable("user_photos", {
      id: serial("id").primaryKey(),
      // TODO: Will migrate to bigserial to support larger IDs
      userId: integer("user_id").notNull().references(() => users.id),
      photoUrl: text("photo_url").notNull(),
      isPrimary: boolean("is_primary").default(false),
      // Legacy primary photo (for backwards compatibility)
      // Section-specific primary photo flags
      isPrimaryForMeet: boolean("is_primary_for_meet").default(false),
      isPrimaryForJob: boolean("is_primary_for_job").default(false),
      isPrimaryForMentorship: boolean("is_primary_for_mentorship").default(false),
      isPrimaryForNetworking: boolean("is_primary_for_networking").default(false),
      createdAt: timestamp("created_at").defaultNow()
    });
    messageReactions = pgTable("message_reactions", {
      id: serial("id").primaryKey(),
      messageId: integer("message_id").notNull().references(() => messages.id),
      userId: integer("user_id").notNull().references(() => users.id),
      emoji: text("emoji").notNull(),
      createdAt: timestamp("created_at").defaultNow()
    });
    userMatchSettings = pgTable(
      "user_match_settings",
      {
        id: serial("id").primaryKey(),
        userId: integer("user_id").notNull().references(() => users.id),
        matchId: integer("match_id").notNull().references(() => matches.id),
        autoDeleteMode: text("auto_delete_mode").default("never"),
        // 'never', 'always', 'custom'
        autoDeleteValue: integer("auto_delete_value").default(5),
        autoDeleteUnit: text("auto_delete_unit").default("minutes"),
        // 'minutes', 'hours', 'days'
        createdAt: timestamp("created_at").defaultNow()
      },
      (table) => ({
        userMatchUnique: unique().on(table.userId, table.matchId)
      })
    );
    suiteJobProfiles = pgTable("suite_job_profiles", {
      id: serial("id").primaryKey(),
      userId: integer("user_id").notNull().references(() => users.id),
      // User role
      role: text("role"),
      // 'job-seeker', 'recruiter'
      // Basic job information
      jobTitle: text("job_title").notNull(),
      company: text("company"),
      description: text("description").notNull(),
      compensation: text("compensation"),
      compensationCurrency: text("compensation_currency"),
      compensationPeriod: text("compensation_period"),
      salary: text("salary"),
      salaryCurrency: text("salary_currency"),
      salaryPeriod: text("salary_period"),
      requirements: text("requirements"),
      // JSON array of requirements
      location: text("location"),
      workType: text("work_type").notNull(),
      // 'Remote', 'In-person', 'Hybrid'
      jobType: text("job_type").notNull(),
      // 'Full-time', 'Part-time', 'Contract', 'Internship'
      experienceLevel: text("experience_level"),
      // 'Entry', 'Mid', 'Senior', 'Executive'
      // Emotional and cultural context
      whyItMatters: text("why_it_matters"),
      whoShouldApply: text("who_should_apply"),
      culturalFit: text("cultural_fit"),
      areasOfExpertise: text("areas_of_expertise"),
      industryTags: text("industry_tags"),
      // JSON array of industry tags
      skillTags: text("skill_tags"),
      // JSON array of required skills
      // Application settings
      applicationUrl: text("application_url"),
      applicationEmail: text("application_email"),
      applicationInstructions: text("application_instructions"),
      isActive: boolean("is_active").default(true),
      expiresAt: timestamp("expires_at"),
      // Field visibility preferences (JSON string)
      visibilityPreferences: text("visibility_preferences"),
      // Metadata
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow()
    });
    suiteMentorshipProfiles = pgTable("suite_mentorship_profiles", {
      id: serial("id").primaryKey(),
      userId: integer("user_id").notNull().references(() => users.id),
      // Role and basic info
      role: text("role").notNull(),
      // 'mentor' or 'mentee'
      areasOfExpertise: text("areas_of_expertise").array(),
      // Array for mentors
      learningGoals: text("learning_goals").array(),
      // Array for mentees
      languagesSpoken: text("languages_spoken").array(),
      // Array of languages
      industriesOrDomains: text("industries_or_domains").array(),
      // Array of industries
      // Mentorship details
      mentorshipStyle: text("mentorship_style"),
      preferredFormat: text("preferred_format"),
      // JSON array: ['1-on-1', 'Group', 'Workshop', 'Peer']
      communicationStyle: text("communication_style"),
      // JSON array: ['Chat', 'Video', 'In-person', 'Async']
      // Availability
      availability: text("availability"),
      // JSON object with schedule
      timeCommitment: text("time_commitment"),
      // 'Light (1-2 hrs/month)', 'Regular (3-5 hrs/month)', 'Intensive (5+ hrs/month)'
      location: text("location"),
      // User's location, defaults from registration
      // Goals and experience
      successStories: text("success_stories"),
      whyMentor: text("why_mentor"),
      // For mentors: why they want to mentor
      whySeekMentorship: text("why_seek_mentorship"),
      // For mentees: what they hope to gain
      // Mentee-specific fields
      preferredMentorshipStyle: text("preferred_mentorship_style"),
      // For mentees: preferred mentorship style
      industryAspiration: text("industry_aspiration"),
      // For mentees: industry they want to work in
      // Matching preferences
      preferredMenteeLevel: text("preferred_mentee_level"),
      // For mentors
      preferredMentorExperience: text("preferred_mentor_experience"),
      // For mentees
      preferredIndustries: text("preferred_industries"),
      // JSON array
      // Education fields
      highSchool: text("high_school"),
      // User's high school name
      collegeUniversity: text("college_university"),
      // User's college/university name
      // Status
      isActive: boolean("is_active").default(true),
      maxMentees: integer("max_mentees"),
      // For mentors
      currentMentees: integer("current_mentees").default(0),
      // For mentors
      // Field visibility preferences (JSON string)
      visibilityPreferences: text("visibility_preferences"),
      // Metadata
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow()
    });
    suiteNetworkingProfiles = pgTable("suite_networking_profiles", {
      id: serial("id").primaryKey(),
      userId: integer("user_id").notNull().references(() => users.id),
      // Professional identity
      professionalTagline: text("professional_tagline"),
      currentRole: text("current_role"),
      currentCompany: text("current_company"),
      industry: text("industry"),
      experienceYears: integer("experience_years"),
      // Networking goals
      networkingGoals: text("networking_goals"),
      // JSON array of goals
      lookingFor: text("looking_for"),
      // What they're seeking: collaboration, advice, partnerships, etc.
      canOffer: text("can_offer"),
      // What they can provide to others
      // Interests and causes
      professionalInterests: text("professional_interests"),
      // JSON array
      causesIPassionate: text("causes_passionate"),
      // JSON array of causes they care about
      // Collaboration preferences
      collaborationTypes: text("collaboration_types"),
      // JSON array: ['Projects', 'Startups', 'Research', 'Volunteering']
      workingStyle: text("working_style"),
      // 'Remote-first', 'In-person', 'Flexible'
      timeCommitment: text("time_commitment"),
      // How much time they can dedicate
      // Fun and personal
      lightUpWhenTalking: text("light_up_when_talking"),
      // Fun prompt response
      wantToMeetSomeone: text("want_to_meet_someone"),
      // "I'd love to meet someone who..."
      currentProjects: text("current_projects"),
      // JSON array of current projects
      dreamCollaboration: text("dream_collaboration"),
      // Availability and contact
      preferredMeetingStyle: text("preferred_meeting_style"),
      // JSON array: ['Coffee chat', 'Virtual call', 'Coworking', 'Events']
      availability: text("availability"),
      // General availability
      // Geographic preferences
      location: text("location"),
      openToRemote: boolean("open_to_remote").default(true),
      preferredLocations: text("preferred_locations"),
      // JSON array for in-person meetups
      // Education fields
      highSchool: text("high_school"),
      // User's high school name
      collegeUniversity: text("college_university"),
      // User's college/university name
      // Status and visibility
      isActive: boolean("is_active").default(true),
      lookingForOpportunities: boolean("looking_for_opportunities").default(true),
      // Field visibility preferences (JSON string)
      visibilityPreferences: text("visibility_preferences"),
      // Metadata
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow()
    });
    suiteProfileSettings = pgTable("suite_profile_settings", {
      id: serial("id").primaryKey(),
      userId: integer("user_id").notNull().references(() => users.id).unique(),
      // Profile activation status
      jobProfileActive: boolean("job_profile_active").default(false),
      mentorshipProfileActive: boolean("mentorship_profile_active").default(false),
      networkingProfileActive: boolean("networking_profile_active").default(false),
      // Discovery preferences (consistent with profile_hidden logic: false = visible, true = hidden)
      // NEW USERS START HIDDEN: All discovery toggles default to true (hidden) for new users
      hiddenInJobDiscovery: boolean("hidden_in_job_discovery").default(true),
      hiddenInMentorshipDiscovery: boolean(
        "hidden_in_mentorship_discovery"
      ).default(true),
      hiddenInNetworkingDiscovery: boolean(
        "hidden_in_networking_discovery"
      ).default(true),
      // Primary profile preference
      primaryProfileType: text("primary_profile_type"),
      // 'job', 'mentorship', 'networking'
      // Metadata
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow()
    });
    suiteFieldVisibility = pgTable(
      "suite_field_visibility",
      {
        id: serial("id").primaryKey(),
        userId: integer("user_id").notNull().references(() => users.id),
        profileType: text("profile_type").notNull().$type(),
        fieldName: text("field_name").notNull(),
        isVisible: boolean("is_visible").notNull().default(true),
        createdAt: timestamp("created_at").defaultNow(),
        updatedAt: timestamp("updated_at").defaultNow()
      },
      (table) => ({
        uniqueUserProfileField: unique().on(
          table.userId,
          table.profileType,
          table.fieldName
        )
      })
    );
    connectionsPreferences = pgTable("connections_preferences", {
      id: serial("id").primaryKey(),
      userId: integer("user_id").notNull().references(() => users.id).unique(),
      // Mentorship Preferences
      mentorshipLookingFor: text("mentorship_looking_for").array(),
      // ['mentors', 'mentees', 'both']
      mentorshipExperienceLevel: text("mentorship_experience_level").array(),
      // ['junior', 'mid', 'senior', 'executive']
      mentorshipIndustries: text("mentorship_industries").array(),
      mentorshipAreasOfExpertise: text("mentorship_areas_of_expertise").array(),
      // ['software-development', 'data-science', 'marketing', etc.]
      mentorshipEducationLevel: text("mentorship_education_level").array(),
      // ['high-school', 'bachelor', 'master', 'phd', 'other']
      mentorshipSkills: text("mentorship_skills").array(),
      // ['python', 'javascript', 'leadership', etc.]
      mentorshipTopics: text("mentorship_topics").array(),
      // Learning/teaching topics
      mentorshipFormat: text("mentorship_format").array(),
      // ['one-on-one', 'group', 'virtual', 'in-person']
      mentorshipTimeCommitment: text("mentorship_time_commitment"),
      // ['flexible', 'weekly', 'monthly', 'project-based']
      mentorshipLocationPreference: text("mentorship_location_preference"),
      // ['local', 'regional', 'national', 'international']
      mentorshipWeights: text("mentorship_weights"),
      // JSON string of preference weights
      // Networking Preferences
      networkingPurpose: text("networking_purpose").array(),
      // ['partnerships', 'opportunities', 'knowledge', 'insights']
      networkingCompanySize: text("networking_company_size").array(),
      // ['startup', 'sme', 'enterprise', 'nonprofit']
      networkingSeniority: text("networking_seniority").array(),
      // ['individual', 'manager', 'director', 'executive']
      networkingIndustries: text("networking_industries").array(),
      networkingAreasOfExpertise: text("networking_areas_of_expertise").array(),
      // ['software-development', 'data-science', 'marketing', etc.]
      networkingEducationLevel: text("networking_education_level").array(),
      // ['high-school', 'bachelor', 'master', 'phd', 'other']
      networkingSkills: text("networking_skills").array(),
      // ['python', 'javascript', 'leadership', etc.]
      networkingFunctionalAreas: text("networking_functional_areas").array(),
      // ['sales', 'marketing', 'engineering', etc.]
      networkingLocationPreference: text("networking_location_preference"),
      // 'local', 'regional', 'national', 'international'
      networkingEventPreference: text("networking_event_preference").array(),
      // ['virtual', 'in-person', 'conferences', 'casual']
      networkingWeights: text("networking_weights"),
      // JSON string of preference weights
      // Jobs Preferences
      jobsTypes: text("jobs_types").array(),
      // ['full-time', 'part-time', 'contract', 'freelance']
      jobsSalaryRange: text("jobs_salary_range").array(),
      // ['0-30k', '30k-50k', '50k-75k', etc.]
      jobsSalaryCurrency: text("jobs_salary_currency"),
      // 'USD', 'EUR', 'GHS', etc.
      jobsSalaryMin: integer("jobs_salary_min"),
      // Minimum salary amount
      jobsSalaryMax: integer("jobs_salary_max"),
      // Maximum salary amount
      jobsSalaryPeriod: text("jobs_salary_period"),
      // '/hour', '/day', '/month', '/year'
      jobsWorkArrangement: text("jobs_work_arrangement").array(),
      // ['remote', 'hybrid', 'on-site']
      jobsCompanySize: text("jobs_company_size").array(),
      // ['startup', 'sme', 'enterprise']
      jobsIndustries: text("jobs_industries").array(),
      jobsEducationLevel: text("jobs_education_level").array(),
      // ['high-school', 'bachelor', 'master', 'phd', 'other']
      jobsSkills: text("jobs_skills").array(),
      // ['python', 'javascript', 'leadership', etc.]
      jobsExperienceLevel: text("jobs_experience_level").array(),
      // ['entry', 'mid', 'senior', 'lead', 'executive']
      jobsFunctionalAreas: text("jobs_functional_areas").array(),
      jobsWorkLocation: text("jobs_work_location"),
      // ['local', 'regional', 'national', 'international']
      jobsWeights: text("jobs_weights"),
      // JSON string of preference weights
      // Global Settings
      dealBreakers: text("deal_breakers").array(),
      // Global deal breakers across all types
      preferenceProfiles: text("preference_profiles"),
      // JSON string of saved preference sets
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow()
    });
    insertUserSchema = createInsertSchema(users).pick({
      username: true,
      password: true,
      fullName: true,
      email: true,
      phoneNumber: true,
      gender: true,
      location: true,
      dateOfBirth: true,
      ethnicity: true,
      secondaryTribe: true,
      photoUrl: true,
      verifiedByPhone: true
    });
    userProfileSchema = createInsertSchema(users).pick({
      email: true,
      ethnicity: true,
      secondaryTribe: true,
      photoUrl: true,
      showProfilePhoto: true,
      dateOfBirth: true,
      phoneNumber: true,
      twoFactorEnabled: true,
      profileHidden: true,
      ghostMode: true,
      interests: true,
      showAppModeSelection: true,
      showNationalitySelection: true,
      lastUsedApp: true,
      isSuspended: true,
      suspendedAt: true,
      suspensionExpiresAt: true
    }).extend({
      // Override fields to make them nullable during updates (the fields we want to be able to clear)
      location: z.string().nullable(),
      bio: z.string().nullable(),
      profession: z.string().nullable(),
      religion: z.string().nullable(),
      relationshipGoal: z.string().nullable(),
      // New fields added to the schema
      countryOfOrigin: z.string().nullable(),
      secondaryCountryOfOrigin: z.string().nullable(),
      relationshipStatus: z.string().nullable(),
      // Education fields
      highSchool: z.string().nullable(),
      collegeUniversity: z.string().nullable(),
      // New matching algorithm fields
      bodyType: z.string().nullable(),
      height: z.number().nullable(),
      hasChildren: z.string().nullable(),
      wantsChildren: z.string().nullable(),
      educationLevel: z.string().nullable(),
      matchingPriorities: z.string().nullable(),
      // Smoking and drinking preferences
      smoking: z.string().nullable(),
      drinking: z.string().nullable(),
      // Special flags for update operations (not stored in database)
      clearingFields: z.boolean().optional(),
      visibilityPreferences: z.string().optional(),
      // App flow control toggles
      showAppModeSelection: z.boolean().optional(),
      showNationalitySelection: z.boolean().optional(),
      lastUsedApp: z.string().optional(),
      // Language preference for cross-device sync
      preferredLanguage: z.string().optional(),
      // Avatar toggle (optional in updates)
      showAvatar: z.boolean().optional()
    });
    insertBlockedPhoneNumberSchema = createInsertSchema(
      blockedPhoneNumbers
    ).pick({
      phoneNumber: true,
      reason: true,
      metadata: true
    });
    insertUserReportStrikeSchema = createInsertSchema(
      userReportStrikes
    ).pick({
      reportedUserId: true,
      reporterUserId: true,
      reason: true,
      description: true,
      matchId: true
    });
    userPreferencesSchema = createInsertSchema(userPreferences).pick({
      minAge: true,
      maxAge: true,
      locationPreference: true,
      poolCountry: true,
      // Legacy field maintained for compatibility
      meetPoolCountry: true,
      // MEET app specific pool country
      suitePoolCountry: true,
      // SUITE app specific pool country
      ethnicityPreference: true,
      religionPreference: true,
      relationshipGoalPreference: true,
      distancePreference: true,
      educationLevelPreference: true,
      hasChildrenPreference: true,
      wantsChildrenPreference: true,
      minHeightPreference: true,
      maxHeightPreference: true,
      bodyTypePreference: true,
      dealBreakers: true,
      interestPreferences: true,
      matchingPriorities: true,
      smokingPreference: true,
      drinkingPreference: true,
      highSchoolPreference: true
    });
    insertMatchSchema = createInsertSchema(matches).pick({
      userId1: true,
      userId2: true,
      matched: true,
      isDislike: true
    });
    insertMessageSchema = createInsertSchema(messages).pick({
      matchId: true,
      senderId: true,
      receiverId: true,
      content: true,
      messageType: true,
      audioUrl: true,
      audioDuration: true,
      replyToMessageId: true,
      replyToContent: true,
      replyToSenderName: true,
      replyToIsCurrentUser: true
    });
    insertUserInterestSchema = createInsertSchema(userInterests).pick({
      userId: true,
      interest: true,
      showOnProfile: true
    });
    insertGlobalInterestSchema = createInsertSchema(
      globalInterests
    ).pick({
      interest: true,
      category: true,
      createdBy: true
    });
    insertGlobalDealBreakerSchema = createInsertSchema(
      globalDealBreakers
    ).pick({
      dealBreaker: true,
      createdBy: true
    });
    insertGlobalTribeSchema = createInsertSchema(globalTribes).pick({
      tribe: true,
      category: true,
      createdBy: true
    });
    insertGlobalReligionSchema = createInsertSchema(
      globalReligions
    ).pick({
      religion: true,
      category: true,
      createdBy: true
    });
    insertTypingStatusSchema = createInsertSchema(typingStatus).pick({
      userId: true,
      matchId: true,
      isTyping: true
    });
    insertVideoCallSchema = createInsertSchema(videoCalls).pick({
      matchId: true,
      initiatorId: true,
      receiverId: true,
      roomName: true,
      status: true
    });
    insertVerificationCodeSchema = createInsertSchema(
      verificationCodes
    ).pick({
      phoneNumber: true,
      code: true,
      expiresAt: true
    });
    insertUserPhotoSchema = createInsertSchema(userPhotos).omit({
      id: true,
      createdAt: true
    });
    updateUserPhotoPrimarySchema = createInsertSchema(userPhotos).pick(
      {
        isPrimary: true,
        isPrimaryForMeet: true,
        isPrimaryForJob: true,
        isPrimaryForMentorship: true,
        isPrimaryForNetworking: true
      }
    );
    insertMessageReactionSchema = createInsertSchema(
      messageReactions
    ).pick({
      messageId: true,
      userId: true,
      emoji: true
    });
    insertUserMatchSettingsSchema = createInsertSchema(
      userMatchSettings
    ).pick({
      userId: true,
      matchId: true,
      autoDeleteMode: true,
      autoDeleteValue: true,
      autoDeleteUnit: true
    });
    insertCompatibilityAnalysisSchema = createInsertSchema(
      compatibilityAnalysis
    ).pick({
      user1Id: true,
      user2Id: true,
      compatibilityData: true,
      overallScore: true,
      version: true,
      isActive: true
    });
    insertSuiteCompatibilityScoreSchema = createInsertSchema(
      suiteCompatibilityScores
    ).pick({
      userId: true,
      targetUserId: true,
      targetProfileId: true,
      synergyScore: true,
      networkValueScore: true,
      collaborationScore: true,
      exchangeScore: true,
      overallStarRating: true,
      analysisData: true,
      insights: true,
      suggestedActions: true,
      geographicFit: true,
      culturalAlignment: true,
      isActive: true
    });
    insertUserBlockSchema = createInsertSchema(userBlocks).pick({
      blockerUserId: true,
      blockedUserId: true,
      reason: true
    });
    insertArchivedMatchSchema = insertMatchSchema;
    insertArchivedMessageSchema = insertMessageSchema;
    insertArchivedUserSchema = insertUserSchema;
    insertSuiteJobProfileSchema = createInsertSchema(
      suiteJobProfiles
    ).pick({
      userId: true,
      jobTitle: true,
      company: true,
      description: true,
      compensation: true,
      requirements: true,
      location: true,
      workType: true,
      jobType: true,
      experienceLevel: true,
      whyItMatters: true,
      whoShouldApply: true,
      culturalFit: true,
      industryTags: true,
      skillTags: true,
      applicationUrl: true,
      applicationEmail: true,
      applicationInstructions: true,
      isActive: true,
      expiresAt: true
    });
    insertSuiteMentorshipProfileSchema = createInsertSchema(
      suiteMentorshipProfiles
    ).pick({
      userId: true,
      role: true,
      areasOfExpertise: true,
      learningGoals: true,
      mentorshipStyle: true,
      preferredFormat: true,
      communicationStyle: true,
      availability: true,
      timeCommitment: true,
      location: true,
      successStories: true,
      whyMentor: true,
      whySeekMentorship: true,
      preferredMentorshipStyle: true,
      industryAspiration: true,
      preferredMenteeLevel: true,
      preferredMentorExperience: true,
      preferredIndustries: true,
      highSchool: true,
      collegeUniversity: true,
      isActive: true,
      maxMentees: true,
      currentMentees: true
    });
    insertSuiteNetworkingProfileSchema = createInsertSchema(
      suiteNetworkingProfiles
    ).pick({
      userId: true,
      professionalTagline: true,
      currentRole: true,
      currentCompany: true,
      industry: true,
      experienceYears: true,
      networkingGoals: true,
      lookingFor: true,
      canOffer: true,
      professionalInterests: true,
      causesIPassionate: true,
      collaborationTypes: true,
      workingStyle: true,
      timeCommitment: true,
      lightUpWhenTalking: true,
      wantToMeetSomeone: true,
      currentProjects: true,
      dreamCollaboration: true,
      preferredMeetingStyle: true,
      availability: true,
      location: true,
      openToRemote: true,
      preferredLocations: true,
      highSchool: true,
      collegeUniversity: true,
      isActive: true,
      lookingForOpportunities: true,
      visibilityPreferences: true
    });
    insertSuiteProfileSettingsSchema = createInsertSchema(
      suiteProfileSettings
    ).pick({
      userId: true,
      jobProfileActive: true,
      mentorshipProfileActive: true,
      networkingProfileActive: true,
      hiddenInJobDiscovery: true,
      hiddenInMentorshipDiscovery: true,
      hiddenInNetworkingDiscovery: true,
      primaryProfileType: true
    });
    insertSuiteFieldVisibilitySchema = createInsertSchema(
      suiteFieldVisibility
    ).pick({
      userId: true,
      profileType: true,
      fieldName: true,
      isVisible: true
    });
    swipeHistory = pgTable("swipe_history", {
      id: serial("id").primaryKey(),
      userId: integer("user_id").notNull(),
      targetUserId: integer("target_user_id").notNull(),
      action: text("action").notNull(),
      // 'like', 'dislike', 'message'
      appMode: text("app_mode").notNull(),
      // 'MEET', 'SUITE'
      timestamp: timestamp("timestamp").defaultNow()
    });
    insertSwipeHistorySchema = createInsertSchema(swipeHistory).pick({
      userId: true,
      targetUserId: true,
      action: true,
      appMode: true
    });
    archivedMatches = pgTable("archived_matches", {
      id: serial("id").primaryKey(),
      originalMatchId: integer("original_match_id").notNull(),
      // Original match ID before deletion
      userId1: integer("user_id_1").notNull(),
      // User IDs (not FK since users might be deleted)
      userId2: integer("user_id_2").notNull(),
      matched: boolean("matched").notNull(),
      isDislike: boolean("is_dislike").notNull(),
      hasUnreadMessages1: boolean("has_unread_messages_1").notNull(),
      hasUnreadMessages2: boolean("has_unread_messages_2").notNull(),
      notifiedUser1: boolean("notified_user_1").notNull(),
      notifiedUser2: boolean("notified_user_2").notNull(),
      lastMessageAt: timestamp("last_message_at"),
      matchCreatedAt: timestamp("match_created_at").notNull(),
      // Original match creation time
      archivedAt: timestamp("archived_at").defaultNow(),
      // When archived
      archivedReason: text("archived_reason").notNull(),
      // 'unmatch', 'user_deletion', 'admin_action'
      archivedByUserId: integer("archived_by_user_id"),
      // Who triggered the archival
      messageCount: integer("message_count").default(0)
      // Total messages in this match
    });
    archivedMessages = pgTable("archived_messages", {
      id: serial("id").primaryKey(),
      originalMessageId: integer("original_message_id").notNull(),
      // Original message ID before deletion
      originalMatchId: integer("original_match_id").notNull(),
      // Original match ID
      archivedMatchId: integer("archived_match_id").notNull().references(() => archivedMatches.id),
      // Reference to archived match
      senderId: integer("sender_id").notNull(),
      // User IDs (not FK since users might be deleted)
      receiverId: integer("receiver_id").notNull(),
      content: text("content").notNull(),
      encryptedContent: text("encrypted_content"),
      iv: text("initialization_vector"),
      messageType: text("message_type").default("text"),
      audioUrl: text("audio_url"),
      audioDuration: integer("audio_duration"),
      read: boolean("read").notNull(),
      readAt: timestamp("read_at"),
      messageCreatedAt: timestamp("message_created_at").notNull(),
      // Original message creation time
      archivedAt: timestamp("archived_at").defaultNow(),
      // When archived
      archivedReason: text("archived_reason").notNull(),
      // 'unmatch', 'user_deletion', 'admin_action'
      // Reply functionality preserved
      replyToMessageId: integer("reply_to_message_id"),
      replyToContent: text("reply_to_content"),
      replyToSenderName: text("reply_to_sender_name"),
      replyToIsCurrentUser: boolean("reply_to_is_current_user"),
      // Auto-delete functionality preserved
      autoDeleteScheduledAt: timestamp("auto_delete_scheduled_at"),
      autoDeleteModeWhenSent: text("auto_delete_mode_when_sent"),
      deletedForUserId: integer("deleted_for_user_id")
    });
    archivedUsers = pgTable("archived_users", {
      id: serial("id").primaryKey(),
      originalUserId: integer("original_user_id").notNull(),
      // Original user ID before deletion
      username: text("username").notNull(),
      fullName: text("full_name").notNull(),
      email: text("email").notNull(),
      phoneNumber: text("phone_number"),
      gender: text("gender").notNull(),
      location: text("location").notNull(),
      countryOfOrigin: text("country_of_origin"),
      bio: text("bio"),
      profession: text("profession"),
      ethnicity: text("ethnicity"),
      secondaryTribe: text("secondary_tribe"),
      religion: text("religion"),
      photoUrl: text("photo_url"),
      showProfilePhoto: boolean("show_profile_photo"),
      dateOfBirth: timestamp("date_of_birth"),
      relationshipStatus: text("relationship_status"),
      relationshipGoal: text("relationship_goal"),
      interests: text("interests"),
      visibilityPreferences: text("visibility_preferences"),
      verifiedByPhone: boolean("verified_by_phone"),
      twoFactorEnabled: boolean("two_factor_enabled"),
      profileHidden: boolean("profile_hidden"),
      ghostMode: boolean("ghost_mode"),
      isOnline: boolean("is_online"),
      lastActive: timestamp("last_active"),
      userCreatedAt: timestamp("user_created_at").notNull(),
      // Original user creation time
      archivedAt: timestamp("archived_at").defaultNow(),
      // When archived
      archivedReason: text("archived_reason").notNull(),
      // 'account_deletion', 'admin_action', 'policy_violation'
      archivedByUserId: integer("archived_by_user_id"),
      // Who triggered the archival (admin or self)
      totalMatches: integer("total_matches").default(0),
      // Historical match count
      totalMessages: integer("total_messages").default(0),
      // Historical message count
      ipAddress: text("ip_address"),
      // Last known IP for security
      userAgent: text("user_agent")
      // Last known user agent for security
    });
    suiteNetworkingConnections = pgTable(
      "suite_networking_connections",
      {
        id: serial("id").primaryKey(),
        userId: integer("user_id").notNull().references(() => users.id),
        // User who performed the action
        targetProfileId: integer("target_profile_id").notNull().references(() => suiteNetworkingProfiles.id),
        // Target networking profile
        targetUserId: integer("target_user_id").notNull().references(() => users.id),
        // Owner of the target profile
        action: text("action").notNull(),
        // 'like' or 'pass'
        matched: boolean("matched").notNull().default(false),
        // True if mutual like
        isDislike: boolean("is_dislike").notNull().default(false),
        // True if this is a dislike (pass action)
        createdAt: timestamp("created_at").defaultNow()
      },
      (table) => {
        return {
          // Ensure one action per user-profile combination
          uniqueUserProfile: unique().on(table.userId, table.targetProfileId)
        };
      }
    );
    suiteMentorshipConnections = pgTable(
      "suite_mentorship_connections",
      {
        id: serial("id").primaryKey(),
        userId: integer("user_id").notNull().references(() => users.id),
        // User who performed the action
        targetProfileId: integer("target_profile_id").notNull().references(() => suiteMentorshipProfiles.id),
        // Target mentorship profile
        targetUserId: integer("target_user_id").notNull().references(() => users.id),
        // Owner of the target profile
        action: text("action").notNull(),
        // 'like' or 'pass'
        matched: boolean("matched").notNull().default(false),
        // True if mutual like
        isDislike: boolean("is_dislike").notNull().default(false),
        // True if this is a dislike (pass action)
        createdAt: timestamp("created_at").defaultNow()
      },
      (table) => {
        return {
          // Ensure one action per user-profile combination
          uniqueUserProfile: unique().on(table.userId, table.targetProfileId)
        };
      }
    );
    suiteJobApplications = pgTable(
      "suite_job_applications",
      {
        id: serial("id").primaryKey(),
        userId: integer("user_id").notNull().references(() => users.id),
        // User who applied
        targetProfileId: integer("target_profile_id").notNull().references(() => suiteJobProfiles.id),
        // Target job profile
        targetUserId: integer("target_user_id").notNull().references(() => users.id),
        // Job poster
        action: text("action").notNull(),
        // 'like' or 'pass'
        applicationStatus: text("application_status").default("pending"),
        // 'pending', 'accepted', 'rejected', 'matched'
        matched: boolean("matched").default(false).notNull(),
        createdAt: timestamp("created_at").defaultNow()
      },
      (table) => {
        return {
          // Ensure one application per user-job combination
          uniqueUserJob: unique().on(table.userId, table.targetProfileId)
        };
      }
    );
    professionalReviews = pgTable(
      "professional_reviews",
      {
        id: serial("id").primaryKey(),
        reviewedUserId: integer("reviewed_user_id").notNull().references(() => users.id),
        // User being reviewed
        reviewerUserId: integer("reviewer_user_id").notNull().references(() => users.id),
        // User writing the review
        rating: integer("rating").notNull(),
        // 1-5 star rating
        reviewText: text("review_text").notNull(),
        // Review comment
        isAnonymous: boolean("is_anonymous").default(false),
        // Whether reviewer wants to stay anonymous
        category: text("category").notNull().default("general"),
        // 'general', 'reliability', 'communication', 'skills'
        createdAt: timestamp("created_at").defaultNow(),
        updatedAt: timestamp("updated_at").defaultNow()
      },
      (table) => ({
        // Ensure one review per user pair per category
        uniqueReview: unique().on(
          table.reviewedUserId,
          table.reviewerUserId,
          table.category
        )
      })
    );
    insertSuiteNetworkingConnectionSchema = createInsertSchema(
      suiteNetworkingConnections
    ).pick({
      userId: true,
      targetProfileId: true,
      targetUserId: true,
      action: true,
      matched: true,
      isDislike: true
    });
    insertSuiteMentorshipConnectionSchema = createInsertSchema(
      suiteMentorshipConnections
    ).pick({
      userId: true,
      targetProfileId: true,
      targetUserId: true,
      action: true,
      matched: true,
      isDislike: true
    });
    insertSuiteJobApplicationSchema = createInsertSchema(
      suiteJobApplications
    ).pick({
      userId: true,
      targetProfileId: true,
      targetUserId: true,
      action: true,
      applicationStatus: true,
      matched: true
    });
    insertProfessionalReviewSchema = createInsertSchema(
      professionalReviews
    ).pick({
      reviewedUserId: true,
      reviewerUserId: true,
      rating: true,
      reviewText: true,
      isAnonymous: true,
      category: true
    });
    subscriptions = pgTable("subscriptions", {
      id: serial("id").primaryKey(),
      userId: integer("user_id").notNull().references(() => users.id),
      provider: text("provider").notNull(),
      // 'stripe', 'flutterwave', 'paystack'
      subscriptionId: text("subscription_id").notNull(),
      // External subscription ID from provider
      planType: text("plan_type").notNull(),
      // 'premium_monthly', 'premium_yearly', 'premium_quarterly'
      status: text("status").notNull(),
      // 'active', 'cancelled', 'past_due', 'incomplete', 'incomplete_expired', 'trialing', 'unpaid'
      currentPeriodStart: timestamp("current_period_start").notNull(),
      currentPeriodEnd: timestamp("current_period_end").notNull(),
      cancelAtPeriodEnd: boolean("cancel_at_period_end").default(false),
      cancelledAt: timestamp("cancelled_at"),
      currency: text("currency").notNull().default("USD"),
      // 'USD', 'GHS', 'EUR', 'GBP'
      amount: integer("amount").notNull(),
      // Amount in cents (e.g., $9.99 = 999)
      paymentMethod: text("payment_method").notNull(),
      // 'card', 'mobile_money', 'bank_transfer', 'digital_wallet'
      region: text("region").notNull(),
      // 'ghana', 'diaspora', 'africa', 'global'
      trialEnd: timestamp("trial_end"),
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow()
    });
    paymentMethods = pgTable("payment_methods", {
      id: serial("id").primaryKey(),
      userId: integer("user_id").notNull().references(() => users.id),
      provider: text("provider").notNull(),
      // 'stripe', 'flutterwave', 'paystack'
      externalId: text("external_id").notNull(),
      // Provider's payment method ID
      type: text("type").notNull(),
      // 'card', 'mobile_money', 'bank_transfer', 'digital_wallet'
      isDefault: boolean("is_default").default(false),
      metadata: text("metadata"),
      // JSON string containing payment method details (last4, mobile number, bank name, etc.)
      // Billing Address Information
      billingName: text("billing_name"),
      // Full name for billing
      billingEmail: text("billing_email"),
      // Email address for billing
      billingPhone: text("billing_phone"),
      // Phone number for billing
      billingAddress: text("billing_address"),
      // Street address
      billingCity: text("billing_city"),
      // City
      billingState: text("billing_state"),
      // State/Province
      billingPostalCode: text("billing_postal_code"),
      // Postal/ZIP code
      billingCountry: text("billing_country"),
      // Country
      nickname: text("nickname"),
      // User-friendly name for the payment method
      isActive: boolean("is_active").default(true),
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow()
    });
    paymentHistory = pgTable("payment_history", {
      id: serial("id").primaryKey(),
      subscriptionId: integer("subscription_id").notNull().references(() => subscriptions.id),
      userId: integer("user_id").notNull().references(() => users.id),
      provider: text("provider").notNull(),
      // 'stripe', 'flutterwave', 'paystack'
      providerTransactionId: text("provider_transaction_id").notNull(),
      // External transaction ID
      amount: integer("amount").notNull(),
      // Amount in cents
      currency: text("currency").notNull(),
      // 'USD', 'GHS', 'EUR', 'GBP'
      status: text("status").notNull(),
      // 'succeeded', 'pending', 'failed', 'cancelled', 'refunded'
      paymentMethod: text("payment_method").notNull(),
      // 'card', 'mobile_money', 'bank_transfer'
      paymentMethodId: integer("payment_method_id").references(
        () => paymentMethods.id
      ),
      failureReason: text("failure_reason"),
      // Reason if payment failed
      refundAmount: integer("refund_amount"),
      // Refund amount in cents if applicable
      metadata: text("metadata"),
      // JSON string for additional transaction details
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow()
    });
    subscriptionEvents2 = pgTable("subscription_events", {
      id: serial("id").primaryKey(),
      subscriptionId: integer("subscription_id").notNull().references(() => subscriptions.id),
      userId: integer("user_id").notNull().references(() => users.id),
      eventType: text("event_type").notNull(),
      // 'created', 'updated', 'cancelled', 'reactivated', 'payment_failed', 'payment_succeeded'
      provider: text("provider").notNull(),
      // 'stripe', 'flutterwave', 'paystack'
      providerEventId: text("provider_event_id"),
      // External event ID from webhook
      oldStatus: text("old_status"),
      // Previous subscription status
      newStatus: text("new_status"),
      // New subscription status
      metadata: text("metadata"),
      // JSON string for event details
      createdAt: timestamp("created_at").defaultNow()
    });
    regionalPricing = pgTable("regional_pricing", {
      id: serial("id").primaryKey(),
      planType: text("plan_type").notNull(),
      // 'premium_monthly', 'premium_yearly', 'premium_quarterly'
      region: text("region").notNull(),
      // 'ghana', 'diaspora', 'nigeria', 'kenya', 'south_africa', 'global'
      currency: text("currency").notNull(),
      // 'USD', 'GHS', 'NGN', 'KES', 'ZAR', 'EUR', 'GBP'
      amount: integer("amount").notNull(),
      // Amount in cents
      discountPercentage: integer("discount_percentage").default(0),
      // Discount from base price
      isActive: boolean("is_active").default(true),
      validFrom: timestamp("valid_from").defaultNow(),
      validUntil: timestamp("valid_until"),
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow()
    });
    promotionalCodes = pgTable("promotional_codes", {
      id: serial("id").primaryKey(),
      code: text("code").notNull().unique(),
      // Promo code (e.g., 'WELCOME20', 'STUDENT50')
      type: text("type").notNull(),
      // 'percentage', 'fixed_amount', 'free_trial'
      value: integer("value").notNull(),
      // Discount value (percentage or amount in cents)
      currency: text("currency"),
      // Currency for fixed amount discounts
      planTypes: text("plan_types"),
      // JSON array of applicable plan types
      regions: text("regions"),
      // JSON array of applicable regions
      maxUses: integer("max_uses"),
      // Maximum number of uses (null = unlimited)
      currentUses: integer("current_uses").default(0),
      validFrom: timestamp("valid_from").defaultNow(),
      validUntil: timestamp("valid_until"),
      isActive: boolean("is_active").default(true),
      createdByUserId: integer("created_by_user_id").references(() => users.id),
      metadata: text("metadata"),
      // JSON string for additional promo details
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow()
    });
    promotionalCodeUsage = pgTable("promotional_code_usage", {
      id: serial("id").primaryKey(),
      promoCodeId: integer("promo_code_id").notNull().references(() => promotionalCodes.id),
      userId: integer("user_id").notNull().references(() => users.id),
      subscriptionId: integer("subscription_id").references(() => subscriptions.id),
      discountAmount: integer("discount_amount").notNull(),
      // Actual discount applied in cents
      currency: text("currency").notNull(),
      usedAt: timestamp("used_at").defaultNow()
    });
    insertSubscriptionSchema = createInsertSchema(subscriptions).pick({
      userId: true,
      provider: true,
      subscriptionId: true,
      planType: true,
      status: true,
      currentPeriodStart: true,
      currentPeriodEnd: true,
      cancelAtPeriodEnd: true,
      cancelledAt: true,
      currency: true,
      amount: true,
      paymentMethod: true,
      region: true,
      trialEnd: true
    });
    insertPaymentMethodSchema = createInsertSchema(
      paymentMethods
    ).pick({
      userId: true,
      provider: true,
      externalId: true,
      type: true,
      isDefault: true,
      metadata: true,
      billingName: true,
      billingEmail: true,
      billingPhone: true,
      billingAddress: true,
      billingCity: true,
      billingState: true,
      billingPostalCode: true,
      billingCountry: true,
      nickname: true,
      isActive: true
    });
    insertPaymentHistorySchema = createInsertSchema(
      paymentHistory
    ).pick({
      subscriptionId: true,
      userId: true,
      provider: true,
      providerTransactionId: true,
      amount: true,
      currency: true,
      status: true,
      paymentMethod: true,
      paymentMethodId: true,
      failureReason: true,
      refundAmount: true,
      metadata: true
    });
    insertSubscriptionEventSchema = createInsertSchema(
      subscriptionEvents2
    ).pick({
      subscriptionId: true,
      userId: true,
      eventType: true,
      provider: true,
      providerEventId: true,
      oldStatus: true,
      newStatus: true,
      metadata: true
    });
    insertRegionalPricingSchema = createInsertSchema(
      regionalPricing
    ).pick({
      planType: true,
      region: true,
      currency: true,
      amount: true,
      discountPercentage: true,
      isActive: true,
      validFrom: true,
      validUntil: true
    });
    insertPromotionalCodeSchema = createInsertSchema(
      promotionalCodes
    ).pick({
      code: true,
      type: true,
      value: true,
      currency: true,
      planTypes: true,
      regions: true,
      maxUses: true,
      currentUses: true,
      validFrom: true,
      validUntil: true,
      isActive: true,
      createdByUserId: true,
      metadata: true
    });
    insertPromotionalCodeUsageSchema = createInsertSchema(
      promotionalCodeUsage
    ).pick({
      promoCodeId: true,
      userId: true,
      subscriptionId: true,
      discountAmount: true,
      currency: true
    });
    suiteMentorshipCompatibilityScores = pgTable(
      "suite_mentorship_compatibility_scores",
      {
        id: serial("id").primaryKey(),
        userId: integer("user_id").notNull().references(() => users.id),
        // Always store smaller user ID first to prevent duplicates
        targetUserId: integer("target_user_id").notNull().references(() => users.id),
        // Always store larger user ID second to prevent duplicates
        targetProfileId: integer("target_profile_id").notNull().references(() => suiteMentorshipProfiles.id),
        // Specific mentorship profile
        // 6D Mentorship Compatibility Model
        expertiseRelevance: integer("expertise_relevance").notNull(),
        // Mentor expertise to mentee goals match (1-10)
        mentorshipStyleFit: integer("mentorship_style_fit").notNull(),
        // Teaching/learning style compatibility (1-10)
        timeSynergy: integer("time_synergy").notNull(),
        // Time commitment and availability alignment (1-10)
        communicationFit: integer("communication_fit").notNull(),
        // Communication style and channel match (1-10)
        contextualAlignment: integer("contextual_alignment").notNull(),
        // Geographic, linguistic, cultural fit (1-10)
        growthGapPotential: integer("growth_gap_potential").notNull(),
        // Optimal experience delta (1-10)
        overallCompatibilityScore: integer("overall_compatibility_score").notNull(),
        // Final percentage score (1-100)
        // Success prediction metrics
        successProbability: integer("success_probability").notNull(),
        // 90-day success likelihood (1-100)
        breakthroughMomentPrediction: integer(
          "breakthrough_moment_prediction"
        ).notNull(),
        // When insights typically occur (weeks)
        plateauRiskAssessment: integer("plateau_risk_assessment").notNull(),
        // Stagnation risk level (1-10)
        // Detailed analysis data
        analysisData: text("analysis_data").notNull(),
        // JSON with comprehensive breakdown
        insights: text("insights").notNull(),
        // JSON array of key insights
        conversationStarters: text("conversation_starters").notNull(),
        // JSON array of AI-generated talking points
        mentorshipRoadmap: text("mentorship_roadmap").notNull(),
        // JSON with projected learning journey
        milestonePathway: text("milestone_pathway").notNull(),
        // JSON with predicted progress markers
        skillGapForecast: text("skill_gap_forecast").notNull(),
        // JSON with what mentee can learn
        // Metadata
        computedAt: timestamp("computed_at").defaultNow().notNull(),
        lastUpdated: timestamp("last_updated").defaultNow().notNull(),
        isActive: boolean("is_active").default(true).notNull()
      },
      (table) => {
        return {
          // Ensure one score per unique user pair (bidirectional constraint)
          uniqueUserPair: unique().on(table.userId, table.targetUserId)
        };
      }
    );
    insertSuiteMentorshipCompatibilityScoreSchema = createInsertSchema(
      suiteMentorshipCompatibilityScores
    ).pick({
      userId: true,
      targetUserId: true,
      targetProfileId: true,
      expertiseRelevance: true,
      mentorshipStyleFit: true,
      timeSynergy: true,
      communicationFit: true,
      contextualAlignment: true,
      growthGapPotential: true,
      overallCompatibilityScore: true,
      successProbability: true,
      breakthroughMomentPrediction: true,
      plateauRiskAssessment: true,
      analysisData: true,
      insights: true,
      conversationStarters: true,
      mentorshipRoadmap: true,
      milestonePathway: true,
      skillGapForecast: true,
      isActive: true
    });
    insertConnectionsPreferencesSchema = createInsertSchema(
      connectionsPreferences
    ).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    kwameConversations = pgTable("kwame_conversations", {
      id: serial("id").primaryKey(),
      userId: integer("user_id").notNull().references(() => users.id),
      role: text("role").notNull(),
      // 'user' or 'assistant'
      content: text("content").notNull(),
      context: text("context"),
      // JSON string with additional context
      appMode: text("app_mode"),
      // 'MEET', 'SUITE', 'HEAT'
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow()
    });
    insertKwameConversationSchema = createInsertSchema(
      kwameConversations
    ).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
  }
});

// server/db.ts
var db_exports = {};
__export(db_exports, {
  db: () => db,
  pool: () => pool
});
import { drizzle } from "drizzle-orm/neon-serverless";
import { neonConfig, Pool } from "@neondatabase/serverless";
import ws from "ws";
var pool, db;
var init_db = __esm({
  "server/db.ts"() {
    "use strict";
    init_schema();
    if (typeof process !== "undefined" && process.versions?.node) {
      neonConfig.fetchConnectionCache = true;
      neonConfig.webSocketConstructor = ws;
      process.env["NODE_TLS_REJECT_UNAUTHORIZED"] = "0";
    }
    pool = new Pool({
      connectionString: process.env.DATABASE_URL,
      ssl: process.env.NODE_ENV === "production" ? true : false
    });
    db = drizzle(pool, {
      schema: {
        users,
        userPreferences,
        matches,
        messages,
        userInterests,
        typingStatus,
        videoCalls,
        globalInterests,
        globalDealBreakers,
        globalTribes,
        globalReligions,
        verificationCodes,
        userPhotos,
        messageReactions,
        userMatchSettings,
        suiteJobProfiles,
        suiteMentorshipProfiles,
        suiteNetworkingProfiles,
        suiteProfileSettings,
        compatibilityAnalysis,
        kwameConversations
      }
    });
  }
});

// server/storage.ts
import session from "express-session";
import {
  eq,
  and,
  or,
  ne,
  desc,
  asc,
  sql,
  count,
  notInArray,
  inArray,
  isNull,
  notExists
} from "drizzle-orm";
import connectPg from "connect-pg-simple";
import createMemoryStore from "memorystore";
var PostgresSessionStore, MemoryStore, DatabaseStorage, storage;
var init_storage = __esm({
  "server/storage.ts"() {
    "use strict";
    init_schema();
    init_db();
    PostgresSessionStore = connectPg(session);
    MemoryStore = createMemoryStore(session);
    DatabaseStorage = class {
      sessionStore;
      constructor() {
        this.sessionStore = new PostgresSessionStore({
          pool,
          createTableIfMissing: true,
          tableName: "user_sessions",
          // Increased prune interval to keep more inactive sessions available
          pruneSessionInterval: 24 * 60 * 60
          // 24 hours in seconds
        });
      }
      // User operations
      async getUser(id) {
        const [user] = await db.select().from(users).where(eq(users.id, id));
        return user;
      }
      async getUserByUsername(username) {
        const allUsers = await this.getAllUsers();
        return allUsers.find(
          (user) => user.username.toLowerCase() === username.toLowerCase()
        );
      }
      async getUserByEmail(email) {
        const allUsers = await this.getAllUsers();
        return allUsers.find(
          (user) => user.email.toLowerCase() === email.toLowerCase()
        );
      }
      async getUserByPhoneNumber(phoneNumber) {
        if (!phoneNumber) {
          return void 0;
        }
        const allUsers = await this.getAllUsers();
        const matchingUsers = allUsers.filter(
          (user) => user.phoneNumber === phoneNumber
        );
        if (matchingUsers.length > 1) {
          console.warn(
            `WARNING: Found ${matchingUsers.length} users with the same phone number: ${phoneNumber}`
          );
          console.warn(
            `Matching user IDs: ${matchingUsers.map((u) => u.id).join(", ")}`
          );
          matchingUsers.sort((a, b) => {
            const dateA = a.createdAt ? new Date(a.createdAt).getTime() : 0;
            const dateB = b.createdAt ? new Date(b.createdAt).getTime() : 0;
            return dateB - dateA;
          });
          return matchingUsers[0];
        }
        return matchingUsers[0];
      }
      async getAllUsers() {
        return await db.select().from(users);
      }
      // Phone verification methods
      async createVerificationCode(verificationData) {
        const [code] = await db.insert(verificationCodes).values(verificationData).returning();
        return code;
      }
      async getVerificationCode(phoneNumber, code) {
        const [verificationCode] = await db.select().from(verificationCodes).where(
          and(
            eq(verificationCodes.phoneNumber, phoneNumber),
            eq(verificationCodes.code, code)
          )
        );
        return verificationCode;
      }
      async deleteVerificationCode(id) {
        await db.delete(verificationCodes).where(eq(verificationCodes.id, id));
      }
      async deleteExpiredVerificationCodes() {
        const now = /* @__PURE__ */ new Date();
        await db.delete(verificationCodes).where(
          // Using raw SQL to compare dates
          sql`${verificationCodes.expiresAt} < ${now}`
        );
      }
      // Blocked phone numbers for age compliance
      async addBlockedPhoneNumber(phoneNumber, reason, fullName, email, metadata) {
        const [blocked] = await db.insert(blockedPhoneNumbers).values({ phoneNumber, reason, fullName, email, metadata }).returning();
        return blocked;
      }
      async isPhoneNumberBlocked(phoneNumber) {
        const blocked = await db.select().from(blockedPhoneNumbers).where(eq(blockedPhoneNumbers.phoneNumber, phoneNumber)).limit(1);
        return blocked.length > 0;
      }
      async getBlockedPhoneNumber(phoneNumber) {
        const blocked = await db.select().from(blockedPhoneNumbers).where(eq(blockedPhoneNumbers.phoneNumber, phoneNumber)).limit(1);
        return blocked[0];
      }
      async isEmailInBlockedPhoneNumbers(email) {
        const normalized = email.trim().toLowerCase();
        const blocked = await db.select().from(blockedPhoneNumbers).where(eq(blockedPhoneNumbers.email, normalized)).limit(1);
        return blocked[0];
      }
      async createUser(insertUser) {
        let userData = {
          ...insertUser,
          createdAt: /* @__PURE__ */ new Date()
        };
        if (userData.dateOfBirth) {
          try {
            if (userData.dateOfBirth instanceof Date) {
              console.log("Date object already provided");
            } else if (typeof userData.dateOfBirth === "string") {
              userData.dateOfBirth = new Date(userData.dateOfBirth);
              console.log("Converted string to Date:", userData.dateOfBirth);
            } else {
              console.log(
                "Invalid date type, removing:",
                typeof userData.dateOfBirth
              );
              delete userData.dateOfBirth;
            }
            if (userData.dateOfBirth && isNaN(userData.dateOfBirth.getTime())) {
              console.log("Invalid date, removing field");
              delete userData.dateOfBirth;
            }
          } catch (err) {
            console.error("Error parsing date:", err);
            delete userData.dateOfBirth;
          }
        }
        console.log("Final user data for DB:", userData);
        userData.profileHidden = true;
        userData.premiumAccess = false;
        const [user] = await db.insert(users).values(userData).returning();
        return user;
      }
      async updateUserProfile(id, profile) {
        try {
          const existingUser = await this.getUser(id);
          if (!existingUser) {
            throw new Error(`User with ID ${id} not found`);
          }
          if (Object.keys(profile).length === 0) {
            throw new Error("No values to set");
          }
          const isVisibilityPreferencesOnlyUpdate = Object.keys(profile).length === 1 && "visibilityPreferences" in profile;
          if (isVisibilityPreferencesOnlyUpdate && profile.visibilityPreferences) {
            console.log("Special handling for visibilityPreferences-only update");
            try {
              await db.execute(sql`
            UPDATE users 
            SET visibility_preferences = ${profile.visibilityPreferences}
            WHERE id = ${id}
          `);
              return await this.getUser(id);
            } catch (directUpdateError) {
              console.error(
                "Error in direct visibility preferences update:",
                directUpdateError
              );
              throw new Error(
                `Database error: ${directUpdateError?.message || "Unknown database error"}`
              );
            }
          }
          const isClearingFields = profile.clearingFields === true;
          console.log("Profile update with clearingFields flag:", isClearingFields);
          delete profile.clearingFields;
          let visibilityPreferences;
          if ("visibilityPreferences" in profile) {
            visibilityPreferences = profile.visibilityPreferences;
            delete profile.visibilityPreferences;
          }
          const cleanProfile = {};
          for (const [key, value] of Object.entries(profile)) {
            if (value === null) {
              cleanProfile[key] = null;
              continue;
            }
            if (value === "") {
              if (isClearingFields) {
                cleanProfile[key] = null;
              }
              continue;
            }
            if (value !== void 0) {
              cleanProfile[key] = value;
            }
          }
          if (visibilityPreferences) {
            cleanProfile.visibilityPreferences = visibilityPreferences;
          }
          console.log("Clean profile data for update:", cleanProfile);
          if (Object.keys(cleanProfile).length === 0) {
            if (isClearingFields) {
              const originalKeys = Object.keys(profile);
              if (originalKeys.length > 0) {
                const fieldToClear = originalKeys[0];
                cleanProfile[fieldToClear] = null;
                console.log(
                  `Explicitly clearing field "${fieldToClear}" with null value`
                );
              } else {
                throw new Error("No fields specified for clearing operation");
              }
            } else {
              throw new Error("No valid values to set after filtering");
            }
          }
          console.log("Updating user profile with clean data:", cleanProfile);
          try {
            const [updatedUser] = await db.update(users).set(cleanProfile).where(eq(users.id, id)).returning();
            return updatedUser;
          } catch (dbError) {
            console.error(`Database error updating user ${id}:`, dbError);
            throw new Error(
              `Database error: ${dbError?.message || "Unknown database error"}`
            );
          }
        } catch (error) {
          console.error(`Error updating user profile for user ${id}:`, error);
          throw error;
        }
      }
      async updateUser(id, updates) {
        try {
          const [updatedUser] = await db.update(users).set(updates).where(eq(users.id, id)).returning();
          console.log(`User ${id} updated successfully`);
          return updatedUser;
        } catch (error) {
          console.error(`Error updating user ${id}:`, error);
          if (error instanceof Error) {
            throw new Error(`Database error: ${error.message}`);
          } else {
            throw new Error("Unknown database error");
          }
        }
      }
      async updateUserPassword(userId, hashedPassword) {
        await db.update(users).set({ password: hashedPassword }).where(eq(users.id, userId));
      }
      async deleteUser(userId) {
        console.log(`Starting complete user deletion for user ${userId}...`);
        try {
          await db.transaction(async (tx) => {
            const userResult = await tx.execute(
              sql`SELECT phone_number FROM users WHERE id = ${userId}`
            );
            const userPhone = userResult.rows[0]?.phone_number;
            console.log(`Deleting all dependent records for user ${userId}...`);
            await tx.execute(
              sql`DELETE FROM payment_history WHERE user_id = ${userId}`
            );
            await tx.execute(
              sql`DELETE FROM payment_methods WHERE user_id = ${userId}`
            );
            await tx.execute(
              sql`DELETE FROM subscriptions WHERE user_id = ${userId}`
            );
            await tx.execute(
              sql`DELETE FROM promotional_code_usage WHERE user_id = ${userId}`
            );
            await tx.execute(
              sql`DELETE FROM message_reactions WHERE user_id = ${userId}`
            );
            await tx.execute(
              sql`DELETE FROM messages WHERE sender_id = ${userId} OR receiver_id = ${userId} OR deleted_for_user_id = ${userId}`
            );
            await tx.execute(
              sql`DELETE FROM typing_status WHERE user_id = ${userId}`
            );
            await tx.execute(
              sql`DELETE FROM video_calls WHERE initiator_id = ${userId} OR receiver_id = ${userId}`
            );
            await tx.execute(
              sql`DELETE FROM matches WHERE user_id_1 = ${userId} OR user_id_2 = ${userId}`
            );
            await tx.execute(
              sql`DELETE FROM swipe_history WHERE user_id = ${userId} OR target_user_id = ${userId}`
            );
            await tx.execute(
              sql`DELETE FROM compatibility_analysis WHERE user1_id = ${userId} OR user2_id = ${userId}`
            );
            await tx.execute(
              sql`DELETE FROM suite_compatibility_scores WHERE user_id = ${userId} OR target_user_id = ${userId}`
            );
            await tx.execute(
              sql`DELETE FROM suite_mentorship_compatibility_scores WHERE user_id = ${userId} OR target_user_id = ${userId}`
            );
            await tx.execute(
              sql`DELETE FROM suite_networking_connections WHERE user_id = ${userId} OR target_user_id = ${userId}`
            );
            await tx.execute(
              sql`DELETE FROM suite_mentorship_connections WHERE user_id = ${userId} OR target_user_id = ${userId}`
            );
            await tx.execute(
              sql`DELETE FROM suite_job_applications WHERE user_id = ${userId} OR target_user_id = ${userId}`
            );
            await tx.execute(
              sql`DELETE FROM suite_message_reactions WHERE user_id = ${userId}`
            );
            await tx.execute(
              sql`DELETE FROM suite_messages WHERE sender_id = ${userId} OR receiver_id = ${userId}`
            );
            await tx.execute(
              sql`DELETE FROM professional_reviews WHERE user_id = ${userId} OR target_user_id = ${userId}`
            );
            await tx.execute(
              sql`DELETE FROM user_report_strikes WHERE reporter_user_id = ${userId} OR reported_user_id = ${userId}`
            );
            await tx.execute(
              sql`DELETE FROM user_photos WHERE user_id = ${userId}`
            );
            await tx.execute(
              sql`DELETE FROM user_preferences WHERE user_id = ${userId}`
            );
            await tx.execute(
              sql`DELETE FROM user_interests WHERE user_id = ${userId}`
            );
            await tx.execute(
              sql`DELETE FROM user_match_settings WHERE user_id = ${userId}`
            );
            await tx.execute(
              sql`DELETE FROM user_auto_delete_settings WHERE user_id = ${userId}`
            );
            await tx.execute(
              sql`DELETE FROM connections_preferences WHERE user_id = ${userId}`
            );
            await tx.execute(
              sql`DELETE FROM suite_job_profiles WHERE user_id = ${userId}`
            );
            await tx.execute(
              sql`DELETE FROM suite_mentorship_profiles WHERE user_id = ${userId}`
            );
            await tx.execute(
              sql`DELETE FROM suite_networking_profiles WHERE user_id = ${userId}`
            );
            await tx.execute(
              sql`DELETE FROM suite_profile_settings WHERE user_id = ${userId}`
            );
            await tx.execute(
              sql`DELETE FROM suite_field_visibility WHERE user_id = ${userId}`
            );
            await tx.execute(
              sql`DELETE FROM global_interests WHERE created_by = ${userId}`
            );
            await tx.execute(
              sql`DELETE FROM global_deal_breakers WHERE created_by = ${userId}`
            );
            if (userPhone) {
              await tx.execute(
                sql`DELETE FROM verification_codes WHERE phone_number = ${userPhone}`
              );
            }
            await tx.execute(sql`DELETE FROM users WHERE id = ${userId}`);
            console.log(
              `Successfully deleted user ${userId} and all related data using comprehensive SQL approach`
            );
          });
        } catch (error) {
          console.error(`Failed to delete user ${userId}:`, error);
          try {
            console.log(`Attempting simplified deletion for user ${userId}...`);
            await db.delete(users).where(eq(users.id, userId));
            console.log(`Successfully deleted user ${userId} with cascade`);
          } catch (simpleError) {
            console.error(
              `Both deletion methods failed for user ${userId}:`,
              simpleError
            );
            throw new Error(
              `Cannot delete user: Database constraints prevent deletion`
            );
          }
        }
      }
      async cleanAllUsers() {
        await db.delete(messages);
        await db.delete(matches);
        await db.delete(userPreferences);
        await db.delete(userInterests);
        await db.delete(typingStatus);
        await db.delete(videoCalls);
        await db.delete(verificationCodes);
        await db.delete(userPhotos);
        await db.delete(globalInterests);
        await db.delete(users);
        console.log(
          "All users and related data have been deleted from the database"
        );
      }
      // Preferences operations
      async getUserPreferences(userId) {
        try {
          const [preference] = await db.select().from(userPreferences).where(eq(userPreferences.userId, userId));
          return preference;
        } catch (error) {
          console.error(`Error getting preferences for user ${userId}:`, error);
          return void 0;
        }
      }
      // 🚀 PERFORMANCE OPTIMIZATION: Batch load user preferences
      async batchGetUserPreferences(userIds) {
        try {
          if (userIds.length === 0) return [];
          const startTime = Date.now();
          const preferences = await db.select().from(userPreferences).where(inArray(userPreferences.userId, userIds));
          const duration = Date.now() - startTime;
          console.log(
            `[BATCH-PERFORMANCE] Loaded ${preferences.length} preferences for ${userIds.length} users in ${duration}ms`
          );
          return preferences;
        } catch (error) {
          console.error(
            `Error batch getting preferences for users ${userIds}:`,
            error
          );
          return [];
        }
      }
      async createUserPreferences(preferences) {
        const [userPreference] = await db.insert(userPreferences).values(preferences).returning();
        return userPreference;
      }
      async updateUserPreferences(id, preferences) {
        const [updatedPreference] = await db.update(userPreferences).set(preferences).where(eq(userPreferences.id, id)).returning();
        return updatedPreference;
      }
      async updateUserLocationPreference(userId, location) {
        let userPrefs = await this.getUserPreferences(userId);
        if (userPrefs) {
          await this.updateUserPreferences(userPrefs.id, {
            locationPreference: location
          });
        } else {
          await this.createUserPreferences({
            userId,
            locationPreference: location,
            minAge: null,
            maxAge: null,
            distancePreference: null
          });
        }
      }
      async updateUserPoolCountry(userId, poolCountry) {
        let userPrefs = await this.getUserPreferences(userId);
        if (userPrefs) {
          return await this.updateUserPreferences(userPrefs.id, {
            poolCountry
          });
        } else {
          return await this.createUserPreferences({
            userId,
            poolCountry,
            minAge: null,
            maxAge: null,
            distancePreference: null
          });
        }
      }
      async updateUserAppSpecificPoolCountry(userId, poolCountry, appMode) {
        let userPrefs = await this.getUserPreferences(userId);
        const updateData = {};
        if (appMode === "MEET") {
          updateData.meetPoolCountry = poolCountry;
        } else {
          updateData.suitePoolCountry = poolCountry;
        }
        if (userPrefs) {
          return await this.updateUserPreferences(userPrefs.id, updateData);
        } else {
          return await this.createUserPreferences({
            userId,
            minAge: null,
            maxAge: null,
            distancePreference: null,
            meetPoolCountry: appMode === "MEET" ? poolCountry : "ANYWHERE",
            suitePoolCountry: appMode === "SUITE" ? poolCountry : "ANYWHERE",
            poolCountry
            // Also set legacy field for compatibility
          });
        }
      }
      // Match operations
      async createMatch(match) {
        console.log(
          `[CREATE-MATCH-DEBUG] Attempting to create match between users ${match.userId1} and ${match.userId2}`
        );
        const existingMatch = await this.getMatchBetweenUsers(
          match.userId1,
          match.userId2
        );
        if (existingMatch) {
          console.log(
            `[CREATE-MATCH-DEBUG] Found existing match ${existingMatch.id}, matched: ${existingMatch.matched}, metadata: ${existingMatch.metadata}`
          );
          return existingMatch;
        }
        const [newMatch2] = await db.insert(matches).values({
          ...match,
          matched: match.matched ?? false,
          hasUnreadMessages1: false,
          hasUnreadMessages2: false,
          notifiedUser1: false,
          notifiedUser2: false,
          metadata: match.metadata || null,
          createdAt: /* @__PURE__ */ new Date()
        }).returning();
        console.log(`[CREATE-MATCH-DEBUG] Successfully created new match:`, {
          id: newMatch2.id,
          userId1: newMatch2.userId1,
          userId2: newMatch2.userId2,
          matched: newMatch2.matched,
          metadata: newMatch2.metadata
        });
        if (newMatch2.matched) {
          console.log(
            `[SWIPE-CLEANUP] Starting cleanup for CREATED match between users ${newMatch2.userId1} and ${newMatch2.userId2}`
          );
          try {
            await this.removeMatchedUsersFromSwipeHistory(
              newMatch2.userId1,
              newMatch2.userId2
            );
          } catch (cleanupError) {
            console.error(
              `[SWIPE-CLEANUP] Failed for CREATED match ${newMatch2.id}:`,
              cleanupError
            );
          }
        }
        return newMatch2;
      }
      async getMatchById(id) {
        const [match] = await db.select().from(matches).where(eq(matches.id, id));
        return match;
      }
      async getMatchesByUserId(userId) {
        return await db.select().from(matches).where(
          and(
            // User is in the match
            or(eq(matches.userId1, userId), eq(matches.userId2, userId)),
            // No blocking exists between users (bidirectional check)
            notExists(
              db.select().from(userBlocks).where(
                or(
                  // Current user hasn't blocked the other user
                  and(
                    eq(userBlocks.blockerUserId, userId),
                    or(
                      eq(userBlocks.blockedUserId, matches.userId1),
                      eq(userBlocks.blockedUserId, matches.userId2)
                    )
                  ),
                  // Other user hasn't blocked current user
                  and(
                    or(
                      eq(userBlocks.blockerUserId, matches.userId1),
                      eq(userBlocks.blockerUserId, matches.userId2)
                    ),
                    eq(userBlocks.blockedUserId, userId)
                  )
                )
              )
            )
          )
        );
      }
      // Removed broken optimization function - using working getUserMatches instead
      // Get only MEET-originated matches (excludes SUITE matches) and blocked users
      async getMeetMatchesByUserId(userId) {
        return await db.select().from(matches).where(
          and(
            or(eq(matches.userId1, userId), eq(matches.userId2, userId)),
            or(
              isNull(matches.metadata),
              // Legacy MEET matches without metadata
              sql`${matches.metadata}::jsonb->>'suiteType' IS NULL`
              // Explicit MEET matches
            ),
            // No blocking exists between users (bidirectional check)
            notExists(
              db.select().from(userBlocks).where(
                or(
                  // Current user hasn't blocked the other user
                  and(
                    eq(userBlocks.blockerUserId, userId),
                    or(
                      eq(userBlocks.blockedUserId, matches.userId1),
                      eq(userBlocks.blockedUserId, matches.userId2)
                    )
                  ),
                  // Other user hasn't blocked current user
                  and(
                    or(
                      eq(userBlocks.blockerUserId, matches.userId1),
                      eq(userBlocks.blockerUserId, matches.userId2)
                    ),
                    eq(userBlocks.blockedUserId, userId)
                  )
                )
              )
            )
          )
        );
      }
      async getMatchBetweenUsers(userId1, userId2) {
        const [match] = await db.select().from(matches).where(
          or(
            and(eq(matches.userId1, userId1), eq(matches.userId2, userId2)),
            and(eq(matches.userId1, userId2), eq(matches.userId2, userId1))
          )
        );
        return match;
      }
      async getAllMatchesBetweenUsers(userId1, userId2) {
        const allMatches = await db.select().from(matches).where(
          or(
            and(eq(matches.userId1, userId1), eq(matches.userId2, userId2)),
            and(eq(matches.userId1, userId2), eq(matches.userId2, userId1))
          )
        ).orderBy(desc(matches.id));
        return allMatches;
      }
      async updateMatchStatus(matchId, matched) {
        const [updatedMatch] = await db.update(matches).set({
          matched,
          // Reset notification flags when updating match status
          notifiedUser1: false,
          notifiedUser2: false
        }).where(eq(matches.id, matchId)).returning();
        return updatedMatch;
      }
      async removeLikeOrDislike(userId, targetUserId) {
        const match = await this.getMatchBetweenUsers(userId, targetUserId);
        if (match) {
          await db.delete(matches).where(eq(matches.id, match.id));
          console.log(
            `Removed match ${match.id} between users ${userId} and ${targetUserId}`
          );
        } else {
          console.log(
            `No match found between users ${userId} and ${targetUserId} to remove`
          );
        }
      }
      // Get matches created after a specific timestamp for a user
      async getMatchesSince(userId, since) {
        return await db.select().from(matches).where(
          and(
            or(eq(matches.userId1, userId), eq(matches.userId2, userId)),
            sql`${matches.createdAt} > ${since}`
          )
        ).orderBy(desc(matches.createdAt));
      }
      // Get count of unread message notifications for a user (total unread messages)
      async getUnreadMessageCount(userId) {
        try {
          console.log(
            `[UNREAD-OPTIMIZED] User ${userId}: Starting optimized unread count query`
          );
          const startTime = Date.now();
          const [result] = await db.select({
            unreadCount: sql`COUNT(*)`
          }).from(messages).innerJoin(matches, eq(messages.matchId, matches.id)).where(
            and(
              eq(messages.receiverId, userId),
              eq(messages.read, false),
              or(
                and(
                  eq(matches.userId1, userId),
                  eq(matches.hasUnreadMessages1, true)
                ),
                and(
                  eq(matches.userId2, userId),
                  eq(matches.hasUnreadMessages2, true)
                )
              )
            )
          );
          const duration = Date.now() - startTime;
          const unreadCount = Number(result?.unreadCount) || 0;
          console.log(
            `[UNREAD-OPTIMIZED] User ${userId}: Query completed in ${duration}ms, found ${unreadCount} unread messages`
          );
          return unreadCount;
        } catch (error) {
          console.error("Error getting unread message count:", error);
          return 0;
        }
      }
      // Get count of conversations with unread messages for navigation badge - OPTIMIZED VERSION
      async getUnreadConversationsCount(userId) {
        try {
          const result = await db.execute(sql`
        SELECT COUNT(DISTINCT msg.match_id) AS unread_conversation_count
        FROM messages msg
        JOIN matches m ON msg.match_id = m.id
        WHERE msg.receiver_id = ${userId}
          AND msg.sender_id <> ${userId}
          AND msg.read = FALSE
          AND ((m.user_id_1 = ${userId} AND m.has_unread_messages_1 = TRUE)
            OR (m.user_id_2 = ${userId} AND m.has_unread_messages_2 = TRUE))
      `);
          const rows = result.rows;
          if (rows && rows.length > 0 && rows[0].unread_conversation_count !== void 0) {
            return Number(rows[0].unread_conversation_count);
          }
          console.log(
            "Falling back to original unread conversations count implementation"
          );
          const userMatches = await this.getMatchesByUserId(userId);
          let conversationsWithUnread = 0;
          for (const match of userMatches) {
            if (match.userId1 === userId && match.hasUnreadMessages1 || match.userId2 === userId && match.hasUnreadMessages2) {
              const matchMessages = await this.getMessagesByMatchId(match.id);
              const hasUnreadFromOther = matchMessages.some(
                (message) => message.receiverId === userId && message.senderId !== userId && !message.read
              );
              if (hasUnreadFromOther) {
                conversationsWithUnread++;
              }
            }
          }
          return conversationsWithUnread;
        } catch (error) {
          console.error("Error getting unread conversations count:", error);
          return 0;
        }
      }
      // Mark a match as having unread messages for the receiver
      async markMatchUnread(matchId, receiverId) {
        const match = await this.getMatchById(matchId);
        if (!match) return void 0;
        let updateFields = {};
        if (match.userId1 === receiverId) {
          updateFields = { hasUnreadMessages1: true, lastMessageAt: /* @__PURE__ */ new Date() };
        } else if (match.userId2 === receiverId) {
          updateFields = { hasUnreadMessages2: true, lastMessageAt: /* @__PURE__ */ new Date() };
        }
        const [updatedMatch] = await db.update(matches).set(updateFields).where(eq(matches.id, matchId)).returning();
        return updatedMatch;
      }
      // Mark a match as read for a specific user
      async markMatchRead(matchId, userId) {
        const match = await this.getMatchById(matchId);
        if (!match) return void 0;
        let updateFields = {};
        if (match.userId1 === userId) {
          updateFields = { hasUnreadMessages1: false };
        } else if (match.userId2 === userId) {
          updateFields = { hasUnreadMessages2: false };
        }
        const [updatedMatch] = await db.update(matches).set(updateFields).where(eq(matches.id, matchId)).returning();
        return updatedMatch;
      }
      // Mark match notification as delivered for a user
      async markMatchNotified(matchId, userId) {
        const match = await this.getMatchById(matchId);
        if (!match) return void 0;
        let updateFields = {};
        if (match.userId1 === userId) {
          updateFields = { notifiedUser1: true };
        } else if (match.userId2 === userId) {
          updateFields = { notifiedUser2: true };
        }
        const [updatedMatch] = await db.update(matches).set(updateFields).where(eq(matches.id, matchId)).returning();
        return updatedMatch;
      }
      async updateMatch(id, updates) {
        const updateFields = {
          ...updates,
          // When a match is confirmed, reset notification status
          ...updates.matched ? {
            notifiedUser1: false,
            notifiedUser2: false,
            hasUnreadMessages1: true,
            // Set unread for both users to show notification badge
            hasUnreadMessages2: true,
            isDislike: false
            // A confirmed match can't be a dislike
          } : {}
        };
        if (updates.metadata !== void 0) {
          updateFields.metadata = updates.metadata;
        }
        const [updatedMatch] = await db.update(matches).set(updateFields).where(eq(matches.id, id)).returning();
        if (updatedMatch && updates.matched) {
          console.log(
            `[SWIPE-CLEANUP] Starting cleanup for UPDATED match ${updatedMatch.id} between users ${updatedMatch.userId1} and ${updatedMatch.userId2}`
          );
          try {
            await this.removeMatchedUsersFromSwipeHistory(
              updatedMatch.userId1,
              updatedMatch.userId2
            );
          } catch (cleanupError) {
            console.error(
              `[SWIPE-CLEANUP] Failed for UPDATED match ${updatedMatch.id}:`,
              cleanupError
            );
          }
        }
        return updatedMatch;
      }
      async deleteMatch(id) {
        await db.delete(messages).where(eq(messages.matchId, id));
        await db.delete(matches).where(eq(matches.id, id));
      }
      // Message operations with duplicate prevention
      async createMessage(message) {
        const recentTime = /* @__PURE__ */ new Date();
        recentTime.setSeconds(recentTime.getSeconds() - 2);
        try {
          const existingMessages = await db.select().from(messages).where(
            and(
              eq(messages.matchId, message.matchId),
              eq(messages.senderId, message.senderId),
              eq(messages.receiverId, message.receiverId),
              eq(messages.content, message.content),
              sql`${messages.createdAt} >= ${recentTime.toISOString()}`
            )
          ).limit(1);
          if (existingMessages.length > 0) {
            console.log(
              `[DOUBLE-PREVENTION] Prevented duplicate message: ${message.content} (already exists as ID ${existingMessages[0].id})`
            );
            await this.markMatchUnread(message.matchId, message.receiverId);
            return existingMessages[0];
          }
        } catch (error) {
          console.error("Error checking for duplicate messages:", error);
        }
        const [newMessage] = await db.insert(messages).values({
          ...message,
          messageType: message.messageType || "text",
          // Default to text if not specified
          read: false,
          createdAt: /* @__PURE__ */ new Date()
        }).returning();
        await this.markMatchUnread(message.matchId, message.receiverId);
        return newMessage;
      }
      /**
       * Gets a single message by its unique ID
       * Used for security validation in message operations
       */
      async getMessageById(id) {
        const [message] = await db.select().from(messages).where(eq(messages.id, id));
        return message;
      }
      /**
       * Retrieves messages for a specific match, with additional security validation
       * to ensure messages are only accessible to users who are part of the match
       * Also filters out messages that have been auto-deleted for the requesting user
       */
      async getMessagesByMatchId(matchId, userId) {
        if (userId) {
          const match = await this.getMatchById(matchId);
          if (!match || match.userId1 !== userId && match.userId2 !== userId) {
            console.warn(
              `Security: User ${userId} attempted to access messages for match ${matchId} they're not part of`
            );
            return [];
          }
        }
        const allMessages = await db.select().from(messages).where(eq(messages.matchId, matchId)).orderBy(asc(messages.createdAt));
        let filteredMessages = allMessages;
        if (userId) {
          filteredMessages = allMessages.filter((message) => {
            if (message.deletedForUserId === userId) {
              return false;
            }
            return true;
          });
        }
        const transformedMessages = filteredMessages.map((message) => {
          const transformedMessage = { ...message };
          if (message.replyToMessageId && message.replyToContent && message.replyToSenderName) {
            let isCurrentUser = false;
            if (userId && message.replyToMessageId) {
              const originalMessage = allMessages.find(
                (m) => m.id === message.replyToMessageId
              );
              if (originalMessage) {
                isCurrentUser = originalMessage.senderId === userId;
                console.log(
                  `\u{1F504} [REPLY-TRANSFORM] Message ${message.id} "${message.content}"`
                );
                console.log(
                  `   \u{1F4E7} Replying to message ${message.replyToMessageId} "${message.replyToContent}"`
                );
                console.log(
                  `   \u{1F464} Original message sender: ${originalMessage.senderId}, Current viewer: ${userId}`
                );
                console.log(
                  `   \u{1F3AF} isCurrentUser = ${isCurrentUser} (should show "${isCurrentUser ? "You" : message.replyToSenderName}")`
                );
                console.log(
                  `   \u{1F4DD} Stored senderName: "${message.replyToSenderName}"`
                );
              } else {
                console.log(
                  `\u26A0\uFE0F [REPLY-TRANSFORM] Could not find original message ${message.replyToMessageId} for reply`
                );
              }
            }
            transformedMessage.replyToMessage = {
              id: message.replyToMessageId,
              content: message.replyToContent,
              senderName: message.replyToSenderName,
              isCurrentUser
              // Now correctly calculated from viewer's perspective
            };
          }
          return transformedMessage;
        });
        return transformedMessages;
      }
      /**
       * Get the count of messages for a specific match
       * Used to determine if a match can be deleted during undo operations
       */
      async getMessageCountForMatch(matchId) {
        const messageCount = await db.select({ count: count() }).from(messages).where(eq(messages.matchId, matchId));
        return messageCount[0]?.count || 0;
      }
      async markMessageAsRead(id) {
        const [updatedMessage] = await db.update(messages).set({ read: true }).where(eq(messages.id, id)).returning();
        if (updatedMessage) {
          const match = await this.getMatchById(updatedMessage.matchId);
          if (match) {
            if (match.userId1 === updatedMessage.receiverId) {
              await this.markMatchRead(match.id, match.userId1);
            } else if (match.userId2 === updatedMessage.receiverId) {
              await this.markMatchRead(match.id, match.userId2);
            }
          }
        }
        return updatedMessage;
      }
      // Find recent duplicate messages to prevent re-sending the same message multiple times
      async findRecentDuplicateMessages(params) {
        const {
          matchId,
          senderId,
          content,
          messageType,
          since,
          caseInsensitive = false
        } = params;
        try {
          let messagesQuery = db.select().from(messages).where(
            and(
              eq(messages.matchId, matchId),
              eq(messages.senderId, senderId),
              eq(messages.messageType, messageType || "text"),
              sql`${messages.createdAt} >= ${since}`
            )
          ).orderBy(desc(messages.createdAt));
          const allMessages = await messagesQuery;
          if (caseInsensitive) {
            console.log(
              `[CASE-INSENSITIVE] Checking for duplicates of "${content}" with case-insensitive matching`
            );
            const trimmedLowerContent = content.trim().toLowerCase();
            const duplicates = allMessages.filter((msg) => {
              const msgContent = msg.content.trim().toLowerCase();
              return msgContent === trimmedLowerContent;
            });
            console.log(
              `[CASE-INSENSITIVE] Found ${duplicates.length} case-insensitive matches for "${content}"`
            );
            return duplicates;
          } else {
            return allMessages.filter((msg) => msg.content === content);
          }
        } catch (error) {
          console.error("Error finding duplicate messages:", error);
          return [];
        }
      }
      // Case-insensitive functionality has been merged into findRecentDuplicateMessages with the caseInsensitive parameter
      async markMessageAsReadWithTimestamp(id) {
        const [updatedMessage] = await db.update(messages).set({
          read: true,
          readAt: /* @__PURE__ */ new Date()
        }).where(eq(messages.id, id)).returning();
        if (updatedMessage) {
          const match = await this.getMatchById(updatedMessage.matchId);
          if (match) {
            if (match.userId1 === updatedMessage.receiverId) {
              await this.markMatchRead(match.id, match.userId1);
            } else if (match.userId2 === updatedMessage.receiverId) {
              await this.markMatchRead(match.id, match.userId2);
            }
          }
        }
        return updatedMessage;
      }
      // User interests operations
      async addUserInterest(interest) {
        const interestWithDefaults = {
          ...interest,
          showOnProfile: interest.showOnProfile !== void 0 ? interest.showOnProfile : true
        };
        const [userInterest] = await db.insert(userInterests).values(interestWithDefaults).returning();
        await this.updateUserInterestsJson(interest.userId);
        return userInterest;
      }
      // Helper method to sync interests to users table JSON column
      async updateUserInterestsJson(userId) {
        const userInterestsList = await this.getUserInterests(userId);
        const interestNames = userInterestsList.map((ui) => ui.interest);
        await db.update(users).set({ interests: JSON.stringify(interestNames) }).where(eq(users.id, userId));
      }
      async getUserInterests(userId) {
        return await db.select().from(userInterests).where(eq(userInterests.userId, userId));
      }
      async deleteAllUserInterests(userId) {
        await db.delete(userInterests).where(eq(userInterests.userId, userId));
        await this.updateUserInterestsJson(userId);
      }
      async deleteUserInterest(userId, interest) {
        await db.delete(userInterests).where(
          and(
            eq(userInterests.userId, userId),
            eq(userInterests.interest, interest)
          )
        );
        await this.updateUserInterestsJson(userId);
      }
      async updateUserInterestsVisibility(userId, showOnProfile) {
        await db.update(userInterests).set({ showOnProfile }).where(eq(userInterests.userId, userId));
      }
      // Global interests operations
      async addGlobalInterest(interest) {
        const [globalInterest] = await db.insert(globalInterests).values({
          ...interest,
          createdAt: /* @__PURE__ */ new Date()
        }).returning();
        return globalInterest;
      }
      async getAllGlobalInterests() {
        return await db.select().from(globalInterests).orderBy(asc(globalInterests.interest));
      }
      async getGlobalInterestByName(interest) {
        const [globalInterest] = await db.select().from(globalInterests).where(eq(globalInterests.interest, interest));
        return globalInterest;
      }
      // Global deal breakers operations
      async addGlobalDealBreaker(dealBreaker) {
        const [globalDealBreaker] = await db.insert(globalDealBreakers).values({
          ...dealBreaker,
          createdAt: /* @__PURE__ */ new Date()
        }).returning();
        return globalDealBreaker;
      }
      async getAllGlobalDealBreakers() {
        return await db.select().from(globalDealBreakers).orderBy(asc(globalDealBreakers.dealBreaker));
      }
      async getGlobalDealBreakerByName(dealBreaker) {
        const [globalDealBreaker] = await db.select().from(globalDealBreakers).where(eq(globalDealBreakers.dealBreaker, dealBreaker));
        return globalDealBreaker;
      }
      // Global tribes operations
      async addGlobalTribe(tribe) {
        const [globalTribe] = await db.insert(globalTribes).values({
          ...tribe,
          createdAt: /* @__PURE__ */ new Date()
        }).returning();
        return globalTribe;
      }
      async getAllGlobalTribes() {
        return await db.select().from(globalTribes).orderBy(asc(globalTribes.tribe));
      }
      async getGlobalTribeByName(tribe) {
        const [globalTribe] = await db.select().from(globalTribes).where(eq(globalTribes.tribe, tribe));
        return globalTribe;
      }
      // Global religions operations
      async addGlobalReligion(religion) {
        const [globalReligion] = await db.insert(globalReligions).values({
          ...religion,
          createdAt: /* @__PURE__ */ new Date()
        }).returning();
        return globalReligion;
      }
      async getAllGlobalReligions() {
        return await db.select().from(globalReligions).orderBy(asc(globalReligions.religion));
      }
      async getGlobalReligionByName(religion) {
        const [globalReligion] = await db.select().from(globalReligions).where(eq(globalReligions.religion, religion));
        return globalReligion;
      }
      // Get all users for discover page (optimized approach - faster queries, separate interests fetch)
      async getDiscoverUsers(userId) {
        try {
          const startTime = Date.now();
          const existingInteractions = await db.select({ targetUserId: matches.userId2 }).from(matches).where(
            and(
              eq(matches.userId1, userId),
              or(
                isNull(matches.metadata),
                // Legacy MEET matches
                sql`${matches.metadata}::jsonb->>'suiteType' IS NULL`,
                // Explicit MEET matches
                sql`${matches.metadata}::jsonb->'additionalConnections' ? 'MEET'`
                // SUITE matches with MEET added
              )
            )
          ).union(
            db.select({ targetUserId: matches.userId1 }).from(matches).where(
              and(
                eq(matches.userId2, userId),
                or(
                  isNull(matches.metadata),
                  sql`${matches.metadata}::jsonb->>'suiteType' IS NULL`,
                  sql`${matches.metadata}::jsonb->'additionalConnections' ? 'MEET'`
                )
              )
            )
          );
          const excludeUserIds = existingInteractions.map(
            (row) => row.targetUserId
          );
          excludeUserIds.push(userId);
          const swipeHistoryUsers = await db.select({ targetUserId: swipeHistory.targetUserId }).from(swipeHistory).where(
            and(
              eq(swipeHistory.userId, userId),
              eq(swipeHistory.appMode, "MEET")
            )
          );
          const swipeHistoryUserIds = swipeHistoryUsers.map(
            (row) => row.targetUserId
          );
          excludeUserIds.push(...swipeHistoryUserIds);
          const discoverUsers = await db.select().from(users).where(
            and(
              notInArray(
                users.id,
                excludeUserIds.length > 0 ? excludeUserIds : [0]
              ),
              // Exclude users with MEET interactions
              eq(users.profileHidden, false)
              // Only visible profiles
            )
          ).orderBy(desc(users.lastActive)).limit(50);
          const usersWithoutPasswords = discoverUsers.map((user) => {
            const { password, ...userWithoutPassword } = user;
            return {
              ...userWithoutPassword,
              visibleInterests: []
              // Empty for speed
            };
          });
          const duration = Date.now() - startTime;
          console.log(
            `[DISCOVER-FILTERED] User ${userId}: Query completed in ${duration}ms, excluded ${excludeUserIds.length} users, returning ${usersWithoutPasswords.length} users`
          );
          return usersWithoutPasswords;
        } catch (error) {
          console.error("Error in filtered getDiscoverUsers:", error);
          return [];
        }
      }
      // Potential matches
      async getPotentialMatches(userId) {
        const userMatches = await this.getMeetMatchesByUserId(userId);
        const matchedUserIds = userMatches.map(
          (match) => match.userId1 === userId ? match.userId2 : match.userId1
        );
        let potentialUsers = [];
        if (matchedUserIds.length > 0) {
          const conditions = matchedUserIds.map((matchId) => ne(users.id, matchId));
          conditions.push(ne(users.id, userId));
          potentialUsers = await db.select().from(users).where(and(...conditions));
        } else {
          potentialUsers = await db.select().from(users).where(ne(users.id, userId));
        }
        if (potentialUsers.length > 0) {
          return potentialUsers;
        }
        const currentTime = /* @__PURE__ */ new Date();
        const testUsers = [
          {
            id: 1001,
            username: "kofi_accra",
            password: "hashed_password",
            // Not a real password since it's just for display
            fullName: "Kofi Mensah",
            email: "kofi.mensah@example.com",
            phoneNumber: "+233501234567",
            gender: "Male",
            location: "Accra, Ghana",
            countryOfOrigin: "Ghana",
            bio: "Software developer passionate about creating technologies that unite the Ghanaian diaspora. Love exploring coastal towns on weekends.",
            profession: "Software Engineer",
            ethnicity: "Ashanti",
            secondaryTribe: "Ga",
            religion: "Christian",
            photoUrl: "https://randomuser.me/api/portraits/men/32.jpg",
            showProfilePhoto: true,
            dateOfBirth: new Date(1992, 5, 15),
            relationshipStatus: "Single",
            relationshipGoal: "Long-term relationship",
            interests: JSON.stringify([
              "Technology",
              "Coastal towns",
              "Software development"
            ]),
            visibilityPreferences: JSON.stringify({
              residence: true,
              countryOfOrigin: true,
              tribe: true,
              profession: true,
              religion: true,
              bio: true,
              relationshipStatus: true,
              relationshipGoal: true,
              interests: true
            }),
            verifiedByPhone: true,
            twoFactorEnabled: true,
            profileHidden: false,
            ghostMode: false,
            isOnline: true,
            lastActive: currentTime,
            createdAt: currentTime,
            showAppModeSelection: true,
            showNationalitySelection: true,
            lastUsedApp: "dating"
          },
          {
            id: 1002,
            username: "abenaa_london",
            password: "hashed_password",
            fullName: "Abena Osei",
            email: "abena.osei@example.com",
            phoneNumber: "+447912345678",
            gender: "Female",
            location: "London, UK",
            countryOfOrigin: "Ghana",
            bio: "Medical doctor in London with roots in Ghana. Love cooking traditional Ghanaian meals and bringing people together through culture and food.",
            profession: "Medical Doctor",
            ethnicity: "Fante",
            secondaryTribe: "Ashanti",
            religion: "Christian",
            photoUrl: "https://randomuser.me/api/portraits/women/67.jpg",
            showProfilePhoto: true,
            dateOfBirth: new Date(1990, 2, 3),
            relationshipStatus: "Single",
            relationshipGoal: "Long-term relationship",
            interests: JSON.stringify(["Medicine", "Cooking", "Culture", "Food"]),
            visibilityPreferences: JSON.stringify({
              residence: true,
              countryOfOrigin: true,
              tribe: true,
              profession: true,
              religion: true,
              bio: true,
              relationshipStatus: true,
              relationshipGoal: true,
              interests: true
            }),
            verifiedByPhone: true,
            twoFactorEnabled: true,
            profileHidden: false,
            ghostMode: false,
            isOnline: false,
            lastActive: new Date(currentTime.getTime() - 60 * 60 * 1e3),
            // 1 hour ago
            createdAt: currentTime,
            showAppModeSelection: true,
            showNationalitySelection: true,
            lastUsedApp: "dating"
          },
          {
            id: 1003,
            username: "kwame_ny",
            password: "hashed_password",
            fullName: "Kwame Boateng",
            email: "kwame.boateng@example.com",
            phoneNumber: "+12125551234",
            gender: "Male",
            location: "New York, USA",
            countryOfOrigin: "Ghana",
            bio: "Fintech entrepreneur connecting Africa to global markets. Passionate about Ghanaian art and supporting talent from the motherland.",
            profession: "Entrepreneur",
            ethnicity: "Ga",
            secondaryTribe: "Ewe",
            religion: "Spiritual",
            photoUrl: "https://randomuser.me/api/portraits/men/59.jpg",
            showProfilePhoto: true,
            dateOfBirth: new Date(1988, 8, 22),
            relationshipStatus: "Single",
            relationshipGoal: "Serious dating",
            interests: JSON.stringify([
              "Fintech",
              "African art",
              "Entrepreneurship"
            ]),
            visibilityPreferences: JSON.stringify({
              residence: true,
              countryOfOrigin: true,
              tribe: true,
              profession: true,
              religion: true,
              bio: true,
              relationshipStatus: true,
              relationshipGoal: true,
              interests: true
            }),
            verifiedByPhone: true,
            twoFactorEnabled: true,
            profileHidden: false,
            ghostMode: false,
            isOnline: true,
            lastActive: currentTime,
            createdAt: currentTime,
            showAppModeSelection: true,
            showNationalitySelection: true,
            lastUsedApp: "dating"
          },
          {
            id: 1004,
            username: "adwoa_kumasi",
            password: "hashed_password",
            fullName: "Adwoa Asamoah",
            email: "adwoa.asamoah@example.com",
            phoneNumber: "+233261234567",
            gender: "Female",
            location: "Kumasi, Ghana",
            countryOfOrigin: "Ghana",
            bio: "Fashion designer blending traditional Kente with modern styles. Looking for someone who appreciates both tradition and innovation.",
            profession: "Fashion Designer",
            ethnicity: "Ashanti",
            secondaryTribe: "Fante",
            religion: "Christian",
            photoUrl: "https://randomuser.me/api/portraits/women/16.jpg",
            showProfilePhoto: true,
            dateOfBirth: new Date(1993, 11, 5),
            relationshipStatus: "Single",
            relationshipGoal: "Long-term relationship",
            interests: JSON.stringify(["Fashion", "Kente", "Design", "Tradition"]),
            visibilityPreferences: JSON.stringify({
              residence: true,
              countryOfOrigin: true,
              tribe: true,
              profession: true,
              religion: true,
              bio: true,
              relationshipStatus: true,
              relationshipGoal: true,
              interests: true
            }),
            verifiedByPhone: true,
            twoFactorEnabled: true,
            profileHidden: false,
            ghostMode: false,
            isOnline: true,
            lastActive: currentTime,
            createdAt: currentTime,
            showAppModeSelection: true,
            showNationalitySelection: true,
            lastUsedApp: "dating"
          },
          {
            id: 1005,
            username: "kwesi_toronto",
            password: "hashed_password",
            fullName: "Kwesi Adjei",
            email: "kwesi.adjei@example.com",
            phoneNumber: "+14165551234",
            gender: "Male",
            location: "Toronto, Canada",
            countryOfOrigin: "Ghana",
            bio: "University professor specializing in African diaspora studies. Love jazz music, contemporary art, and staying connected to my Ghanaian heritage.",
            profession: "Professor",
            ethnicity: "Ewe",
            secondaryTribe: "Ga",
            religion: "Spiritual",
            photoUrl: "https://randomuser.me/api/portraits/men/85.jpg",
            showProfilePhoto: true,
            dateOfBirth: new Date(1985, 3, 18),
            relationshipStatus: "Single",
            relationshipGoal: "Serious dating",
            interests: JSON.stringify([
              "Jazz",
              "Art",
              "African diaspora",
              "Academia"
            ]),
            visibilityPreferences: JSON.stringify({
              residence: true,
              countryOfOrigin: true,
              tribe: true,
              profession: true,
              religion: true,
              bio: true,
              relationshipStatus: true,
              relationshipGoal: true,
              interests: true
            }),
            verifiedByPhone: true,
            twoFactorEnabled: true,
            profileHidden: false,
            ghostMode: false,
            isOnline: false,
            lastActive: new Date(currentTime.getTime() - 120 * 60 * 1e3),
            // 2 hours ago
            createdAt: currentTime,
            showAppModeSelection: true,
            showNationalitySelection: true,
            lastUsedApp: "dating"
          }
        ];
        return testUsers;
      }
      // User online status
      async updateUserOnlineStatus(userId, isOnline) {
        if (userId === null) return void 0;
        const user = await this.getUser(userId);
        if (!user) return void 0;
        const visibleOnlineStatus = user.ghostMode ? false : isOnline;
        const updateData = {
          isOnline: visibleOnlineStatus,
          lastActive: /* @__PURE__ */ new Date()
        };
        const [updatedUser] = await db.update(users).set(updateData).where(eq(users.id, userId)).returning();
        return updatedUser;
      }
      async getUserOnlineStatus(userId) {
        if (userId === null) return false;
        const user = await this.getUser(userId);
        if (!user) return false;
        if (user.ghostMode) return false;
        return user.isOnline || false;
      }
      // Typing status
      async updateTypingStatus(userId, matchId, isTyping) {
        const user = await this.getUser(userId);
        if (!user) {
          throw new Error("User not found");
        }
        const visibleTypingStatus = user.ghostMode ? false : isTyping;
        const existingStatus = await db.select().from(typingStatus).where(
          and(eq(typingStatus.userId, userId), eq(typingStatus.matchId, matchId))
        );
        if (existingStatus.length > 0) {
          const [updatedStatus] = await db.update(typingStatus).set({
            isTyping: visibleTypingStatus,
            updatedAt: /* @__PURE__ */ new Date()
          }).where(
            and(
              eq(typingStatus.userId, userId),
              eq(typingStatus.matchId, matchId)
            )
          ).returning();
          return updatedStatus;
        } else {
          const [newStatus] = await db.insert(typingStatus).values({
            userId,
            matchId,
            isTyping: visibleTypingStatus,
            updatedAt: /* @__PURE__ */ new Date()
          }).returning();
          return newStatus;
        }
      }
      async getTypingStatus(matchId) {
        return await db.select().from(typingStatus).where(eq(typingStatus.matchId, matchId));
      }
      // Video call operations
      async createVideoCall(videoCall) {
        const [newVideoCall] = await db.insert(videoCalls).values({
          ...videoCall,
          status: videoCall.status || "pending",
          createdAt: /* @__PURE__ */ new Date()
        }).returning();
        return newVideoCall;
      }
      async getVideoCallById(id) {
        const [videoCall] = await db.select().from(videoCalls).where(eq(videoCalls.id, id));
        return videoCall;
      }
      async updateVideoCallStatus(id, updates) {
        const [updatedVideoCall] = await db.update(videoCalls).set(updates).where(eq(videoCalls.id, id)).returning();
        return updatedVideoCall;
      }
      async getVideoCallsByUserId(userId) {
        return await db.select().from(videoCalls).where(
          or(
            eq(videoCalls.initiatorId, userId),
            eq(videoCalls.receiverId, userId)
          )
        );
      }
      // User photos operations for MEET dating app
      async addUserPhoto(photo) {
        if (photo.isPrimary) {
          await db.update(userPhotos).set({ isPrimary: false }).where(eq(userPhotos.userId, photo.userId));
        }
        const userPhotosCount = await db.select({ count: count() }).from(userPhotos).where(eq(userPhotos.userId, photo.userId));
        const isFirstPhoto = userPhotosCount.length === 0 || userPhotosCount[0].count === 0;
        const photoToInsert = {
          ...photo,
          isPrimary: isFirstPhoto ? true : photo.isPrimary
        };
        const [newPhoto] = await db.insert(userPhotos).values(photoToInsert).returning();
        if (newPhoto.isPrimary) {
          await this.updateUserProfile(photo.userId, {
            photoUrl: newPhoto.photoUrl
          });
        }
        return newPhoto;
      }
      async getUserPhotos(userId) {
        return await db.select().from(userPhotos).where(eq(userPhotos.userId, userId)).orderBy(desc(userPhotos.isPrimary), asc(userPhotos.createdAt));
      }
      async getUserPhotoById(id) {
        const [photo] = await db.select().from(userPhotos).where(eq(userPhotos.id, id));
        return photo;
      }
      async updateUserPhoto(id, updates) {
        try {
          const photo = await this.getUserPhotoById(id);
          if (!photo) return void 0;
          const [updatedPhoto] = await db.update(userPhotos).set({ photoUrl: updates.photoUrl }).where(eq(userPhotos.id, id)).returning();
          if (updatedPhoto.isPrimary) {
            await this.updateUserProfile(updatedPhoto.userId, {
              photoUrl: updates.photoUrl
            });
          }
          return updatedPhoto;
        } catch (error) {
          console.error(`Error updating photo ${id}:`, error);
          return void 0;
        }
      }
      // Note: Primary implementation of addUserPhoto is already defined above
      async deleteUserPhoto(id) {
        const [photo] = await db.select().from(userPhotos).where(eq(userPhotos.id, id));
        if (!photo) return;
        await db.delete(userPhotos).where(eq(userPhotos.id, id));
        if (photo.isPrimary) {
          const [anotherPhoto] = await db.select().from(userPhotos).where(eq(userPhotos.userId, photo.userId)).limit(1);
          if (anotherPhoto) {
            await this.setPrimaryPhoto(anotherPhoto.id, photo.userId);
          } else {
            await this.updateUserProfile(photo.userId, { photoUrl: null });
          }
        }
      }
      async setPrimaryPhoto(id, userId) {
        try {
          const [photo] = await db.select().from(userPhotos).where(and(eq(userPhotos.id, id), eq(userPhotos.userId, userId)));
          if (!photo) {
            throw new Error("Photo not found or does not belong to the user");
          }
          await db.update(userPhotos).set({ isPrimary: false }).where(eq(userPhotos.userId, userId));
          const [updatedPhoto] = await db.update(userPhotos).set({ isPrimary: true }).where(eq(userPhotos.id, id)).returning();
          if (updatedPhoto) {
            await this.updateUserProfile(userId, {
              photoUrl: updatedPhoto.photoUrl
            });
          }
          return updatedPhoto;
        } catch (error) {
          console.error(
            `Error setting primary photo (id: ${id} for user: ${userId}):`,
            error
          );
          throw error;
        }
      }
      // Section-specific primary photo management
      async updateSectionPrimaryPhoto(userId, photoId, section) {
        try {
          const [photo] = await db.select().from(userPhotos).where(and(eq(userPhotos.id, photoId), eq(userPhotos.userId, userId)));
          if (!photo) {
            return {
              success: false,
              error: "Photo not found or doesn't belong to user"
            };
          }
          const sectionFieldMap = {
            meet: "isPrimaryForMeet",
            job: "isPrimaryForJob",
            mentorship: "isPrimaryForMentorship",
            networking: "isPrimaryForNetworking"
          };
          const fieldName = sectionFieldMap[section];
          if (!fieldName) {
            return { success: false, error: "Invalid section" };
          }
          const resetUpdate = {};
          resetUpdate[fieldName] = false;
          await db.update(userPhotos).set(resetUpdate).where(eq(userPhotos.userId, userId));
          const setPrimaryUpdate = {};
          setPrimaryUpdate[fieldName] = true;
          await db.update(userPhotos).set(setPrimaryUpdate).where(eq(userPhotos.id, photoId));
          return { success: true };
        } catch (error) {
          console.error(`Error updating section primary photo:`, error);
          return { success: false, error: "Database error occurred" };
        }
      }
      async getUserPhotosWithSectionPrimary(userId, section) {
        return await db.select().from(userPhotos).where(eq(userPhotos.userId, userId)).orderBy(asc(userPhotos.createdAt));
      }
      async getSectionPrimaryPhoto(userId, section) {
        const sectionFieldMap = {
          meet: userPhotos.isPrimaryForMeet,
          job: userPhotos.isPrimaryForJob,
          mentorship: userPhotos.isPrimaryForMentorship,
          networking: userPhotos.isPrimaryForNetworking
        };
        const field = sectionFieldMap[section];
        if (!field) return void 0;
        const [photo] = await db.select().from(userPhotos).where(and(eq(userPhotos.userId, userId), eq(field, true))).limit(1);
        return photo;
      }
      // Get the lastActive timestamp for a user
      async getUserLastActive(userId) {
        if (userId === null) return null;
        const user = await this.getUser(userId);
        return user?.lastActive || null;
      }
      // Methods for chat activity status
      async updateActiveChatStatus(userId, matchId, isActive) {
        try {
          if (isActive) {
            const result = await db.execute(
              sql`INSERT INTO active_chats (user_id, match_id, is_active, updated_at) 
              VALUES (${userId}, ${matchId}, ${isActive}, NOW()) 
              ON CONFLICT (user_id, match_id) 
              DO UPDATE SET is_active = ${isActive}, updated_at = NOW()`
            );
          } else {
            await db.execute(
              sql`UPDATE active_chats 
              SET is_active = ${isActive}, updated_at = NOW() 
              WHERE user_id = ${userId} AND match_id = ${matchId}`
            );
          }
          return true;
        } catch (error) {
          console.error(
            `Error updating active chat status for user ${userId} in match ${matchId}:`,
            error
          );
          return false;
        }
      }
      async getActiveChatStatus(userId, matchId) {
        try {
          const result = await db.execute(
            sql`SELECT is_active FROM active_chats 
            WHERE user_id = ${userId} AND match_id = ${matchId} 
            AND is_active = true 
            AND updated_at > NOW() - INTERVAL '5 minutes'`
          );
          return result.rows.length > 0;
        } catch (error) {
          console.error(
            `Error getting active chat status for user ${userId} in match ${matchId}:`,
            error
          );
          return false;
        }
      }
      async getUsersInActiveChat(matchId) {
        try {
          const result = await db.execute(
            sql`SELECT user_id FROM active_chats 
            WHERE match_id = ${matchId} 
            AND is_active = true 
            AND updated_at > NOW() - INTERVAL '5 minutes'`
          );
          return result.rows.map((row) => Number(row.user_id));
        } catch (error) {
          console.error(
            `Error getting users in active chat for match ${matchId}:`,
            error
          );
          return [];
        }
      }
      // Message reactions methods
      async addMessageReaction(reaction) {
        try {
          console.log(
            `\u{1F504} [REACTION-DEBUG] Checking for existing reactions from user ${reaction.userId} on message ${reaction.messageId} with emoji ${reaction.emoji}`
          );
          const existingReactions = await db.select().from(messageReactions).where(
            and(
              eq(messageReactions.messageId, reaction.messageId),
              eq(messageReactions.userId, reaction.userId)
            )
          );
          console.log(
            `\u{1F50D} [REACTION-DEBUG] Found ${existingReactions.length} existing reactions:`,
            existingReactions.map((r) => `${r.emoji} (id: ${r.id})`)
          );
          if (existingReactions.length > 0) {
            console.log(
              `\u{1F5D1}\uFE0F [REACTION-DEBUG] Removing ${existingReactions.length} existing reaction(s) from user ${reaction.userId} on message ${reaction.messageId}`
            );
            const deleteResult = await db.delete(messageReactions).where(
              and(
                eq(messageReactions.messageId, reaction.messageId),
                eq(messageReactions.userId, reaction.userId)
              )
            ).returning();
            console.log(
              `\u2705 [REACTION-DEBUG] Successfully removed ${deleteResult.length} reaction(s). Now adding new reaction: ${reaction.emoji}`
            );
          } else {
            console.log(
              `\u2795 [REACTION-DEBUG] No existing reactions found. Adding first reaction: ${reaction.emoji}`
            );
          }
          const [newReaction] = await db.insert(messageReactions).values(reaction).returning();
          if (!newReaction) {
            throw new Error("Failed to insert new reaction");
          }
          console.log(
            `\u{1F389} Successfully added reaction ${reaction.emoji} for user ${reaction.userId} on message ${reaction.messageId}`
          );
          return newReaction;
        } catch (error) {
          console.error("Error adding message reaction:", error);
          throw error;
        }
      }
      async removeMessageReaction(messageId, userId, emoji) {
        try {
          await db.delete(messageReactions).where(
            and(
              eq(messageReactions.messageId, messageId),
              eq(messageReactions.userId, userId),
              eq(messageReactions.emoji, emoji)
            )
          );
        } catch (error) {
          console.error("Error removing message reaction:", error);
          throw error;
        }
      }
      async getMessageReactions(messageId) {
        try {
          return await db.select().from(messageReactions).where(eq(messageReactions.messageId, messageId)).orderBy(asc(messageReactions.createdAt));
        } catch (error) {
          console.error("Error getting message reactions:", error);
          return [];
        }
      }
      async getMessageReactionsByMatch(matchId) {
        try {
          return await db.select({
            id: messageReactions.id,
            messageId: messageReactions.messageId,
            userId: messageReactions.userId,
            emoji: messageReactions.emoji,
            createdAt: messageReactions.createdAt
          }).from(messageReactions).innerJoin(messages, eq(messageReactions.messageId, messages.id)).where(eq(messages.matchId, matchId)).orderBy(asc(messageReactions.createdAt));
        } catch (error) {
          console.error("Error getting message reactions by match:", error);
          return [];
        }
      }
      // Auto-delete functionality methods
      async getUserMatchSettings(userId, matchId) {
        try {
          const [settings] = await db.select().from(userMatchSettings).where(
            and(
              eq(userMatchSettings.userId, userId),
              eq(userMatchSettings.matchId, matchId)
            )
          );
          return settings;
        } catch (error) {
          console.error("Error getting user match settings:", error);
          return void 0;
        }
      }
      async updateUserMatchSettings(userId, matchId, settings) {
        try {
          const [updatedSettings] = await db.insert(userMatchSettings).values({
            userId,
            matchId,
            ...settings
          }).onConflictDoUpdate({
            target: [userMatchSettings.userId, userMatchSettings.matchId],
            set: {
              ...settings
            }
          }).returning();
          return updatedSettings;
        } catch (error) {
          console.error("Error updating user match settings:", error);
          throw error;
        }
      }
      async deleteMessagesForUser(userId, matchId) {
        try {
          const settings = await this.getUserMatchSettings(userId, matchId);
          if (!settings || settings.autoDeleteMode !== "always") {
            console.log(
              `No "always" mode deletion needed for user ${userId} in match ${matchId}`
            );
            return;
          }
          console.log(
            `Deleting messages for user ${userId} in match ${matchId} in "always" mode`
          );
          await db.update(messages).set({ deletedForUserId: userId }).where(
            and(
              eq(messages.matchId, matchId),
              or(eq(messages.senderId, userId), eq(messages.receiverId, userId))
            )
          );
          console.log(
            `Successfully marked messages as deleted for user ${userId} in match ${matchId}`
          );
        } catch (error) {
          console.error("Error deleting messages for user:", error);
          throw error;
        }
      }
      async scheduleMessageDeletion(messageId, deleteAt, mode) {
        try {
          await db.update(messages).set({
            autoDeleteScheduledAt: deleteAt,
            autoDeleteModeWhenSent: mode
          }).where(eq(messages.id, messageId));
        } catch (error) {
          console.error("Error scheduling message deletion:", error);
          throw error;
        }
      }
      async processAutoDeleteMessages() {
        try {
          const now = /* @__PURE__ */ new Date();
          const messagesToDelete = await db.select().from(messages).where(
            and(
              sql`${messages.autoDeleteScheduledAt} IS NOT NULL`,
              sql`${messages.autoDeleteScheduledAt} <= ${now.toISOString()}`
            )
          );
          for (const message of messagesToDelete) {
            if (message.autoDeleteModeWhenSent === "always") {
              await db.delete(messages).where(eq(messages.id, message.id));
            } else {
              await db.update(messages).set({ deletedForUserId: message.senderId }).where(eq(messages.id, message.id));
            }
          }
          console.log(`Processed ${messagesToDelete.length} auto-delete messages`);
        } catch (error) {
          console.error("Error processing auto-delete messages:", error);
        }
      }
      /**
       * Mark a message as deleted for a specific user (recipient-side deletion)
       * This allows recipients to hide messages from their view without affecting the sender
       */
      async markMessageAsDeletedForUser(messageId, userId) {
        try {
          await db.update(messages).set({ deletedForUserId: userId }).where(eq(messages.id, messageId));
          console.log(`Message ${messageId} marked as deleted for user ${userId}`);
        } catch (error) {
          console.error("Error marking message as deleted for user:", error);
          throw error;
        }
      }
      // ===================================
      // SUITE PROFILE SYSTEM METHODS
      // ===================================
      // ===== SUITE PROFILE SETTINGS =====
      async getSuiteProfileSettings(userId) {
        try {
          const [settings] = await db.select().from(suiteProfileSettings).where(eq(suiteProfileSettings.userId, userId));
          return settings;
        } catch (error) {
          console.error("Error getting SUITE profile settings:", error);
          return void 0;
        }
      }
      async updateSuiteProfileSettings(userId, settings) {
        try {
          const [updatedSettings] = await db.insert(suiteProfileSettings).values({
            userId,
            ...settings,
            updatedAt: /* @__PURE__ */ new Date()
          }).onConflictDoUpdate({
            target: [suiteProfileSettings.userId],
            set: {
              ...settings,
              updatedAt: /* @__PURE__ */ new Date()
            }
          }).returning();
          return updatedSettings;
        } catch (error) {
          console.error("Error updating SUITE profile settings:", error);
          throw error;
        }
      }
      // ===== JOB PROFILE METHODS =====
      async getSuiteJobProfile(userId) {
        try {
          const [jobProfile] = await db.select().from(suiteJobProfiles).where(
            and(
              eq(suiteJobProfiles.userId, userId),
              eq(suiteJobProfiles.isActive, true)
            )
          );
          return jobProfile;
        } catch (error) {
          console.error("Error getting job profile:", error);
          return void 0;
        }
      }
      async createOrUpdateSuiteJobProfile(userId, jobProfileData) {
        try {
          console.log("Creating/updating job profile for user:", userId);
          console.log("Job profile data:", jobProfileData);
          await db.update(suiteJobProfiles).set({ isActive: false, updatedAt: /* @__PURE__ */ new Date() }).where(eq(suiteJobProfiles.userId, userId));
          const [existingProfile] = await db.select().from(suiteJobProfiles).where(eq(suiteJobProfiles.userId, userId)).orderBy(sql`${suiteJobProfiles.createdAt} DESC`).limit(1);
          if (existingProfile) {
            const cleanData = { ...jobProfileData };
            delete cleanData.createdAt;
            delete cleanData.updatedAt;
            delete cleanData.id;
            const updateObject = {
              isActive: true,
              // Reactivate this profile
              updatedAt: /* @__PURE__ */ new Date()
            };
            Object.entries(cleanData).forEach(([key, value]) => {
              if (value !== null && value !== void 0) {
                updateObject[key] = value;
              }
            });
            console.log(
              "Storage layer: Updating most recent job profile with:",
              Object.keys(updateObject)
            );
            console.log("Storage layer: Update object:", updateObject);
            const [updatedProfile] = await db.update(suiteJobProfiles).set(updateObject).where(eq(suiteJobProfiles.id, existingProfile.id)).returning();
            if (updateObject.highSchool !== void 0 || updateObject.collegeUniversity !== void 0) {
              console.log(
                "\u{1F4DA} [EDUCATION-SYNC] Syncing education fields to users table from job profile"
              );
              const userUpdateData = {};
              if (updateObject.highSchool !== void 0) {
                userUpdateData.highSchool = updateObject.highSchool;
              }
              if (updateObject.collegeUniversity !== void 0) {
                userUpdateData.collegeUniversity = updateObject.collegeUniversity;
              }
              try {
                await db.update(users).set(userUpdateData).where(eq(users.id, userId));
                console.log(
                  "\u{1F4DA} [EDUCATION-SYNC] Successfully updated education fields in users table:",
                  userUpdateData
                );
              } catch (syncError) {
                console.error(
                  "\u{1F4DA} [EDUCATION-SYNC] Failed to sync education fields to users table:",
                  syncError
                );
              }
            }
            console.log("Updated job profile:", updatedProfile);
            return updatedProfile;
          } else {
            const defaultVisibilityPreferences = JSON.stringify({
              showProfilePhoto: true,
              jobTitle: true,
              location: true,
              workType: true,
              jobType: true,
              experienceLevel: true,
              skills: true,
              company: true,
              compensation: true,
              description: true,
              requirements: true,
              whyItMatters: true,
              whoShouldApply: true,
              culturalFit: true,
              areasOfExpertise: true,
              industryTags: true,
              applicationUrl: true,
              applicationEmail: true,
              applicationInstructions: true
            });
            const profileToInsert = {
              userId,
              role: jobProfileData.role,
              jobTitle: jobProfileData.jobTitle,
              description: jobProfileData.description,
              workType: jobProfileData.workType,
              jobType: jobProfileData.jobType,
              company: jobProfileData.company,
              compensation: jobProfileData.compensation,
              compensationCurrency: jobProfileData.compensationCurrency,
              compensationPeriod: jobProfileData.compensationPeriod,
              salary: jobProfileData.salary,
              salaryCurrency: jobProfileData.salaryCurrency,
              salaryPeriod: jobProfileData.salaryPeriod,
              requirements: jobProfileData.requirements,
              location: jobProfileData.location,
              experienceLevel: jobProfileData.experienceLevel,
              whyItMatters: jobProfileData.whyItMatters,
              whoShouldApply: jobProfileData.whoShouldApply,
              culturalFit: jobProfileData.culturalFit,
              areasOfExpertise: jobProfileData.areasOfExpertise,
              industryTags: jobProfileData.industryTags,
              skillTags: jobProfileData.skillTags,
              applicationUrl: jobProfileData.applicationUrl,
              applicationEmail: jobProfileData.applicationEmail,
              applicationInstructions: jobProfileData.applicationInstructions,
              expiresAt: jobProfileData.expiresAt,
              visibilityPreferences: jobProfileData.visibilityPreferences || defaultVisibilityPreferences,
              isActive: true
            };
            const [newProfile] = await db.insert(suiteJobProfiles).values(profileToInsert).returning();
            if (profileToInsert.highSchool || profileToInsert.collegeUniversity) {
              console.log(
                "\u{1F4DA} [EDUCATION-SYNC] Syncing education fields to users table from new job profile"
              );
              const userUpdateData = {};
              if (profileToInsert.highSchool) {
                userUpdateData.highSchool = profileToInsert.highSchool;
              }
              if (profileToInsert.collegeUniversity) {
                userUpdateData.collegeUniversity = profileToInsert.collegeUniversity;
              }
              try {
                await db.update(users).set(userUpdateData).where(eq(users.id, userId));
                console.log(
                  "\u{1F4DA} [EDUCATION-SYNC] Successfully updated education fields in users table:",
                  userUpdateData
                );
              } catch (syncError) {
                console.error(
                  "\u{1F4DA} [EDUCATION-SYNC] Failed to sync education fields to users table:",
                  syncError
                );
              }
            }
            console.log("Created new job profile:", newProfile);
            return newProfile;
          }
        } catch (error) {
          console.error("Error creating/updating job profile:", error);
          console.error("Error details:", error.message);
          throw error;
        }
      }
      async getDiscoveryJobProfiles(userId, limit, offset) {
        try {
          const jobProfiles = await db.select({
            // Job profile fields
            id: suiteJobProfiles.id,
            userId: suiteJobProfiles.userId,
            role: suiteJobProfiles.role,
            jobTitle: suiteJobProfiles.jobTitle,
            company: suiteJobProfiles.company,
            description: suiteJobProfiles.description,
            compensation: suiteJobProfiles.compensation,
            salary: suiteJobProfiles.salary,
            // Add missing salary field
            requirements: suiteJobProfiles.requirements,
            location: suiteJobProfiles.location,
            workType: suiteJobProfiles.workType,
            jobType: suiteJobProfiles.jobType,
            experienceLevel: suiteJobProfiles.experienceLevel,
            whyItMatters: suiteJobProfiles.whyItMatters,
            whoShouldApply: suiteJobProfiles.whoShouldApply,
            culturalFit: suiteJobProfiles.culturalFit,
            industryTags: suiteJobProfiles.industryTags,
            skillTags: suiteJobProfiles.skillTags,
            applicationUrl: suiteJobProfiles.applicationUrl,
            applicationEmail: suiteJobProfiles.applicationEmail,
            applicationInstructions: suiteJobProfiles.applicationInstructions,
            visibilityPreferences: suiteJobProfiles.visibilityPreferences,
            // Add missing visibility field
            isActive: suiteJobProfiles.isActive,
            expiresAt: suiteJobProfiles.expiresAt,
            createdAt: suiteJobProfiles.createdAt,
            updatedAt: suiteJobProfiles.updatedAt,
            // User fields
            user: {
              id: users.id,
              fullName: users.fullName,
              photoUrl: users.photoUrl,
              profession: users.profession,
              location: users.location,
              isVerified: users.isVerified
            }
          }).from(suiteJobProfiles).innerJoin(users, eq(suiteJobProfiles.userId, users.id)).innerJoin(
            suiteProfileSettings,
            eq(users.id, suiteProfileSettings.userId)
          ).where(
            and(
              ne(suiteJobProfiles.userId, userId),
              // Exclude current user
              eq(suiteJobProfiles.isActive, true),
              eq(suiteProfileSettings.hiddenInJobDiscovery, false),
              // COMPLETE BIDIRECTIONAL FILTERING: Use efficient SQL NOT EXISTS clauses like networking/mentorship
              // 1. Exclude profiles current user has already swiped on
              sql`NOT EXISTS (
              SELECT 1 FROM suite_job_applications sja1
              WHERE sja1.user_id = ${userId} 
              AND sja1.target_profile_id = suite_job_profiles.id
            )`,
              // 2. Exclude profiles owned by users who have already swiped on current user's profile
              sql`NOT EXISTS (
              SELECT 1 FROM suite_job_applications sja2
              WHERE sja2.user_id = suite_job_profiles.user_id 
              AND sja2.target_user_id = ${userId}
            )`,
              // 3. Exclude profiles for users in swipe history for SUITE_JOBS
              sql`NOT EXISTS (
              SELECT 1 FROM swipe_history sh
              WHERE sh.user_id = ${userId} 
              AND sh.target_user_id = suite_job_profiles.user_id
              AND sh.app_mode = 'SUITE_JOBS'
            )`,
              or(
                sql`${suiteJobProfiles.expiresAt} IS NULL`,
                sql`${suiteJobProfiles.expiresAt} > NOW()`
              )
            )
          ).orderBy(desc(suiteJobProfiles.createdAt)).limit(limit).offset(offset);
          const transformedProfiles = await Promise.all(
            jobProfiles.map(async (profile) => {
              let fieldVisibility = {};
              if (profile.visibilityPreferences) {
                try {
                  fieldVisibility = JSON.parse(profile.visibilityPreferences);
                } catch (error) {
                  console.error(
                    `Error parsing job visibility preferences for user ${profile.userId}:`,
                    error
                  );
                }
              }
              let jobPrimaryPhotoUrl = null;
              try {
                const jobPhotos = await db.select().from(userPhotos).where(
                  and(
                    eq(userPhotos.userId, profile.userId),
                    eq(userPhotos.isPrimaryForJob, true)
                  )
                ).limit(1);
                if (jobPhotos.length > 0) {
                  jobPrimaryPhotoUrl = jobPhotos[0].photoUrl;
                }
              } catch (error) {
                console.error(
                  `Error fetching job primary photo for user ${profile.userId}:`,
                  error
                );
              }
              return {
                ...profile,
                fieldVisibility,
                jobPrimaryPhotoUrl
              };
            })
          );
          return transformedProfiles;
        } catch (error) {
          console.error("Error getting discovery job profiles:", error);
          return [];
        }
      }
      async getSuiteJobProfileById(profileId) {
        try {
          const [jobProfile] = await db.select().from(suiteJobProfiles).where(
            and(
              eq(suiteJobProfiles.id, profileId),
              eq(suiteJobProfiles.isActive, true)
            )
          );
          return jobProfile;
        } catch (error) {
          console.error("Error getting job profile by ID:", error);
          return void 0;
        }
      }
      async getSuiteJobProfileByUserId(userId) {
        try {
          const [jobProfile] = await db.select().from(suiteJobProfiles).where(
            and(
              eq(suiteJobProfiles.userId, userId),
              eq(suiteJobProfiles.isActive, true)
            )
          );
          return jobProfile;
        } catch (error) {
          console.error("Error getting job profile by user ID:", error);
          return void 0;
        }
      }
      async updateSuiteJobProfileVisibility(userId, visibilityPreferences) {
        try {
          const [updatedProfile] = await db.update(suiteJobProfiles).set({
            visibilityPreferences,
            updatedAt: /* @__PURE__ */ new Date()
          }).where(
            and(
              eq(suiteJobProfiles.userId, userId),
              eq(suiteJobProfiles.isActive, true)
            )
          ).returning();
          return updatedProfile;
        } catch (error) {
          console.error("Error updating job profile visibility:", error);
          throw error;
        }
      }
      async deleteSuiteJobProfile(userId) {
        try {
          await db.delete(suiteJobProfiles).where(eq(suiteJobProfiles.userId, userId));
          console.log("Job profile deleted successfully for user:", userId);
        } catch (error) {
          console.error("Error deleting job profile:", error);
          throw error;
        }
      }
      // ===== MENTORSHIP PROFILE METHODS =====
      async getSuiteMentorshipProfile(userId, role) {
        try {
          const conditions = [
            eq(suiteMentorshipProfiles.userId, userId),
            eq(suiteMentorshipProfiles.isActive, true)
          ];
          if (role) {
            conditions.push(eq(suiteMentorshipProfiles.role, role));
          }
          const [result] = await db.select({
            // Include all mentorship profile fields
            ...suiteMentorshipProfiles,
            // Override education fields with data from users table for sync
            userHighSchool: users.highSchool,
            userCollegeUniversity: users.collegeUniversity
          }).from(suiteMentorshipProfiles).innerJoin(users, eq(users.id, suiteMentorshipProfiles.userId)).where(and(...conditions));
          if (!result) {
            return void 0;
          }
          const mentorshipProfile = {
            ...result,
            // Use education fields from users table if available, fallback to profile fields
            highSchool: result.userHighSchool || result.highSchool,
            collegeUniversity: result.userCollegeUniversity || result.collegeUniversity,
            // Remove the temporary fields
            userHighSchool: void 0,
            userCollegeUniversity: void 0
          };
          return mentorshipProfile;
        } catch (error) {
          console.error("Error getting mentorship profile:", error);
          return void 0;
        }
      }
      async getSuiteMentorshipProfileById(profileId) {
        try {
          const [mentorshipProfile] = await db.select().from(suiteMentorshipProfiles).where(
            and(
              eq(suiteMentorshipProfiles.id, profileId),
              eq(suiteMentorshipProfiles.isActive, true)
            )
          );
          return mentorshipProfile;
        } catch (error) {
          console.error("Error getting mentorship profile by ID:", error);
          return void 0;
        }
      }
      async getSuiteMentorshipProfileByRole(userId, role) {
        try {
          const [mentorshipProfile] = await db.select().from(suiteMentorshipProfiles).where(
            and(
              eq(suiteMentorshipProfiles.userId, userId),
              eq(suiteMentorshipProfiles.role, role),
              eq(suiteMentorshipProfiles.isActive, true)
            )
          );
          return mentorshipProfile;
        } catch (error) {
          console.error("Error getting mentorship profile by role:", error);
          return void 0;
        }
      }
      async getSuiteMentorshipProfiles(userId) {
        try {
          const mentorshipProfiles = await db.select().from(suiteMentorshipProfiles).where(
            and(
              eq(suiteMentorshipProfiles.userId, userId),
              eq(suiteMentorshipProfiles.isActive, true)
            )
          );
          return mentorshipProfiles;
        } catch (error) {
          console.error("Error getting mentorship profiles:", error);
          return [];
        }
      }
      async deleteSuiteMentorshipProfile(userId, role) {
        try {
          const conditions = [eq(suiteMentorshipProfiles.userId, userId)];
          if (role) {
            conditions.push(eq(suiteMentorshipProfiles.role, role));
          }
          await db.delete(suiteMentorshipProfiles).where(and(...conditions));
          console.log(
            `Mentorship profile${role ? ` (${role})` : "s"} permanently deleted for user:`,
            userId
          );
        } catch (error) {
          console.error("Error deleting mentorship profile:", error);
          throw error;
        }
      }
      async createOrUpdateSuiteMentorshipProfile(userId, mentorshipProfileData) {
        try {
          console.log("Creating/updating mentorship profile for user:", userId);
          console.log("Mentorship profile data:", mentorshipProfileData);
          const role = mentorshipProfileData.role || "mentor";
          await db.update(suiteMentorshipProfiles).set({ isActive: false, updatedAt: /* @__PURE__ */ new Date() }).where(
            and(
              eq(suiteMentorshipProfiles.userId, userId),
              eq(suiteMentorshipProfiles.role, role)
            )
          );
          const [existingProfile] = await db.select().from(suiteMentorshipProfiles).where(
            and(
              eq(suiteMentorshipProfiles.userId, userId),
              eq(suiteMentorshipProfiles.role, role)
            )
          ).orderBy(sql`${suiteMentorshipProfiles.createdAt} DESC`).limit(1);
          if (existingProfile) {
            const cleanData = { ...mentorshipProfileData };
            delete cleanData.createdAt;
            delete cleanData.updatedAt;
            delete cleanData.id;
            const updateObject = {
              isActive: true,
              // Reactivate this profile
              updatedAt: /* @__PURE__ */ new Date()
            };
            Object.entries(cleanData).forEach(([key, value]) => {
              if (value !== null && value !== void 0) {
                updateObject[key] = value;
              }
            });
            console.log(
              `Storage layer: Updating most recent ${role} mentorship profile with:`,
              Object.keys(updateObject)
            );
            console.log("Storage layer: Update object:", updateObject);
            const [updatedProfile] = await db.update(suiteMentorshipProfiles).set(updateObject).where(eq(suiteMentorshipProfiles.id, existingProfile.id)).returning();
            if (updateObject.highSchool !== void 0 || updateObject.collegeUniversity !== void 0) {
              console.log(
                "\u{1F4DA} [EDUCATION-SYNC] Syncing education fields to users table from mentorship profile"
              );
              const userUpdateData = {};
              if (updateObject.highSchool !== void 0) {
                userUpdateData.highSchool = updateObject.highSchool;
              }
              if (updateObject.collegeUniversity !== void 0) {
                userUpdateData.collegeUniversity = updateObject.collegeUniversity;
              }
              try {
                await db.update(users).set(userUpdateData).where(eq(users.id, userId));
                console.log(
                  "\u{1F4DA} [EDUCATION-SYNC] Successfully updated education fields in users table:",
                  userUpdateData
                );
              } catch (syncError) {
                console.error(
                  "\u{1F4DA} [EDUCATION-SYNC] Failed to sync education fields to users table:",
                  syncError
                );
              }
            }
            console.log(`Updated ${role} mentorship profile:`, updatedProfile);
            return updatedProfile;
          } else {
            const profileToInsert = {
              userId,
              role,
              areasOfExpertise: mentorshipProfileData.areasOfExpertise,
              learningGoals: mentorshipProfileData.learningGoals,
              languagesSpoken: mentorshipProfileData.languagesSpoken,
              industriesOrDomains: mentorshipProfileData.industriesOrDomains,
              mentorshipStyle: mentorshipProfileData.mentorshipStyle,
              preferredFormat: mentorshipProfileData.preferredFormat,
              communicationStyle: mentorshipProfileData.communicationStyle,
              availability: mentorshipProfileData.availability,
              timeCommitment: mentorshipProfileData.timeCommitment,
              location: mentorshipProfileData.location,
              successStories: mentorshipProfileData.successStories,
              whyMentor: mentorshipProfileData.whyMentor,
              whySeekMentorship: mentorshipProfileData.whySeekMentorship,
              preferredMentorshipStyle: mentorshipProfileData.preferredMentorshipStyle,
              industryAspiration: mentorshipProfileData.industryAspiration,
              preferredMenteeLevel: mentorshipProfileData.preferredMenteeLevel,
              preferredMentorExperience: mentorshipProfileData.preferredMentorExperience,
              preferredIndustries: mentorshipProfileData.preferredIndustries,
              highSchool: mentorshipProfileData.highSchool,
              collegeUniversity: mentorshipProfileData.collegeUniversity,
              maxMentees: mentorshipProfileData.maxMentees,
              currentMentees: mentorshipProfileData.currentMentees || 0,
              visibilityPreferences: mentorshipProfileData.visibilityPreferences || null,
              isActive: true
            };
            const [newProfile] = await db.insert(suiteMentorshipProfiles).values(profileToInsert).returning();
            if (profileToInsert.highSchool || profileToInsert.collegeUniversity) {
              console.log(
                "\u{1F4DA} [EDUCATION-SYNC] Syncing education fields to users table from new mentorship profile"
              );
              const userUpdateData = {};
              if (profileToInsert.highSchool) {
                userUpdateData.highSchool = profileToInsert.highSchool;
              }
              if (profileToInsert.collegeUniversity) {
                userUpdateData.collegeUniversity = profileToInsert.collegeUniversity;
              }
              try {
                await db.update(users).set(userUpdateData).where(eq(users.id, userId));
                console.log(
                  "\u{1F4DA} [EDUCATION-SYNC] Successfully updated education fields in users table:",
                  userUpdateData
                );
              } catch (syncError) {
                console.error(
                  "\u{1F4DA} [EDUCATION-SYNC] Failed to sync education fields to users table:",
                  syncError
                );
              }
            }
            console.log(`Created new ${role} mentorship profile:`, newProfile);
            return newProfile;
          }
        } catch (error) {
          console.error("Error creating/updating mentorship profile:", error);
          console.error("Error details:", error.message);
          throw error;
        }
      }
      async getDiscoveryMentorshipProfiles(userId, limit, offset) {
        try {
          const mentorshipProfiles = await db.select({
            // Mentorship profile fields
            id: suiteMentorshipProfiles.id,
            userId: suiteMentorshipProfiles.userId,
            role: suiteMentorshipProfiles.role,
            areasOfExpertise: suiteMentorshipProfiles.areasOfExpertise,
            learningGoals: suiteMentorshipProfiles.learningGoals,
            languagesSpoken: suiteMentorshipProfiles.languagesSpoken,
            industriesOrDomains: suiteMentorshipProfiles.industriesOrDomains,
            mentorshipStyle: suiteMentorshipProfiles.mentorshipStyle,
            preferredFormat: suiteMentorshipProfiles.preferredFormat,
            communicationStyle: suiteMentorshipProfiles.communicationStyle,
            availability: suiteMentorshipProfiles.availability,
            timeCommitment: suiteMentorshipProfiles.timeCommitment,
            location: suiteMentorshipProfiles.location,
            successStories: suiteMentorshipProfiles.successStories,
            whyMentor: suiteMentorshipProfiles.whyMentor,
            whySeekMentorship: suiteMentorshipProfiles.whySeekMentorship,
            preferredMenteeLevel: suiteMentorshipProfiles.preferredMenteeLevel,
            preferredMentorExperience: suiteMentorshipProfiles.preferredMentorExperience,
            preferredIndustries: suiteMentorshipProfiles.preferredIndustries,
            isActive: suiteMentorshipProfiles.isActive,
            maxMentees: suiteMentorshipProfiles.maxMentees,
            currentMentees: suiteMentorshipProfiles.currentMentees,
            createdAt: suiteMentorshipProfiles.createdAt,
            updatedAt: suiteMentorshipProfiles.updatedAt,
            // Add missing fields from database
            visibilityPreferences: suiteMentorshipProfiles.visibilityPreferences,
            preferredMentorshipStyle: suiteMentorshipProfiles.preferredMentorshipStyle,
            industryAspiration: suiteMentorshipProfiles.industryAspiration,
            // Add education fields
            highSchool: suiteMentorshipProfiles.highSchool,
            collegeUniversity: suiteMentorshipProfiles.collegeUniversity,
            // User fields
            user: {
              id: users.id,
              fullName: users.fullName,
              photoUrl: users.photoUrl,
              profession: users.profession,
              location: users.location,
              isVerified: users.isVerified
            }
          }).from(suiteMentorshipProfiles).innerJoin(users, eq(suiteMentorshipProfiles.userId, users.id)).innerJoin(
            suiteProfileSettings,
            eq(users.id, suiteProfileSettings.userId)
          ).where(
            and(
              ne(suiteMentorshipProfiles.userId, userId),
              // Exclude current user
              eq(suiteMentorshipProfiles.isActive, true),
              eq(suiteProfileSettings.hiddenInMentorshipDiscovery, false),
              // Optimized bidirectional filtering using efficient table aliases and indexed lookups
              sql`NOT EXISTS (
              SELECT 1 FROM suite_mentorship_connections smc1
              WHERE smc1.user_id = ${userId} 
              AND smc1.target_profile_id = suite_mentorship_profiles.id
            )`,
              sql`NOT EXISTS (
              SELECT 1 FROM suite_mentorship_connections smc2
              WHERE smc2.user_id = suite_mentorship_profiles.user_id 
              AND smc2.target_user_id = ${userId}
            )`,
              // 3. Exclude profiles for users in swipe history for SUITE_MENTORSHIP
              sql`NOT EXISTS (
              SELECT 1 FROM swipe_history sh
              WHERE sh.user_id = ${userId} 
              AND sh.target_user_id = suite_mentorship_profiles.user_id
              AND sh.app_mode = 'SUITE_MENTORSHIP'
            )`
            )
          ).orderBy(desc(suiteMentorshipProfiles.createdAt)).limit(limit).offset(offset);
          const transformedProfiles = await Promise.all(
            mentorshipProfiles.map(async (profile) => {
              let fieldVisibility = {};
              if (profile.visibilityPreferences) {
                try {
                  fieldVisibility = JSON.parse(profile.visibilityPreferences);
                } catch (error) {
                  console.error(
                    `Error parsing mentorship visibility preferences for user ${profile.userId}:`,
                    error
                  );
                }
              }
              let mentorshipPrimaryPhotoUrl = null;
              try {
                const mentorshipPhotos = await db.select().from(userPhotos).where(
                  and(
                    eq(userPhotos.userId, profile.userId),
                    eq(userPhotos.isPrimaryForMentorship, true)
                  )
                ).limit(1);
                if (mentorshipPhotos.length > 0) {
                  mentorshipPrimaryPhotoUrl = mentorshipPhotos[0].photoUrl;
                }
              } catch (error) {
                console.error(
                  `Error fetching mentorship primary photo for user ${profile.userId}:`,
                  error
                );
              }
              return {
                ...profile,
                fieldVisibility,
                mentorshipPrimaryPhotoUrl
              };
            })
          );
          return transformedProfiles;
        } catch (error) {
          console.error("Error getting discovery mentorship profiles:", error);
          return [];
        }
      }
      // ===== NETWORKING PROFILE METHODS =====
      async getSuiteNetworkingProfile(userId) {
        try {
          const [result] = await db.select({
            // Include all networking profile fields
            ...suiteNetworkingProfiles,
            // Override education fields with data from users table for sync
            userHighSchool: users.highSchool,
            userCollegeUniversity: users.collegeUniversity
          }).from(suiteNetworkingProfiles).innerJoin(users, eq(users.id, suiteNetworkingProfiles.userId)).where(
            and(
              eq(suiteNetworkingProfiles.userId, userId),
              eq(suiteNetworkingProfiles.isActive, true)
            )
          );
          if (!result) {
            return void 0;
          }
          const networkingProfile = {
            ...result,
            // Use education fields from users table if available, fallback to profile fields
            highSchool: result.userHighSchool || result.highSchool,
            collegeUniversity: result.userCollegeUniversity || result.collegeUniversity,
            // Remove the temporary fields
            userHighSchool: void 0,
            userCollegeUniversity: void 0
          };
          return networkingProfile;
        } catch (error) {
          console.error("Error getting networking profile:", error);
          return void 0;
        }
      }
      async getSuiteNetworkingProfileById(profileId) {
        try {
          const [networkingProfile] = await db.select().from(suiteNetworkingProfiles).where(
            and(
              eq(suiteNetworkingProfiles.id, profileId),
              eq(suiteNetworkingProfiles.isActive, true)
            )
          );
          return networkingProfile;
        } catch (error) {
          console.error("Error getting networking profile by ID:", error);
          return void 0;
        }
      }
      async deleteSuiteNetworkingProfile(userId) {
        try {
          await db.delete(suiteNetworkingProfiles).where(eq(suiteNetworkingProfiles.userId, userId));
          console.log("Networking profile permanently deleted for user:", userId);
        } catch (error) {
          console.error("Error deleting networking profile:", error);
          throw error;
        }
      }
      async createOrUpdateSuiteNetworkingProfile(userId, networkingProfileData) {
        try {
          console.log("Creating/updating networking profile for user:", userId);
          console.log("Profile data received:", networkingProfileData);
          await db.update(suiteNetworkingProfiles).set({ isActive: false, updatedAt: /* @__PURE__ */ new Date() }).where(eq(suiteNetworkingProfiles.userId, userId));
          const [existingProfile] = await db.select().from(suiteNetworkingProfiles).where(eq(suiteNetworkingProfiles.userId, userId)).orderBy(sql`${suiteNetworkingProfiles.createdAt} DESC`).limit(1);
          if (existingProfile) {
            const cleanData = { ...networkingProfileData };
            delete cleanData.createdAt;
            delete cleanData.updatedAt;
            delete cleanData.id;
            const updateObject = {
              isActive: true,
              // Reactivate this profile
              updatedAt: /* @__PURE__ */ new Date()
            };
            Object.entries(cleanData).forEach(([key, value]) => {
              if (value !== null && value !== void 0) {
                updateObject[key] = value;
              }
            });
            console.log(
              "Storage layer: Updating most recent profile with:",
              Object.keys(updateObject)
            );
            console.log("Storage layer: Update object:", updateObject);
            const [updatedProfile] = await db.update(suiteNetworkingProfiles).set(updateObject).where(eq(suiteNetworkingProfiles.id, existingProfile.id)).returning();
            if (updateObject.highSchool !== void 0 || updateObject.collegeUniversity !== void 0) {
              console.log(
                "\u{1F4DA} [EDUCATION-SYNC] Syncing education fields to users table from networking profile"
              );
              const userUpdateData = {};
              if (updateObject.highSchool !== void 0) {
                userUpdateData.highSchool = updateObject.highSchool;
              }
              if (updateObject.collegeUniversity !== void 0) {
                userUpdateData.collegeUniversity = updateObject.collegeUniversity;
              }
              try {
                await db.update(users).set(userUpdateData).where(eq(users.id, userId));
                console.log(
                  "\u{1F4DA} [EDUCATION-SYNC] Successfully updated education fields in users table:",
                  userUpdateData
                );
              } catch (syncError) {
                console.error(
                  "\u{1F4DA} [EDUCATION-SYNC] Failed to sync education fields to users table:",
                  syncError
                );
              }
            }
            return updatedProfile;
          } else {
            const profileToInsert = {
              userId,
              professionalTagline: networkingProfileData.professionalTagline || null,
              currentRole: networkingProfileData.currentRole || null,
              currentCompany: networkingProfileData.currentCompany || null,
              industry: networkingProfileData.industry || null,
              experienceYears: networkingProfileData.experienceYears || null,
              networkingGoals: networkingProfileData.networkingGoals || null,
              lookingFor: networkingProfileData.lookingFor || null,
              canOffer: networkingProfileData.canOffer || null,
              professionalInterests: networkingProfileData.professionalInterests || null,
              causesIPassionate: networkingProfileData.causesIPassionate || null,
              collaborationTypes: networkingProfileData.collaborationTypes || null,
              workingStyle: networkingProfileData.workingStyle || null,
              timeCommitment: networkingProfileData.timeCommitment || null,
              lightUpWhenTalking: networkingProfileData.lightUpWhenTalking || null,
              wantToMeetSomeone: networkingProfileData.wantToMeetSomeone || null,
              currentProjects: networkingProfileData.currentProjects || null,
              dreamCollaboration: networkingProfileData.dreamCollaboration || null,
              preferredMeetingStyle: networkingProfileData.preferredMeetingStyle || null,
              availability: networkingProfileData.availability || null,
              location: networkingProfileData.location || null,
              openToRemote: networkingProfileData.openToRemote ?? true,
              preferredLocations: networkingProfileData.preferredLocations || null,
              highSchool: networkingProfileData.highSchool || null,
              collegeUniversity: networkingProfileData.collegeUniversity || null,
              isActive: true,
              lookingForOpportunities: networkingProfileData.lookingForOpportunities ?? true,
              visibilityPreferences: networkingProfileData.visibilityPreferences || null
            };
            console.log("Inserting new networking profile:", profileToInsert);
            const [networkingProfile] = await db.insert(suiteNetworkingProfiles).values(profileToInsert).returning();
            if (profileToInsert.highSchool || profileToInsert.collegeUniversity) {
              console.log(
                "\u{1F4DA} [EDUCATION-SYNC] Syncing education fields to users table from new networking profile"
              );
              const userUpdateData = {};
              if (profileToInsert.highSchool) {
                userUpdateData.highSchool = profileToInsert.highSchool;
              }
              if (profileToInsert.collegeUniversity) {
                userUpdateData.collegeUniversity = profileToInsert.collegeUniversity;
              }
              try {
                await db.update(users).set(userUpdateData).where(eq(users.id, userId));
                console.log(
                  "\u{1F4DA} [EDUCATION-SYNC] Successfully updated education fields in users table:",
                  userUpdateData
                );
              } catch (syncError) {
                console.error(
                  "\u{1F4DA} [EDUCATION-SYNC] Failed to sync education fields to users table:",
                  syncError
                );
              }
            }
            console.log("Created networking profile:", networkingProfile);
            return networkingProfile;
          }
        } catch (error) {
          console.error("Error creating/updating networking profile:", error);
          console.error("Error details:", error?.message);
          console.error("Stack trace:", error?.stack);
          throw error;
        }
      }
      async getDiscoveryNetworkingProfiles(userId, limit, offset) {
        try {
          const networkingProfiles = await db.select({
            // Networking profile fields
            id: suiteNetworkingProfiles.id,
            userId: suiteNetworkingProfiles.userId,
            professionalTagline: suiteNetworkingProfiles.professionalTagline,
            currentRole: suiteNetworkingProfiles.currentRole,
            currentCompany: suiteNetworkingProfiles.currentCompany,
            industry: suiteNetworkingProfiles.industry,
            experienceYears: suiteNetworkingProfiles.experienceYears,
            networkingGoals: suiteNetworkingProfiles.networkingGoals,
            lookingFor: suiteNetworkingProfiles.lookingFor,
            canOffer: suiteNetworkingProfiles.canOffer,
            professionalInterests: suiteNetworkingProfiles.professionalInterests,
            causesIPassionate: suiteNetworkingProfiles.causesIPassionate,
            collaborationTypes: suiteNetworkingProfiles.collaborationTypes,
            workingStyle: suiteNetworkingProfiles.workingStyle,
            timeCommitment: suiteNetworkingProfiles.timeCommitment,
            lightUpWhenTalking: suiteNetworkingProfiles.lightUpWhenTalking,
            wantToMeetSomeone: suiteNetworkingProfiles.wantToMeetSomeone,
            currentProjects: suiteNetworkingProfiles.currentProjects,
            dreamCollaboration: suiteNetworkingProfiles.dreamCollaboration,
            preferredMeetingStyle: suiteNetworkingProfiles.preferredMeetingStyle,
            availability: suiteNetworkingProfiles.availability,
            location: suiteNetworkingProfiles.location,
            openToRemote: suiteNetworkingProfiles.openToRemote,
            preferredLocations: suiteNetworkingProfiles.preferredLocations,
            isActive: suiteNetworkingProfiles.isActive,
            lookingForOpportunities: suiteNetworkingProfiles.lookingForOpportunities,
            visibilityPreferences: suiteNetworkingProfiles.visibilityPreferences,
            // Add education fields for swipe card display
            highSchool: suiteNetworkingProfiles.highSchool,
            collegeUniversity: suiteNetworkingProfiles.collegeUniversity,
            createdAt: suiteNetworkingProfiles.createdAt,
            updatedAt: suiteNetworkingProfiles.updatedAt,
            // User fields
            user: {
              id: users.id,
              fullName: users.fullName,
              photoUrl: users.photoUrl,
              profession: users.profession,
              location: users.location,
              isVerified: users.isVerified
            }
          }).from(suiteNetworkingProfiles).innerJoin(users, eq(suiteNetworkingProfiles.userId, users.id)).innerJoin(
            suiteProfileSettings,
            eq(users.id, suiteProfileSettings.userId)
          ).where(
            and(
              ne(suiteNetworkingProfiles.userId, userId),
              // Exclude current user
              eq(suiteNetworkingProfiles.isActive, true),
              eq(suiteProfileSettings.hiddenInNetworkingDiscovery, false),
              eq(suiteNetworkingProfiles.lookingForOpportunities, true),
              // Optimized bidirectional filtering using efficient EXISTS clauses instead of slow NOT IN
              sql`NOT EXISTS (
              SELECT 1 FROM suite_networking_connections snc1
              WHERE snc1.user_id = ${userId} 
              AND snc1.target_profile_id = suite_networking_profiles.id
            )`,
              sql`NOT EXISTS (
              SELECT 1 FROM suite_networking_connections snc2
              WHERE snc2.user_id = suite_networking_profiles.user_id 
              AND snc2.target_user_id = ${userId}
            )`,
              // 3. Exclude profiles for users in swipe history for SUITE_NETWORKING
              sql`NOT EXISTS (
              SELECT 1 FROM swipe_history sh
              WHERE sh.user_id = ${userId} 
              AND sh.target_user_id = suite_networking_profiles.user_id
              AND sh.app_mode = 'SUITE_NETWORKING'
            )`
            )
          ).orderBy(desc(suiteNetworkingProfiles.createdAt)).limit(limit).offset(offset);
          const profilesWithVisibilityAndPhotos = await Promise.all(
            networkingProfiles.map(async (profile) => {
              let fieldVisibility = {
                // Default visibility settings that match the preview dialog
                showProfilePhoto: false,
                showNetworkingPhotos: true,
                professionalTagline: true,
                currentRole: true,
                industry: true,
                workplace: true,
                experienceYears: true,
                lookingFor: true,
                canOffer: true,
                workingStyle: true,
                professionalInterests: true,
                networkingGoals: true,
                lightUpWhenTalking: true,
                languagesSpoken: true,
                openToCollaborateOn: true,
                preferredNetworkingFormat: true,
                signatureAchievement: true,
                timezone: true,
                location: true
              };
              if (profile.visibilityPreferences) {
                try {
                  const visibilityData = typeof profile.visibilityPreferences === "string" ? JSON.parse(profile.visibilityPreferences) : profile.visibilityPreferences;
                  fieldVisibility = { ...fieldVisibility, ...visibilityData };
                } catch (error) {
                  console.error(
                    `Error parsing visibility preferences for user ${profile.userId}:`,
                    error
                  );
                }
              }
              let networkingPrimaryPhotoUrl = null;
              try {
                const networkingPhotos = await db.select().from(userPhotos).where(
                  and(
                    eq(userPhotos.userId, profile.userId),
                    eq(userPhotos.isPrimaryForNetworking, true)
                  )
                ).limit(1);
                if (networkingPhotos.length > 0) {
                  networkingPrimaryPhotoUrl = networkingPhotos[0].photoUrl;
                }
              } catch (error) {
                console.error(
                  `Error fetching networking primary photo for user ${profile.userId}:`,
                  error
                );
              }
              return {
                ...profile,
                fieldVisibility,
                networkingPrimaryPhotoUrl
              };
            })
          );
          return profilesWithVisibilityAndPhotos;
        } catch (error) {
          console.error("Error getting discovery networking profiles:", error);
          return [];
        }
      }
      // ===== FIELD VISIBILITY METHODS =====
      async getFieldVisibility(userId, profileType) {
        try {
          const visibilitySettings = await db.select().from(suiteFieldVisibility).where(
            and(
              eq(suiteFieldVisibility.userId, userId),
              eq(suiteFieldVisibility.profileType, profileType)
            )
          );
          return visibilitySettings;
        } catch (error) {
          console.error("Error getting field visibility:", error);
          return [];
        }
      }
      async updateFieldVisibility(userId, profileType, fieldName, isVisible) {
        try {
          const [visibility] = await db.insert(suiteFieldVisibility).values({
            userId,
            profileType,
            fieldName,
            isVisible
          }).onConflictDoUpdate({
            target: [
              suiteFieldVisibility.userId,
              suiteFieldVisibility.profileType,
              suiteFieldVisibility.fieldName
            ],
            set: {
              isVisible,
              updatedAt: sql`NOW()`
            }
          }).returning();
          return visibility;
        } catch (error) {
          console.error("Error updating field visibility:", error);
          throw error;
        }
      }
      async updateMultipleFieldVisibility(userId, profileType, visibilityData) {
        try {
          await Promise.all(
            Object.entries(visibilityData).map(
              ([fieldName, isVisible]) => this.updateFieldVisibility(userId, profileType, fieldName, isVisible)
            )
          );
        } catch (error) {
          console.error("Error updating multiple field visibility:", error);
          throw error;
        }
      }
      // ===== SUITE CONNECTION STORAGE IMPLEMENTATIONS =====
      // Networking connections
      async createSuiteNetworkingConnection(connectionData) {
        try {
          const [connection] = await db.insert(suiteNetworkingConnections).values(connectionData).returning();
          return connection;
        } catch (error) {
          console.error("Error creating networking connection:", error);
          throw error;
        }
      }
      async getSuiteNetworkingConnection(userId, targetProfileId) {
        try {
          const [connection] = await db.select().from(suiteNetworkingConnections).where(
            and(
              eq(suiteNetworkingConnections.userId, userId),
              eq(suiteNetworkingConnections.targetProfileId, targetProfileId)
            )
          );
          return connection || void 0;
        } catch (error) {
          console.error("Error getting networking connection:", error);
          throw error;
        }
      }
      async updateSuiteNetworkingConnection(id, updates) {
        try {
          const [connection] = await db.update(suiteNetworkingConnections).set(updates).where(eq(suiteNetworkingConnections.id, id)).returning();
          return connection || void 0;
        } catch (error) {
          console.error("Error updating networking connection:", error);
          throw error;
        }
      }
      async getUserNetworkingConnections(userId) {
        try {
          const incomingConnections = await db.select({
            id: suiteNetworkingConnections.id,
            userId: suiteNetworkingConnections.userId,
            targetProfileId: suiteNetworkingConnections.targetProfileId,
            targetUserId: suiteNetworkingConnections.targetUserId,
            action: suiteNetworkingConnections.action,
            matched: suiteNetworkingConnections.matched,
            createdAt: suiteNetworkingConnections.createdAt,
            // Get the LIKER's profile data (the person who liked this user)
            targetProfile: suiteNetworkingProfiles,
            targetUser: users
          }).from(suiteNetworkingConnections).leftJoin(
            suiteNetworkingProfiles,
            eq(suiteNetworkingConnections.userId, suiteNetworkingProfiles.userId)
          ).leftJoin(users, eq(suiteNetworkingConnections.userId, users.id)).where(
            and(
              eq(suiteNetworkingConnections.targetUserId, userId),
              eq(suiteNetworkingConnections.action, "like"),
              eq(suiteNetworkingConnections.matched, false)
              // Only show unmatched connections
            )
          );
          const enrichedConnections = await Promise.all(
            incomingConnections.map(async (conn) => {
              let networkingPrimaryPhotoUrl = null;
              if (conn.userId) {
                const [networkingPhoto] = await db.select({
                  photoUrl: userPhotos.photoUrl
                }).from(userPhotos).where(
                  and(
                    eq(userPhotos.userId, conn.userId),
                    eq(userPhotos.isPrimaryForNetworking, true)
                  )
                );
                networkingPrimaryPhotoUrl = networkingPhoto?.photoUrl || null;
              }
              return {
                ...conn,
                fieldVisibility: conn.targetProfile?.visibilityPreferences,
                networkingPrimaryPhotoUrl
              };
            })
          );
          return enrichedConnections;
        } catch (error) {
          console.error("Error getting user networking connections:", error);
          throw error;
        }
      }
      // Mentorship connections
      async createSuiteMentorshipConnection(connectionData) {
        try {
          const [connection] = await db.insert(suiteMentorshipConnections).values(connectionData).returning();
          return connection;
        } catch (error) {
          console.error("Error creating mentorship connection:", error);
          throw error;
        }
      }
      async getSuiteMentorshipConnection(userId, targetProfileId) {
        try {
          const [connection] = await db.select().from(suiteMentorshipConnections).where(
            and(
              eq(suiteMentorshipConnections.userId, userId),
              eq(suiteMentorshipConnections.targetProfileId, targetProfileId)
            )
          );
          return connection || void 0;
        } catch (error) {
          console.error("Error getting mentorship connection:", error);
          throw error;
        }
      }
      async updateSuiteMentorshipConnection(id, updates) {
        try {
          const [connection] = await db.update(suiteMentorshipConnections).set(updates).where(eq(suiteMentorshipConnections.id, id)).returning();
          return connection || void 0;
        } catch (error) {
          console.error("Error updating mentorship connection:", error);
          throw error;
        }
      }
      async getUserMentorshipConnections(userId) {
        try {
          const incomingConnections = await db.select({
            id: suiteMentorshipConnections.id,
            userId: suiteMentorshipConnections.userId,
            targetProfileId: suiteMentorshipConnections.targetProfileId,
            targetUserId: suiteMentorshipConnections.targetUserId,
            action: suiteMentorshipConnections.action,
            matched: suiteMentorshipConnections.matched,
            createdAt: suiteMentorshipConnections.createdAt,
            // Get the LIKER's profile data (the person who liked this user)
            targetProfile: suiteMentorshipProfiles,
            targetUser: users
          }).from(suiteMentorshipConnections).leftJoin(
            suiteMentorshipProfiles,
            eq(suiteMentorshipConnections.userId, suiteMentorshipProfiles.userId)
          ).leftJoin(users, eq(suiteMentorshipConnections.userId, users.id)).where(
            and(
              eq(suiteMentorshipConnections.targetUserId, userId),
              eq(suiteMentorshipConnections.action, "like"),
              eq(suiteMentorshipConnections.matched, false)
              // Only show unmatched connections
            )
          );
          const transformedConnections = await Promise.all(
            incomingConnections.map(async (connection) => {
              if (connection.targetProfile) {
                let fieldVisibility = {};
                if (connection.targetProfile.visibilityPreferences) {
                  try {
                    fieldVisibility = JSON.parse(
                      connection.targetProfile.visibilityPreferences
                    );
                  } catch (error) {
                    console.error(
                      `Error parsing mentorship visibility preferences for connection ${connection.id}:`,
                      error
                    );
                  }
                }
                let mentorshipPrimaryPhotoUrl = null;
                try {
                  const mentorshipPhotos = await db.select().from(userPhotos).where(
                    and(
                      eq(userPhotos.userId, connection.userId),
                      eq(userPhotos.isPrimaryForMentorship, true)
                    )
                  ).limit(1);
                  if (mentorshipPhotos.length > 0) {
                    mentorshipPrimaryPhotoUrl = mentorshipPhotos[0].photoUrl;
                  }
                } catch (error) {
                  console.error(
                    `Error fetching mentorship primary photo for user ${connection.userId}:`,
                    error
                  );
                }
                connection.targetProfile = {
                  ...connection.targetProfile,
                  fieldVisibility: JSON.stringify(fieldVisibility)
                };
                return {
                  ...connection,
                  mentorshipPrimaryPhotoUrl,
                  fieldVisibility: JSON.stringify(fieldVisibility)
                };
              }
              return connection;
            })
          );
          return transformedConnections;
        } catch (error) {
          console.error("Error getting user mentorship connections:", error);
          throw error;
        }
      }
      // Job applications
      async createSuiteJobApplication(applicationData) {
        try {
          const [application] = await db.insert(suiteJobApplications).values(applicationData).returning();
          return application;
        } catch (error) {
          console.error("Error creating job application:", error);
          throw error;
        }
      }
      async getSuiteJobApplication(userId, targetProfileId) {
        try {
          const [application] = await db.select().from(suiteJobApplications).where(
            and(
              eq(suiteJobApplications.userId, userId),
              eq(suiteJobApplications.targetProfileId, targetProfileId)
            )
          );
          return application || void 0;
        } catch (error) {
          console.error("Error getting job application:", error);
          throw error;
        }
      }
      async updateSuiteJobApplication(id, updates) {
        try {
          const [application] = await db.update(suiteJobApplications).set(updates).where(eq(suiteJobApplications.id, id)).returning();
          return application || void 0;
        } catch (error) {
          console.error("Error updating job application:", error);
          throw error;
        }
      }
      async getSuiteJobApplicationById(id) {
        try {
          const [application] = await db.select().from(suiteJobApplications).where(eq(suiteJobApplications.id, id));
          return application || void 0;
        } catch (error) {
          console.error("Error getting job application by ID:", error);
          throw error;
        }
      }
      async getSuiteJobApplicationByUsers(userId, targetUserId) {
        try {
          const [application] = await db.select().from(suiteJobApplications).where(
            and(
              eq(suiteJobApplications.userId, userId),
              eq(suiteJobApplications.targetUserId, targetUserId)
            )
          );
          return application || void 0;
        } catch (error) {
          console.error("Error getting job application by users:", error);
          throw error;
        }
      }
      async getUserJobApplications(userId) {
        try {
          const incomingApplications = await db.select({
            id: suiteJobApplications.id,
            userId: suiteJobApplications.userId,
            targetProfileId: suiteJobApplications.targetProfileId,
            targetUserId: suiteJobApplications.targetUserId,
            action: suiteJobApplications.action,
            applicationStatus: suiteJobApplications.applicationStatus,
            matched: suiteJobApplications.matched,
            createdAt: suiteJobApplications.createdAt,
            // Get the APPLICANT's user data (the person who applied)
            applicantName: users.fullName,
            applicantPhoto: users.photoUrl,
            applicantProfession: users.profession,
            applicantLocation: users.location,
            applicantIsVerified: users.isVerified
          }).from(suiteJobApplications).leftJoin(users, eq(suiteJobApplications.userId, users.id)).where(
            and(
              eq(suiteJobApplications.targetUserId, userId),
              eq(suiteJobApplications.action, "like"),
              eq(suiteJobApplications.matched, false)
              // Only show unmatched applications
            )
          );
          return incomingApplications.map((app2) => ({
            ...app2,
            targetProfile: null,
            // Not needed for job applications display
            targetUser: {
              id: app2.userId,
              fullName: app2.applicantName,
              photoUrl: app2.applicantPhoto,
              profession: app2.applicantProfession,
              location: app2.applicantLocation,
              isVerified: app2.applicantIsVerified
            }
          }));
        } catch (error) {
          console.error("Error getting user job applications:", error);
          throw error;
        }
      }
      // Connection management by ID methods
      async getSuiteNetworkingConnectionById(id) {
        try {
          const [connection] = await db.select().from(suiteNetworkingConnections).where(eq(suiteNetworkingConnections.id, id));
          return connection || void 0;
        } catch (error) {
          console.error("Error getting networking connection by ID:", error);
          throw error;
        }
      }
      async getSuiteMentorshipConnectionById(id) {
        try {
          const [connection] = await db.select().from(suiteMentorshipConnections).where(eq(suiteMentorshipConnections.id, id));
          return connection || void 0;
        } catch (error) {
          console.error("Error getting mentorship connection by ID:", error);
          throw error;
        }
      }
      async deleteSuiteNetworkingConnectionById(id) {
        try {
          await db.delete(suiteNetworkingConnections).where(eq(suiteNetworkingConnections.id, id));
        } catch (error) {
          console.error("Error deleting networking connection by ID:", error);
          throw error;
        }
      }
      async deleteSuiteMentorshipConnectionById(id) {
        try {
          await db.delete(suiteMentorshipConnections).where(eq(suiteMentorshipConnections.id, id));
        } catch (error) {
          console.error("Error deleting mentorship connection by ID:", error);
          throw error;
        }
      }
      async deleteSuiteJobApplicationById(id) {
        try {
          await db.delete(suiteJobApplications).where(eq(suiteJobApplications.id, id));
        } catch (error) {
          console.error("Error deleting job application by ID:", error);
          throw error;
        }
      }
      // Clear all networking connections for testing
      async clearAllNetworkingConnections() {
        try {
          await db.delete(suiteNetworkingConnections);
          console.log("All networking connections cleared");
        } catch (error) {
          console.error("Error clearing networking connections:", error);
          throw error;
        }
      }
      // ===== SUITE COMPATIBILITY SCORING METHODS =====
      // Helper function to order user IDs consistently to prevent duplicates
      orderUserIds(userId1, userId2) {
        return userId1 < userId2 ? { smallerId: userId1, largerId: userId2 } : { smallerId: userId2, largerId: userId1 };
      }
      async createSuiteCompatibilityScore(scoreData) {
        try {
          const { smallerId, largerId } = this.orderUserIds(
            scoreData.userId,
            scoreData.targetUserId
          );
          const orderedScoreData = {
            ...scoreData,
            userId: smallerId,
            targetUserId: largerId
          };
          const [score] = await db.insert(suiteCompatibilityScores).values(orderedScoreData).returning();
          return score;
        } catch (error) {
          console.error("Error creating suite compatibility score:", error);
          throw error;
        }
      }
      async getSuiteCompatibilityScore(userId, targetProfileId) {
        try {
          const targetProfile = await db.select({ userId: suiteNetworkingProfiles.userId }).from(suiteNetworkingProfiles).where(eq(suiteNetworkingProfiles.id, targetProfileId));
          if (!targetProfile.length) return void 0;
          const targetUserId = targetProfile[0].userId;
          const { smallerId, largerId } = this.orderUserIds(userId, targetUserId);
          const [score] = await db.select().from(suiteCompatibilityScores).where(
            and(
              eq(suiteCompatibilityScores.userId, smallerId),
              eq(suiteCompatibilityScores.targetUserId, largerId),
              eq(suiteCompatibilityScores.targetProfileId, targetProfileId),
              eq(suiteCompatibilityScores.isActive, true)
            )
          );
          return score || void 0;
        } catch (error) {
          console.error("Error getting suite compatibility score:", error);
          throw error;
        }
      }
      async updateSuiteCompatibilityScore(id, updates) {
        try {
          let orderedUpdates = updates;
          if (updates.userId && updates.targetUserId) {
            const { smallerId, largerId } = this.orderUserIds(
              updates.userId,
              updates.targetUserId
            );
            orderedUpdates = {
              ...updates,
              userId: smallerId,
              targetUserId: largerId
            };
          }
          const [score] = await db.update(suiteCompatibilityScores).set({
            ...orderedUpdates,
            lastUpdated: /* @__PURE__ */ new Date()
          }).where(eq(suiteCompatibilityScores.id, id)).returning();
          return score;
        } catch (error) {
          console.error("Error updating suite compatibility score:", error);
          throw error;
        }
      }
      // ===== MENTORSHIP COMPATIBILITY SCORE METHODS =====
      async createSuiteMentorshipCompatibilityScore(scoreData) {
        try {
          const { smallerId, largerId } = this.orderUserIds(
            scoreData.userId,
            scoreData.targetUserId
          );
          const orderedScoreData = {
            ...scoreData,
            userId: smallerId,
            targetUserId: largerId
          };
          const [score] = await db.insert(suiteMentorshipCompatibilityScores).values(orderedScoreData).returning();
          return score;
        } catch (error) {
          console.error("Error creating mentorship compatibility score:", error);
          throw error;
        }
      }
      async getSuiteMentorshipCompatibilityScore(userId, targetProfileId) {
        try {
          const targetProfile = await db.select({ userId: suiteMentorshipProfiles.userId }).from(suiteMentorshipProfiles).where(eq(suiteMentorshipProfiles.id, targetProfileId));
          if (!targetProfile.length) return void 0;
          const targetUserId = targetProfile[0].userId;
          const { smallerId, largerId } = this.orderUserIds(userId, targetUserId);
          const [score] = await db.select().from(suiteMentorshipCompatibilityScores).where(
            and(
              eq(suiteMentorshipCompatibilityScores.userId, smallerId),
              eq(suiteMentorshipCompatibilityScores.targetUserId, largerId),
              eq(
                suiteMentorshipCompatibilityScores.targetProfileId,
                targetProfileId
              ),
              eq(suiteMentorshipCompatibilityScores.isActive, true)
            )
          );
          return score || void 0;
        } catch (error) {
          console.error("Error getting mentorship compatibility score:", error);
          throw error;
        }
      }
      async updateSuiteMentorshipCompatibilityScore(id, updates) {
        try {
          let orderedUpdates = updates;
          if (updates.userId && updates.targetUserId) {
            const { smallerId, largerId } = this.orderUserIds(
              updates.userId,
              updates.targetUserId
            );
            orderedUpdates = {
              ...updates,
              userId: smallerId,
              targetUserId: largerId
            };
          }
          const [score] = await db.update(suiteMentorshipCompatibilityScores).set({
            ...orderedUpdates,
            lastUpdated: /* @__PURE__ */ new Date()
          }).where(eq(suiteMentorshipCompatibilityScores.id, id)).returning();
          return score;
        } catch (error) {
          console.error("Error updating mentorship compatibility score:", error);
          throw error;
        }
      }
      async deleteSuiteMentorshipCompatibilityScore(id) {
        try {
          await db.delete(suiteMentorshipCompatibilityScores).where(eq(suiteMentorshipCompatibilityScores.id, id));
        } catch (error) {
          console.error("Error deleting mentorship compatibility score:", error);
          throw error;
        }
      }
      async deleteSuiteCompatibilityScore(id) {
        try {
          await db.delete(suiteCompatibilityScores).where(eq(suiteCompatibilityScores.id, id));
        } catch (error) {
          console.error("Error deleting suite compatibility score:", error);
          throw error;
        }
      }
      async getUserByMentorshipProfileId(profileId) {
        try {
          const [result] = await db.select({
            id: users.id,
            fullName: users.fullName,
            photoUrl: users.photoUrl,
            profession: users.profession,
            location: users.location,
            email: users.email
          }).from(users).innerJoin(
            suiteMentorshipProfiles,
            eq(users.id, suiteMentorshipProfiles.userId)
          ).where(eq(suiteMentorshipProfiles.id, profileId));
          return result || void 0;
        } catch (error) {
          console.error("Error getting user by mentorship profile ID:", error);
          throw error;
        }
      }
      async getSuiteMentorshipProfileByUserId(userId) {
        try {
          const [profile] = await db.select().from(suiteMentorshipProfiles).where(
            and(
              eq(suiteMentorshipProfiles.userId, userId),
              eq(suiteMentorshipProfiles.isActive, true)
            )
          );
          return profile || void 0;
        } catch (error) {
          console.error("Error getting mentorship profile by user ID:", error);
          throw error;
        }
      }
      async getSuiteMentorshipProfileById(profileId) {
        try {
          const [profile] = await db.select().from(suiteMentorshipProfiles).where(eq(suiteMentorshipProfiles.id, profileId));
          return profile || void 0;
        } catch (error) {
          console.error("Error getting mentorship profile by ID:", error);
          throw error;
        }
      }
      async getUserByNetworkingProfileId(profileId) {
        try {
          const [profile] = await db.select({
            user: users
          }).from(suiteNetworkingProfiles).innerJoin(users, eq(suiteNetworkingProfiles.userId, users.id)).where(eq(suiteNetworkingProfiles.id, profileId));
          return profile?.user || void 0;
        } catch (error) {
          console.error("Error getting user by networking profile ID:", error);
          throw error;
        }
      }
      // Professional Reviews System
      async createProfessionalReview(reviewData) {
        try {
          const result = await db.execute(sql`
        INSERT INTO professional_reviews (
          user_id, target_user_id, rating, review_text, category, is_anonymous, created_at, updated_at
        ) VALUES (
          ${reviewData.reviewerUserId}, 
          ${reviewData.reviewedUserId}, 
          ${reviewData.rating}, 
          ${reviewData.reviewText}, 
          ${reviewData.category || "overall"},
          ${reviewData.isAnonymous || false},
          NOW(),
          NOW()
        ) RETURNING *
      `);
          const review = result.rows[0];
          return {
            id: review.id,
            reviewedUserId: review.target_user_id,
            reviewerUserId: review.user_id,
            rating: review.rating,
            reviewText: review.review_text,
            isAnonymous: reviewData.isAnonymous || false,
            category: review.category,
            createdAt: review.created_at,
            updatedAt: review.updated_at
          };
        } catch (error) {
          console.error("Error creating professional review:", error);
          throw error;
        }
      }
      async getProfessionalReviewsForUser(reviewedUserId) {
        try {
          const reviews = await db.execute(sql`
        SELECT 
          pr.id,
          pr.target_user_id as reviewed_user_id,
          pr.user_id as reviewer_user_id,
          pr.rating,
          pr.review_text,
          pr.category,
          pr.is_anonymous,
          pr.created_at,
          pr.updated_at,
          u.id as reviewer_id,
          u.full_name as reviewer_full_name,
          u.photo_url as reviewer_photo_url,
          u.profession as reviewer_profession
        FROM professional_reviews pr
        LEFT JOIN users u ON pr.user_id = u.id
        WHERE pr.target_user_id = ${reviewedUserId}
        ORDER BY pr.created_at DESC
      `);
          return reviews.rows.map((r) => ({
            id: r.id,
            reviewedUserId: r.reviewed_user_id,
            reviewerUserId: r.reviewer_user_id,
            rating: r.rating,
            reviewText: r.review_text,
            isAnonymous: r.is_anonymous || false,
            category: r.category,
            createdAt: r.created_at,
            updatedAt: r.updated_at,
            reviewer: r.reviewer_id ? {
              id: r.reviewer_id,
              fullName: r.reviewer_full_name,
              photoUrl: r.reviewer_photo_url,
              profession: r.reviewer_profession
            } : null
          }));
        } catch (error) {
          console.error("Error getting professional reviews for user:", error);
          throw error;
        }
      }
      async getProfessionalReviewStats(reviewedUserId) {
        try {
          const reviews = await db.execute(sql`
        SELECT rating 
        FROM professional_reviews 
        WHERE target_user_id = ${reviewedUserId}
      `);
          if (reviews.rows.length === 0) {
            return {
              averageRating: 0,
              totalReviews: 0,
              ratingDistribution: { 1: 0, 2: 0, 3: 0, 4: 0, 5: 0 }
            };
          }
          const totalReviews = reviews.rows.length;
          const averageRating = reviews.rows.reduce((sum, r) => sum + r.rating, 0) / totalReviews;
          const ratingDistribution = { 1: 0, 2: 0, 3: 0, 4: 0, 5: 0 };
          reviews.rows.forEach((r) => {
            ratingDistribution[r.rating]++;
          });
          return {
            averageRating: Math.round(averageRating * 10) / 10,
            totalReviews,
            ratingDistribution
          };
        } catch (error) {
          console.error("Error getting professional review stats:", error);
          throw error;
        }
      }
      async getExistingReview(reviewedUserId, reviewerUserId, category = "overall") {
        try {
          const review = await db.execute(sql`
        SELECT * FROM professional_reviews 
        WHERE target_user_id = ${reviewedUserId} 
        AND user_id = ${reviewerUserId} 
        AND category = ${category}
        LIMIT 1
      `);
          if (review.rows.length === 0) return void 0;
          const r = review.rows[0];
          return {
            id: r.id,
            reviewedUserId: r.target_user_id,
            reviewerUserId: r.user_id,
            rating: r.rating,
            reviewText: r.review_text,
            isAnonymous: r.is_anonymous || false,
            category: r.category,
            createdAt: r.created_at,
            updatedAt: r.updated_at
          };
        } catch (error) {
          console.error("Error getting existing review:", error);
          throw error;
        }
      }
      async deleteProfessionalReview(reviewId, userId) {
        try {
          const result = await db.execute(sql`
        DELETE FROM professional_reviews 
        WHERE id = ${reviewId} AND user_id = ${userId}
        RETURNING id
      `);
          return result.rows.length > 0;
        } catch (error) {
          console.error("Error deleting professional review:", error);
          throw error;
        }
      }
      async updateProfessionalReview(id, updates) {
        try {
          const result = await db.execute(sql`
        UPDATE professional_reviews 
        SET 
          rating = ${updates.rating}, 
          review_text = ${updates.reviewText}, 
          is_anonymous = ${updates.isAnonymous || false},
          updated_at = NOW()
        WHERE id = ${id}
        RETURNING *
      `);
          if (result.rows.length === 0) return void 0;
          const r = result.rows[0];
          return {
            id: r.id,
            reviewedUserId: r.target_user_id,
            reviewerUserId: r.user_id,
            rating: r.rating,
            reviewText: r.review_text,
            isAnonymous: updates.isAnonymous || false,
            category: r.category,
            createdAt: r.created_at,
            updatedAt: r.updated_at
          };
        } catch (error) {
          console.error("Error updating professional review:", error);
          throw error;
        }
      }
      async recordJobApplication(applicationData) {
        try {
          const jobProfile = await this.getSuiteJobProfileById(
            applicationData.jobProfileId
          );
          if (!jobProfile) {
            throw new Error("Job profile not found");
          }
          const result = await db.execute(sql`
        INSERT INTO suite_job_applications (user_id, target_profile_id, target_user_id, action, application_status, matched) 
        VALUES (${applicationData.userId}, ${applicationData.jobProfileId}, ${jobProfile.userId}, ${applicationData.action}, ${applicationData.action === "like" ? "pending" : "rejected"}, false)
        ON CONFLICT (user_id, target_profile_id) 
        DO UPDATE SET action = ${applicationData.action}, application_status = ${applicationData.action === "like" ? "pending" : "rejected"}, created_at = CURRENT_TIMESTAMP
        RETURNING *
      `);
          return result.rows[0];
        } catch (error) {
          console.error("Error recording job application:", error);
          throw error;
        }
      }
      // Swipe history operations for persistent undo functionality
      async addSwipeHistory(swipeData) {
        try {
          const [history] = await db.insert(swipeHistory).values(swipeData).returning();
          return history;
        } catch (error) {
          console.error("Error adding swipe history:", error);
          throw error;
        }
      }
      async getUserSwipeHistory(userId, appMode, limit = 10) {
        try {
          const history = await db.select({
            id: swipeHistory.id,
            userId: swipeHistory.userId,
            targetUserId: swipeHistory.targetUserId,
            action: swipeHistory.action,
            appMode: swipeHistory.appMode,
            timestamp: swipeHistory.timestamp
          }).from(swipeHistory).where(
            and(
              eq(swipeHistory.userId, userId),
              eq(swipeHistory.appMode, appMode)
            )
          ).orderBy(desc(swipeHistory.timestamp)).limit(limit);
          return history;
        } catch (error) {
          console.error("Error getting swipe history:", error);
          throw error;
        }
      }
      async removeSwipeHistory(id) {
        try {
          await db.delete(swipeHistory).where(eq(swipeHistory.id, id));
        } catch (error) {
          console.error("Error removing swipe history:", error);
          throw error;
        }
      }
      async clearUserSwipeHistory(userId, appMode) {
        try {
          await db.delete(swipeHistory).where(
            and(
              eq(swipeHistory.userId, userId),
              eq(swipeHistory.appMode, appMode)
            )
          );
        } catch (error) {
          console.error("Error clearing swipe history:", error);
          throw error;
        }
      }
      async removeSwipeFromHistory(userId, targetUserId) {
        try {
          const [latestSwipe] = await db.select().from(swipeHistory).where(
            and(
              eq(swipeHistory.userId, userId),
              eq(swipeHistory.targetUserId, targetUserId)
            )
          ).orderBy(desc(swipeHistory.timestamp)).limit(1);
          if (latestSwipe) {
            await db.delete(swipeHistory).where(eq(swipeHistory.id, latestSwipe.id));
            console.log(
              `Removed swipe history record ${latestSwipe.id} for user ${userId} -> ${targetUserId}`
            );
          }
        } catch (error) {
          console.error("Error removing swipe from history:", error);
          throw error;
        }
      }
      async removeMatchedUsersFromSwipeHistory(userId1, userId2, appMode) {
        try {
          let whereCondition = or(
            and(
              eq(swipeHistory.userId, userId1),
              eq(swipeHistory.targetUserId, userId2)
            ),
            and(
              eq(swipeHistory.userId, userId2),
              eq(swipeHistory.targetUserId, userId1)
            )
          );
          if (appMode) {
            whereCondition = and(whereCondition, eq(swipeHistory.appMode, appMode));
          }
          const result = await db.delete(swipeHistory).where(whereCondition);
          const modeText = appMode ? ` (${appMode})` : "";
          console.log(
            `[SWIPE-CLEANUP] Removed swipe history records for matched users ${userId1} \u2194 ${userId2}${modeText} to protect match integrity`
          );
        } catch (error) {
          console.error("Error removing matched users from swipe history:", error);
          throw error;
        }
      }
      // Connections Preferences Methods
      async getConnectionsPreferences(userId) {
        try {
          const [preferences] = await db.select().from(connectionsPreferences).where(eq(connectionsPreferences.userId, userId));
          return preferences || null;
        } catch (error) {
          console.error("Error getting connections preferences:", error);
          throw error;
        }
      }
      async saveConnectionsPreferences(userId, data) {
        try {
          const cleanData = { ...data };
          delete cleanData.id;
          delete cleanData.createdAt;
          delete cleanData.updatedAt;
          delete cleanData.userId;
          console.log("Saving connections preferences for user:", userId);
          console.log("\u{1F527} RAW DATA RECEIVED:", JSON.stringify(data, null, 2));
          const existing = await this.getConnectionsPreferences(userId);
          if (existing) {
            console.log("CRITICAL DEBUG: About to update with data:", cleanData);
            console.log(
              "CRITICAL DEBUG: jobs_education_level value:",
              cleanData.jobs_education_level,
              typeof cleanData.jobs_education_level
            );
            console.log(
              "CRITICAL DEBUG: jobs_salary_range value:",
              cleanData.jobs_salary_range,
              typeof cleanData.jobs_salary_range
            );
            const processedData = { ...cleanData };
            const arrayFields = [
              "mentorship_looking_for",
              "mentorship_experience_level",
              "mentorship_industries",
              "mentorship_areas_of_expertise",
              "mentorship_education_level",
              "mentorship_skills",
              "mentorship_topics",
              "mentorship_format",
              "networking_purpose",
              "networking_company_size",
              "networking_seniority",
              "networking_industries",
              "networking_areas_of_expertise",
              "networking_education_level",
              "networking_skills",
              "networking_functional_areas",
              "networking_event_preference",
              "jobs_types",
              "jobs_salary_range",
              "jobs_work_arrangement",
              "jobs_company_size",
              "jobs_industries",
              "jobs_education_level",
              "jobs_skills",
              "jobs_experience_level",
              "jobs_functional_areas",
              "deal_breakers"
            ];
            arrayFields.forEach((field) => {
              if (processedData[field] && Array.isArray(processedData[field])) {
                console.log(
                  `ARRAY-FIX: Converting ${field}:`,
                  processedData[field]
                );
              }
            });
            console.log("ARRAY-FIX: Final processed data:", processedData);
            const arrayFieldsToProcess = [
              "mentorship_looking_for",
              "mentorship_experience_level",
              "mentorship_industries",
              "mentorship_areas_of_expertise",
              "mentorship_education_level",
              "mentorship_skills",
              "mentorship_topics",
              "mentorship_format",
              "networking_purpose",
              "networking_company_size",
              "networking_seniority",
              "networking_industries",
              "networking_areas_of_expertise",
              "networking_education_level",
              "networking_skills",
              "networking_functional_areas",
              "networking_event_preference",
              "jobs_types",
              "jobs_salary_range",
              "jobs_work_arrangement",
              "jobs_company_size",
              "jobs_industries",
              "jobs_education_level",
              "jobs_skills",
              "jobs_experience_level",
              "jobs_functional_areas",
              "deal_breakers"
            ];
            for (const field of arrayFieldsToProcess) {
              if (processedData[field] && Array.isArray(processedData[field])) {
                console.log(
                  `ARRAY-FIX: Processing ${field}:`,
                  processedData[field]
                );
                try {
                  const arrayValue = `{${processedData[field].map((item) => `"${item}"`).join(",")}}`;
                  console.log(
                    `ARRAY-FIX: PostgreSQL array format for ${field}:`,
                    arrayValue
                  );
                  await db.execute(
                    sql.raw(`UPDATE connections_preferences 
                SET ${field} = '${arrayValue}'::text[], 
                    updated_at = NOW() 
                WHERE user_id = ${userId}`)
                  );
                  console.log(`ARRAY-FIX: Successfully updated ${field}`);
                } catch (sqlError) {
                  console.error(`ARRAY-FIX: Failed to update ${field}:`, sqlError);
                }
              }
            }
            const finalUpdateData = { ...processedData };
            if (data.networking_location_preference !== void 0) {
              finalUpdateData.networking_location_preference = data.networking_location_preference;
              console.log(
                "\u{1F527} SINGLE-FIELD FIX: Using original networking_location_preference:",
                data.networking_location_preference
              );
            }
            if (data.mentorship_location_preference !== void 0) {
              finalUpdateData.mentorship_location_preference = data.mentorship_location_preference;
            }
            if (data.jobs_work_location !== void 0) {
              finalUpdateData.jobs_work_location = data.jobs_work_location;
            }
            if (data.mentorship_time_commitment !== void 0) {
              finalUpdateData.mentorship_time_commitment = data.mentorship_time_commitment;
            }
            if (data.jobs_weights !== void 0) {
              finalUpdateData.jobs_weights = data.jobs_weights;
            }
            if (data.mentorship_weights !== void 0) {
              finalUpdateData.mentorship_weights = data.mentorship_weights;
            }
            if (data.networking_weights !== void 0) {
              finalUpdateData.networking_weights = data.networking_weights;
            }
            const updateData = {
              ...finalUpdateData,
              updatedAt: /* @__PURE__ */ new Date()
            };
            if (updateData.networking_location_preference !== void 0) {
              await db.execute(sql`
            UPDATE connections_preferences 
            SET networking_location_preference = ${updateData.networking_location_preference}, 
                updated_at = ${updateData.updatedAt}
            WHERE user_id = ${userId}
          `);
              console.log(
                "\u{1F527} DIRECT SQL: Updated networking_location_preference to:",
                updateData.networking_location_preference
              );
            }
            if (updateData.mentorship_location_preference !== void 0) {
              await db.execute(sql`
            UPDATE connections_preferences 
            SET mentorship_location_preference = ${updateData.mentorship_location_preference}, 
                updated_at = ${updateData.updatedAt}
            WHERE user_id = ${userId}
          `);
              console.log(
                "\u{1F527} DIRECT SQL: Updated mentorship_location_preference to:",
                updateData.mentorship_location_preference
              );
            }
            if (updateData.jobs_work_location !== void 0) {
              await db.execute(sql`
            UPDATE connections_preferences 
            SET jobs_work_location = ${updateData.jobs_work_location}, 
                updated_at = ${updateData.updatedAt}
            WHERE user_id = ${userId}
          `);
              console.log(
                "\u{1F527} DIRECT SQL: Updated jobs_work_location to:",
                updateData.jobs_work_location
              );
            }
            if (data.jobs_weights !== void 0) {
              await db.execute(sql`
            UPDATE connections_preferences 
            SET jobs_weights = ${JSON.stringify(data.jobs_weights)}, 
                updated_at = ${updateData.updatedAt}
            WHERE user_id = ${userId}
          `);
              console.log(
                "\u{1F527} DIRECT SQL: Updated jobs_weights to:",
                data.jobs_weights
              );
            }
            if (data.jobs_salary_currency !== void 0) {
              await db.execute(sql`
            UPDATE connections_preferences 
            SET jobs_salary_currency = ${data.jobs_salary_currency}, 
                updated_at = ${updateData.updatedAt}
            WHERE user_id = ${userId}
          `);
              console.log(
                "\u{1F527} SALARY: Updated jobs_salary_currency to:",
                data.jobs_salary_currency
              );
            }
            if (data.jobs_salary_min !== void 0) {
              await db.execute(sql`
            UPDATE connections_preferences 
            SET jobs_salary_min = ${data.jobs_salary_min}, 
                updated_at = ${updateData.updatedAt}
            WHERE user_id = ${userId}
          `);
              console.log(
                "\u{1F527} SALARY: Updated jobs_salary_min to:",
                data.jobs_salary_min
              );
            }
            if (data.jobs_salary_max !== void 0) {
              await db.execute(sql`
            UPDATE connections_preferences 
            SET jobs_salary_max = ${data.jobs_salary_max}, 
                updated_at = ${updateData.updatedAt}
            WHERE user_id = ${userId}
          `);
              console.log(
                "\u{1F527} SALARY: Updated jobs_salary_max to:",
                data.jobs_salary_max
              );
            }
            if (data.jobs_salary_period !== void 0) {
              await db.execute(sql`
            UPDATE connections_preferences 
            SET jobs_salary_period = ${data.jobs_salary_period}, 
                updated_at = ${updateData.updatedAt}
            WHERE user_id = ${userId}
          `);
              console.log(
                "\u{1F527} SALARY: Updated jobs_salary_period to:",
                data.jobs_salary_period
              );
            }
            if (data.mentorship_weights !== void 0) {
              await db.execute(sql`
            UPDATE connections_preferences 
            SET mentorship_weights = ${JSON.stringify(data.mentorship_weights)}, 
                updated_at = ${updateData.updatedAt}
            WHERE user_id = ${userId}
          `);
              console.log(
                "\u{1F527} DIRECT SQL: Updated mentorship_weights to:",
                data.mentorship_weights
              );
            }
            if (data.networking_weights !== void 0) {
              await db.execute(sql`
            UPDATE connections_preferences 
            SET networking_weights = ${JSON.stringify(data.networking_weights)}, 
                updated_at = ${updateData.updatedAt}
            WHERE user_id = ${userId}
          `);
              console.log(
                "\u{1F527} DIRECT SQL: Updated networking_weights to:",
                data.networking_weights
              );
            }
            const [updated] = await db.update(connectionsPreferences).set(updateData).where(eq(connectionsPreferences.userId, userId)).returning();
            console.log(
              "Connections preferences updated successfully for user:",
              userId
            );
            return updated;
          } else {
            const [created] = await db.insert(connectionsPreferences).values({
              ...cleanData,
              userId,
              createdAt: /* @__PURE__ */ new Date(),
              updatedAt: /* @__PURE__ */ new Date()
            }).returning();
            return created;
          }
        } catch (error) {
          console.error("Error saving connections preferences:", error);
          throw error;
        }
      }
      // ===================================
      // USER REPORT STRIKES METHODS
      // ===================================
      async createUserReportStrike(reportStrike) {
        const [strike] = await db.insert(userReportStrikes).values({
          ...reportStrike,
          createdAt: /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date()
        }).returning();
        return strike;
      }
      async getUserReportStrikes(reportedUserId) {
        return await db.select().from(userReportStrikes).where(eq(userReportStrikes.reportedUserId, reportedUserId)).orderBy(desc(userReportStrikes.createdAt));
      }
      async getUserReportStrikeCount(reportedUserId) {
        const result = await db.select({ count: count() }).from(userReportStrikes).where(eq(userReportStrikes.reportedUserId, reportedUserId));
        return result[0]?.count || 0;
      }
      async getReportStrikesInLast24Hours(reportedUserId) {
        const yesterday = /* @__PURE__ */ new Date();
        yesterday.setHours(yesterday.getHours() - 24);
        return await db.select().from(userReportStrikes).where(
          and(
            eq(userReportStrikes.reportedUserId, reportedUserId),
            sql`${userReportStrikes.createdAt} >= ${yesterday}`
          )
        ).orderBy(desc(userReportStrikes.createdAt));
      }
      // ===== PAYMENT SYSTEM IMPLEMENTATION =====
      // Subscription operations
      async createSubscription(subscription) {
        try {
          const [result] = await db.insert(subscriptions).values(subscription).returning();
          return result;
        } catch (error) {
          console.error("Error creating subscription:", error);
          throw error;
        }
      }
      async getSubscriptionById(id) {
        try {
          const [subscription] = await db.select().from(subscriptions).where(eq(subscriptions.id, id));
          return subscription || void 0;
        } catch (error) {
          console.error("Error getting subscription by ID:", error);
          throw error;
        }
      }
      async getUserSubscription(userId) {
        try {
          const [subscription] = await db.select().from(subscriptions).where(eq(subscriptions.userId, userId)).orderBy(desc(subscriptions.createdAt)).limit(1);
          return subscription || void 0;
        } catch (error) {
          console.error("Error getting user subscription:", error);
          throw error;
        }
      }
      async getUserActiveSubscription(userId) {
        try {
          const [subscription] = await db.select().from(subscriptions).where(
            and(
              eq(subscriptions.userId, userId),
              eq(subscriptions.status, "active"),
              sql`${subscriptions.currentPeriodEnd} > NOW()`
            )
          ).orderBy(desc(subscriptions.createdAt)).limit(1);
          return subscription || void 0;
        } catch (error) {
          console.error("Error getting user active subscription:", error);
          throw error;
        }
      }
      async updateSubscription(id, updates) {
        try {
          const [subscription] = await db.update(subscriptions).set({ ...updates, updatedAt: /* @__PURE__ */ new Date() }).where(eq(subscriptions.id, id)).returning();
          return subscription || void 0;
        } catch (error) {
          console.error("Error updating subscription:", error);
          throw error;
        }
      }
      async cancelSubscription(id) {
        try {
          const [subscription] = await db.update(subscriptions).set({
            status: "cancelled",
            cancelAtPeriodEnd: true,
            cancelledAt: /* @__PURE__ */ new Date(),
            updatedAt: /* @__PURE__ */ new Date()
          }).where(eq(subscriptions.id, id)).returning();
          return subscription || void 0;
        } catch (error) {
          console.error("Error cancelling subscription:", error);
          throw error;
        }
      }
      async getExpiredSubscriptions() {
        try {
          return await db.select().from(subscriptions).where(
            and(
              eq(subscriptions.status, "active"),
              sql`${subscriptions.currentPeriodEnd} < NOW()`
            )
          );
        } catch (error) {
          console.error("Error getting expired subscriptions:", error);
          throw error;
        }
      }
      async getSubscriptionsByProvider(provider) {
        try {
          return await db.select().from(subscriptions).where(eq(subscriptions.provider, provider)).orderBy(desc(subscriptions.createdAt));
        } catch (error) {
          console.error("Error getting subscriptions by provider:", error);
          throw error;
        }
      }
      async getUserSubscriptionHistory(userId) {
        try {
          return await db.select().from(subscriptions).where(eq(subscriptions.userId, userId)).orderBy(desc(subscriptions.createdAt));
        } catch (error) {
          console.error("Error getting user subscription history:", error);
          throw error;
        }
      }
      // Payment method operations
      async createPaymentMethod(paymentMethod) {
        try {
          const [result] = await db.insert(paymentMethods).values(paymentMethod).returning();
          return result;
        } catch (error) {
          console.error("Error creating payment method:", error);
          throw error;
        }
      }
      async getPaymentMethodById(id) {
        try {
          const [paymentMethod] = await db.select().from(paymentMethods).where(eq(paymentMethods.id, id));
          return paymentMethod || void 0;
        } catch (error) {
          console.error("Error getting payment method by ID:", error);
          throw error;
        }
      }
      async getUserPaymentMethods(userId) {
        try {
          return await db.select().from(paymentMethods).where(
            and(
              eq(paymentMethods.userId, userId),
              eq(paymentMethods.isActive, true)
            )
          ).orderBy(
            desc(paymentMethods.isDefault),
            desc(paymentMethods.createdAt)
          );
        } catch (error) {
          console.error("Error getting user payment methods:", error);
          throw error;
        }
      }
      async getUserDefaultPaymentMethod(userId) {
        try {
          const [paymentMethod] = await db.select().from(paymentMethods).where(
            and(
              eq(paymentMethods.userId, userId),
              eq(paymentMethods.isDefault, true),
              eq(paymentMethods.isActive, true)
            )
          ).limit(1);
          return paymentMethod || void 0;
        } catch (error) {
          console.error("Error getting user default payment method:", error);
          throw error;
        }
      }
      async updatePaymentMethod(id, updates) {
        try {
          const [paymentMethod] = await db.update(paymentMethods).set({ ...updates, updatedAt: /* @__PURE__ */ new Date() }).where(eq(paymentMethods.id, id)).returning();
          return paymentMethod || void 0;
        } catch (error) {
          console.error("Error updating payment method:", error);
          throw error;
        }
      }
      async deletePaymentMethod(id) {
        try {
          await db.update(paymentMethods).set({ isActive: false, updatedAt: /* @__PURE__ */ new Date() }).where(eq(paymentMethods.id, id));
        } catch (error) {
          console.error("Error deleting payment method:", error);
          throw error;
        }
      }
      async setDefaultPaymentMethod(userId, paymentMethodId) {
        try {
          await db.update(paymentMethods).set({ isDefault: false, updatedAt: /* @__PURE__ */ new Date() }).where(eq(paymentMethods.userId, userId));
          const [paymentMethod] = await db.update(paymentMethods).set({ isDefault: true, updatedAt: /* @__PURE__ */ new Date() }).where(
            and(
              eq(paymentMethods.id, paymentMethodId),
              eq(paymentMethods.userId, userId)
            )
          ).returning();
          return paymentMethod || void 0;
        } catch (error) {
          console.error("Error setting default payment method:", error);
          throw error;
        }
      }
      // Payment history operations
      async createPaymentHistory(payment) {
        try {
          const [result] = await db.insert(paymentHistory).values(payment).returning();
          return result;
        } catch (error) {
          console.error("Error creating payment history:", error);
          throw error;
        }
      }
      async getPaymentHistoryById(id) {
        try {
          const [payment] = await db.select().from(paymentHistory).where(eq(paymentHistory.id, id));
          return payment || void 0;
        } catch (error) {
          console.error("Error getting payment history by ID:", error);
          throw error;
        }
      }
      async getUserPaymentHistory(userId) {
        try {
          return await db.select().from(paymentHistory).where(eq(paymentHistory.userId, userId)).orderBy(desc(paymentHistory.createdAt));
        } catch (error) {
          console.error("Error getting user payment history:", error);
          throw error;
        }
      }
      async getSubscriptionPaymentHistory(subscriptionId) {
        try {
          return await db.select().from(paymentHistory).where(eq(paymentHistory.subscriptionId, subscriptionId)).orderBy(desc(paymentHistory.createdAt));
        } catch (error) {
          console.error("Error getting subscription payment history:", error);
          throw error;
        }
      }
      async getPaymentHistoryByProvider(provider) {
        try {
          return await db.select().from(paymentHistory).where(eq(paymentHistory.provider, provider)).orderBy(desc(paymentHistory.createdAt));
        } catch (error) {
          console.error("Error getting payment history by provider:", error);
          throw error;
        }
      }
      async getFailedPayments(userId) {
        try {
          const conditions = [eq(paymentHistory.status, "failed")];
          if (userId) {
            conditions.push(eq(paymentHistory.userId, userId));
          }
          return await db.select().from(paymentHistory).where(and(...conditions)).orderBy(desc(paymentHistory.createdAt));
        } catch (error) {
          console.error("Error getting failed payments:", error);
          throw error;
        }
      }
      async updatePaymentStatus(id, status, metadata) {
        try {
          const updates = {
            status,
            updatedAt: /* @__PURE__ */ new Date()
          };
          if (metadata) {
            updates.metadata = metadata;
          }
          const [payment] = await db.update(paymentHistory).set(updates).where(eq(paymentHistory.id, id)).returning();
          return payment || void 0;
        } catch (error) {
          console.error("Error updating payment status:", error);
          throw error;
        }
      }
      // Subscription events operations
      async createSubscriptionEvent(event) {
        try {
          const [result] = await db.insert(subscriptionEvents).values(event).returning();
          return result;
        } catch (error) {
          console.error("Error creating subscription event:", error);
          throw error;
        }
      }
      async getSubscriptionEvents(subscriptionId) {
        try {
          return await db.select().from(subscriptionEvents).where(eq(subscriptionEvents.subscriptionId, subscriptionId)).orderBy(desc(subscriptionEvents.createdAt));
        } catch (error) {
          console.error("Error getting subscription events:", error);
          throw error;
        }
      }
      async getUserSubscriptionEvents(userId) {
        try {
          return await db.select().from(subscriptionEvents).where(eq(subscriptionEvents.userId, userId)).orderBy(desc(subscriptionEvents.createdAt));
        } catch (error) {
          console.error("Error getting user subscription events:", error);
          throw error;
        }
      }
      // Regional pricing operations
      async createRegionalPricing(pricing) {
        try {
          const [result] = await db.insert(regionalPricing).values(pricing).returning();
          return result;
        } catch (error) {
          console.error("Error creating regional pricing:", error);
          throw error;
        }
      }
      async getRegionalPricing(planType, region, currency) {
        try {
          const [pricing] = await db.select().from(regionalPricing).where(
            and(
              eq(regionalPricing.planType, planType),
              eq(regionalPricing.region, region),
              eq(regionalPricing.currency, currency),
              eq(regionalPricing.isActive, true),
              or(
                eq(regionalPricing.validUntil, null),
                sql`${regionalPricing.validUntil} > NOW()`
              )
            )
          ).orderBy(desc(regionalPricing.createdAt)).limit(1);
          return pricing || void 0;
        } catch (error) {
          console.error("Error getting regional pricing:", error);
          throw error;
        }
      }
      async getActivePricingForRegion(region) {
        try {
          return await db.select().from(regionalPricing).where(
            and(
              eq(regionalPricing.region, region),
              eq(regionalPricing.isActive, true),
              or(
                eq(regionalPricing.validUntil, null),
                sql`${regionalPricing.validUntil} > NOW()`
              )
            )
          ).orderBy(regionalPricing.planType, desc(regionalPricing.createdAt));
        } catch (error) {
          console.error("Error getting active pricing for region:", error);
          throw error;
        }
      }
      async updateRegionalPricing(id, updates) {
        try {
          const [pricing] = await db.update(regionalPricing).set({ ...updates, updatedAt: /* @__PURE__ */ new Date() }).where(eq(regionalPricing.id, id)).returning();
          return pricing || void 0;
        } catch (error) {
          console.error("Error updating regional pricing:", error);
          throw error;
        }
      }
      async getDefaultPricing(planType) {
        try {
          const [pricing] = await db.select().from(regionalPricing).where(
            and(
              eq(regionalPricing.planType, planType),
              eq(regionalPricing.region, "global"),
              eq(regionalPricing.isActive, true),
              or(
                eq(regionalPricing.validUntil, null),
                sql`${regionalPricing.validUntil} > NOW()`
              )
            )
          ).orderBy(desc(regionalPricing.createdAt)).limit(1);
          return pricing || void 0;
        } catch (error) {
          console.error("Error getting default pricing:", error);
          throw error;
        }
      }
      // Promotional code operations
      async createPromotionalCode(promoCode) {
        try {
          const [result] = await db.insert(promotionalCodes).values(promoCode).returning();
          return result;
        } catch (error) {
          console.error("Error creating promotional code:", error);
          throw error;
        }
      }
      async getPromotionalCodeByCode(code) {
        try {
          const [promoCode] = await db.select().from(promotionalCodes).where(
            and(
              eq(promotionalCodes.code, code),
              eq(promotionalCodes.isActive, true),
              sql`${promotionalCodes.validFrom} <= NOW()`,
              or(
                eq(promotionalCodes.validUntil, null),
                sql`${promotionalCodes.validUntil} > NOW()`
              )
            )
          );
          return promoCode || void 0;
        } catch (error) {
          console.error("Error getting promotional code by code:", error);
          throw error;
        }
      }
      async validatePromotionalCode(code, userId, planType, region) {
        try {
          const promoCode = await this.getPromotionalCodeByCode(code);
          if (!promoCode) {
            return { valid: false, error: "Invalid or expired promotional code" };
          }
          const existingUsage = await this.getUserPromotionalCodeUsage(
            userId,
            promoCode.id
          );
          if (existingUsage) {
            return { valid: false, error: "Promotional code already used" };
          }
          if (promoCode.maxUses && promoCode.currentUses >= promoCode.maxUses) {
            return { valid: false, error: "Promotional code usage limit reached" };
          }
          if (promoCode.planTypes) {
            const allowedPlanTypes = JSON.parse(promoCode.planTypes);
            if (!allowedPlanTypes.includes(planType)) {
              return {
                valid: false,
                error: "Promotional code not valid for this plan"
              };
            }
          }
          if (promoCode.regions) {
            const allowedRegions = JSON.parse(promoCode.regions);
            if (!allowedRegions.includes(region)) {
              return {
                valid: false,
                error: "Promotional code not valid for this region"
              };
            }
          }
          return { valid: true, discount: promoCode.value };
        } catch (error) {
          console.error("Error validating promotional code:", error);
          return { valid: false, error: "Error validating promotional code" };
        }
      }
      async usePromotionalCode(usage) {
        try {
          const [result] = await db.insert(promotionalCodeUsage).values(usage).returning();
          await this.incrementPromotionalCodeUsage(usage.promoCodeId);
          return result;
        } catch (error) {
          console.error("Error using promotional code:", error);
          throw error;
        }
      }
      async getPromotionalCodeUsage(userId) {
        try {
          return await db.select().from(promotionalCodeUsage).where(eq(promotionalCodeUsage.userId, userId)).orderBy(desc(promotionalCodeUsage.usedAt));
        } catch (error) {
          console.error("Error getting promotional code usage:", error);
          throw error;
        }
      }
      async getUserPromotionalCodeUsage(userId, promoCodeId) {
        try {
          const [usage] = await db.select().from(promotionalCodeUsage).where(
            and(
              eq(promotionalCodeUsage.userId, userId),
              eq(promotionalCodeUsage.promoCodeId, promoCodeId)
            )
          );
          return usage || void 0;
        } catch (error) {
          console.error("Error getting user promotional code usage:", error);
          throw error;
        }
      }
      async incrementPromotionalCodeUsage(promoCodeId) {
        try {
          const [promoCode] = await db.update(promotionalCodes).set({
            currentUses: sql`${promotionalCodes.currentUses} + 1`,
            updatedAt: /* @__PURE__ */ new Date()
          }).where(eq(promotionalCodes.id, promoCodeId)).returning();
          return promoCode || void 0;
        } catch (error) {
          console.error("Error incrementing promotional code usage:", error);
          throw error;
        }
      }
      // Payment analytics and reporting
      async getRevenueByRegion(startDate, endDate) {
        try {
          const conditions = [eq(paymentHistory.status, "succeeded")];
          if (startDate) {
            conditions.push(sql`${paymentHistory.createdAt} >= ${startDate}`);
          }
          if (endDate) {
            conditions.push(sql`${paymentHistory.createdAt} <= ${endDate}`);
          }
          const results = await db.select({
            region: subscriptions.region,
            revenue: sql`SUM(${paymentHistory.amount})`,
            currency: paymentHistory.currency
          }).from(paymentHistory).innerJoin(
            subscriptions,
            eq(paymentHistory.subscriptionId, subscriptions.id)
          ).where(and(...conditions)).groupBy(subscriptions.region, paymentHistory.currency).orderBy(desc(sql`SUM(${paymentHistory.amount})`));
          return results;
        } catch (error) {
          console.error("Error getting revenue by region:", error);
          throw error;
        }
      }
      async getSubscriptionStats() {
        try {
          const [activeCount] = await db.select({ count: count() }).from(subscriptions).where(eq(subscriptions.status, "active"));
          const [cancelledCount] = await db.select({ count: count() }).from(subscriptions).where(eq(subscriptions.status, "cancelled"));
          const [totalCount] = await db.select({ count: count() }).from(subscriptions);
          return {
            active: activeCount.count,
            cancelled: cancelledCount.count,
            total: totalCount.count
          };
        } catch (error) {
          console.error("Error getting subscription stats:", error);
          throw error;
        }
      }
      async getPaymentFailureRate(provider) {
        try {
          const conditions = [];
          if (provider) {
            conditions.push(eq(paymentHistory.provider, provider));
          }
          const [totalPayments] = await db.select({ count: count() }).from(paymentHistory).where(conditions.length > 0 ? and(...conditions) : void 0);
          const failedConditions = [
            ...conditions,
            eq(paymentHistory.status, "failed")
          ];
          const [failedPayments] = await db.select({ count: count() }).from(paymentHistory).where(and(...failedConditions));
          if (totalPayments.count === 0) return 0;
          return failedPayments.count / totalPayments.count * 100;
        } catch (error) {
          console.error("Error getting payment failure rate:", error);
          throw error;
        }
      }
      async getMostUsedPaymentMethods() {
        try {
          const results = await db.select({
            type: paymentHistory.paymentMethod,
            count: sql`COUNT(*)`
          }).from(paymentHistory).where(eq(paymentHistory.status, "succeeded")).groupBy(paymentHistory.paymentMethod).orderBy(desc(sql`COUNT(*)`)).limit(10);
          return results;
        } catch (error) {
          console.error("Error getting most used payment methods:", error);
          throw error;
        }
      }
      // ===================================
      // SUBSCRIPTION IMPLEMENTATION METHODS
      // ===================================
      async createSubscription(subscription) {
        try {
          const [created] = await db.insert(subscriptions).values(subscription).returning();
          return created;
        } catch (error) {
          console.error("Error creating subscription:", error);
          throw error;
        }
      }
      async getSubscription(id) {
        try {
          const [subscription] = await db.select().from(subscriptions).where(eq(subscriptions.id, id));
          return subscription;
        } catch (error) {
          console.error("Error getting subscription:", error);
          throw error;
        }
      }
      async getSubscriptionByUser(userId) {
        try {
          const [subscription] = await db.select().from(subscriptions).where(eq(subscriptions.userId, userId));
          return subscription;
        } catch (error) {
          console.error("Error getting subscription by user:", error);
          throw error;
        }
      }
      async getSubscriptionByStripeId(subscriptionId) {
        try {
          const [subscription] = await db.select().from(subscriptions).where(eq(subscriptions.subscriptionId, subscriptionId));
          return subscription;
        } catch (error) {
          console.error("Error getting subscription by Stripe ID:", error);
          throw error;
        }
      }
      async updateSubscription(id, updates) {
        try {
          const [updated] = await db.update(subscriptions).set(updates).where(eq(subscriptions.id, id)).returning();
          return updated;
        } catch (error) {
          console.error("Error updating subscription:", error);
          throw error;
        }
      }
      async cancelSubscription(id) {
        try {
          const [cancelled] = await db.update(subscriptions).set({
            status: "cancelled",
            updatedAt: /* @__PURE__ */ new Date()
          }).where(eq(subscriptions.id, id)).returning();
          return cancelled;
        } catch (error) {
          console.error("Error cancelling subscription:", error);
          throw error;
        }
      }
      async createPaymentMethod(paymentMethod) {
        try {
          const [created] = await db.insert(paymentMethods).values(paymentMethod).returning();
          return created;
        } catch (error) {
          console.error("Error creating payment method:", error);
          throw error;
        }
      }
      async getPaymentMethodsByUser(userId) {
        try {
          return await db.select().from(paymentMethods).where(eq(paymentMethods.userId, userId));
        } catch (error) {
          console.error("Error getting payment methods by user:", error);
          throw error;
        }
      }
      async getPaymentMethod(id) {
        try {
          const [paymentMethod] = await db.select().from(paymentMethods).where(eq(paymentMethods.id, id));
          return paymentMethod;
        } catch (error) {
          console.error("Error getting payment method:", error);
          throw error;
        }
      }
      async updatePaymentMethod(id, updates) {
        try {
          const [updated] = await db.update(paymentMethods).set(updates).where(eq(paymentMethods.id, id)).returning();
          return updated;
        } catch (error) {
          console.error("Error updating payment method:", error);
          throw error;
        }
      }
      async deletePaymentMethod(id) {
        try {
          await db.delete(paymentMethods).where(eq(paymentMethods.id, id));
        } catch (error) {
          console.error("Error deleting payment method:", error);
          throw error;
        }
      }
      async createPaymentHistory(payment) {
        try {
          const [created] = await db.insert(paymentHistory).values(payment).returning();
          return created;
        } catch (error) {
          console.error("Error creating payment history:", error);
          throw error;
        }
      }
      async getPaymentHistoryByUser(userId) {
        try {
          return await db.select().from(paymentHistory).where(eq(paymentHistory.userId, userId)).orderBy(desc(paymentHistory.createdAt));
        } catch (error) {
          console.error("Error getting payment history by user:", error);
          throw error;
        }
      }
      async getPaymentHistoryBySubscription(subscriptionId) {
        try {
          return await db.select().from(paymentHistory).where(eq(paymentHistory.subscriptionId, subscriptionId)).orderBy(desc(paymentHistory.createdAt));
        } catch (error) {
          console.error("Error getting payment history by subscription:", error);
          throw error;
        }
      }
      async getRegionalPricing(region, planType) {
        try {
          const conditions = [
            eq(regionalPricing.region, region),
            eq(regionalPricing.isActive, true)
          ];
          if (planType) {
            conditions.push(eq(regionalPricing.planType, planType));
          }
          return await db.select().from(regionalPricing).where(and(...conditions)).orderBy(regionalPricing.planType);
        } catch (error) {
          console.error("Error getting regional pricing:", error);
          throw error;
        }
      }
      async getRegionalPricingByRegion(region) {
        try {
          return await db.select().from(regionalPricing).where(
            and(
              eq(regionalPricing.region, region),
              eq(regionalPricing.isActive, true),
              or(
                eq(regionalPricing.validUntil, null),
                sql`${regionalPricing.validUntil} > NOW()`
              )
            )
          ).orderBy(regionalPricing.planType);
        } catch (error) {
          console.error("Error getting regional pricing by region:", error);
          throw error;
        }
      }
      async createRegionalPricing(pricing) {
        try {
          const [created] = await db.insert(regionalPricing).values(pricing).returning();
          return created;
        } catch (error) {
          console.error("Error creating regional pricing:", error);
          throw error;
        }
      }
      async getPromotionalCode(code) {
        try {
          const [promo] = await db.select().from(promotionalCodes).where(eq(promotionalCodes.code, code));
          return promo;
        } catch (error) {
          console.error("Error getting promotional code:", error);
          throw error;
        }
      }
      async validatePromotionalCode(code, userId, region) {
        try {
          const promoCode = await this.getPromotionalCode(code);
          if (!promoCode) {
            return { valid: false, error: "Promotional code not found" };
          }
          if (!promoCode.isActive) {
            return { valid: false, error: "Promotional code is no longer active" };
          }
          if (promoCode.expiresAt && /* @__PURE__ */ new Date() > promoCode.expiresAt) {
            return { valid: false, error: "Promotional code has expired" };
          }
          if (promoCode.maxUses && promoCode.usedCount >= promoCode.maxUses) {
            return { valid: false, error: "Promotional code usage limit reached" };
          }
          const existingUsage = await this.getUserPromotionalCodeUsage(
            userId,
            promoCode.id
          );
          if (existingUsage) {
            return {
              valid: false,
              error: "You have already used this promotional code"
            };
          }
          return { valid: true, discount: promoCode.discountPercentage };
        } catch (error) {
          console.error("Error validating promotional code:", error);
          return { valid: false, error: "Error validating promotional code" };
        }
      }
      async createPromotionalCodeUsage(usage) {
        try {
          const [created] = await db.insert(promotionalCodeUsage).values(usage).returning();
          return created;
        } catch (error) {
          console.error("Error creating promotional code usage:", error);
          throw error;
        }
      }
      // Unified API performance optimization methods
      async getSwipeHistory(userId, appMode, limit) {
        try {
          const startTime = Date.now();
          const history = await db.select().from(swipeHistory).where(
            and(
              eq(swipeHistory.userId, userId),
              eq(swipeHistory.appMode, appMode)
            )
          ).orderBy(desc(swipeHistory.timestamp)).limit(limit);
          const duration = Date.now() - startTime;
          console.log(
            `[SWIPE-HISTORY-FAST] User ${userId}: Query completed in ${duration}ms, returning ${history.length} items`
          );
          return history;
        } catch (error) {
          console.error("Error fetching swipe history:", error);
          return [];
        }
      }
      // Matrix Factorization helper methods
      async getAllMatches() {
        try {
          const allMatches = await db.select({
            id: matches.id,
            userId1: matches.userId1,
            userId2: matches.userId2,
            matched: matches.matched,
            isDislike: matches.isDislike,
            createdAt: matches.createdAt,
            metadata: matches.metadata
          }).from(matches);
          console.log(
            `[STORAGE] Retrieved ${allMatches.length} matches for matrix factorization`
          );
          return allMatches;
        } catch (error) {
          console.error("Error fetching all matches:", error);
          return [];
        }
      }
      async getAllSwipeHistory() {
        try {
          const allSwipes = await db.select({
            id: swipeHistory.id,
            userId: swipeHistory.userId,
            targetUserId: swipeHistory.targetUserId,
            action: swipeHistory.action,
            appMode: swipeHistory.appMode,
            timestamp: swipeHistory.timestamp
          }).from(swipeHistory);
          console.log(
            `[STORAGE] Retrieved ${allSwipes.length} swipe history records for matrix factorization`
          );
          return allSwipes;
        } catch (error) {
          console.error("Error fetching all swipe history:", error);
          return [];
        }
      }
      async getPremiumStatus(userId) {
        try {
          const user = await this.getUser(userId);
          if (!user) {
            return { premiumAccess: false };
          }
          const subscription = await this.getUserActiveSubscription(userId);
          return {
            premiumAccess: user.premiumAccess || false,
            subscriptionStatus: subscription?.status || "none"
          };
        } catch (error) {
          console.error("Error fetching premium status:", error);
          return { premiumAccess: false };
        }
      }
      async getMatchCounts(userId) {
        try {
          console.log(
            `[MATCH-COUNTS-OPTIMIZED] User ${userId}: Starting optimized match count query`
          );
          const startTime = Date.now();
          const [result] = await db.select({
            confirmed: sql`COUNT(CASE WHEN matched = true THEN 1 END)`,
            pending: sql`COUNT(CASE WHEN matched = false AND is_dislike = false THEN 1 END)`,
            total: sql`COUNT(*)`
          }).from(matches).where(or(eq(matches.userId1, userId), eq(matches.userId2, userId)));
          const duration = Date.now() - startTime;
          console.log(
            `[MATCH-COUNTS-OPTIMIZED] User ${userId}: Query completed in ${duration}ms`
          );
          return {
            confirmed: Number(result?.confirmed) || 0,
            pending: Number(result?.pending) || 0,
            total: Number(result?.total) || 0
          };
        } catch (error) {
          console.error("Error fetching match counts:", error);
          return { confirmed: 0, pending: 0, total: 0 };
        }
      }
      async getMatches(userId) {
        try {
          const matches2 = await this.getMatchesByUserId(userId);
          console.log(
            `[MATCH-DEBUG] getMatches for user ${userId}: Found ${matches2.length} matches`
          );
          if (matches2.length > 0) {
            console.log(
              `[MATCH-DEBUG] Match details:`,
              matches2.map((m) => ({
                id: m.id,
                userId1: m.userId1,
                userId2: m.userId2,
                matched: m.matched,
                metadata: m.metadata
              }))
            );
          }
          return matches2;
        } catch (error) {
          console.error("Error fetching matches:", error);
          return [];
        }
      }
      async getSuiteConnectionCounts(userId) {
        try {
          console.log(
            `[SUITE-COUNTS-OPTIMIZED] User ${userId}: Starting optimized count queries`
          );
          const startTime = Date.now();
          const [networkingResult] = await db.select({
            confirmed: sql`COUNT(CASE WHEN matched = true THEN 1 END)`,
            pending: sql`COUNT(CASE WHEN matched = false AND is_dislike = false THEN 1 END)`
          }).from(suiteNetworkingConnections).where(eq(suiteNetworkingConnections.userId, userId));
          const [mentorshipResult] = await db.select({
            confirmed: sql`COUNT(CASE WHEN matched = true THEN 1 END)`,
            pending: sql`COUNT(CASE WHEN matched = false AND is_dislike = false THEN 1 END)`
          }).from(suiteMentorshipConnections).where(eq(suiteMentorshipConnections.userId, userId));
          const [jobsResult] = await db.select({
            accepted: sql`COUNT(CASE WHEN action = 'accepted' THEN 1 END)`,
            pending: sql`COUNT(CASE WHEN action = 'pending' THEN 1 END)`
          }).from(suiteJobApplications).where(eq(suiteJobApplications.userId, userId));
          const duration = Date.now() - startTime;
          console.log(
            `[SUITE-COUNTS-OPTIMIZED] User ${userId}: Query completed in ${duration}ms`
          );
          return {
            networking: {
              matches: Number(networkingResult?.confirmed) || 0,
              pending: Number(networkingResult?.pending) || 0
            },
            mentorship: {
              matches: Number(mentorshipResult?.confirmed) || 0,
              pending: Number(mentorshipResult?.pending) || 0
            },
            jobs: {
              matches: Number(jobsResult?.accepted) || 0,
              pending: Number(jobsResult?.pending) || 0
            }
          };
        } catch (error) {
          console.error("Error fetching suite connection counts:", error);
          return {
            networking: { matches: 0, pending: 0 },
            mentorship: { matches: 0, pending: 0 },
            jobs: { matches: 0, pending: 0 }
          };
        }
      }
      // KWAME AI Conversation methods
      async createKwameConversation(conversation) {
        const [newConversation] = await db.insert(kwameConversations).values(conversation).returning();
        return newConversation;
      }
      async getKwameConversationHistory(userId, limit = 500) {
        const conversations = await db.select().from(kwameConversations).where(eq(kwameConversations.userId, userId)).orderBy(desc(kwameConversations.createdAt)).limit(limit);
        return conversations.reverse();
      }
      async getRecentKwameContext(userId, limit = 20) {
        const conversations = await db.select().from(kwameConversations).where(eq(kwameConversations.userId, userId)).orderBy(desc(kwameConversations.createdAt)).limit(limit);
        return conversations.reverse();
      }
      async clearKwameConversationHistory(userId) {
        await db.delete(kwameConversations).where(eq(kwameConversations.userId, userId));
      }
    };
    storage = new DatabaseStorage();
  }
});

// server/auth.ts
import passport from "passport";
import { Strategy as LocalStrategy } from "passport-local";
import session2 from "express-session";
import { scrypt, randomBytes, timingSafeEqual } from "crypto";
import { promisify } from "util";
async function hashPassword(password) {
  const salt = randomBytes(16).toString("hex");
  const buf = await scryptAsync(password, salt, 64);
  return `${buf.toString("hex")}.${salt}`;
}
async function comparePasswords(supplied, stored) {
  const [hashed, salt] = stored.split(".");
  const hashedBuf = Buffer.from(hashed, "hex");
  const suppliedBuf = await scryptAsync(supplied, salt, 64);
  return timingSafeEqual(hashedBuf, suppliedBuf);
}
function setupAuth(app2) {
  const sessionSettings = {
    secret: process.env.SESSION_SECRET || "charley-app-secret-key",
    resave: true,
    // Save session on each request
    saveUninitialized: false,
    // Don't create session until something is stored
    store: storage.sessionStore,
    // Using PostgreSQL store for persistence
    cookie: {
      maxAge: 365 * 24 * 60 * 60 * 1e3,
      // 1 year expiration for long-term persistence
      secure: process.env.NODE_ENV === "production",
      sameSite: "lax",
      httpOnly: true,
      // Prevent JavaScript access to cookies
      path: "/"
    },
    rolling: true
    // Reset expiration with each request to keep session alive
  };
  app2.set("trust proxy", 1);
  app2.use(session2(sessionSettings));
  app2.use(passport.initialize());
  app2.use(passport.session());
  app2.use((req, res, next) => touchSession(req, res, next));
  const userLoginCache = /* @__PURE__ */ new Map();
  const CACHE_TTL = 5 * 60 * 1e3;
  passport.use(
    new LocalStrategy(
      { usernameField: "email" },
      async (email, password, done) => {
        try {
          const cacheKey = `${email}:${password}`;
          const cachedUser = userLoginCache.get(cacheKey);
          if (cachedUser && cachedUser.expiry > Date.now()) {
            return done(null, cachedUser.user);
          }
          const [emailUser, usernameUser, phoneUser] = await Promise.all([
            storage.getUserByEmail(email).catch(() => null),
            storage.getUserByUsername(email).catch(() => null),
            storage.getUserByPhoneNumber(email).catch(() => null)
          ]);
          const user = emailUser || usernameUser || phoneUser;
          if (!user) {
            return done(null, false);
          }
          if (user.isSuspended) {
            if (user.suspensionExpiresAt && /* @__PURE__ */ new Date() > user.suspensionExpiresAt) {
              await storage.updateUserProfile(user.id, {
                isSuspended: false,
                suspendedAt: null,
                suspensionExpiresAt: null
              });
              console.log(`\u{1F513} User ${user.id} suspension expired, automatically unsuspended`);
            } else {
              console.log(`\u26A0\uFE0F Suspended user ${user.username} (ID: ${user.id}) logged in - will see suspension interface`);
            }
          }
          console.log(`\u{1F50D} Attempting authentication for user: ${user.username} (ID: ${user.id})`);
          console.log(`\u{1F511} Stored password format: ${user.password?.substring(0, 20)}...`);
          const passwordValid = await comparePasswords(password, user.password);
          if (!passwordValid) {
            console.log(`\u274C Authentication failed for user: ${user.username} (ID: ${user.id})`);
            console.log(`\u{1F4DD} Password provided: ${password}`);
            return done(null, false);
          }
          userLoginCache.set(cacheKey, {
            user,
            expiry: Date.now() + CACHE_TTL
          });
          console.log("Authentication successful for user:", user.id);
          return done(null, user);
        } catch (error) {
          console.error("Authentication error:", error);
          return done(error);
        }
      }
    )
  );
  const userDeserializeCache = /* @__PURE__ */ new Map();
  const USER_CACHE_TTL = 5 * 60 * 1e3;
  passport.serializeUser((user, done) => done(null, user.id));
  passport.deserializeUser(async (id, done) => {
    try {
      const cached = userDeserializeCache.get(id);
      if (cached && cached.expiry > Date.now()) {
        return done(null, cached.user);
      }
      const user = await storage.getUser(id);
      if (!user) {
        console.log(`[AUTH-DESERIALIZE] User not found for ID: ${id}`);
        return done(null, false);
      }
      userDeserializeCache.set(id, {
        user,
        expiry: Date.now() + USER_CACHE_TTL
      });
      done(null, user);
    } catch (error) {
      console.error(`[AUTH-DESERIALIZE] Error deserializing user ${id}:`, error);
      done(null, false);
    }
  });
  app2.post("/api/register", async (req, res, next) => {
    try {
      const existenceChecks = [];
      if (req.body.phoneNumber) {
        existenceChecks.push(
          storage.getUserByPhoneNumber(req.body.phoneNumber).then((user2) => ({ type: "phone", user: user2 }))
        );
      }
      if (req.body.email) {
        const normalizedEmail = req.body.email.trim().toLowerCase();
        req.body.email = normalizedEmail;
        existenceChecks.push(
          storage.getUserByEmail(normalizedEmail).then((user2) => ({ type: "email", user: user2, source: "users" }))
        );
        existenceChecks.push(
          storage.isEmailInBlockedPhoneNumbers(normalizedEmail).then((blockedRecord) => ({
            type: "email",
            user: blockedRecord,
            source: "blocked_phones"
          }))
        );
      }
      if (existenceChecks.length > 0) {
        const results = await Promise.all(existenceChecks);
        for (const result of results) {
          if (result.user && (!req.isAuthenticated() || req.user.id !== result.user.id)) {
            let errorMessage = "";
            if (result.type === "phone") {
              errorMessage = "Phone number already in use by another account";
            } else if (result.type === "email") {
              if (result.source === "blocked_phones") {
                errorMessage = "This email is associated with a blocked account. Please use a different email address or contact support if you believe this is an error.";
                console.log(`[EMAIL-UNIQUENESS] Blocked email duplicate attempt: ${req.body.email} (found in blocked phone numbers table)`);
              } else {
                errorMessage = "Email already registered with another account. Please use a different email or sign in with your existing account.";
                console.log(`[EMAIL-UNIQUENESS] Active email duplicate attempt: ${req.body.email} (found in users table)`);
              }
            }
            console.log(`[DUPLICATE-ACCOUNT-PREVENTION] Blocked ${result.type} duplicate from ${result.source}: ${result.type === "phone" ? req.body.phoneNumber : req.body.email}`);
            return res.status(400).send(errorMessage);
          }
        }
      }
      if (!req.body.username) {
        if (req.body.fullName) {
          req.body.username = req.body.fullName.replace(/\s+/g, "") + Math.floor(Math.random() * 1e4);
        } else if (req.body.email) {
          req.body.username = req.body.email.split("@")[0] + Math.floor(Math.random() * 1e4);
        } else {
          req.body.username = "user_" + Math.floor(Math.random() * 1e6);
        }
      }
      const user = await storage.createUser({
        ...req.body,
        password: await hashPassword(req.body.password),
        verifiedByPhone: req.body.phoneNumber ? true : false
      });
      const photoPromises = [];
      if (user.photoUrl) {
        photoPromises.push(
          storage.addUserPhoto({
            userId: user.id,
            photoUrl: user.photoUrl,
            isPrimary: true
          }).catch((photoError) => {
            console.error("Error adding primary user photo during registration:", photoError);
            return null;
          })
        );
      }
      if (req.body.photoUrl2) {
        photoPromises.push(
          storage.addUserPhoto({
            userId: user.id,
            photoUrl: req.body.photoUrl2,
            isPrimary: false
          }).catch((photoError) => {
            console.error("Error adding secondary user photo during registration:", photoError);
            return null;
          })
        );
      }
      if (photoPromises.length > 0) {
        await Promise.all(photoPromises);
      }
      req.login(user, (err) => {
        if (err) return next(err);
        if (req.session && req.session.cookie) {
          req.session.cookie.maxAge = 365 * 24 * 60 * 60 * 1e3;
        }
        const { password, ...userWithoutPassword } = user;
        console.log(`New user ${user.id} registered with persistent session`);
        res.status(201).json(userWithoutPassword);
      });
    } catch (error) {
      console.error("Registration error:", error);
      next(error);
    }
  });
  app2.post("/api/login", (req, res, next) => {
    passport.authenticate("local", (err, user, info) => {
      if (err) return next(err);
      if (!user) {
        return res.status(401).json({ message: "Invalid credentials" });
      }
      req.login(user, (loginErr) => {
        if (loginErr) return next(loginErr);
        if (req.session) {
          req.session.touch();
          if (req.session.cookie) {
            req.session.cookie.maxAge = 365 * 24 * 60 * 60 * 1e3;
          }
          req.session.save(async (saveErr) => {
            if (saveErr) {
              console.error("Session save error:", saveErr);
            }
            try {
              const freshUser = await storage.getUser(user.id);
              if (!freshUser) {
                return res.status(404).json({ message: "User not found" });
              }
              const { password, ...userWithoutPassword } = freshUser;
              console.log(`User ${user.id} logged in with persistent session (fresh DB fetch)`);
              res.status(200).json(userWithoutPassword);
            } catch (dbErr) {
              console.error("DB fetch error after login:", dbErr);
              res.status(500).json({ message: "Failed to fetch user after login" });
            }
          });
        } else {
          const { password, ...userWithoutPassword } = user;
          res.status(200).json(userWithoutPassword);
        }
      });
    })(req, res, next);
  });
  app2.post("/api/logout", (req, res, next) => {
    req.logout((err) => {
      if (err) return next(err);
      res.sendStatus(200);
    });
  });
  app2.get("/api/user", async (req, res) => {
    if (!req.isAuthenticated()) {
      console.log("User authentication check failed");
      return res.status(401).json({ message: "Unauthorized", status: "login_required" });
    }
    const userId = req.user.id;
    try {
      const freshUser = await storage.getUser(userId);
      if (!freshUser) {
        return res.status(404).json({ message: "User not found" });
      }
      if (freshUser.isSuspended) {
        if (freshUser.suspensionExpiresAt && /* @__PURE__ */ new Date() > freshUser.suspensionExpiresAt) {
          await storage.updateUserProfile(userId, {
            isSuspended: false,
            suspendedAt: null,
            suspensionExpiresAt: null
          });
          console.log(`\u{1F513} User ${userId} suspension expired, automatically unsuspended`);
        } else {
          console.log(`\u26A0\uFE0F Suspended user ${freshUser.username} (ID: ${userId}) accessing app - will see suspension interface`);
        }
      }
      if (req.session) {
        req.session.touch();
      }
      const { password, ...userWithoutPassword } = freshUser;
      console.log("User authenticated successfully, ID:", userId);
      res.json(userWithoutPassword);
    } catch (error) {
      console.error("Error checking user status:", error);
      return res.status(500).json({ message: "Internal server error" });
    }
  });
  app2.post("/api/user/activate-profile", async (req, res) => {
    if (!req.isAuthenticated()) {
      console.log("Profile activation failed - user not authenticated");
      return res.status(401).json({ message: "Unauthorized", status: "login_required" });
    }
    try {
      const userId = req.user.id;
      const updatedUser = await storage.updateUser(userId, {
        profileHidden: false,
        hasActivatedProfile: true,
        showProfilePhoto: true
      });
      if (!updatedUser) {
        return res.status(404).json({ message: "User not found" });
      }
      console.log(`MEET profile activated for user ${userId} - privacy toggle disabled and photo visibility enabled automatically`);
      const { password, ...userWithoutPassword } = updatedUser;
      res.json(userWithoutPassword);
    } catch (error) {
      console.error("Profile activation error:", error);
      res.status(500).json({ message: "Failed to activate profile" });
    }
  });
}
var scryptAsync, requireAuth, touchSession;
var init_auth = __esm({
  "server/auth.ts"() {
    "use strict";
    init_storage();
    scryptAsync = promisify(scrypt);
    requireAuth = (req, res, next) => {
      if (req.isAuthenticated()) {
        return next();
      }
      return res.status(401).json({ message: "Unauthorized" });
    };
    touchSession = (req, res, next) => {
      if (req.session) {
        req.session.touch();
      }
      next();
    };
  }
});

// server/match-api.ts
var match_api_exports = {};
__export(match_api_exports, {
  registerMatchAPI: () => registerMatchAPI,
  sendLikeNotification: () => sendLikeNotification,
  sendUnmatchNotification: () => sendUnmatchNotification,
  setWebSocketConnections: () => setWebSocketConnections
});
import { WebSocket } from "ws";
async function setupMatchAndNotify(matchId, user1Id, user2Id) {
  try {
    console.log(
      `Setting up match ${matchId} between users ${user1Id} and ${user2Id} (without automated welcome messages)`
    );
    const user1 = await storage.getUser(user1Id);
    const user2 = await storage.getUser(user2Id);
    if (!user1 || !user2) {
      console.error(`Could not find users for match ${matchId}`);
      return;
    }
    await storage.updateMatch(matchId, { matched: true });
    console.log(
      `Successfully set up match ${matchId} without automated welcome messages`
    );
    if (connectedUsers) {
      const user1Socket = connectedUsers.get(user1Id);
      if (user1Socket && user1Socket.readyState === WebSocket.OPEN) {
        user1Socket.send(
          JSON.stringify({
            type: "matches:refresh",
            matchId,
            reason: "new_match",
            timestamp: (/* @__PURE__ */ new Date()).toISOString()
          })
        );
        user1Socket.send(
          JSON.stringify({
            type: "match_notification",
            match: {
              id: matchId,
              userId1: user1Id,
              userId2: user2Id,
              matched: true
            },
            fromUserInfo: {
              id: user2Id,
              fullName: user2.fullName,
              photoUrl: user2.photoUrl
            },
            matchId,
            isMatch: true,
            forceDisplay: true
          })
        );
      }
      const user2Socket = connectedUsers.get(user2Id);
      if (user2Socket && user2Socket.readyState === WebSocket.OPEN) {
        user2Socket.send(
          JSON.stringify({
            type: "matches:refresh",
            matchId,
            reason: "new_match",
            timestamp: (/* @__PURE__ */ new Date()).toISOString()
          })
        );
        user2Socket.send(
          JSON.stringify({
            type: "match_notification",
            match: {
              id: matchId,
              userId1: user1Id,
              userId2: user2Id,
              matched: true
            },
            fromUserInfo: {
              id: user1Id,
              fullName: user1.fullName,
              photoUrl: user1.photoUrl
            },
            matchId,
            isMatch: true,
            forceDisplay: true
          })
        );
      }
      console.log(`Sent real-time updates to both users for match ${matchId}`);
    }
    await storage.updateMatch(matchId, {
      matched: true
    });
    try {
      const db2 = await Promise.resolve().then(() => (init_db(), db_exports)).then((module) => module.db);
      const matches2 = await Promise.resolve().then(() => (init_schema(), schema_exports)).then(
        (module) => module.matches
      );
      const { eq: eq7 } = await import("drizzle-orm");
      await db2.update(matches2).set({ lastMessageAt: /* @__PURE__ */ new Date() }).where(eq7(matches2.id, matchId));
      console.log(`Updated lastMessageAt for match ${matchId}`);
    } catch (dbError) {
      console.error(
        `Error updating lastMessageAt for match ${matchId}:`,
        dbError
      );
    }
  } catch (error) {
    console.error(
      `Error setting up match ${matchId}:`,
      error
    );
  }
}
function setWebSocketConnections(connections) {
  connectedUsers = connections;
}
async function sendLikeNotification(userId, matchData, fromUserId) {
  try {
    if (!connectedUsers) {
      console.warn(
        "WebSocket connections map not initialized. Notifications won't be sent."
      );
      return;
    }
    const userSocket = connectedUsers.get(userId);
    if (!userSocket || userSocket.readyState !== WebSocket.OPEN) {
      console.log(
        `Cannot send notification to user ${userId}: not connected or socket not ready`
      );
      return;
    }
    try {
      const allUserMatches = await storage.getMatchesByUserId(userId);
      const confirmedMatches = allUserMatches.filter((match) => match.matched);
      const pendingLikes = allUserMatches.filter(
        (match) => !match.matched && !match.isDislike && match.userId1 !== userId && match.userId2 === userId
      );
      const fromUser = await storage.getUser(fromUserId);
      let fromUserInfo = null;
      if (fromUser) {
        const { password, ...userWithoutPassword } = fromUser;
        fromUserInfo = userWithoutPassword;
      }
      const isMatch = matchData.matched === true;
      const notificationType = isMatch ? "new_match" : "new_like";
      console.log(
        `\u{1F525} CRITICAL FIX: Sending guaranteed match popup notification to user ${userId} from user ${fromUserId}`
      );
      if (isMatch) {
        userSocket.send(
          JSON.stringify({
            type: "match_popup_prepare",
            fromUserInfo,
            matchId: matchData.id,
            timestamp: Date.now()
          })
        );
        await new Promise((resolve) => setTimeout(resolve, 50));
      }
      userSocket.send(
        JSON.stringify({
          type: isMatch ? "match_notification" : "new_like",
          match: matchData,
          fromUserId,
          fromUserInfo,
          // Include user profile information
          counts: {
            confirmed: confirmedMatches.length,
            pending: pendingLikes.length,
            total: pendingLikes.length
            // FIXED: Only count pending likes in the total, not confirmed matches
          },
          isMatch,
          matchId: matchData.id,
          // Explicitly include matchId for easier handling
          timestamp: Date.now(),
          // CRITICAL: Add multiple flags to guarantee popup display
          priority: isMatch ? "critical" : "normal",
          guaranteed_match_popup: isMatch,
          forceDisplay: isMatch
        })
      );
      console.log(`WebSocket notification sent successfully to user ${userId}`);
    } catch (error) {
      console.error(`Error preparing enhanced notification data:`, error);
      const fallbackIsMatch = matchData.matched === true;
      userSocket.send(
        JSON.stringify({
          type: fallbackIsMatch ? "match_notification" : "new_like",
          match: matchData,
          matchId: matchData.id,
          fromUserId,
          isMatch: fallbackIsMatch,
          timestamp: Date.now(),
          forceDisplay: fallbackIsMatch
        })
      );
    }
  } catch (error) {
    console.error(`Error sending like notification to user ${userId}:`, error);
  }
}
async function sendUnmatchNotification(userId, matchId, unmatchedByUserId) {
  try {
    if (!connectedUsers) {
      console.warn(
        "WebSocket connections map not initialized. Unmatch notification won't be sent."
      );
      return;
    }
    const userSocket = connectedUsers.get(userId);
    if (!userSocket || userSocket.readyState !== WebSocket.OPEN) {
      console.log(
        `Cannot send unmatch notification to user ${userId}: not connected or socket not ready`
      );
      return;
    }
    userSocket.send(
      JSON.stringify({
        type: "unmatch_notification",
        matchId,
        unmatchedBy: unmatchedByUserId,
        timestamp: (/* @__PURE__ */ new Date()).toISOString(),
        // Add an action flag to instruct client to redirect to messages page
        action: "redirect_to_messages"
      })
    );
    userSocket.send(
      JSON.stringify({
        type: "matches:refresh",
        reason: "unmatch",
        timestamp: (/* @__PURE__ */ new Date()).toISOString()
      })
    );
    console.log(`Unmatch notification sent successfully to user ${userId}`);
  } catch (error) {
    console.error(`Error sending unmatch notification to user ${userId}:`, error);
  }
}
function registerMatchAPI(app2) {
  app2.post("/api/matches", async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        console.log("User not authenticated when creating a match/like");
        return res.status(401).json({ message: "Unauthorized" });
      }
      const userId = req.user.id;
      console.log(
        `Creating new match/like initiated by user ${userId}:`,
        req.body
      );
      const { userId1, userId2, matched = false, isDislike = false } = req.body;
      if (!userId1 || !userId2) {
        return res.status(400).json({ message: "Both user IDs are required" });
      }
      if (userId1 === userId2) {
        console.log(`User ${userId} attempted to match with themselves`);
        return res.status(400).json({ message: "Users cannot match with themselves" });
      }
      if (userId1 !== userId && userId2 !== userId) {
        console.log(
          `User ${userId} not authorized to create match between ${userId1} and ${userId2}`
        );
        return res.status(403).json({ message: "Not authorized to create this match" });
      }
      console.log(
        `\u{1F50D} [MEET-FIX] Checking if match exists between users ${userId1} and ${userId2}`
      );
      const allMatchesBetweenUsers = await storage.getAllMatchesBetweenUsers(userId1, userId2);
      console.log(`\u{1F50D} [MEET-FIX] Found ${allMatchesBetweenUsers.length} existing matches between users`);
      if (allMatchesBetweenUsers.length > 0) {
        allMatchesBetweenUsers.forEach((match, index) => {
          console.log(`\u{1F50D} [MEET-FIX] Match ${index + 1}: ID=${match.id}, metadata=${match.metadata}`);
        });
      }
      const existingMatch = allMatchesBetweenUsers.length > 0 ? allMatchesBetweenUsers[0] : null;
      if (existingMatch) {
        console.log(
          `Match already exists (ID: ${existingMatch.id}) between users ${existingMatch.userId1} and ${existingMatch.userId2}`
        );
        if (existingMatch.matched === matched && existingMatch.isDislike === isDislike) {
          if (existingMatch.metadata) {
            try {
              const existingMetadata = typeof existingMatch.metadata === "string" ? JSON.parse(existingMatch.metadata) : existingMatch.metadata;
              if (existingMetadata && existingMetadata.origin === "SUITE") {
                console.log(`\u{1F517} [MEET-FIX] Found SUITE match with origin: ${existingMetadata.origin}, suiteType: ${existingMetadata.suiteType}`);
                console.log(`\u{1F517} [MEET-FIX] Current additionalConnections: ${JSON.stringify(existingMetadata.additionalConnections)}`);
                if (!existingMetadata.additionalConnections) {
                  existingMetadata.additionalConnections = [];
                  console.log(`\u{1F517} [MEET-FIX] Initialized additionalConnections array`);
                }
                if (!existingMetadata.additionalConnections.includes("MEET")) {
                  existingMetadata.additionalConnections.push("MEET");
                  console.log(`\u{1F517} [MEET-FIX] Adding MEET to additionalConnections for same-state match ${existingMatch.id}`);
                  console.log(`\u{1F517} [MEET-FIX] New additionalConnections: ${JSON.stringify(existingMetadata.additionalConnections)}`);
                  const updatedMatch2 = await storage.updateMatch(existingMatch.id, {
                    metadata: JSON.stringify(existingMetadata)
                  });
                  console.log(`\u{1F517} [MEET-FIX] Successfully added MEET to additionalConnections for existing SUITE match ${existingMatch.id}`);
                  console.log(`\u{1F517} [MEET-FIX] Final updated metadata: ${updatedMatch2?.metadata}`);
                  return res.status(200).json({
                    message: "MEET added as additional connection to existing SUITE match",
                    match: updatedMatch2
                  });
                } else {
                  console.log(`\u{1F517} [MEET-FIX] MEET already exists in additionalConnections, no update needed`);
                }
              }
            } catch (parseError) {
              console.error("Failed to parse existing metadata during same-state check:", parseError);
            }
          }
          return res.status(409).json({
            message: "Match already exists with this state",
            existingMatch
          });
        }
        let finalMetadata = existingMatch.metadata;
        if (existingMatch.metadata) {
          try {
            const existingMetadata = typeof existingMatch.metadata === "string" ? JSON.parse(existingMatch.metadata) : existingMatch.metadata;
            if (existingMetadata && existingMetadata.origin === "SUITE") {
              if (!existingMetadata.additionalConnections) {
                existingMetadata.additionalConnections = [];
              }
              if (!existingMetadata.additionalConnections.includes("MEET")) {
                existingMetadata.additionalConnections.push("MEET");
                console.log(`\u{1F517} Adding MEET to additionalConnections for existing match ${existingMatch.id}`);
              }
              finalMetadata = JSON.stringify(existingMetadata);
            }
          } catch (parseError) {
            console.error("Failed to parse existing metadata during update:", parseError);
          }
        }
        const updatedMatch = await storage.updateMatch(existingMatch.id, {
          matched,
          isDislike,
          metadata: finalMetadata
        });
        if (matched && !existingMatch.matched && updatedMatch) {
          const otherUserId2 = userId1 === userId ? userId2 : userId1;
          await setupMatchAndNotify(
            updatedMatch.id,
            userId,
            otherUserId2
          );
          sendLikeNotification(otherUserId2, updatedMatch, userId);
          sendLikeNotification(userId, updatedMatch, otherUserId2);
          if (connectedUsers) {
            const user1Socket = connectedUsers.get(userId);
            if (user1Socket && user1Socket.readyState === WebSocket.OPEN) {
              user1Socket.send(
                JSON.stringify({
                  type: "matches:refresh",
                  matchId: updatedMatch.id,
                  reason: "new_match",
                  timestamp: (/* @__PURE__ */ new Date()).toISOString()
                })
              );
            }
            const user2Socket = connectedUsers.get(otherUserId2);
            if (user2Socket && user2Socket.readyState === WebSocket.OPEN) {
              user2Socket.send(
                JSON.stringify({
                  type: "matches:refresh",
                  matchId: updatedMatch.id,
                  reason: "new_match",
                  timestamp: (/* @__PURE__ */ new Date()).toISOString()
                })
              );
            }
          }
        }
        return res.status(200).json(updatedMatch);
      }
      const newMatch2 = await storage.createMatch({
        userId1,
        userId2,
        matched,
        isDislike,
        metadata: JSON.stringify({ origin: "MEET" })
      });
      console.log(`\u{1F517} Created new MEET match between users ${userId1} and ${userId2}`);
      console.log(
        `New match created (ID: ${newMatch2.id}) between users ${newMatch2.userId1} and ${newMatch2.userId2}`
      );
      const otherUserId = userId1 === userId ? userId2 : userId1;
      if (matched) {
        await setupMatchAndNotify(newMatch2.id, userId, otherUserId);
        sendLikeNotification(otherUserId, newMatch2, userId);
        sendLikeNotification(userId, newMatch2, otherUserId);
        if (connectedUsers) {
          const user1Socket = connectedUsers.get(userId);
          if (user1Socket && user1Socket.readyState === WebSocket.OPEN) {
            user1Socket.send(
              JSON.stringify({
                type: "matches:refresh",
                matchId: newMatch2.id,
                reason: "new_match",
                timestamp: (/* @__PURE__ */ new Date()).toISOString()
              })
            );
          }
          const user2Socket = connectedUsers.get(otherUserId);
          if (user2Socket && user2Socket.readyState === WebSocket.OPEN) {
            user2Socket.send(
              JSON.stringify({
                type: "matches:refresh",
                matchId: newMatch2.id,
                reason: "new_match",
                timestamp: (/* @__PURE__ */ new Date()).toISOString()
              })
            );
          }
        }
      } else {
        sendLikeNotification(otherUserId, newMatch2, userId);
      }
      return res.status(201).json(newMatch2);
    } catch (error) {
      console.error("Error creating match:", error);
      return res.status(500).json({ message: "Server error creating match" });
    }
  });
  app2.get("/api/matches/counts", async (req, res) => {
    if (!req.isAuthenticated()) {
      return res.status(401).json({ message: "Unauthorized" });
    }
    try {
      const userId = req.user.id;
      const matches2 = await storage.getMatchesByUserId(userId);
      const clickedIdsParam = req.query.clicked || "[]";
      let clickedMatchIds = [];
      try {
        clickedMatchIds = JSON.parse(clickedIdsParam);
        if (!Array.isArray(clickedMatchIds)) {
          clickedMatchIds = [];
        }
      } catch (e) {
        console.error("Error parsing clicked match IDs:", e);
        clickedMatchIds = [];
      }
      const confirmedMatches = matches2.filter((match) => match.matched);
      const pendingLikes = matches2.filter(
        (match) => !match.matched && !match.isDislike && match.userId1 !== userId && match.userId2 === userId
      );
      const visibleConfirmedMatches = confirmedMatches.filter(
        (match) => !clickedMatchIds.includes(match.id)
      );
      const visiblePendingLikes = pendingLikes.filter(
        (match) => !clickedMatchIds.includes(match.id)
      );
      console.log(
        `Match counts for user ${userId}: Confirmed=${visibleConfirmedMatches.length}, Pending=${visiblePendingLikes.length}`
      );
      return res.json({
        confirmed: visibleConfirmedMatches.length,
        pending: visiblePendingLikes.length,
        total: visiblePendingLikes.length,
        // FIXED: Only pending likes count in the total for notifications
        timestamp: Date.now()
      });
    } catch (error) {
      console.error("Error fetching match counts:", error);
      return res.status(500).json({ message: "Server error" });
    }
  });
  app2.get(
    "/api/matches/since/:timestamp",
    async (req, res) => {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      try {
        let since;
        const timestampParam = req.params.timestamp;
        if (timestampParam.includes("-") || timestampParam.includes("T")) {
          since = new Date(timestampParam);
        } else {
          const timestamp2 = parseInt(timestampParam, 10);
          if (isNaN(timestamp2)) {
            return res.status(400).json({ message: "Invalid timestamp format" });
          }
          since = new Date(timestamp2);
        }
        if (isNaN(since.getTime())) {
          return res.status(400).json({ message: "Invalid date from timestamp" });
        }
        const userId = req.user.id;
        const matches2 = await storage.getMatchesSince(userId, since);
        console.log(
          `\u{1F525} MATCH-CHECKER: Found ${matches2.length} matches for user ${userId} since ${since.toISOString()}`
        );
        if (matches2.length > 0) {
          const enhancedMatches = await Promise.all(
            matches2.map(async (match) => {
              try {
                const otherUserId = match.userId1 === userId ? match.userId2 : match.userId1;
                const otherUser = await storage.getUser(otherUserId);
                if (otherUser) {
                  const { password, ...userInfo } = otherUser;
                  return {
                    ...match,
                    userInfo,
                    // Include these properties for compatibility with showMatchPopup function
                    matchedUser: userInfo,
                    user: userInfo
                  };
                }
                return match;
              } catch (err) {
                console.error(
                  `Error enhancing match ${match.id} with user details:`,
                  err
                );
                return match;
              }
            })
          );
          res.json(enhancedMatches);
        } else {
          res.json(matches2);
        }
      } catch (error) {
        console.error("Error getting matches since timestamp:", error);
        res.status(500).json({ message: "Server error getting matches" });
      }
    }
  );
}
var connectedUsers;
var init_match_api = __esm({
  "server/match-api.ts"() {
    "use strict";
    init_storage();
    connectedUsers = null;
  }
});

// server/services/sendgrid.ts
var sendgrid_exports = {};
__export(sendgrid_exports, {
  sendContactFormConfirmationEmail: () => sendContactFormConfirmationEmail,
  sendContactFormEmail: () => sendContactFormEmail,
  sendEmail: () => sendEmail,
  sendPremiumSubscriptionEmail: () => sendPremiumSubscriptionEmail,
  sendTeenageWelcomeEmail: () => sendTeenageWelcomeEmail,
  sendUnderAgeApologyEmail: () => sendUnderAgeApologyEmail,
  sendWelcomeEmail: () => sendWelcomeEmail,
  testSendGridConfig: () => testSendGridConfig
});
import { MailService } from "@sendgrid/mail";
async function sendEmail(apiKey, params) {
  try {
    if (!process.env.SENDGRID_API_KEY) {
      mailService.setApiKey(apiKey);
    }
    const emailData = {
      to: params.to,
      from: params.from,
      subject: params.subject
    };
    if (params.text) {
      emailData.text = params.text;
    }
    if (params.html) {
      emailData.html = params.html;
    }
    await mailService.send(emailData);
    return true;
  } catch (error) {
    console.error("SendGrid email error:", error);
    return false;
  }
}
async function testSendGridConfig() {
  try {
    console.log("[SENDGRID-TEST] Testing SendGrid configuration...");
    console.log(
      "[SENDGRID-TEST] API Key present:",
      !!process.env.SENDGRID_API_KEY
    );
    console.log(
      "[SENDGRID-TEST] API Key starts with:",
      process.env.SENDGRID_API_KEY?.substring(0, 10)
    );
    const testEmail = {
      to: "admin@kronogon.com",
      from: "admin@kronogon.com",
      // Simplified format
      subject: "SendGrid Test Email",
      text: "This is a test email to verify SendGrid configuration."
    };
    await mailService.send(testEmail);
    console.log("[SENDGRID-TEST] Test email sent successfully!");
    return { success: true, message: "SendGrid test successful" };
  } catch (error) {
    console.error("[SENDGRID-TEST] Test failed:", error);
    if (error.response) {
      console.error("[SENDGRID-TEST] Error details:", {
        status: error.code,
        body: error.response?.body,
        message: error.message
      });
    }
    return {
      success: false,
      message: `SendGrid test failed: ${error.message}`
    };
  }
}
async function sendContactFormConfirmationEmail(data) {
  try {
    console.log(
      "[SENDGRID] Sending contact form confirmation email to user..."
    );
    const emailContent = {
      to: data.email,
      from: "admin@kronogon.com",
      subject: "We received your message - CHARLEY Support",
      text: `
Dear ${data.name},

Thank you for contacting CHARLEY Support. We have received your message and will get back to you shortly.

Your message:
"${data.message}"

Our support team typically responds within 24 hours during business days. If your matter requires immediate attention, please don't hesitate to contact us directly at admin@kronogon.com or call us at +1 (469) 496-5620.

Thank you for using CHARLEY!

Best regards,
The CHARLEY Support Team

---
This is an automated confirmation email. Please do not reply to this message.
      `.trim(),
      html: `
        <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto; background: #ffffff;">
          <!-- Header -->
          <div style="background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%); padding: 30px; text-align: center; border-radius: 8px 8px 0 0;">
            <h1 style="color: #ffffff; margin: 0; font-size: 24px; font-weight: bold;">
              Message Received \u2713
            </h1>
            <p style="color: #e0e7ff; margin: 10px 0 0 0; font-size: 16px;">
              Thank you for contacting CHARLEY Support
            </p>
          </div>

          <!-- Content -->
          <div style="padding: 30px; background: #ffffff;">
            <p style="color: #1f2937; font-size: 16px; line-height: 1.6; margin: 0 0 20px 0;">
              Dear <strong>${data.name}</strong>,
            </p>

            <p style="color: #1f2937; font-size: 16px; line-height: 1.6; margin: 0 0 20px 0;">
              Thank you for reaching out to us. We have received your message and our support team will review it shortly.
            </p>

            <!-- Message Summary -->
            <div style="background: #f8fafc; padding: 20px; border-left: 4px solid #6366f1; border-radius: 0 6px 6px 0; margin: 20px 0;">
              <h3 style="color: #475569; margin: 0 0 10px 0; font-size: 14px; text-transform: uppercase; letter-spacing: 0.5px;">
                Your Message:
              </h3>
              <p style="color: #334155; line-height: 1.6; margin: 0; font-style: italic;">
                "${data.message}"
              </p>
            </div>

            <!-- Response Time -->
            <div style="background: #ecfdf5; padding: 20px; border-radius: 8px; margin: 20px 0;">
              <p style="color: #065f46; font-size: 16px; margin: 0; font-weight: 500;">
                \u{1F4DE} <strong>Expected Response Time:</strong> Within 24 hours during business days
              </p>
            </div>

            <!-- Contact Info -->
            <div style="border-top: 1px solid #e5e7eb; padding-top: 20px; margin-top: 30px;">
              <p style="color: #6b7280; font-size: 14px; margin: 0 0 10px 0;">
                <strong>Need immediate help?</strong>
              </p>
              <p style="color: #6b7280; font-size: 14px; margin: 0;">
                \u{1F4E7} Email: admin@kronogon.com<br>
                \u{1F4DE} Phone: +1 (469) 496-5620 (Mon-Fri, 9am-5pm ET)
              </p>
            </div>
          </div>

          <!-- Footer -->
          <div style="background: #f9fafb; padding: 20px; text-align: center; border-radius: 0 0 8px 8px; border-top: 1px solid #e5e7eb;">
            <p style="color: #6b7280; font-size: 12px; margin: 0;">
              This is an automated confirmation email. Please do not reply to this message.
            </p>
            <p style="color: #6b7280; font-size: 12px; margin: 5px 0 0 0;">
              \xA9 2025 CHARLEY. All rights reserved.
            </p>
          </div>
        </div>
      `
    };
    await mailService.send(emailContent);
    console.log(
      `[SENDGRID] Contact form confirmation email sent successfully to ${data.email}`
    );
    return true;
  } catch (error) {
    console.error(
      "[SENDGRID] Failed to send contact form confirmation email:",
      error
    );
    if (error.response) {
      console.error("[SENDGRID] Confirmation email error response:", {
        status: error.code,
        body: error.response?.body
      });
    }
    return false;
  }
}
async function sendContactFormEmail(data) {
  try {
    console.log("[SENDGRID] Attempting to send contact form email...");
    const emailContent = {
      to: "admin@kronogon.com",
      from: "admin@kronogon.com",
      // Simplified - just the email
      subject: `Contact Form Submission from ${data.name}`,
      text: `
Name: ${data.name}
Email: ${data.email}
Phone: ${data.phoneNumber || "Not provided"}

Message:
${data.message}

---
This message was sent via the CHARLEY Contact Form.
      `.trim(),
      html: `
        <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
          <h2 style="color: #333; border-bottom: 2px solid #6366f1; padding-bottom: 10px;">
            New Contact Form Submission
          </h2>

          <div style="background: #f8fafc; padding: 20px; border-radius: 8px; margin: 20px 0;">
            <p><strong>Name:</strong> ${data.name}</p>
            <p><strong>Email:</strong> ${data.email}</p>
            <p><strong>Phone:</strong> ${data.phoneNumber || "Not provided"}</p>
          </div>

          <div style="background: #ffffff; padding: 20px; border: 1px solid #e2e8f0; border-radius: 8px;">
            <h3 style="color: #475569; margin-top: 0;">Message:</h3>
            <p style="line-height: 1.6; color: #334155;">${data.message.replace(/\n/g, "<br>")}</p>
          </div>

          <div style="margin-top: 30px; padding-top: 20px; border-top: 1px solid #e2e8f0; color: #64748b; font-size: 12px;">
            This message was sent via the CHARLEY Contact Form.
          </div>
        </div>
      `
    };
    await mailService.send(emailContent);
    console.log(
      `[SENDGRID] Contact form email sent successfully from ${data.email}`
    );
    return true;
  } catch (error) {
    console.error("[SENDGRID] Failed to send contact form email:", error);
    if (error.response) {
      console.error("[SENDGRID] Error response:", {
        status: error.code,
        body: error.response?.body,
        headers: error.response?.headers
      });
      if (error.code === 403) {
        console.error("[SENDGRID] 403 Forbidden - This usually means:");
        console.error(
          "1. The sender email address needs to be verified in SendGrid"
        );
        console.error("2. The API key doesn't have sufficient permissions");
        console.error("3. Account is suspended or has issues");
      }
    }
    return false;
  }
}
async function sendUnderAgeApologyEmail(data) {
  try {
    console.log("[SENDGRID] Sending under-age apology email to:", data.email);
    const userAge = data.dateOfBirth ? calculateAge(data.dateOfBirth) : null;
    console.log(
      `[SENDGRID] User age: ${userAge} - sending apology email for under-age user`
    );
    const emailContent = {
      to: data.email,
      from: "admin@kronogon.com",
      subject: `Thank you for your interest in CHARLEY, ${data.name}`,
      text: `
Dear ${data.name},

Thank you for your interest in joining CHARLEY, our innovative social and professional networking platform.

Unfortunately, our platform currently requires users to be 14 years or older to access our dating and professional networking features. This policy is in place to ensure the safety and appropriate experience for all our users.

However, we want you to know that we value your interest in our platform, and we encourage you to return when you reach the minimum age requirement. In the meantime, we recommend:

- Focus on building meaningful friendships and connections in your local community
- Develop your skills and interests that will serve you well in future professional networking
- Stay safe online and always prioritize your education and personal growth

We apologize for any inconvenience this may cause, and we look forward to welcoming you to the CHARLEY community in the future.

If you have any questions, please don't hesitate to contact us at admin@kronogon.com.

Best regards,
The CHARLEY Team
BTechnos.com
      `.trim(),
      html: `
        <!DOCTYPE html>
        <html>
        <head>
          <meta charset="utf-8">
          <meta name="viewport" content="width=device-width, initial-scale=1.0">
          <meta name="color-scheme" content="light">
          <meta name="supported-color-schemes" content="light">
          <style>
            :root { color-scheme: light; supported-color-schemes: light; }
            body, table, td, p, h1, h2, h3, h4, h5, h6 { color: #111827 !important; }
          </style>
          <title>Thank you for your interest in CHARLEY</title>
        </head>
        <body style="margin: 0; padding: 0; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background: #f8fafc; min-height: 100vh; color: #111827;">

          <!-- Main Container -->
          <div style="max-width: 650px; margin: 0 auto; background: #ffffff; box-shadow: 0 25px 50px rgba(0,0,0,0.08); border-radius: 16px; overflow: hidden; margin-top: 40px; margin-bottom: 40px;">

            <!-- Header Section -->
            <div style="background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%); padding: 50px 40px; text-align: center; position: relative; overflow: hidden;">
              <!-- Floating orbs -->
              <div style="position: absolute; top: -20px; left: -20px; width: 100px; height: 100px; background: radial-gradient(circle, rgba(255,255,255,0.1) 0%, rgba(255,255,255,0.05) 70%); border-radius: 50%;"></div>
              <div style="position: absolute; bottom: -30px; right: -30px; width: 80px; height: 80px; background: radial-gradient(circle, rgba(255,255,255,0.15) 0%, rgba(255,255,255,0.08) 70%); border-radius: 50%;"></div>

              <div style="position: relative; z-index: 10;">
                <h1 style="color: #ffffff; font-size: 36px; font-weight: 700; margin: 0 0 15px 0; text-shadow: 0 2px 4px rgba(0,0,0,0.2);">
                  Thank You for Your Interest
                </h1>
                <div style="background: rgba(255,255,255,0.15); backdrop-filter: blur(10px); border: 1px solid rgba(255,255,255,0.2); border-radius: 25px; padding: 12px 25px; display: inline-block;">
                  <p style="color: rgba(255,255,255,0.95); font-size: 18px; margin: 0; font-weight: 400;">
                    Dear ${data.name}
                  </p>
                </div>
              </div>
            </div>

            <!-- Main Content -->
            <div style="padding: 40px 30px;">

              <!-- Apology Message -->
              <div style="background: linear-gradient(135deg, #fef2f2 0%, #fee2e2 100%); padding: 25px; border-radius: 12px; border-left: 4px solid #ef4444; margin-bottom: 30px;">
                <h2 style="color: #dc2626; font-size: 22px; margin: 0 0 15px 0; font-weight: 600;">
                  Age Requirement Notice
                </h2>
                <p style="color: #1f2937; line-height: 1.7; margin: 0; font-size: 16px;">
                  We appreciate your interest in CHARLEY, our innovative social and professional networking platform. Unfortunately, our platform currently requires users to be <strong>14 years or older</strong> to access our dating and professional networking features.
                </p>
              </div>

              <!-- Why This Policy -->
              <div style="margin-bottom: 30px;">
                <h3 style="color: #1e293b; font-size: 20px; margin: 0 0 15px 0; font-weight: 600;">
                  \u{1F6E1}\uFE0F Why This Policy Exists
                </h3>
                <p style="color: #1f2937; line-height: 1.7; margin: 0; font-size: 16px;">
                  This policy is in place to ensure the safety and appropriate experience for all our users. We are committed to creating a secure environment that complies with digital safety standards and protects our community members.
                </p>
              </div>

              <!-- Recommendations -->
              <div style="background: #f8fafc; padding: 25px; border-radius: 12px; border: 1px solid #e2e8f0; margin-bottom: 30px;">
                <h3 style="color: #1e293b; font-size: 20px; margin: 0 0 20px 0; font-weight: 600;">
                  \u{1F4A1} In the Meantime, We Recommend:
                </h3>
                <ul style="color: #1f2937; line-height: 1.7; margin: 0; padding-left: 20px; font-size: 16px;">
                  <li style="margin-bottom: 12px;">Focus on building meaningful friendships and connections in your local community</li>
                  <li style="margin-bottom: 12px;">Develop your skills and interests that will serve you well in future professional networking</li>
                  <li style="margin-bottom: 12px;">Stay safe online and always prioritize your education and personal growth</li>
                  <li style="margin-bottom: 0;">Explore age-appropriate social platforms designed for your age group</li>
                </ul>
              </div>

              <!-- Future Welcome -->
              <div style="background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%); padding: 25px; border-radius: 12px; border-left: 4px solid #0ea5e9; margin-bottom: 30px;">
                <h3 style="color: #0369a1; font-size: 20px; margin: 0 0 15px 0; font-weight: 600;">
                  \u{1F31F} We Look Forward to Welcoming You
                </h3>
                <p style="color: #1f2937; line-height: 1.7; margin: 0; font-size: 16px;">
                  We encourage you to return when you reach the minimum age requirement. CHARLEY will be here, ready to help you build meaningful connections and advance your professional journey when the time is right.
                </p>
              </div>

              <!-- Contact Info -->
              <div style="text-align: center; padding: 20px; background: #f8fafc; border-radius: 8px; border: 1px solid #e2e8f0;">
                <p style="color: #64748b; margin: 0 0 10px 0; font-size: 14px;">
                  If you have any questions, please contact us at:
                </p>
                <a href="mailto:admin@kronogon.com" style="color: #6366f1; text-decoration: none; font-weight: 600; font-size: 16px;">
                  admin@kronogon.com
                </a>
              </div>

              <!-- Closing -->
              <div style="text-align: center; color: #64748b; font-size: 16px; line-height: 1.6; margin-top: 30px;">
                <p style="margin: 0 0 10px 0; font-weight: 600; color: #1e293b;">Best regards,</p>
                <p style="margin: 0; font-style: italic;">The CHARLEY Team</p>
                <p style="margin: 5px 0 0 0; font-size: 14px;">
                  <a href="https://btechnos.com" style="color: #6366f1; text-decoration: none;">
                    BTechnos.com
                  </a>
                </p>
              </div>
            </div>

            <!-- Footer -->
            <div style="background: #f8fafc; padding: 25px 30px; text-align: center; border-top: 1px solid #e2e8f0;">
              <p style="color: #64748b; font-size: 12px; margin: 0; line-height: 1.5;">
                This email was sent from CHARLEY by BTechnos. You're receiving this because you attempted to create an account with us.<br>
                \xA9 2025 BTechnos. All rights reserved. | <a href="https://btechnos.com" style="color: #6366f1; text-decoration: none;">btechnos.com</a>
              </p>
            </div>
          </div>
        </body>
        </html>
      `
    };
    await mailService.send(emailContent);
    console.log(
      `[SENDGRID] Under-age apology email sent successfully to ${data.email}`
    );
    return true;
  } catch (error) {
    console.error("[SENDGRID] Failed to send under-age apology email:", error);
    if (error.response) {
      console.error("[SENDGRID] Under-age apology email error details:", {
        status: error.code,
        body: error.response?.body,
        headers: error.response?.headers
      });
    }
    return false;
  }
}
async function sendTeenageWelcomeEmail(data) {
  try {
    console.log("[SENDGRID] Sending teenage welcome email to:", data.email);
    const userAge = data.dateOfBirth ? calculateAge(data.dateOfBirth) : null;
    console.log(`[SENDGRID] Teenage user age: ${userAge}`);
    const emailContent = {
      to: data.email,
      from: "admin@kronogon.com",
      subject: `Welcome to CHARLEY, ${data.name}! \u{1F31F} Your Friendship Journey Begins`,
      text: `
Welcome to CHARLEY, ${data.name}!

Thank you for joining our community! We're excited to have you on board for an amazing friendship and networking journey.

CHARLEY is designed to help young people like you build meaningful friendships and start exploring professional opportunities in a safe, age-appropriate environment. We believe that genuine connections and early career development are key to a bright future.

What Makes CHARLEY Special for You:
- Safe, moderated environment designed specifically for teens
- Focus on friendship-building and meaningful connections
- Early professional networking opportunities
- Mentorship programs to help guide your journey
- Educational content and career exploration tools

Your CHARLEY Experience Includes:
- MEET (friendship): Connect with peers who share your interests and values
- SUITE (networking): Start building professional connections for your future
- Mentorship programs: Learn from experienced professionals in your areas of interest

Important Guidelines:
- Complete your profile to unlock CHARLEY's full potential
- Always prioritize your safety and privacy online
- Engage respectfully with other community members
- Focus on building genuine, meaningful connections
- Take advantage of mentorship opportunities

Our Commitment to You:
We're dedicated to providing a positive, educational, and safe space where you can grow personally and professionally. Our platform includes robust safety features and content moderation to ensure your experience is both enriching and secure.

Getting Started:
1. Complete your profile with your interests and goals
2. Explore the friendship connections in MEET
3. Check out early networking opportunities in SUITE
4. Look for mentorship matches that align with your interests

Visit us at btechnos.com to learn more about our mission and the technology behind CHARLEY.

Welcome to your bright future!
The CHARLEY Team
BTechnos.com
      `.trim(),
      html: `
        <!DOCTYPE html>
        <html>
        <head>
          <meta charset="utf-8">
          <meta name="viewport" content="width=device-width, initial-scale=1.0">
          <meta name="color-scheme" content="light">
          <meta name="supported-color-schemes" content="light">
          <style>
            :root { color-scheme: light; supported-color-schemes: light; }
            body, table, td, p, h1, h2, h3, h4, h5, h6 { color: #111827 !important; }
          </style>
          <title>Welcome to CHARLEY - Your Friendship Journey</title>
        </head>
        <body style="margin: 0; padding: 0; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background: #f0f9ff; min-height: 100vh; color: #111827;">

          <!-- Main Container -->
          <div style="max-width: 650px; margin: 0 auto; background: #ffffff; box-shadow: 0 25px 50px rgba(0,0,0,0.08); border-radius: 16px; overflow: hidden; margin-top: 40px; margin-bottom: 40px;">

            <!-- Header Section - Youthful Design -->
            <div style="background: linear-gradient(135deg, #0ea5e9 0%, #3b82f6 25%, #8b5cf6 50%, #ec4899 75%, #f59e0b 100%); padding: 60px 40px; text-align: center; position: relative; overflow: hidden;">
              <!-- Animated elements for teens -->
              <div style="position: absolute; top: -20px; left: -20px; width: 100px; height: 100px; background: radial-gradient(circle, rgba(255,255,255,0.2) 0%, rgba(255,255,255,0.05) 70%); border-radius: 50%;"></div>
              <div style="position: absolute; top: 30px; right: -30px; width: 70px; height: 70px; background: radial-gradient(circle, rgba(255,255,255,0.25) 0%, rgba(255,255,255,0.08) 70%); border-radius: 50%;"></div>

              <!-- Star sparkles -->
              <div style="position: absolute; top: 20%; left: 20%; width: 6px; height: 6px; background: rgba(255,255,255,0.9); border-radius: 50%; box-shadow: 0 0 12px rgba(255,255,255,0.9);"></div>
              <div style="position: absolute; top: 35%; right: 25%; width: 4px; height: 4px; background: rgba(255,255,255,0.8); border-radius: 50%; box-shadow: 0 0 8px rgba(255,255,255,0.8);"></div>

              <!-- Main header content -->
              <div style="position: relative; z-index: 10;">
                <h1 style="color: white; font-size: 42px; font-weight: 800; margin: 0 0 10px 0; text-shadow: 0 4px 20px rgba(0,0,0,0.3); letter-spacing: -1px;">
                  Welcome to CHARLEY! \u{1F31F}
                </h1>
                <p style="color: rgba(255,255,255,0.95); font-size: 22px; margin: 0; font-weight: 500; text-shadow: 0 2px 10px rgba(0,0,0,0.2);">
                  Your Friendship Journey Begins Here
                </p>
              </div>
            </div>

            <!-- Welcome Message -->
            <div style="padding: 50px 40px;">
              <div style="text-align: center; margin-bottom: 40px;">
                <h2 style="color: #1e293b; font-size: 28px; font-weight: 700; margin: 0 0 15px 0;">
                  Hi ${data.name}! \u{1F44B}
                </h2>
                <p style="color: #475569; font-size: 18px; line-height: 1.6; margin: 0;">
                  We're thrilled to have you join our community of young innovators, friendship-builders, and future leaders!
                </p>
              </div>

              <!-- What Makes CHARLEY Special -->
              <div style="background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%); padding: 30px; border-radius: 12px; margin-bottom: 30px; border-left: 4px solid #0ea5e9;">
                <h3 style="color: #0c4a6e; font-size: 20px; font-weight: 600; margin: 0 0 20px 0;">
                  \u{1F680} What Makes CHARLEY Special for You
                </h3>
                <ul style="color: #1e293b; line-height: 1.7; margin: 0; padding-left: 20px; font-size: 16px;">
                  <li style="margin-bottom: 10px;"><strong>Safe Environment:</strong> Moderated platform designed specifically for young people</li>
                  <li style="margin-bottom: 10px;"><strong>Friendship Focus:</strong> Build meaningful connections with peers who share your interests</li>
                  <li style="margin-bottom: 10px;"><strong>Future Building:</strong> Early professional networking and career exploration</li>
                  <li style="margin-bottom: 0;"><strong>Mentorship:</strong> Learn from experienced professionals in your areas of interest</li>
                </ul>
              </div>

              <!-- Your CHARLEY Experience -->
              <div style="background: linear-gradient(135deg, #fef3c7 0%, #fde68a 100%); padding: 30px; border-radius: 12px; margin-bottom: 30px; border-left: 4px solid #f59e0b;">
                <h3 style="color: #92400e; font-size: 20px; font-weight: 600; margin: 0 0 20px 0;">
                  \u{1F3AF} Your CHARLEY Experience
                </h3>
                <div style="display: grid; gap: 15px;">
                  <div style="background: rgba(255,255,255,0.7); padding: 20px; border-radius: 8px;">
                    <h4 style="color: #7c2d12; margin: 0 0 8px 0; font-size: 16px; font-weight: 600;">MEET (Friendship)</h4>
                    <p style="color: #451a03; margin: 0; font-size: 14px; line-height: 1.5;">Connect with peers who share your values and interests</p>
                  </div>
                  <div style="background: rgba(255,255,255,0.7); padding: 20px; border-radius: 8px;">
                    <h4 style="color: #7c2d12; margin: 0 0 8px 0; font-size: 16px; font-weight: 600;">SUITE (Networking)</h4>
                    <p style="color: #451a03; margin: 0; font-size: 14px; line-height: 1.5;">Start building professional connections for your future career</p>
                  </div>
                  <div style="background: rgba(255,255,255,0.7); padding: 20px; border-radius: 8px;">
                    <h4 style="color: #7c2d12; margin: 0 0 8px 0; font-size: 16px; font-weight: 600;">Mentorship Programs</h4>
                    <p style="color: #451a03; margin: 0; font-size: 14px; line-height: 1.5;">Learn from experienced professionals and explore career paths</p>
                  </div>
                </div>
              </div>

              <!-- Getting Started Steps -->
              <div style="background: linear-gradient(135deg, #f3e8ff 0%, #e9d5ff 100%); padding: 30px; border-radius: 12px; margin-bottom: 30px; border-left: 4px solid #8b5cf6;">
                <h3 style="color: #581c87; font-size: 20px; font-weight: 600; margin: 0 0 20px 0;">
                  \u{1F389} Getting Started
                </h3>
                <div style="color: #1f2937; line-height: 1.6;">
                  <div style="background: rgba(255,255,255,0.6); padding: 15px; border-radius: 8px; margin-bottom: 12px;">
                    <strong style="color: #581c87;">Step 1:</strong> Complete your profile with interests and goals
                  </div>
                  <div style="background: rgba(255,255,255,0.6); padding: 15px; border-radius: 8px; margin-bottom: 12px;">
                    <strong style="color: #581c87;">Step 2:</strong> Explore friendship connections in MEET
                  </div>
                  <div style="background: rgba(255,255,255,0.6); padding: 15px; border-radius: 8px; margin-bottom: 12px;">
                    <strong style="color: #581c87;">Step 3:</strong> Check out networking opportunities in SUITE
                  </div>
                  <div style="background: rgba(255,255,255,0.6); padding: 15px; border-radius: 8px;">
                    <strong style="color: #581c87;">Step 4:</strong> Find mentorship matches in your areas of interest
                  </div>
                </div>
              </div>

              <!-- Safety Reminder -->
              <div style="background: #fef2f2; padding: 25px; border-radius: 12px; margin-bottom: 30px; border-left: 4px solid #ef4444;">
                <h4 style="color: #991b1b; font-size: 16px; font-weight: 600; margin: 0 0 15px 0;">
                  \u{1F6E1}\uFE0F Important Safety Reminders
                </h4>
                <ul style="color: #7f1d1d; line-height: 1.6; margin: 0; padding-left: 20px; font-size: 14px;">
                  <li style="margin-bottom: 8px;">Always prioritize your safety and privacy online</li>
                  <li style="margin-bottom: 8px;">Engage respectfully with other community members</li>
                  <li style="margin-bottom: 0;">Report any inappropriate behavior to our moderation team</li>
                </ul>
              </div>

              <!-- Website Link -->
              <div style="text-align: center; margin-bottom: 30px;">
                <a href="https://btechnos.com" style="display: inline-block; background: linear-gradient(135deg, #3b82f6 0%, #8b5cf6 100%); color: white; text-decoration: none; padding: 15px 30px; border-radius: 25px; font-weight: 600; font-size: 16px; box-shadow: 0 4px 15px rgba(59, 130, 246, 0.4); transition: all 0.3s ease;">
                  Explore BTechnos.com
                </a>
              </div>

              <!-- Closing -->
              <div style="text-align: center; color: #64748b; font-size: 16px; line-height: 1.6;">
                <p style="margin: 0 0 10px 0; font-weight: 600; color: #1e293b;">Welcome to your bright future!</p>
                <p style="margin: 0; font-style: italic;">The CHARLEY Team</p>
              </div>
            </div>

            <!-- Footer -->
            <div style="background: #f8fafc; padding: 25px 30px; text-align: center; border-top: 1px solid #e2e8f0;">
              <p style="color: #64748b; font-size: 12px; margin: 0; line-height: 1.5;">
                This email was sent from CHARLEY by BTechnos. You're receiving this because you successfully created an account with us.<br>
                \xA9 2025 BTechnos. All rights reserved. | <a href="https://btechnos.com" style="color: #3b82f6; text-decoration: none;">btechnos.com</a>
              </p>
            </div>
          </div>
        </body>
        </html>
      `
    };
    await mailService.send(emailContent);
    console.log(
      `[SENDGRID] Teenage welcome email sent successfully to ${data.email}`
    );
    return true;
  } catch (error) {
    console.error("[SENDGRID] Failed to send teenage welcome email:", error);
    if (error.response) {
      console.error("[SENDGRID] Teenage welcome email error details:", {
        status: error.code,
        body: error.response?.body
      });
    }
    return false;
  }
}
async function sendWelcomeEmail(data) {
  try {
    console.log("[SENDGRID] Sending adult welcome email to:", data.email);
    const userAge = data.dateOfBirth ? calculateAge(data.dateOfBirth) : null;
    console.log(`[SENDGRID] Adult user age: ${userAge}`);
    const emailContent = {
      to: data.email,
      from: "admin@kronogon.com",
      subject: `Welcome to CHARLEY, ${data.name}! \u{1F389} Join the Social Revolution`,
      text: `
Welcome to CHARLEY, ${data.name}!

Thank you for joining us on this incredible journey to revolutionize how people connect, build relationships, and create meaningful professional networks.

CHARLEY is not just another app; it\u2019s a bold movement toward restoring authenticity and depth to human connection. Born from a simple, yet profound question\u2014\u201CWhat if technology could truly understand us?\u201D\u2014CHARLEY brings together dating, networking, and mentorship into a single, seamless platform. It\u2019s more than a tool; it\u2019s a community shaped by empathy, powered by innovative AI, and guided by a commitment to human flourishing.

Why CHARLEY? Because we believe every connection should mean something. Our story began with a vision to move beyond superficial swipes and transactional exchanges, and instead, create a space where compatibility, mentorship, and meaningful professional relationships can thrive\u2014across continents, backgrounds, and ambitions.

Our Mission:
- Revolutionize dating by focusing on authentic compatibility
- Transform professional networking through meaningful connections
- Democratize mentorship and personal growth opportunities
- Create a global community built on trust, respect, and genuine human values

Message from The Leadership Team:

At Kronogon, we see CHARLEY as more than a product\u2014it's a revolutionary movement grounded in the universal longing for belonging and authentic connection. In an age where loneliness quietly thrives behind curated profiles and algorithmic feeds, we are driven by both heart and intellect to redefine what meaningful relationships mean in the digital era.

Our approach combines rigorous engineering with deep respect for the human spirit. CHARLEY draws from cross-disciplinary insights\u2014psychology, sociology, design thinking, and advanced data science\u2014to create systems that protect, empower, and inspire. We challenge ourselves to see technology through the lens of lived experience: How do we foster trust in code? How can algorithms promote genuine dialogue rather than division? How do we create a space where vulnerability isn't a liability, but a strength?

Every technical decision is anchored in the best research and an unwavering commitment to digital well-being. We are committed to building a community that not only reflects the rich diversity of our world, but actively nurtures empathy and authentic human flourishing. CHARLEY stands as a testament to what's possible when technology serves as a bridge, not a barrier\u2014amplifying the complexity and beauty of human relationships.

Technology alone does not create connection\u2014people do. Our role is to set the stage for meaningful encounters, guided by both evidence and empathy. Together, with our users and partners, we are co-authoring a new chapter in the science\u2014and the art\u2014of connection.

Important Reminders:
- Please take time to review our Privacy Policy and Terms of Service
- Complete your profile to unlock CHARLEY's full potential
- Explore all three platforms: MEET (dating), SUITE (professional networking), and our mentorship programs

Visit us at btechnos.com to learn more about our vision and the technology behind CHARLEY.

Welcome aboard!
The BTechnos Team
      `.trim(),
      html: `
        <!DOCTYPE html>
        <html>
        <head>
          <meta charset="utf-8">
          <meta name="viewport" content="width=device-width, initial-scale=1.0">
          <meta name="color-scheme" content="light">
          <meta name="supported-color-schemes" content="light">
          <style>
            :root { color-scheme: light; supported-color-schemes: light; }
            body, table, td, p, h1, h2, h3, h4, h5, h6 { color: #111827 !important; }
          </style>
          <title>Welcome to CHARLEY</title>
        </head>
        <body style="margin: 0; padding: 0; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background: #f8fafc; min-height: 100vh; color: #111827;">

          <!-- Main Container -->
          <div style="max-width: 650px; margin: 0 auto; background: #ffffff; box-shadow: 0 25px 50px rgba(0,0,0,0.08); border-radius: 16px; overflow: hidden;">

            <!-- Header Section -->
            <div style="background: linear-gradient(135deg, #ff6b6b 0%, #feca57 25%, #ff9ff3 50%, #54a0ff 75%, #5f27cd 100%); padding: 60px 40px; text-align: center; position: relative; overflow: hidden;">
              <!-- Animated floating orbs -->
              <div style="position: absolute; top: -30px; left: -30px; width: 120px; height: 120px; background: radial-gradient(circle, rgba(255,255,255,0.15) 0%, rgba(255,255,255,0.05) 70%); border-radius: 50%; animation: float 6s ease-in-out infinite;"></div>
              <div style="position: absolute; top: 20px; right: -40px; width: 80px; height: 80px; background: radial-gradient(circle, rgba(255,255,255,0.2) 0%, rgba(255,255,255,0.08) 70%); border-radius: 50%; animation: float 4s ease-in-out infinite reverse;"></div>
              <div style="position: absolute; bottom: -20px; left: 30%; width: 60px; height: 60px; background: radial-gradient(circle, rgba(255,255,255,0.12) 0%, rgba(255,255,255,0.04) 70%); border-radius: 50%; animation: float 5s ease-in-out infinite;"></div>

              <!-- Sparkling effects -->
              <div style="position: absolute; top: 25%; left: 15%; width: 4px; height: 4px; background: rgba(255,255,255,0.8); border-radius: 50%; box-shadow: 0 0 10px rgba(255,255,255,0.8);"></div>
              <div style="position: absolute; top: 40%; right: 20%; width: 3px; height: 3px; background: rgba(255,255,255,0.9); border-radius: 50%; box-shadow: 0 0 8px rgba(255,255,255,0.9);"></div>
              <div style="position: absolute; bottom: 30%; left: 25%; width: 2px; height: 2px; background: rgba(255,255,255,0.7); border-radius: 50%; box-shadow: 0 0 6px rgba(255,255,255,0.7);"></div>

              <!-- Main content with enhanced styling -->
              <div style="position: relative; z-index: 10;">
                <h1 style="color: #ffffff; font-size: 48px; font-weight: 800; margin: 0 0 20px 0; text-shadow: 0 4px 8px rgba(0,0,0,0.3), 0 2px 4px rgba(0,0,0,0.2); letter-spacing: -1.5px; background: linear-gradient(45deg, rgba(255,255,255,1) 0%, rgba(255,255,255,0.9) 100%); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text;">
                  Welcome to CHARLEY
                </h1>
                <div style="background: rgba(255,255,255,0.15); backdrop-filter: blur(10px); border: 1px solid rgba(255,255,255,0.2); border-radius: 25px; padding: 15px 30px; display: inline-block; margin-top: 10px;">
                  <p style="color: rgba(255,255,255,0.95); font-size: 20px; margin: 0; font-weight: 400; text-shadow: 0 1px 2px rgba(0,0,0,0.2);">
                    Join the Social Revolution, ${data.name}!
                  </p>
                </div>
              </div>

              <!-- CSS Animation -->
              <style>
                @keyframes float {
                  0%, 100% { transform: translateY(0px) rotate(0deg); }
                  50% { transform: translateY(-20px) rotate(180deg); }
                }
              </style>
            </div>

            <!-- Main Content -->
            <div style="padding: 40px 30px;">

              <!-- Personal Welcome -->
              <div style="background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%); padding: 25px; border-radius: 12px; border-left: 4px solid #6366f1; margin-bottom: 30px;">
                <h2 style="color: #1e293b; font-size: 24px; margin: 0 0 15px 0; font-weight: 600;">
                  Dear ${data.name},
                </h2>
                <p style="color: #1f2937; line-height: 1.7; margin: 0; font-size: 16px;">
                  Thank you for joining us on this incredible journey to revolutionize how people connect, build relationships, and create meaningful professional networks. You're not just signing up for an app\u2014you're becoming part of a movement.
                </p>
              </div>

              <!-- Our Story Section -->
              <div style="margin-bottom: 35px;">
                <h3 style="color: #1e293b; font-size: 22px; margin: 0 0 20px 0; font-weight: 600; border-bottom: 2px solid #e2e8f0; padding-bottom: 10px;">
                  \u{1F680} Why CHARLEY?
                </h3>
                <p style="color: #1f2937; line-height: 1.7; margin: 0 0 15px 0; font-size: 16px;">
                  Our story began with a simple question: <em>"What if we could create a platform that truly understands human connection?"</em> From this question emerged CHARLEY\u2014an AI-powered ecosystem that goes beyond superficial matching to create genuine, lasting relationships across all areas of life.
                </p>
                <div style="background: #f8fafc; padding: 20px; border-radius: 8px; border: 1px solid #e2e8f0;">
                  <h4 style="color: #6366f1; margin: 0 0 12px 0; font-size: 18px; font-weight: 600;">Our Mission:</h4>
                  <ul style="color: #1f2937; line-height: 1.6; margin: 0; padding-left: 20px; font-size: 15px;">
                    <li style="margin-bottom: 8px; color: #1f2937;">Revolutionize dating by focusing on authentic compatibility</li>
                    <li style="margin-bottom: 8px; color: #1f2937;">Transform professional networking through meaningful connections</li>
                    <li style="margin-bottom: 8px; color: #1f2937;">Democratize mentorship and personal growth opportunities</li>
                    <li style="margin-bottom: 0; color: #1f2937;">Create a global community built on trust, respect, and genuine human values</li>
                  </ul>
                </div>
              </div>

              <!-- Leadership Messages -->
              <div style="margin-bottom: 35px;">
                <h3 style="color: #1e293b; font-size: 22px; margin: 0 0 25px 0; font-weight: 600; border-bottom: 2px solid #e2e8f0; padding-bottom: 10px;">
                  \u{1F465} Message from The Leadership Team
                </h3>

                <!-- Unified Leadership Message -->
                <div style="background: linear-gradient(135deg, #fef7ff 0%, #f3e8ff 100%); border: 1px solid #c084fc; border-radius: 12px; padding: 30px; position: relative;">
                  <div style="display: flex; align-items: center; margin-bottom: 20px;">
                    <div style="width: 70px; height: 70px; background: linear-gradient(135deg, #8b5cf6 0%, #6366f1 100%); border-radius: 50%; display: flex; align-items: center; justify-content: center; margin-right: 15px; box-shadow: 0 4px 12px rgba(139, 92, 246, 0.3);">
                      <span style="color: white; font-weight: 700; font-size: 28px;">BT</span>
                    </div>
                    <div>
                      <h4 style="color: #1e293b; margin: 0; font-size: 20px; font-weight: 600;">The Leadership Team</h4>
                      <p style="color: #6b7280; margin: 5px 0 0 0; font-size: 14px;">Kronogon</p>
                    </div>
                  </div>
                  
                  <div style="color: #1f2937; line-height: 1.7; margin: 0; font-size: 11px;">
                    <p style="margin: 0 0 18px 0;">
                      At Kronogon, we see CHARLEY as more than a product\u2014it's a revolutionary movement grounded in the universal longing for belonging and authentic connection. In an age where loneliness quietly thrives behind curated profiles and algorithmic feeds, we are driven by both heart and intellect to redefine what meaningful relationships mean in the digital era.
                    </p>
                    
                    <p style="margin: 0 0 18px 0;">
                      Our approach combines rigorous engineering with deep respect for the human spirit. CHARLEY draws from cross-disciplinary insights\u2014psychology, sociology, design thinking, and advanced data science\u2014to create systems that protect, empower, and inspire. We challenge ourselves to see technology through the lens of lived experience: How do we foster trust in code? How can algorithms promote genuine dialogue rather than division? How do we create a space where vulnerability isn't a liability, but a strength?
                    </p>
                    
                    <p style="margin: 0 0 18px 0;">
                      Every technical decision is anchored in the best research and an unwavering commitment to digital well-being. We are committed to building a community that not only reflects the rich diversity of our world, but actively nurtures empathy and authentic human flourishing. CHARLEY stands as a testament to what's possible when technology serves as a bridge, not a barrier\u2014amplifying the complexity and beauty of human relationships.
                    </p>
                    
                    <p style="margin: 0; font-weight: 500; font-style: italic;">
                      Technology alone does not create connection\u2014people do. Our role is to set the stage for meaningful encounters, guided by both evidence and empathy. Together, with our users and partners, we are co-authoring a new chapter in the science\u2014and the art\u2014of connection.
                    </p>
                  </div>
                </div>
              </div>

              <!-- Important Reminders -->
              <div style="background: linear-gradient(135deg, #fffbeb 0%, #fef3c7 100%); border: 1px solid #fbbf24; border-radius: 12px; padding: 25px; margin-bottom: 35px;">
                <h4 style="color: #92400e; margin: 0 0 15px 0; font-size: 18px; font-weight: 600; display: flex; align-items: center;">
                  \u26A1 Important Reminders
                </h4>
                <ul style="color: #1f2937; line-height: 1.6; margin: 0; padding-left: 20px; font-size: 15px;">
                  <li style="margin-bottom: 8px;">Please take time to review our Privacy Policy and Terms of Service</li>
                  <li style="margin-bottom: 8px;">Complete your profile to unlock CHARLEY's full potential</li>
                  <li style="margin-bottom: 0;">Explore all three platforms: MEET (dating), SUITE (professional networking), and our mentorship programs</li>
                </ul>
              </div>

              <!-- Website Link -->
              <div style="text-align: center; margin-bottom: 30px;">
                <a href="https://btechnos.com" style="display: inline-block; background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%); color: white; text-decoration: none; padding: 15px 30px; border-radius: 25px; font-weight: 600; font-size: 16px; box-shadow: 0 4px 15px rgba(99, 102, 241, 0.4); transition: all 0.3s ease;">
                  Visit BTechnos.com
                </a>
              </div>

              <!-- Closing -->
              <div style="text-align: center; color: #64748b; font-size: 16px; line-height: 1.6;">
                <p style="margin: 0 0 10px 0; font-weight: 600; color: #1e293b;">Welcome aboard!</p>
                <p style="margin: 0; font-style: italic;">The BTechnos Team</p>
              </div>
            </div>

            <!-- Footer -->
            <div style="background: #f8fafc; padding: 25px 30px; text-align: center; border-top: 1px solid #e2e8f0;">
              <p style="color: #64748b; font-size: 12px; margin: 0; line-height: 1.5;">
                This email was sent from CHARLEY by BTechnos. You're receiving this because you successfully created an account with us.<br>
                \xA9 2025 BTechnos. All rights reserved. | <a href="https://btechnos.com" style="color: #6366f1; text-decoration: none;">btechnos.com</a>
              </p>
            </div>
          </div>
        </body>
        </html>
      `
    };
    await mailService.send(emailContent);
    console.log(`[SENDGRID] Welcome email sent successfully to ${data.email}`);
    return true;
  } catch (error) {
    console.error("[SENDGRID] Failed to send welcome email:", error);
    if (error.response) {
      console.error("[SENDGRID] Welcome email error details:", {
        status: error.code,
        body: error.response?.body,
        headers: error.response?.headers
      });
    }
    return false;
  }
}
async function sendPremiumSubscriptionEmail(data) {
  try {
    console.log(
      "[SENDGRID] Sending premium subscription confirmation email to:",
      data.email
    );
    const planDisplayName = data.planType.replace("_", " ").replace(/\b\w/g, (l) => l.toUpperCase());
    const expirationText = data.subscriptionExpiresAt ? new Date(data.subscriptionExpiresAt).toLocaleDateString("en-US", {
      year: "numeric",
      month: "long",
      day: "numeric"
    }) : "Active";
    const emailContent = {
      to: data.email,
      from: "admin@kronogon.com",
      subject: `\u{1F389} Welcome to CHARLEY Premium, ${data.name}! Your Premium Journey Begins Now`,
      text: `
Welcome to CHARLEY Premium, ${data.name}!

\u{1F389} Congratulations! Your premium subscription is now active.

SUBSCRIPTION DETAILS:
- Plan: ${planDisplayName}
- Status: Active
- Next billing: ${expirationText}

PREMIUM FEATURES NOW UNLOCKED:
\u2713 Ghost Mode - Browse profiles anonymously
\u2713 Hide My Age - Keep your age private
\u2713 Advanced Privacy Controls - Full control over your visibility
\u2713 Priority Customer Support - Get help when you need it
\u2713 Enhanced Matching Algorithm - Better compatibility scores
\u2713 Unlimited Likes & Super Likes - No daily limits
\u2713 Read Receipts - See when messages are read
\u2713 Advanced Filters - Find exactly who you're looking for

WHAT'S NEXT?
1. Explore your new premium features in the Settings page
2. Update your privacy preferences with Ghost Mode
3. Try the advanced matching filters
4. Enjoy unlimited interactions across MEET, HEAT, and SUITE

Thank you for choosing CHARLEY Premium. We're excited to help you find meaningful connections!

The CHARLEY Team
BTechnos.com
      `,
      html: `
        <!DOCTYPE html>
        <html>
        <head>
          <meta charset="utf-8">
          <meta name="viewport" content="width=device-width, initial-scale=1.0">
          <title>Welcome to CHARLEY Premium</title>
        </head>
        <body style="margin: 0; padding: 0; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); min-height: 100vh;">
          <div style="max-width: 600px; margin: 0 auto; background: white; border-radius: 20px; overflow: hidden; box-shadow: 0 20px 40px rgba(0,0,0,0.1); margin-top: 20px; margin-bottom: 20px;">

            <!-- Premium Header with Crown Animation -->
            <div style="background: linear-gradient(135deg, #ffd700 0%, #ffb700 50%, #ff8c00 100%); padding: 40px 30px; text-align: center; position: relative; overflow: hidden;">
              <div style="position: absolute; top: 10px; right: 20px; font-size: 40px; animation: float 3s ease-in-out infinite;">\u{1F451}</div>
              <div style="position: absolute; top: 20px; left: 20px; font-size: 30px; animation: float 3s ease-in-out infinite reverse;">\u2728</div>

              <h1 style="color: #1a1a1a; margin: 0 0 15px 0; font-size: 32px; font-weight: 800; text-shadow: 2px 2px 4px rgba(0,0,0,0.1);">
                \u{1F389} Welcome to CHARLEY Premium!
              </h1>
              <p style="color: #2d2d2d; font-size: 18px; margin: 0; font-weight: 600;">
                Dear ${data.name}, your premium journey begins now!
              </p>

              <style>
                @keyframes float {
                  0%, 100% { transform: translateY(0px) rotate(0deg); }
                  50% { transform: translateY(-10px) rotate(5deg); }
                }
              </style>
            </div>

            <!-- Subscription Status Card -->
            <div style="padding: 30px; background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%);">
              <div style="background: white; padding: 25px; border-radius: 15px; border: 2px solid #ffd700; box-shadow: 0 8px 25px rgba(255, 215, 0, 0.2);">
                <h2 style="color: #1e293b; font-size: 24px; margin: 0 0 20px 0; font-weight: 700; text-align: center;">
                  \u{1F3C6} Subscription Activated
                </h2>

                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 20px;">
                  <div style="background: #f8fafc; padding: 15px; border-radius: 8px; text-align: center;">
                    <div style="font-size: 14px; color: #64748b; font-weight: 600; margin-bottom: 5px;">PLAN</div>
                    <div style="font-size: 18px; color: #1e293b; font-weight: 700;">${planDisplayName}</div>
                  </div>
                  <div style="background: #f8fafc; padding: 15px; border-radius: 8px; text-align: center;">
                    <div style="font-size: 14px; color: #64748b; font-weight: 600; margin-bottom: 5px;">STATUS</div>
                    <div style="font-size: 18px; color: #10b981; font-weight: 700;">\u2705 Active</div>
                  </div>
                </div>


              </div>
            </div>

            <!-- Premium Features Showcase -->
            <div style="padding: 30px;">
              <h2 style="color: #1e293b; font-size: 26px; margin: 0 0 25px 0; font-weight: 700; text-align: center;">
                \u2728 Premium Features Unlocked
              </h2>

              <div style="display: grid; gap: 15px;">
                <div style="background: linear-gradient(135deg, #ede9fe 0%, #ddd6fe 100%); padding: 20px; border-radius: 12px; border-left: 4px solid #8b5cf6;">
                  <h3 style="color: #6b21a8; margin: 0 0 8px 0; font-size: 18px; font-weight: 600;">\u{1F47B} Ghost Mode</h3>
                  <p style="color: #1f2937; margin: 0; font-size: 15px; line-height: 1.5;">Browse profiles completely anonymously - they won't know you viewed them unless you interact!</p>
                </div>

                <div style="background: linear-gradient(135deg, #fef3f2 0%, #fecaca 100%); padding: 20px; border-radius: 12px; border-left: 4px solid #ef4444;">
                  <h3 style="color: #b91c1c; margin: 0 0 8px 0; font-size: 18px; font-weight: 600;">\u{1F512} Hide My Age</h3>
                  <p style="color: #1f2937; margin: 0; font-size: 15px; line-height: 1.5;">Keep your age private while still getting matched with age-appropriate connections.</p>
                </div>

                <div style="background: linear-gradient(135deg, #f0f9ff 0%, #bfdbfe 100%); padding: 20px; border-radius: 12px; border-left: 4px solid #3b82f6;">
                  <h3 style="color: #1d4ed8; margin: 0 0 8px 0; font-size: 18px; font-weight: 600;">\u26A1 Unlimited Interactions</h3>
                  <p style="color: #1f2937; margin: 0; font-size: 15px; line-height: 1.5;">No daily limits on likes, super likes, or messages. Connect as much as you want!</p>
                </div>

                <div style="background: linear-gradient(135deg, #f0fdf4 0%, #bbf7d0 100%); padding: 20px; border-radius: 12px; border-left: 4px solid #10b981;">
                  <h3 style="color: #047857; margin: 0 0 8px 0; font-size: 18px; font-weight: 600;">\u{1F3AF} Advanced Filters</h3>
                  <p style="color: #1f2937; margin: 0; font-size: 15px; line-height: 1.5;">Precise filtering options to find exactly who you're looking for across all platforms.</p>
                </div>

                <div style="background: linear-gradient(135deg, #fffbeb 0%, #fed7aa 100%); padding: 20px; border-radius: 12px; border-left: 4px solid #f59e0b;">
                  <h3 style="color: #b45309; margin: 0 0 8px 0; font-size: 18px; font-weight: 600;">\u{1F451} Priority Support</h3>
                  <p style="color: #1f2937; margin: 0; font-size: 15px; line-height: 1.5;">Get premium customer support with faster response times and dedicated assistance.</p>
                </div>
              </div>
            </div>

            <!-- Next Steps -->
            <div style="padding: 30px; background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%);">
              <h2 style="color: #1e293b; font-size: 24px; margin: 0 0 25px 0; font-weight: 700; text-align: center;">
                \u{1F680} What's Next?
              </h2>

              <div style="background: white; padding: 25px; border-radius: 12px; border: 1px solid #e2e8f0;">
                <ol style="color: #1f2937; line-height: 1.7; margin: 0; padding-left: 20px; font-size: 16px;">
                  <li style="margin-bottom: 12px;"><strong>Explore Premium Features:</strong> Visit your Settings page to configure Ghost Mode and privacy options</li>
                  <li style="margin-bottom: 12px;"><strong>Update Your Profile:</strong> Premium users get priority in the matching algorithm</li>
                  <li style="margin-bottom: 12px;"><strong>Try Advanced Filters:</strong> Find your perfect match with precision filtering</li>
                  <li style="margin-bottom: 0;"><strong>Connect Without Limits:</strong> Enjoy unlimited interactions across MEET, HEAT, and SUITE</li>
                </ol>
              </div>
            </div>

            <!-- CTA Section -->
            <div style="padding: 30px; text-align: center;">
              <div style="background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%); padding: 25px; border-radius: 15px; margin-bottom: 25px;">
                <h3 style="color: white; margin: 0 0 15px 0; font-size: 22px; font-weight: 700;">
                  Ready to Experience Premium?
                </h3>
                <p style="color: white; margin: 0 0 20px 0; font-size: 16px; opacity: 0.9;">
                  Your premium features are already active and waiting for you!
                </p>
                <a href="https://charley.btechnos.com/settings" style="display: inline-block; background: white; color: #6366f1; text-decoration: none; padding: 12px 30px; border-radius: 25px; font-weight: 600; font-size: 16px; box-shadow: 0 4px 15px rgba(255, 255, 255, 0.3);">
                  Explore Premium Features \u2192
                </a>
              </div>
            </div>

            <!-- Footer -->
            <div style="background: #1e293b; padding: 30px; text-align: center; color: white;">
              <div style="margin-bottom: 20px;">
                <h3 style="color: #ffd700; margin: 0 0 10px 0; font-size: 24px; font-weight: 700;">CHARLEY</h3>
                <p style="color: #94a3b8; margin: 0; font-size: 14px;">Premium Dating & Professional Networking</p>
              </div>

              <div style="border-top: 1px solid #334155; padding-top: 20px;">
                <p style="color: #94a3b8; font-size: 12px; margin: 0; line-height: 1.5;">
                  This email was sent from CHARLEY by BTechnos. You're receiving this because you successfully subscribed to CHARLEY Premium.<br>
                  Need help? Contact us at admin@kronogon.com<br>
                  \xA9 2025 BTechnos. All rights reserved. | <a href="https://btechnos.com" style="color: #ffd700; text-decoration: none;">btechnos.com</a>
                </p>
              </div>
            </div>
          </div>
        </body>
        </html>
      `
    };
    await mailService.send(emailContent);
    console.log(
      `[SENDGRID] Premium subscription email sent successfully to ${data.email}`
    );
    return true;
  } catch (error) {
    console.error(
      "[SENDGRID] Failed to send premium subscription email:",
      error
    );
    if (error.response) {
      console.error("[SENDGRID] Premium subscription email error details:", {
        status: error.code,
        body: error.response?.body,
        headers: error.response?.headers
      });
    }
    return false;
  }
}
var mailService, calculateAge;
var init_sendgrid = __esm({
  "server/services/sendgrid.ts"() {
    "use strict";
    mailService = new MailService();
    if (process.env.SENDGRID_API_KEY) {
      mailService.setApiKey(process.env.SENDGRID_API_KEY);
      console.log("[SENDGRID] API key initialized successfully");
    } else {
      console.error("[SENDGRID] No API key found in environment variables");
    }
    calculateAge = (dateOfBirth) => {
      const today = /* @__PURE__ */ new Date();
      const birthDate = new Date(dateOfBirth);
      let age = today.getFullYear() - birthDate.getFullYear();
      const monthDiff = today.getMonth() - birthDate.getMonth();
      if (monthDiff < 0 || monthDiff === 0 && today.getDate() < birthDate.getDate()) {
        age--;
      }
      return age;
    };
  }
});

// server/user-blocking-api.ts
var user_blocking_api_exports = {};
__export(user_blocking_api_exports, {
  areUsersBlocked: () => areUsersBlocked,
  getBlockedUserIds: () => getBlockedUserIds,
  getUsersWhoBlockedUser: () => getUsersWhoBlockedUser,
  registerUserBlockingAPI: () => registerUserBlockingAPI
});
import { eq as eq4, and as and3, or as or3 } from "drizzle-orm";
import { ZodError } from "zod";
import { fromZodError } from "zod-validation-error";
function registerUserBlockingAPI(app2) {
  app2.post("/api/user/block", async (req, res) => {
    try {
      if (!req.isAuthenticated() || !req.user || !req.user.id) {
        console.log("[USER-BLOCKING] Authentication failed:", {
          isAuthenticated: req.isAuthenticated ? req.isAuthenticated() : "function not available",
          hasUser: !!req.user,
          userId: req.user?.id
        });
        return res.status(401).json({
          message: "Unauthorized",
          details: "Valid authentication session required"
        });
      }
      const currentUserId = req.user.id;
      console.log(`[USER-BLOCKING] User ${currentUserId} initiating block request`);
      console.log("[USER-BLOCKING] Validating request body:", req.body);
      const { blockedUserId, reason } = req.body;
      if (!blockedUserId || typeof blockedUserId !== "number") {
        return res.status(400).json({ message: "Valid blockedUserId is required" });
      }
      const completeData = {
        blockerUserId: currentUserId,
        blockedUserId,
        reason: reason || null
      };
      const validatedData = insertUserBlockSchema.parse(completeData);
      console.log("[USER-BLOCKING] Validation successful:", validatedData);
      console.log(`[USER-BLOCKING] User ${currentUserId} attempting to block user ${blockedUserId}`);
      if (currentUserId === blockedUserId) {
        console.log(`[USER-BLOCKING] User ${currentUserId} attempted to block themselves`);
        return res.status(400).json({ message: "Cannot block yourself" });
      }
      try {
        const newBlock = await db.insert(userBlocks).values({
          blockerUserId: currentUserId,
          blockedUserId,
          reason: reason || null
        }).returning();
        console.log(`[USER-BLOCKING] Successfully created block ${newBlock[0].id}: User ${currentUserId} blocked user ${blockedUserId}`);
        const targetUser = await storage.getUser(blockedUserId);
        if (!targetUser) {
          console.log(`[USER-BLOCKING] Target user ${blockedUserId} not found after blocking`);
          return res.status(404).json({ message: "User not found" });
        }
        res.status(201).json({
          message: "User blocked successfully",
          blockId: newBlock[0].id,
          blockedUser: {
            id: targetUser.id,
            fullName: targetUser.fullName
          }
        });
      } catch (blockError) {
        if (blockError.code === "23505" || blockError.constraint?.includes("unique")) {
          console.log(`[USER-BLOCKING] Block already exists between users ${currentUserId} and ${blockedUserId}`);
          return res.status(200).json({
            message: "User is already blocked",
            note: "Block already exists"
          });
        }
        if (blockError.code === "23503") {
          console.log(`[USER-BLOCKING] Target user ${blockedUserId} not found (foreign key violation)`);
          return res.status(404).json({ message: "User not found" });
        }
        throw blockError;
      }
    } catch (error) {
      console.error("[USER-BLOCKING] Error blocking user:", error);
      if (error instanceof ZodError) {
        const validationError = fromZodError(error);
        return res.status(400).json({
          message: "Validation error",
          details: validationError.toString()
        });
      }
      res.status(500).json({ message: "Failed to block user" });
    }
  });
  app2.delete("/api/user/unblock/:blockedUserId", requireAuth, async (req, res) => {
    try {
      const currentUserId = req.user?.id;
      if (!currentUserId) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      const blockedUserId = parseInt(req.params.blockedUserId);
      if (isNaN(blockedUserId)) {
        return res.status(400).json({ message: "Invalid user ID" });
      }
      console.log(`[USER-BLOCKING] User ${currentUserId} attempting to unblock user ${blockedUserId}`);
      const deletedBlocks = await db.delete(userBlocks).where(
        and3(
          eq4(userBlocks.blockerUserId, currentUserId),
          eq4(userBlocks.blockedUserId, blockedUserId)
        )
      ).returning();
      if (deletedBlocks.length === 0) {
        console.log(`[USER-BLOCKING] No block found between users ${currentUserId} and ${blockedUserId}`);
        return res.status(404).json({ message: "Block not found" });
      }
      console.log(`[USER-BLOCKING] Successfully removed block ${deletedBlocks[0].id}: User ${currentUserId} unblocked user ${blockedUserId}`);
      res.status(200).json({
        message: "User unblocked successfully",
        unblocked: true
      });
    } catch (error) {
      console.error("[USER-BLOCKING] Error unblocking user:", error);
      res.status(500).json({ message: "Failed to unblock user" });
    }
  });
  app2.get("/api/user/blocked-users", requireAuth, async (req, res) => {
    try {
      const currentUserId = req.user?.id;
      if (!currentUserId) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      console.log(`[USER-BLOCKING] Getting blocked users list for user ${currentUserId}`);
      const blockedUsers = await db.select().from(userBlocks).where(eq4(userBlocks.blockerUserId, currentUserId)).orderBy(userBlocks.createdAt);
      const blockedUsersWithInfo = await Promise.all(
        blockedUsers.map(async (block) => {
          const user = await storage.getUser(block.blockedUserId);
          return {
            blockId: block.id,
            blockedUserId: block.blockedUserId,
            reason: block.reason,
            createdAt: block.createdAt,
            fullName: user?.fullName || "Unknown User",
            photoUrl: user?.photoUrl || null
          };
        })
      );
      console.log(`[USER-BLOCKING] Found ${blockedUsersWithInfo.length} blocked users for user ${currentUserId}`);
      res.status(200).json({
        blockedUsers: blockedUsersWithInfo,
        totalCount: blockedUsersWithInfo.length
      });
    } catch (error) {
      console.error("[USER-BLOCKING] Error getting blocked users:", error);
      res.status(500).json({ message: "Failed to get blocked users" });
    }
  });
  app2.get("/api/user/is-blocked/:userId", requireAuth, async (req, res) => {
    try {
      const currentUserId = req.user?.id;
      if (!currentUserId) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      const targetUserId = parseInt(req.params.userId);
      if (isNaN(targetUserId)) {
        return res.status(400).json({ message: "Invalid user ID" });
      }
      const blocks = await db.select().from(userBlocks).where(
        or3(
          and3(
            eq4(userBlocks.blockerUserId, currentUserId),
            eq4(userBlocks.blockedUserId, targetUserId)
          ),
          and3(
            eq4(userBlocks.blockerUserId, targetUserId),
            eq4(userBlocks.blockedUserId, currentUserId)
          )
        )
      );
      const isBlocked = blocks.length > 0;
      const blockType = blocks.length > 0 ? blocks[0].blockerUserId === currentUserId ? "blocked_by_you" : "blocked_you" : null;
      res.status(200).json({
        isBlocked,
        blockType,
        blockDetails: blocks.length > 0 ? blocks[0] : null
      });
    } catch (error) {
      console.error("[USER-BLOCKING] Error checking block status:", error);
      res.status(500).json({ message: "Failed to check block status" });
    }
  });
  console.log("[USER-BLOCKING] User blocking API endpoints registered");
}
async function areUsersBlocked(userId1, userId2) {
  try {
    const blocks = await db.select().from(userBlocks).where(
      or3(
        and3(
          eq4(userBlocks.blockerUserId, userId1),
          eq4(userBlocks.blockedUserId, userId2)
        ),
        and3(
          eq4(userBlocks.blockerUserId, userId2),
          eq4(userBlocks.blockedUserId, userId1)
        )
      )
    ).limit(1);
    return blocks.length > 0;
  } catch (error) {
    console.error("[USER-BLOCKING] Error checking if users are blocked:", error);
    return false;
  }
}
async function getBlockedUserIds(userId) {
  try {
    const blocks = await db.select({ blockedUserId: userBlocks.blockedUserId }).from(userBlocks).where(eq4(userBlocks.blockerUserId, userId));
    return blocks.map((block) => block.blockedUserId);
  } catch (error) {
    console.error("[USER-BLOCKING] Error getting blocked user IDs:", error);
    return [];
  }
}
async function getUsersWhoBlockedUser(userId) {
  try {
    const blocks = await db.select({ blockerUserId: userBlocks.blockerUserId }).from(userBlocks).where(eq4(userBlocks.blockedUserId, userId));
    return blocks.map((block) => block.blockerUserId);
  } catch (error) {
    console.error("[USER-BLOCKING] Error getting users who blocked user:", error);
    return [];
  }
}
var init_user_blocking_api = __esm({
  "server/user-blocking-api.ts"() {
    "use strict";
    init_storage();
    init_auth();
    init_schema();
    init_db();
  }
});

// server/jobs-compatibility-api.ts
var jobs_compatibility_api_exports = {};
__export(jobs_compatibility_api_exports, {
  registerJobsCompatibilityAPI: () => registerJobsCompatibilityAPI
});
function registerJobsCompatibilityAPI(app2) {
  app2.get("/api/jobs/compatibility/:targetUserId", async (req, res) => {
    try {
      let currentUserId = req.user?.id;
      if (!req.isAuthenticated() || !currentUserId) {
        currentUserId = 2;
      }
      const targetUserId = parseInt(req.params.targetUserId);
      if (isNaN(targetUserId)) {
        return res.status(400).json({ message: "Invalid target user ID" });
      }
      if (targetUserId === currentUserId) {
        return res.status(400).json({
          message: "Cannot create professional review for yourself"
        });
      }
      const existingReview = await storage.getExistingReview(targetUserId, currentUserId, "overall");
      if (existingReview) {
        return res.status(200).json({
          review: existingReview,
          created: false,
          cached: true
        });
      }
      const targetUser = await storage.getUser(targetUserId);
      if (!targetUser) {
        return res.status(404).json({ message: "Target user not found" });
      }
      const currentUser = await storage.getUser(currentUserId);
      if (!currentUser) {
        return res.status(400).json({ message: "Current user not found" });
      }
      const reviewData = {
        reviewedUserId: targetUserId,
        reviewerUserId: currentUserId,
        rating: 1,
        // Default minimum rating (constraint requires 1-5)
        reviewText: "Review pending",
        // Placeholder text - user will update this
        category: "overall",
        isAnonymous: false
      };
      const newReview = await storage.createProfessionalReview(reviewData);
      res.status(200).json({
        review: newReview,
        created: true,
        cached: false,
        message: "Professional review record created successfully"
      });
    } catch (error) {
      console.error("Error in jobs compatibility API:", error);
      res.status(500).json({
        message: "Server error in jobs compatibility processing"
      });
    }
  });
  app2.get("/api/jobs/compatibility/dashboard/:targetUserId", async (req, res) => {
    try {
      let currentUserId = req.user?.id;
      if (!req.isAuthenticated() || !currentUserId) {
        currentUserId = 2;
      }
      const targetUserId = parseInt(req.params.targetUserId);
      if (isNaN(targetUserId)) {
        return res.status(400).json({ message: "Invalid target user ID" });
      }
      if (targetUserId === currentUserId) {
        return res.status(400).json({
          message: "Cannot view jobs compatibility dashboard for yourself"
        });
      }
      const targetUser = await storage.getUser(targetUserId);
      if (!targetUser) {
        return res.status(404).json({ message: "Target user not found" });
      }
      const currentUser = await storage.getUser(currentUserId);
      if (!currentUser) {
        return res.status(400).json({ message: "Current user not found" });
      }
      let existingReview = await storage.getExistingReview(targetUserId, currentUserId, "overall");
      let reviewCreated = false;
      if (!existingReview) {
        const reviewData = {
          reviewedUserId: targetUserId,
          reviewerUserId: currentUserId,
          rating: 1,
          // Default minimum rating (constraint requires 1-5)
          reviewText: "Review pending",
          // Placeholder text - user will update this
          category: "overall",
          isAnonymous: false
        };
        existingReview = await storage.createProfessionalReview(reviewData);
        reviewCreated = true;
      }
      const reviewsData = await storage.getProfessionalReviewsForUser(targetUserId);
      const reviewStats = await storage.getProfessionalReviewStats(targetUserId);
      const jobPhotos = await storage.getUserPhotos(targetUserId);
      const jobPrimaryPhoto = jobPhotos.find((photo) => photo.isPrimaryForJob);
      const dashboardData = {
        currentUser: {
          id: currentUser.id,
          fullName: currentUser.fullName,
          photoUrl: currentUser.photoUrl
        },
        targetUser: {
          id: targetUser.id,
          fullName: targetUser.fullName,
          photoUrl: jobPrimaryPhoto?.photoUrl || targetUser.photoUrl,
          profession: targetUser.profession,
          location: targetUser.location
        },
        currentReview: existingReview,
        allReviews: reviewsData,
        stats: reviewStats,
        reviewCreated,
        cached: !reviewCreated
      };
      res.status(200).json(dashboardData);
    } catch (error) {
      console.error("Error in jobs compatibility dashboard API:", error);
      res.status(500).json({
        message: "Server error in jobs compatibility dashboard"
      });
    }
  });
}
var init_jobs_compatibility_api = __esm({
  "server/jobs-compatibility-api.ts"() {
    "use strict";
    init_storage();
  }
});

// server/geocoding-service.ts
import fetch3 from "node-fetch";
import dotenv from "dotenv";
var GeocodingService, geocodingService;
var init_geocoding_service = __esm({
  "server/geocoding-service.ts"() {
    "use strict";
    dotenv.config();
    GeocodingService = class {
      coordinateCache = /* @__PURE__ */ new Map();
      googlePlacesApiKey = process.env.GOOGLE_PLACES_API_KEY || process.env.VITE_GOOGLE_PLACES_API_KEY;
      /**
       * TIMEZONE API INTEGRATION
       * Get timezone information from coordinates using Google Timezone API
       */
      async getTimezoneFromCoordinates(lat, lng) {
        try {
          if (!this.googlePlacesApiKey) {
            return null;
          }
          const timestamp2 = Math.floor(Date.now() / 1e3);
          const url = `https://maps.googleapis.com/maps/api/timezone/json?location=${lat},${lng}&timestamp=${timestamp2}&key=${this.googlePlacesApiKey}`;
          console.log(`[TIMEZONE] Getting timezone for coordinates: ${lat}, ${lng}`);
          const response = await fetch3(url);
          const data = await response.json();
          if (data.status === "OK") {
            const rawOffset = data.rawOffset / 3600;
            const dstOffset = data.dstOffset / 3600;
            const totalOffset = rawOffset + dstOffset;
            console.log(`[TIMEZONE] Success: ${data.timeZoneId}, offset: ${totalOffset}h`);
            return {
              timezone: data.timeZoneId,
              offset: totalOffset
            };
          } else {
            console.log(`[TIMEZONE] API returned status: ${data.status}`);
            return null;
          }
        } catch (error) {
          console.error(`[TIMEZONE] Error getting timezone:`, error);
          return null;
        }
      }
      /**
       * GOOGLE PLACES API GEOCODING
       * Real-time location lookup using Google Places API for global coverage
       */
      async geocodeWithGooglePlaces(location) {
        try {
          if (!this.googlePlacesApiKey) {
            console.log("[GEOCODING] Google Places API key not found, using fallback database");
            return null;
          }
          const encodedLocation = encodeURIComponent(location);
          const url = `https://maps.googleapis.com/maps/api/geocode/json?address=${encodedLocation}&key=${this.googlePlacesApiKey}`;
          console.log(`[GEOCODING] Geocoding "${location}" with Google Places API`);
          const response = await fetch3(url);
          const data = await response.json();
          if (data.status === "OK" && data.results.length > 0) {
            const result = data.results[0];
            const { lat, lng } = result.geometry.location;
            let city;
            let country;
            for (const component of result.address_components) {
              if (component.types.includes("locality") || component.types.includes("administrative_area_level_1")) {
                city = component.long_name;
              }
              if (component.types.includes("country")) {
                country = component.long_name;
              }
            }
            const timezoneInfo = await this.getTimezoneFromCoordinates(lat, lng);
            const locationData = {
              coordinates: { latitude: lat, longitude: lng },
              city,
              country,
              timezone: timezoneInfo?.timezone,
              timezoneOffset: timezoneInfo?.offset,
              confidence: 0.95,
              // High confidence for Google Places API
              source: "google-places"
            };
            console.log(`[GEOCODING] Successfully geocoded "${location}": ${lat}, ${lng} (${city}, ${country}, ${timezoneInfo?.timezone})`);
            return locationData;
          } else {
            console.log(`[GEOCODING] Google Places API returned status: ${data.status} for "${location}"`);
            return null;
          }
        } catch (error) {
          console.error(`[GEOCODING] Error with Google Places API for "${location}":`, error);
          return null;
        }
      }
      /**
       * Fallback location coordinate database for offline/backup scenarios
       */
      fallbackLocationDatabase = {
        // Major US Cities
        "richardson, tx, usa": { coordinates: { latitude: 32.9483, longitude: -96.7299 }, city: "Richardson", country: "USA", confidence: 0.95, source: "precise" },
        "dallas, tx, usa": { coordinates: { latitude: 32.7767, longitude: -96.797 }, city: "Dallas", country: "USA", confidence: 0.95, source: "precise" },
        "houston, tx, usa": { coordinates: { latitude: 29.7604, longitude: -95.3698 }, city: "Houston", country: "USA", confidence: 0.95, source: "precise" },
        "austin, tx, usa": { coordinates: { latitude: 30.2672, longitude: -97.7431 }, city: "Austin", country: "USA", confidence: 0.95, source: "precise" },
        "new york, ny, usa": { coordinates: { latitude: 40.7128, longitude: -74.006 }, city: "New York", country: "USA", confidence: 0.95, source: "precise" },
        "los angeles, ca, usa": { coordinates: { latitude: 34.0522, longitude: -118.2437 }, city: "Los Angeles", country: "USA", confidence: 0.95, source: "precise" },
        "chicago, il, usa": { coordinates: { latitude: 41.8781, longitude: -87.6298 }, city: "Chicago", country: "USA", confidence: 0.95, source: "precise" },
        "miami, fl, usa": { coordinates: { latitude: 25.7617, longitude: -80.1918 }, city: "Miami", country: "USA", confidence: 0.95, source: "precise" },
        // European Cities  
        "madrid, spain": { coordinates: { latitude: 40.4168, longitude: -3.7038 }, city: "Madrid", country: "Spain", confidence: 0.95, source: "precise" },
        "barcelona, spain": { coordinates: { latitude: 41.3851, longitude: 2.1734 }, city: "Barcelona", country: "Spain", confidence: 0.95, source: "precise" },
        "berlin, germany": { coordinates: { latitude: 52.52, longitude: 13.405 }, city: "Berlin", country: "Germany", confidence: 0.95, source: "precise" },
        "munich, germany": { coordinates: { latitude: 48.1351, longitude: 11.582 }, city: "Munich", country: "Germany", confidence: 0.95, source: "precise" },
        "london, uk": { coordinates: { latitude: 51.5074, longitude: -0.1278 }, city: "London", country: "UK", confidence: 0.95, source: "precise" },
        "manchester, uk": { coordinates: { latitude: 53.4808, longitude: -2.2426 }, city: "Manchester", country: "UK", confidence: 0.95, source: "precise" },
        "paris, france": { coordinates: { latitude: 48.8566, longitude: 2.3522 }, city: "Paris", country: "France", confidence: 0.95, source: "precise" },
        "rome, italy": { coordinates: { latitude: 41.9028, longitude: 12.4964 }, city: "Rome", country: "Italy", confidence: 0.95, source: "precise" },
        "amsterdam, netherlands": { coordinates: { latitude: 52.3676, longitude: 4.9041 }, city: "Amsterdam", country: "Netherlands", confidence: 0.95, source: "precise" },
        // African Cities
        "accra, ghana": { coordinates: { latitude: 5.6037, longitude: -0.187 }, city: "Accra", country: "Ghana", confidence: 0.95, source: "precise" },
        "kumasi, ghana": { coordinates: { latitude: 6.6885, longitude: -1.6244 }, city: "Kumasi", country: "Ghana", confidence: 0.95, source: "precise" },
        "tamale, ghana": { coordinates: { latitude: 9.4075, longitude: -0.8533 }, city: "Tamale", country: "Ghana", confidence: 0.95, source: "precise" },
        "lagos, nigeria": { coordinates: { latitude: 6.5244, longitude: 3.3792 }, city: "Lagos", country: "Nigeria", confidence: 0.95, source: "precise" },
        "abuja, nigeria": { coordinates: { latitude: 9.0765, longitude: 7.3986 }, city: "Abuja", country: "Nigeria", confidence: 0.95, source: "precise" },
        "kano, nigeria": { coordinates: { latitude: 12.0022, longitude: 8.592 }, city: "Kano", country: "Nigeria", confidence: 0.95, source: "precise" },
        // Canadian Cities
        "toronto, canada": { coordinates: { latitude: 43.6532, longitude: -79.3832 }, city: "Toronto", country: "Canada", confidence: 0.95, source: "precise" },
        "vancouver, canada": { coordinates: { latitude: 49.2827, longitude: -123.1207 }, city: "Vancouver", country: "Canada", confidence: 0.95, source: "precise" },
        "montreal, canada": { coordinates: { latitude: 45.5019, longitude: -73.5674 }, city: "Montreal", country: "Canada", confidence: 0.95, source: "precise" },
        // Country Fallbacks (approximate center coordinates)
        "usa": { coordinates: { latitude: 39.8283, longitude: -98.5795 }, city: void 0, country: "USA", confidence: 0.6, source: "fallback" },
        "united states": { coordinates: { latitude: 39.8283, longitude: -98.5795 }, city: void 0, country: "USA", confidence: 0.6, source: "fallback" },
        "spain": { coordinates: { latitude: 40.4637, longitude: -3.7492 }, city: void 0, country: "Spain", confidence: 0.6, source: "fallback" },
        "germany": { coordinates: { latitude: 51.1657, longitude: 10.4515 }, city: void 0, country: "Germany", confidence: 0.6, source: "fallback" },
        "ghana": { coordinates: { latitude: 7.9465, longitude: -1.0232 }, city: void 0, country: "Ghana", confidence: 0.6, source: "fallback" },
        "nigeria": { coordinates: { latitude: 9.082, longitude: 8.6753 }, city: void 0, country: "Nigeria", confidence: 0.6, source: "fallback" },
        "uk": { coordinates: { latitude: 55.3781, longitude: -3.436 }, city: void 0, country: "UK", confidence: 0.6, source: "fallback" },
        "united kingdom": { coordinates: { latitude: 55.3781, longitude: -3.436 }, city: void 0, country: "UK", confidence: 0.6, source: "fallback" },
        "france": { coordinates: { latitude: 46.6034, longitude: 1.8883 }, city: void 0, country: "France", confidence: 0.6, source: "fallback" },
        "italy": { coordinates: { latitude: 41.8719, longitude: 12.5674 }, city: void 0, country: "Italy", confidence: 0.6, source: "fallback" },
        "netherlands": { coordinates: { latitude: 52.1326, longitude: 5.2913 }, city: void 0, country: "Netherlands", confidence: 0.6, source: "fallback" },
        "canada": { coordinates: { latitude: 56.1304, longitude: -106.3468 }, city: void 0, country: "Canada", confidence: 0.6, source: "fallback" }
      };
      /**
       * Get coordinates for a location string
       */
      async getCoordinates(location) {
        if (!location || location.trim() === "") {
          return null;
        }
        const locationKey = this.normalizeLocationString(location);
        console.log(`[GEOCODING] Looking up coordinates for: "${location}" \u2192 normalized: "${locationKey}"`);
        if (this.coordinateCache.has(locationKey)) {
          const cached = this.coordinateCache.get(locationKey);
          console.log(`[GEOCODING] Cache hit: ${cached.coordinates.latitude}, ${cached.coordinates.longitude} (${cached.source})`);
          return cached;
        }
        const locationData = await this.findLocationInDatabase(locationKey);
        if (locationData) {
          this.coordinateCache.set(locationKey, locationData);
          console.log(`[GEOCODING] Location found: ${locationData.coordinates.latitude}, ${locationData.coordinates.longitude} (${locationData.source})`);
          return locationData;
        }
        const parsedLocation = this.parseStructuredLocation(location);
        if (parsedLocation) {
          this.coordinateCache.set(locationKey, parsedLocation);
          console.log(`[GEOCODING] Parsed location: ${parsedLocation.coordinates.latitude}, ${parsedLocation.coordinates.longitude} (${parsedLocation.source})`);
          return parsedLocation;
        }
        console.log(`[GEOCODING] No coordinates found for: "${location}"`);
        return null;
      }
      /**
       * Normalize location string for consistent matching
       */
      normalizeLocationString(location) {
        return location.toLowerCase().trim().replace(/\s+/g, " ").replace(/[,]+/g, ",").replace(/\s*,\s*/g, ", ");
      }
      /**
       * Find location using Google Places API first, then fallback database
       */
      async findLocationInDatabase(normalizedLocation) {
        const googleResult = await this.geocodeWithGooglePlaces(normalizedLocation);
        if (googleResult) {
          return googleResult;
        }
        if (this.fallbackLocationDatabase[normalizedLocation]) {
          return this.fallbackLocationDatabase[normalizedLocation];
        }
        for (const [key, data] of Object.entries(this.fallbackLocationDatabase)) {
          if (normalizedLocation.includes(key) || key.includes(normalizedLocation)) {
            return data;
          }
          const locationParts = normalizedLocation.split(",").map((p) => p.trim());
          const keyParts = key.split(",").map((p) => p.trim());
          const hasMatch = locationParts.some(
            (part) => keyParts.some(
              (keyPart) => part.includes(keyPart) || keyPart.includes(part)
            )
          );
          if (hasMatch) {
            return { ...data, confidence: data.confidence * 0.8, source: "approximate" };
          }
        }
        return null;
      }
      /**
       * Parse structured location (City, State, Country format)
       */
      parseStructuredLocation(location) {
        const parts = location.split(",").map((p) => p.trim().toLowerCase());
        if (parts.length >= 2) {
          const lastPart = parts[parts.length - 1];
          const countryData = this.fallbackLocationDatabase[lastPart];
          if (countryData) {
            return {
              ...countryData,
              confidence: countryData.confidence * 0.7,
              source: "approximate"
            };
          }
        }
        return null;
      }
      /**
       * Calculate distance between two coordinates using Haversine formula
       */
      calculateDistance(coord1, coord2) {
        const R = 6371;
        const lat1Rad = this.toRadians(coord1.latitude);
        const lat2Rad = this.toRadians(coord2.latitude);
        const deltaLatRad = this.toRadians(coord2.latitude - coord1.latitude);
        const deltaLonRad = this.toRadians(coord2.longitude - coord1.longitude);
        const a = Math.sin(deltaLatRad / 2) * Math.sin(deltaLatRad / 2) + Math.cos(lat1Rad) * Math.cos(lat2Rad) * Math.sin(deltaLonRad / 2) * Math.sin(deltaLonRad / 2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        const distance = R * c;
        return Math.round(distance * 100) / 100;
      }
      /**
       * Calculate distance between two location strings
       */
      async calculateLocationDistance(location1, location2) {
        console.log(`[DISTANCE-CALC] Calculating distance between "${location1}" and "${location2}"`);
        const [coord1Data, coord2Data] = await Promise.all([
          this.getCoordinates(location1),
          this.getCoordinates(location2)
        ]);
        if (!coord1Data || !coord2Data) {
          console.log(`[DISTANCE-CALC] Missing coordinates - coord1: ${!!coord1Data}, coord2: ${!!coord2Data}`);
          return {
            distance: null,
            confidence: 0,
            details: {
              location1Data: coord1Data,
              location2Data: coord2Data
            }
          };
        }
        const distance = this.calculateDistance(coord1Data.coordinates, coord2Data.coordinates);
        const confidence = Math.min(coord1Data.confidence, coord2Data.confidence);
        console.log(`[DISTANCE-CALC] Distance: ${distance}km, Confidence: ${confidence}`);
        console.log(`[DISTANCE-CALC] Locations: (${coord1Data.coordinates.latitude}, ${coord1Data.coordinates.longitude}) \u2192 (${coord2Data.coordinates.latitude}, ${coord2Data.coordinates.longitude})`);
        return {
          distance,
          confidence,
          details: {
            location1Data: coord1Data,
            location2Data: coord2Data
          }
        };
      }
      /**
       * Check if distance is within preference range
       */
      async isWithinDistancePreference(userLocation, candidateLocation, maxDistanceKm) {
        const distanceResult = await this.calculateLocationDistance(userLocation, candidateLocation);
        if (distanceResult.distance === null) {
          return {
            withinRange: true,
            actualDistance: null,
            confidence: 0
          };
        }
        const withinRange = distanceResult.distance <= maxDistanceKm;
        console.log(`[DISTANCE-FILTER] ${userLocation} \u2192 ${candidateLocation}: ${distanceResult.distance}km ${withinRange ? "\u2713" : "\u2717"} ${maxDistanceKm}km limit`);
        return {
          withinRange,
          actualDistance: distanceResult.distance,
          confidence: distanceResult.confidence
        };
      }
      /**
       * FACTOR 4: TIMEZONE COMPATIBILITY CALCULATIONS
       * Calculate timezone compatibility between two locations
       */
      async calculateTimezoneCompatibility(location1, location2) {
        console.log(`[TIMEZONE-COMPAT] Calculating timezone compatibility: "${location1}" vs "${location2}"`);
        try {
          const [loc1Data, loc2Data] = await Promise.all([
            this.getCoordinates(location1),
            this.getCoordinates(location2)
          ]);
          if (!loc1Data || !loc2Data) {
            console.log(`[TIMEZONE-COMPAT] Missing location data`);
            return {
              score: 0.5,
              // Neutral score when data unavailable
              hoursDifference: 0,
              overlappingHours: [],
              compatibility: "fair",
              confidence: 0
            };
          }
          let offset1 = loc1Data.timezoneOffset;
          let offset2 = loc2Data.timezoneOffset;
          if (offset1 === void 0 || offset2 === void 0) {
            offset1 = offset1 ?? Math.round(loc1Data.coordinates.longitude / 15);
            offset2 = offset2 ?? Math.round(loc2Data.coordinates.longitude / 15);
            console.log(`[TIMEZONE-COMPAT] Using longitude-based timezone estimation`);
          }
          const hoursDifference = Math.abs(offset1 - offset2);
          const activeHours1 = this.getActiveHours(offset1);
          const activeHours2 = this.getActiveHours(offset2);
          const overlappingHours = activeHours1.filter((hour) => activeHours2.includes(hour));
          let score;
          let compatibility;
          if (hoursDifference === 0) {
            score = 1;
            compatibility = "excellent";
          } else if (hoursDifference <= 3) {
            score = 0.8 - hoursDifference * 0.1;
            compatibility = "good";
          } else if (hoursDifference <= 8) {
            score = 0.6 - hoursDifference * 0.05;
            compatibility = "fair";
          } else {
            score = Math.max(0.1, 0.4 - hoursDifference * 0.02);
            compatibility = "poor";
          }
          const overlapBonus = overlappingHours.length / 14;
          score = Math.min(1, score + overlapBonus * 0.2);
          const confidence = Math.min(loc1Data.confidence, loc2Data.confidence);
          console.log(`[TIMEZONE-COMPAT] ${location1} (UTC${offset1}) vs ${location2} (UTC${offset2})`);
          console.log(`[TIMEZONE-COMPAT] Hours difference: ${hoursDifference}, Overlapping hours: ${overlappingHours.length}`);
          console.log(`[TIMEZONE-COMPAT] Score: ${(score * 100).toFixed(1)}%, Compatibility: ${compatibility}`);
          return {
            score,
            hoursDifference,
            overlappingHours,
            compatibility,
            confidence
          };
        } catch (error) {
          console.error(`[TIMEZONE-COMPAT] Error calculating timezone compatibility:`, error);
          return {
            score: 0.5,
            hoursDifference: 0,
            overlappingHours: [],
            compatibility: "fair",
            confidence: 0
          };
        }
      }
      /**
       * Get active hours in UTC for a given timezone offset
       * Assumes people are active from 9 AM to 11 PM local time
       */
      getActiveHours(utcOffset) {
        const activeHours = [];
        for (let localHour = 9; localHour <= 23; localHour++) {
          let utcHour = localHour - utcOffset;
          if (utcHour < 0) utcHour += 24;
          if (utcHour >= 24) utcHour -= 24;
          activeHours.push(utcHour);
        }
        return activeHours.sort((a, b) => a - b);
      }
      /**
       * Helper function to convert degrees to radians
       */
      toRadians(degrees) {
        return degrees * (Math.PI / 180);
      }
      /**
       * Convert degrees to radians
       */
      toRadians(degrees) {
        return degrees * (Math.PI / 180);
      }
      /**
       * Get distance-based compatibility score (0-1 scale)
       */
      async getDistanceCompatibilityScore(userLocation, candidateLocation, maxDistanceKm = 100) {
        const distanceResult = await this.calculateLocationDistance(userLocation, candidateLocation);
        if (distanceResult.distance === null || distanceResult.confidence < 0.3) {
          return 0.5;
        }
        const distance = distanceResult.distance;
        if (distance <= maxDistanceKm) {
          const proximityScore = Math.max(0.5, 1 - distance / maxDistanceKm * 0.5);
          return proximityScore * distanceResult.confidence;
        } else {
          const excessDistance = distance - maxDistanceKm;
          const decayScore = Math.max(0.1, Math.exp(-excessDistance / maxDistanceKm));
          return decayScore * distanceResult.confidence;
        }
      }
      /**
       * Get comprehensive location analysis
       */
      async analyzeLocationCompatibility(userLocation, candidateLocation, distancePreference) {
        const maxDistance = distancePreference || 100;
        const distanceResult = await this.calculateLocationDistance(userLocation, candidateLocation);
        const score = await this.getDistanceCompatibilityScore(userLocation, candidateLocation, maxDistance);
        let analysis = "";
        if (distanceResult.distance === null) {
          analysis = "Distance calculation unavailable - using neutral scoring";
        } else if (distanceResult.distance <= maxDistance) {
          analysis = `Within ${maxDistance}km preference (${distanceResult.distance}km) - high compatibility`;
        } else {
          analysis = `Beyond ${maxDistance}km preference (${distanceResult.distance}km) - reduced compatibility`;
        }
        return {
          score,
          distance: distanceResult.distance,
          withinPreference: distanceResult.distance !== null && distanceResult.distance <= maxDistance,
          confidence: distanceResult.confidence,
          analysis
        };
      }
    };
    geocodingService = new GeocodingService();
  }
});

// server/advanced-matching-algorithms.ts
var AdvancedMatchingEngine, advancedMatchingEngine;
var init_advanced_matching_algorithms = __esm({
  "server/advanced-matching-algorithms.ts"() {
    "use strict";
    init_geocoding_service();
    AdvancedMatchingEngine = class {
      interactionCache = /* @__PURE__ */ new Map();
      vectorCache = /* @__PURE__ */ new Map();
      diversityThreshold = 0.15;
      // Minimum diversity injection percentage
      /**
       * Enhanced content scoring using multiple similarity algorithms
       */
      calculateAdvancedContentScore(user, candidate, userPreferences3, candidatePreferences) {
        const userVector = this.createUserVector(user, userPreferences3 || void 0);
        const candidateVector = this.createUserVector(candidate, candidatePreferences || void 0);
        const cosineSim = this.calculateCosineSimilarity(userVector, candidateVector);
        const jaccardSim = this.calculateJaccardSimilarity(user, candidate, userPreferences3 || void 0, candidatePreferences || void 0);
        const tfidfSim = this.calculateTFIDFSimilarity(user, candidate);
        const preferenceScore = this.calculatePreferenceAlignment(candidate, userPreferences3);
        const finalScore = cosineSim * 0.3 + jaccardSim * 0.25 + tfidfSim * 0.2 + preferenceScore * 0.25;
        return {
          score: Math.min(finalScore, 1),
          details: {
            cosine: cosineSim,
            jaccard: jaccardSim,
            tfidf: tfidfSim,
            preference: preferenceScore
          }
        };
      }
      /**
       * Matrix Factorization using simplified SVD approach
       */
      async calculateMatrixFactorizationScore(userId, candidateId, interactionMatrix) {
        try {
          const userIndex = interactionMatrix.userIds.indexOf(userId);
          const candidateIndex = interactionMatrix.userIds.indexOf(candidateId);
          if (userIndex === -1 || candidateIndex === -1) {
            return 0.5;
          }
          const userInteractions = interactionMatrix.interactions[userIndex];
          const candidateProfile = interactionMatrix.profileVectors.get(candidateId);
          if (!candidateProfile) return 0.5;
          const similarUsers = this.findSimilarUsersMatrix(userId, interactionMatrix);
          let weightedSum = 0;
          let totalWeight = 0;
          for (const { userId: simUserId, similarity } of similarUsers) {
            const simUserIndex = interactionMatrix.userIds.indexOf(simUserId);
            if (simUserIndex !== -1) {
              const simUserInteraction = interactionMatrix.interactions[simUserIndex][candidateIndex];
              if (simUserInteraction > 0) {
                weightedSum += similarity * simUserInteraction;
                totalWeight += Math.abs(similarity);
              }
            }
          }
          return totalWeight > 0 ? Math.min(weightedSum / totalWeight, 1) : 0.5;
        } catch (error) {
          console.error("[MATRIX-FACTORIZATION] Error:", error);
          return 0.5;
        }
      }
      /**
       * Advanced context scoring with reciprocity analysis
       */
      calculateAdvancedContextScore(candidate, context, reciprocityData) {
        let score = 0.5;
        const details = {};
        if (candidate.lastActive) {
          const hoursSinceActive = (context.currentTime.getTime() - candidate.lastActive.getTime()) / (1e3 * 60 * 60);
          const activityScore = Math.exp(-hoursSinceActive / 24);
          score += activityScore * 0.3;
          details.activity = activityScore;
        }
        if (candidate.isOnline) {
          score += 0.2;
          details.online = true;
        }
        const completeness = this.calculateProfileCompleteness(candidate);
        const completenessBonus = Math.sqrt(completeness) * 0.25;
        score += completenessBonus;
        details.completeness = completeness;
        const reciprocityScore = this.calculateReciprocityScore(reciprocityData);
        score += reciprocityScore * 0.25;
        details.reciprocity = reciprocityScore;
        return {
          score: Math.min(score, 1),
          details
        };
      }
      /**
       * ENHANCED DEMOGRAPHIC DIVERSITY INJECTION & FILTER BUBBLE PREVENTION
       * 
       * Implements all 5 demographic diversity categories:
       * 1. Age range expansion beyond preferences
       * 2. Ethnicity and secondaryTribe variety  
       * 3. Education level diversity
       * 4. Profession category mixing
       * 5. Location geographic diversity
       */
      injectDemographicDiversity(rankedCandidates, allCandidates, currentUser, userPreferences3, diversityPercentage = 0.15) {
        console.log(`[DEMOGRAPHIC-DIVERSITY] \u{1F3AF} Starting diversity injection for user ${currentUser.id}`);
        console.log(`[DEMOGRAPHIC-DIVERSITY] Total candidates: ${allCandidates.length}, Top results: ${rankedCandidates.length}`);
        const totalResults = rankedCandidates.length;
        const diversityCount = Math.floor(totalResults * diversityPercentage);
        if (diversityCount === 0 || allCandidates.length <= rankedCandidates.length) {
          console.log(`[DEMOGRAPHIC-DIVERSITY] \u26A0\uFE0F Skipping diversity injection (insufficient candidates)`);
          return rankedCandidates;
        }
        const topCandidateIds = new Set(rankedCandidates.map((r) => r.userId));
        const diversityCandidates = allCandidates.filter((c) => !topCandidateIds.has(c.id));
        console.log(`[DEMOGRAPHIC-DIVERSITY] Available diversity candidates: ${diversityCandidates.length}`);
        const ageExpandedCandidates = this.expandAgeRangeDiversity(diversityCandidates, currentUser, userPreferences3);
        const ethnicityDiverseCandidates = this.injectEthnicityDiversity(diversityCandidates, currentUser);
        const educationDiverseCandidates = this.injectEducationDiversity(diversityCandidates, currentUser);
        const professionDiverseCandidates = this.injectProfessionDiversity(diversityCandidates, currentUser);
        const geographicDiverseCandidates = this.injectGeographicDiversity(diversityCandidates, currentUser);
        const allDiversityCandidates = [
          ...ageExpandedCandidates,
          ...ethnicityDiverseCandidates,
          ...educationDiverseCandidates,
          ...professionDiverseCandidates,
          ...geographicDiverseCandidates
        ];
        const uniqueDiversityCandidates = Array.from(
          new Map(allDiversityCandidates.map((c) => [c.id, c])).values()
        ).slice(0, diversityCount * 2);
        console.log(`[DEMOGRAPHIC-DIVERSITY] Selected ${uniqueDiversityCandidates.length} unique diversity candidates`);
        const diverseResults = [];
        for (let i = 0; i < Math.min(diversityCount, uniqueDiversityCandidates.length); i++) {
          const candidate = uniqueDiversityCandidates[i];
          const diversityScore = this.calculateDiversityScore(candidate, currentUser);
          diverseResults.push({
            userId: candidate.id,
            contentScore: 0.4,
            collaborativeScore: 0.3,
            contextScore: 0.5,
            diversityBonus: diversityScore,
            // Calculated diversity boost
            reciprocityScore: 0.5,
            finalScore: 0.5 + diversityScore * 0.3,
            // Base score + diversity bonus
            algorithmVersion: "advanced-v1.0-demographic-diversity",
            reasons: ["Demographic diversity", "Filter bubble prevention", "Serendipitous match"]
          });
        }
        console.log(`[DEMOGRAPHIC-DIVERSITY] \u2705 Created ${diverseResults.length} diversity recommendations`);
        const result = [...rankedCandidates];
        const injectionInterval = Math.floor(totalResults / diversityCount);
        for (let i = 0; i < diverseResults.length; i++) {
          const insertPosition = (i + 1) * injectionInterval;
          if (insertPosition < result.length) {
            result.splice(insertPosition + i, 0, diverseResults[i]);
          } else {
            result.push(diverseResults[i]);
          }
        }
        console.log(`[DEMOGRAPHIC-DIVERSITY] \u{1F3AF} Final results: ${result.length} total matches (${diverseResults.length} diversity injected)`);
        return result;
      }
      /**
       * DEMOGRAPHIC DIVERSITY CATEGORY 1: AGE RANGE EXPANSION
       * Includes users slightly outside age preferences for diversity
       */
      expandAgeRangeDiversity(candidates, currentUser, preferences) {
        if (!preferences || !currentUser.dateOfBirth) return [];
        const userAge = this.calculateAge(currentUser.dateOfBirth);
        const minAge = preferences.minAge || 18;
        const maxAge = preferences.maxAge || 45;
        const expandedMinAge = Math.max(18, minAge - 4);
        const expandedMaxAge = Math.min(50, maxAge + 4);
        const ageDiverseCandidates = candidates.filter((candidate) => {
          if (!candidate.dateOfBirth) return false;
          const candidateAge = this.calculateAge(candidate.dateOfBirth);
          const inExpandedRange = candidateAge >= expandedMinAge && candidateAge <= expandedMaxAge;
          const outsideOriginalPrefs = candidateAge < minAge || candidateAge > maxAge;
          return inExpandedRange && outsideOriginalPrefs;
        });
        const boostedCandidates = ageDiverseCandidates.map((candidate) => ({
          candidate,
          newUserBoost: this.calculateNewUserBoost(candidate)
        })).sort((a, b) => b.newUserBoost - a.newUserBoost).map((item) => item.candidate);
        console.log(`[AGE-DIVERSITY] Found ${ageDiverseCandidates.length} candidates outside age prefs (${minAge}-${maxAge} \u2192 ${expandedMinAge}-${expandedMaxAge}) with new user boosts applied`);
        return boostedCandidates.slice(0, 3);
      }
      /**
       * DEMOGRAPHIC DIVERSITY CATEGORY 2: ETHNICITY & SECONDARY TRIBE VARIETY
       * Introduces ethnic diversity beyond user's typical preferences
       */
      injectEthnicityDiversity(candidates, currentUser) {
        const currentEthnicity = currentUser.ethnicity;
        const currentSecondaryTribe = currentUser.secondaryTribe;
        const ethnicityDiverseCandidates = candidates.filter((candidate) => {
          const differentEthnicity = candidate.ethnicity && candidate.ethnicity !== currentEthnicity;
          const differentSecondaryTribe = candidate.secondaryTribe && candidate.secondaryTribe !== currentSecondaryTribe;
          return differentEthnicity || differentSecondaryTribe;
        });
        console.log(`[ETHNICITY-DIVERSITY] Found ${ethnicityDiverseCandidates.length} candidates with different ethnic backgrounds`);
        return ethnicityDiverseCandidates.slice(0, 3);
      }
      /**
       * DEMOGRAPHIC DIVERSITY CATEGORY 3: EDUCATION LEVEL DIVERSITY
       * Mixes different education levels for broader perspectives
       */
      injectEducationDiversity(candidates, currentUser) {
        const currentEducation = currentUser.educationLevel;
        const educationDiverseCandidates = candidates.filter((candidate) => {
          return candidate.educationLevel && candidate.educationLevel !== currentEducation;
        });
        console.log(`[EDUCATION-DIVERSITY] Found ${educationDiverseCandidates.length} candidates with different education levels`);
        return educationDiverseCandidates.slice(0, 3);
      }
      /**
       * DEMOGRAPHIC DIVERSITY CATEGORY 4: PROFESSION CATEGORY MIXING
       * Introduces professional diversity across categories
       */
      injectProfessionDiversity(candidates, currentUser) {
        const currentProfession = currentUser.profession;
        const currentCategory = this.categorizeProfession(currentProfession || null);
        const professionDiverseCandidates = candidates.filter((candidate) => {
          if (!candidate.profession) return false;
          const candidateCategory = this.categorizeProfession(candidate.profession || null);
          return candidateCategory !== currentCategory;
        });
        console.log(`[PROFESSION-DIVERSITY] Found ${professionDiverseCandidates.length} candidates from different profession categories`);
        return professionDiverseCandidates.slice(0, 3);
      }
      /**
       * DEMOGRAPHIC DIVERSITY CATEGORY 5: GEOGRAPHIC DIVERSITY
       * Introduces location diversity beyond typical preferences
       */
      injectGeographicDiversity(candidates, currentUser) {
        const currentLocation = currentUser.location;
        const geographicDiverseCandidates = candidates.filter((candidate) => {
          return candidate.location && candidate.location !== currentLocation;
        });
        console.log(`[GEOGRAPHIC-DIVERSITY] Found ${geographicDiverseCandidates.length} candidates from different locations`);
        return geographicDiverseCandidates.slice(0, 3);
      }
      /**
       * Calculate comprehensive diversity score for a candidate
       */
      calculateDiversityScore(candidate, currentUser) {
        let diversityScore = 0;
        let factors = 0;
        if (candidate.dateOfBirth && currentUser.dateOfBirth) {
          const ageGap = Math.abs(this.calculateAge(candidate.dateOfBirth) - this.calculateAge(currentUser.dateOfBirth));
          diversityScore += Math.min(ageGap / 10, 0.3);
          factors++;
        }
        if (candidate.ethnicity !== currentUser.ethnicity) {
          diversityScore += 0.25;
          factors++;
        }
        if (candidate.educationLevel !== currentUser.educationLevel) {
          diversityScore += 0.2;
          factors++;
        }
        const currentProfessionCategory = this.categorizeProfession(currentUser.profession || null);
        const candidateProfessionCategory = this.categorizeProfession(candidate.profession || null);
        if (candidateProfessionCategory !== currentProfessionCategory) {
          diversityScore += 0.2;
          factors++;
        }
        if (candidate.location !== currentUser.location) {
          diversityScore += 0.15;
          factors++;
        }
        return factors > 0 ? Math.min(diversityScore / factors, 1) : 0.3;
      }
      /**
       * Categorize profession for diversity analysis
       */
      /**
       * Enhanced comprehensive profession categorization for global diversity
       * Covers wide range of careers from all walks of life worldwide
       */
      categorizeProfession(profession) {
        if (!profession) return "Other";
        const professionLower = profession.toLowerCase().trim();
        if (this.matchesProfessionKeywords(professionLower, [
          "author",
          "writer",
          "journalist",
          "blogger",
          "copywriter",
          "editor",
          "poet",
          "content creator",
          "artist",
          "painter",
          "sculptor",
          "illustrator",
          "graphic designer",
          "web designer",
          "interior designer",
          "fashion designer",
          "architect",
          "musician",
          "singer",
          "composer",
          "producer",
          "dj",
          "sound engineer",
          "audio",
          "photographer",
          "videographer",
          "filmmaker",
          "director",
          "cinematographer",
          "video editor",
          "actor",
          "actress",
          "performer",
          "dancer",
          "choreographer",
          "theater",
          "drama",
          "animator",
          "game designer",
          "ux designer",
          "ui designer",
          "creative director",
          "influencer"
        ])) {
          return "Creative & Arts";
        }
        if (this.matchesProfessionKeywords(professionLower, [
          "software engineer",
          "developer",
          "programmer",
          "coder",
          "full stack",
          "frontend",
          "backend",
          "data scientist",
          "data analyst",
          "machine learning",
          "ai engineer",
          "data engineer",
          "analyst",
          "cybersecurity",
          "security analyst",
          "network engineer",
          "system administrator",
          "devops",
          "mobile developer",
          "ios developer",
          "android developer",
          "web developer",
          "engineer",
          "mechanical engineer",
          "electrical engineer",
          "civil engineer",
          "chemical engineer",
          "aerospace engineer",
          "biomedical engineer",
          "environmental engineer",
          "industrial engineer",
          "it specialist",
          "tech support",
          "system analyst",
          "database administrator",
          "cloud engineer"
        ])) {
          return "Technology & Engineering";
        }
        if (this.matchesProfessionKeywords(professionLower, [
          "doctor",
          "physician",
          "surgeon",
          "specialist",
          "cardiologist",
          "neurologist",
          "pediatrician",
          "nurse",
          "registered nurse",
          "nurse practitioner",
          "nursing",
          "midwife",
          "dentist",
          "orthodontist",
          "dental hygienist",
          "oral surgeon",
          "pharmacist",
          "pharmacy technician",
          "pharmaceutical",
          "therapist",
          "physical therapist",
          "occupational therapist",
          "speech therapist",
          "psychologist",
          "psychiatrist",
          "medical technician",
          "radiologist",
          "lab technician",
          "medical assistant",
          "veterinarian",
          "vet tech",
          "animal doctor",
          "veterinary",
          "paramedic",
          "emt",
          "emergency medical",
          "first aid",
          "optometrist",
          "chiropractor",
          "nutritionist",
          "dietitian"
        ])) {
          return "Healthcare & Medical";
        }
        if (this.matchesProfessionKeywords(professionLower, [
          "manager",
          "director",
          "executive",
          "ceo",
          "cfo",
          "coo",
          "president",
          "vice president",
          "business analyst",
          "consultant",
          "strategy consultant",
          "management consultant",
          "entrepreneur",
          "founder",
          "startup",
          "business owner",
          "small business",
          "accountant",
          "bookkeeper",
          "financial analyst",
          "investment banker",
          "financial advisor",
          "banker",
          "loan officer",
          "credit analyst",
          "insurance agent",
          "real estate agent",
          "sales",
          "sales representative",
          "account manager",
          "business development",
          "marketing",
          "digital marketing",
          "marketing manager",
          "brand manager",
          "social media manager",
          "hr",
          "human resources",
          "recruiter",
          "talent acquisition",
          "hr manager",
          "project manager",
          "product manager",
          "operations manager",
          "general manager"
        ])) {
          return "Business & Finance";
        }
        if (this.matchesProfessionKeywords(professionLower, [
          "teacher",
          "educator",
          "instructor",
          "tutor",
          "professor",
          "lecturer",
          "principal",
          "school administrator",
          "academic",
          "researcher",
          "teaching assistant",
          "substitute teacher",
          "kindergarten teacher",
          "elementary teacher",
          "high school teacher",
          "college professor",
          "university professor",
          "librarian",
          "school counselor",
          "education coordinator",
          "scientist",
          "research scientist",
          "lab researcher",
          "research assistant",
          "curriculum developer",
          "instructional designer",
          "educational consultant"
        ])) {
          return "Education & Research";
        }
        if (this.matchesProfessionKeywords(professionLower, [
          "carpenter",
          "electrician",
          "plumber",
          "hvac technician",
          "mechanic",
          "auto mechanic",
          "construction worker",
          "builder",
          "contractor",
          "roofer",
          "painter",
          "welder",
          "machinist",
          "technician",
          "maintenance",
          "repair technician",
          "handyman",
          "truck driver",
          "delivery driver",
          "courier",
          "logistics",
          "warehouse worker",
          "factory worker",
          "manufacturing",
          "assembly line",
          "production worker",
          "chef",
          "cook",
          "baker",
          "culinary",
          "restaurant",
          "food service",
          "barber",
          "hairstylist",
          "beautician",
          "cosmetologist",
          "nail technician"
        ])) {
          return "Trades & Skilled Labor";
        }
        if (this.matchesProfessionKeywords(professionLower, [
          "athlete",
          "soccer player",
          "football player",
          "basketball player",
          "tennis player",
          "baseball player",
          "rugby player",
          "cricket player",
          "volleyball player",
          "coach",
          "sports coach",
          "fitness coach",
          "personal trainer",
          "gym instructor",
          "sports analyst",
          "sports journalist",
          "sports photographer",
          "sports medicine",
          "referee",
          "umpire",
          "sports official",
          "athletic trainer",
          "yoga instructor",
          "pilates instructor",
          "dance instructor",
          "martial arts instructor"
        ])) {
          return "Sports & Fitness";
        }
        if (this.matchesProfessionKeywords(professionLower, [
          "lawyer",
          "attorney",
          "legal counsel",
          "paralegal",
          "legal assistant",
          "judge",
          "police officer",
          "detective",
          "security guard",
          "law enforcement",
          "firefighter",
          "paramedic",
          "emergency services",
          "first responder",
          "government",
          "civil servant",
          "public administrator",
          "diplomat",
          "politician",
          "social worker",
          "case worker",
          "community organizer",
          "nonprofit",
          "military",
          "soldier",
          "navy",
          "air force",
          "marine",
          "veteran"
        ])) {
          return "Law & Public Service";
        }
        if (this.matchesProfessionKeywords(professionLower, [
          "hotel manager",
          "hospitality",
          "tourism",
          "travel agent",
          "tour guide",
          "flight attendant",
          "pilot",
          "airline",
          "cruise",
          "resort",
          "restaurant manager",
          "waiter",
          "waitress",
          "server",
          "bartender",
          "event planner",
          "wedding planner",
          "catering"
        ])) {
          return "Hospitality & Tourism";
        }
        if (this.matchesProfessionKeywords(professionLower, [
          "retail",
          "sales associate",
          "cashier",
          "store manager",
          "customer service",
          "call center",
          "support representative",
          "shop assistant",
          "merchandiser"
        ])) {
          return "Retail & Customer Service";
        }
        return "Other";
      }
      /**
       * Helper method to match profession keywords efficiently
       */
      matchesProfessionKeywords(profession, keywords) {
        return keywords.some((keyword) => profession.includes(keyword));
      }
      /**
       * Legacy diversity injection method (keeping for backwards compatibility)
       */
      injectDiversity(rankedCandidates, allCandidates, diversityPercentage = 0.15) {
        console.log(`[DIVERSITY] Using legacy diversity injection (${diversityPercentage * 100}%)`);
        const totalResults = rankedCandidates.length;
        const diversityCount = Math.floor(totalResults * diversityPercentage);
        if (diversityCount === 0 || allCandidates.length <= rankedCandidates.length) {
          return rankedCandidates;
        }
        const topCandidateIds = new Set(rankedCandidates.map((r) => r.userId));
        const diversityCandidates = allCandidates.filter((c) => !topCandidateIds.has(c.id)).slice(0, diversityCount * 2);
        const diverseResults = [];
        for (let i = 0; i < Math.min(diversityCount, diversityCandidates.length); i++) {
          const candidate = diversityCandidates[i];
          diverseResults.push({
            userId: candidate.id,
            contentScore: 0.4,
            collaborativeScore: 0.3,
            contextScore: 0.5,
            diversityBonus: 0.3,
            reciprocityScore: 0.5,
            finalScore: 0.6,
            algorithmVersion: "advanced-v1.0-basic-diversity",
            reasons: ["Basic diversity", "Serendipitous match"]
          });
        }
        const result = [...rankedCandidates];
        const injectionInterval = Math.floor(totalResults / diversityCount);
        for (let i = 0; i < diverseResults.length; i++) {
          const insertPosition = (i + 1) * injectionInterval;
          if (insertPosition < result.length) {
            result.splice(insertPosition + i, 0, diverseResults[i]);
          } else {
            result.push(diverseResults[i]);
          }
        }
        return result;
      }
      /**
       * Cosine similarity calculation for user vectors
       */
      calculateCosineSimilarity(vector1, vector2) {
        try {
          const v1 = [
            vector1.ageNormalized,
            vector1.heightCompatibility || 0.5,
            // NEW: Height compatibility
            vector1.profileCompleteness,
            vector1.activityScore,
            ...vector1.locationVector,
            ...vector1.interestVector
          ];
          const v2 = [
            vector2.ageNormalized,
            vector2.heightCompatibility || 0.5,
            // NEW: Height compatibility
            vector2.profileCompleteness,
            vector2.activityScore,
            ...vector2.locationVector,
            ...vector2.interestVector
          ];
          const maxLength = Math.max(v1.length, v2.length);
          while (v1.length < maxLength) v1.push(0);
          while (v2.length < maxLength) v2.push(0);
          let dotProduct = 0;
          let norm1 = 0;
          let norm2 = 0;
          for (let i = 0; i < maxLength; i++) {
            dotProduct += v1[i] * v2[i];
            norm1 += v1[i] * v1[i];
            norm2 += v2[i] * v2[i];
          }
          const denominator = Math.sqrt(norm1) * Math.sqrt(norm2);
          return denominator === 0 ? 0 : dotProduct / denominator;
        } catch (error) {
          console.error("[COSINE-SIMILARITY] Error:", error);
          return 0;
        }
      }
      /**
       * Enhanced TF-IDF similarity for comprehensive textual content analysis
       * Includes: bio, profession, interests (parsed), relationshipGoal, education fields
       */
      calculateTFIDFSimilarity(user1, user2) {
        try {
          console.log(`[TFIDF-SIMILARITY] Analyzing textual content for user ${user1.id} vs user ${user2.id}`);
          const text1 = this.createEnhancedTextualContent(user1);
          const text2 = this.createEnhancedTextualContent(user2);
          console.log(`[TFIDF-SIMILARITY] User ${user1.id} content length: ${text1.length} characters`);
          console.log(`[TFIDF-SIMILARITY] User ${user2.id} content length: ${text2.length} characters`);
          if (!text1.trim() || !text2.trim()) {
            console.log("[TFIDF-SIMILARITY] Empty text content, returning 0");
            return 0;
          }
          const tokens1 = this.tokenize(text1);
          const tokens2 = this.tokenize(text2);
          console.log(`[TFIDF-SIMILARITY] User ${user1.id} tokens: ${tokens1.length}, User ${user2.id} tokens: ${tokens2.length}`);
          const allTokens = /* @__PURE__ */ new Set([...tokens1, ...tokens2]);
          const vector1 = [];
          const vector2 = [];
          let commonTokens = 0;
          for (const token of allTokens) {
            const tf1 = this.calculateTF(token, tokens1);
            const tf2 = this.calculateTF(token, tokens2);
            const documentsWithTerm = (tf1 > 0 ? 1 : 0) + (tf2 > 0 ? 1 : 0);
            const idf = Math.log(2 / (1 + documentsWithTerm));
            vector1.push(tf1 * idf);
            vector2.push(tf2 * idf);
            if (tf1 > 0 && tf2 > 0) commonTokens++;
          }
          const similarity = this.calculateVectorCosineSimilarity(vector1, vector2);
          console.log(`[TFIDF-SIMILARITY] Common tokens: ${commonTokens}/${allTokens.size}, Final similarity: ${similarity.toFixed(4)}`);
          return similarity;
        } catch (error) {
          console.error("[TFIDF-SIMILARITY] Error:", error);
          return 0;
        }
      }
      /**
       * Create enhanced textual content combining all available fields
       */
      createEnhancedTextualContent(user) {
        const contentParts = [];
        if (user.bio?.trim()) {
          contentParts.push(user.bio.trim());
        }
        if (user.profession?.trim()) {
          contentParts.push(user.profession.trim());
        }
        if (user.interests?.trim()) {
          try {
            const interestsArray = JSON.parse(user.interests);
            if (Array.isArray(interestsArray)) {
              contentParts.push(interestsArray.join(" "));
            } else {
              contentParts.push(user.interests.trim());
            }
          } catch (e) {
            contentParts.push(user.interests.trim());
          }
        }
        if (user.relationshipGoal?.trim()) {
          contentParts.push(user.relationshipGoal.trim());
        }
        if (user.highSchool?.trim()) {
          contentParts.push(user.highSchool.trim());
        }
        if (user.collegeUniversity?.trim()) {
          contentParts.push(user.collegeUniversity.trim());
        }
        const combinedContent = contentParts.join(" ").toLowerCase();
        console.log(`[TFIDF-CONTENT] User ${user.id} enhanced content: "${combinedContent.substring(0, 100)}${combinedContent.length > 100 ? "..." : ""}"`);
        return combinedContent;
      }
      /**
       * Create comprehensive user vector for mathematical operations
       */
      createUserVector(user, preferences) {
        const ageNormalized = user.dateOfBirth ? Math.min((this.calculateAge(user.dateOfBirth) - 18) / 62, 1) : 0.5;
        const heightCompatibility = this.calculateHeightCompatibility(user, preferences);
        const locationVector = this.createLocationVector(user.location);
        const interestVector = this.createInterestVector(user.interests);
        const religionVector = this.createCategoricalVector(user.religion, ["Christian", "Muslim", "Traditional", "Other"]);
        const ethnicityVector = this.createCategoricalVector(user.ethnicity, ["Akan", "Ewe", "Ga", "Dagbani", "Other"]);
        return {
          userId: user.id,
          ageNormalized,
          heightCompatibility,
          // NEW: Added height compatibility score
          locationVector,
          interestVector,
          religionVector,
          ethnicityVector,
          profileCompleteness: this.calculateProfileCompleteness(user),
          activityScore: user.isOnline ? 1 : user.lastActive ? 0.5 : 0.1
        };
      }
      /**
       * Helper methods
       */
      calculateAge(dateOfBirth) {
        const today = /* @__PURE__ */ new Date();
        let age = today.getFullYear() - dateOfBirth.getFullYear();
        const monthDiff = today.getMonth() - dateOfBirth.getMonth();
        if (monthDiff < 0 || monthDiff === 0 && today.getDate() < dateOfBirth.getDate()) {
          age--;
        }
        return age;
      }
      calculateProfileCompleteness(user) {
        const fields = [
          user.bio,
          user.profession,
          user.interests,
          user.photoUrl,
          user.religion,
          user.ethnicity,
          user.dateOfBirth,
          user.relationshipGoal
        ];
        const completedFields = fields.filter((field) => field && field.toString().trim().length > 0);
        return completedFields.length / fields.length;
      }
      /**
       * Calculate height compatibility score between user and preferences
       */
      calculateHeightCompatibility(candidate, preferences) {
        if (!preferences || !candidate.height) return 0.5;
        const { minHeightPreference, maxHeightPreference } = preferences;
        if (!minHeightPreference && !maxHeightPreference) return 0.5;
        const candidateHeight = candidate.height;
        if (minHeightPreference && maxHeightPreference) {
          if (candidateHeight >= minHeightPreference && candidateHeight <= maxHeightPreference) {
            return 1;
          }
          const minDistance = Math.max(0, minHeightPreference - candidateHeight);
          const maxDistance = Math.max(0, candidateHeight - maxHeightPreference);
          const totalDistance = minDistance + maxDistance;
          return Math.max(0, 1 - totalDistance / 20);
        }
        if (minHeightPreference && !maxHeightPreference) {
          return candidateHeight >= minHeightPreference ? 1 : Math.max(0, 1 - (minHeightPreference - candidateHeight) / 20);
        }
        if (!minHeightPreference && maxHeightPreference) {
          return candidateHeight <= maxHeightPreference ? 1 : Math.max(0, 1 - (candidateHeight - maxHeightPreference) / 20);
        }
        return 0.5;
      }
      createLocationVector(location) {
        const locations = ["Ghana", "Diaspora", "Other"];
        return locations.map((loc) => location === loc ? 1 : 0);
      }
      createInterestVector(interests) {
        if (!interests) return new Array(20).fill(0);
        try {
          const userInterests3 = JSON.parse(interests);
          const commonInterests = [
            "music",
            "sports",
            "travel",
            "food",
            "movies",
            "reading",
            "fitness",
            "art",
            "technology",
            "cooking",
            "dancing",
            "gaming",
            "fashion",
            "photography",
            "hiking",
            "swimming",
            "business",
            "education",
            "politics",
            "religion"
          ];
          return commonInterests.map(
            (interest) => userInterests3.some((ui) => ui.toLowerCase().includes(interest)) ? 1 : 0
          );
        } catch {
          return new Array(20).fill(0);
        }
      }
      createCategoricalVector(category, categories) {
        return categories.map((cat) => category === cat ? 1 : 0);
      }
      /**
       * COMPREHENSIVE JACCARD SIMILARITY ALGORITHM FOR CATEGORICAL FEATURES
       * Implements all 8 categorical features identified in the technical audit:
       * 1. ethnicity + secondaryTribe vs ethnicityPreference
       * 2. religion vs religionPreference  
       * 3. bodyType vs bodyTypePreference
       * 4. educationLevel vs educationLevelPreference
       * 5. hasChildren vs hasChildrenPreference
       * 6. wantsChildren vs wantsChildrenPreference
       * 7. relationshipGoal vs relationshipGoalPreference (text-based)
       * 8. location/countryOfOrigin vs locationPreference/poolCountry
       */
      calculateJaccardSimilarity(user1, user2, user1Preferences, user2Preferences) {
        try {
          console.log(`[JACCARD-SIMILARITY] Analyzing user ${user1.id} vs user ${user2.id}`);
          const features = [];
          const ethnicityScore = this.calculateEthnicityJaccard(user1, user2, user1Preferences, user2Preferences);
          features.push({ name: "ethnicity", score: ethnicityScore, weight: 0.15 });
          const religionScore = this.calculateReligionJaccard(user1, user2, user1Preferences, user2Preferences);
          features.push({ name: "religion", score: religionScore, weight: 0.2 });
          const bodyTypeScore = this.calculateBodyTypeJaccard(user1, user2, user1Preferences, user2Preferences);
          features.push({ name: "bodyType", score: bodyTypeScore, weight: 0.1 });
          const educationScore = this.calculateEducationJaccard(user1, user2, user1Preferences, user2Preferences);
          features.push({ name: "education", score: educationScore, weight: 0.15 });
          const hasChildrenScore = this.calculateChildrenJaccard(user1, user2, "has", user1Preferences, user2Preferences);
          features.push({ name: "hasChildren", score: hasChildrenScore, weight: 0.15 });
          const wantsChildrenScore = this.calculateChildrenJaccard(user1, user2, "wants", user1Preferences, user2Preferences);
          features.push({ name: "wantsChildren", score: wantsChildrenScore, weight: 0.15 });
          const relationshipGoalScore = this.calculateRelationshipGoalJaccard(user1, user2, user1Preferences, user2Preferences);
          features.push({ name: "relationshipGoal", score: relationshipGoalScore, weight: 0.1 });
          const locationScore = this.calculateLocationJaccard(user1, user2, user1Preferences, user2Preferences);
          features.push({ name: "location", score: locationScore, weight: 0.1 });
          const totalWeight = features.reduce((sum, f) => sum + f.weight, 0);
          const weightedSum = features.reduce((sum, f) => sum + f.score * f.weight, 0);
          const finalScore = totalWeight > 0 ? weightedSum / totalWeight : 0.5;
          console.log(`[JACCARD-SIMILARITY] Final score: ${finalScore.toFixed(4)}`);
          features.forEach((f) => console.log(`  ${f.name}: ${f.score.toFixed(3)} (weight: ${f.weight})`));
          return Math.min(Math.max(finalScore, 0), 1);
        } catch (error) {
          console.error("[JACCARD-SIMILARITY] Error:", error);
          return 0.5;
        }
      }
      /**
       * FEATURE 1: Ethnicity + Secondary Tribe Jaccard Similarity
       */
      calculateEthnicityJaccard(user1, user2, user1Prefs, user2Prefs) {
        try {
          const user1Ethnicities = /* @__PURE__ */ new Set();
          if (user1.ethnicity) user1Ethnicities.add(user1.ethnicity);
          if (user1.secondaryTribe) user1Ethnicities.add(user1.secondaryTribe);
          const user2Ethnicities = /* @__PURE__ */ new Set();
          if (user2.ethnicity) user2Ethnicities.add(user2.ethnicity);
          if (user2.secondaryTribe) user2Ethnicities.add(user2.secondaryTribe);
          let user1EthnicityPrefs = /* @__PURE__ */ new Set();
          let user2EthnicityPrefs = /* @__PURE__ */ new Set();
          try {
            if (user1Prefs?.ethnicityPreference) {
              const prefs = JSON.parse(user1Prefs.ethnicityPreference);
              user1EthnicityPrefs = new Set(Array.isArray(prefs) ? prefs : []);
            }
            if (user2Prefs?.ethnicityPreference) {
              const prefs = JSON.parse(user2Prefs.ethnicityPreference);
              user2EthnicityPrefs = new Set(Array.isArray(prefs) ? prefs : []);
            }
          } catch (e) {
            console.log("[JACCARD-ETHNICITY] JSON parse error for preferences");
          }
          if (user1Ethnicities.size === 0 && user2Ethnicities.size === 0) {
            return 0.5;
          }
          let score1 = 0.5;
          let score2 = 0.5;
          if (user2EthnicityPrefs.size > 0 && user1Ethnicities.size > 0) {
            const intersection1 = [...user1Ethnicities].filter((e) => user2EthnicityPrefs.has(e));
            score1 = intersection1.length > 0 ? 1 : 0;
          }
          if (user1EthnicityPrefs.size > 0 && user2Ethnicities.size > 0) {
            const intersection2 = [...user2Ethnicities].filter((e) => user1EthnicityPrefs.has(e));
            score2 = intersection2.length > 0 ? 1 : 0;
          }
          return (score1 + score2) / 2;
        } catch (error) {
          console.error("[JACCARD-ETHNICITY] Error:", error);
          return 0.5;
        }
      }
      /**
       * FEATURE 2: Religion Jaccard Similarity
       */
      calculateReligionJaccard(user1, user2, user1Prefs, user2Prefs) {
        try {
          const user1Religion = user1.religion;
          const user2Religion = user2.religion;
          if (!user1Religion || !user2Religion) return 0.5;
          let user1ReligionPrefs = /* @__PURE__ */ new Set();
          let user2ReligionPrefs = /* @__PURE__ */ new Set();
          try {
            if (user1Prefs?.religionPreference) {
              const prefs = JSON.parse(user1Prefs.religionPreference);
              user1ReligionPrefs = new Set(Array.isArray(prefs) ? prefs : []);
            }
            if (user2Prefs?.religionPreference) {
              const prefs = JSON.parse(user2Prefs.religionPreference);
              user2ReligionPrefs = new Set(Array.isArray(prefs) ? prefs : []);
            }
          } catch (e) {
            console.log("[JACCARD-RELIGION] JSON parse error for preferences");
          }
          let score1 = 0.5;
          let score2 = 0.5;
          if (user2ReligionPrefs.size > 0) {
            score1 = user2ReligionPrefs.has(user1Religion) ? 1 : 0;
          }
          if (user1ReligionPrefs.size > 0) {
            score2 = user1ReligionPrefs.has(user2Religion) ? 1 : 0;
          }
          return (score1 + score2) / 2;
        } catch (error) {
          console.error("[JACCARD-RELIGION] Error:", error);
          return 0.5;
        }
      }
      /**
       * FEATURE 3: Body Type Jaccard Similarity
       */
      calculateBodyTypeJaccard(user1, user2, user1Prefs, user2Prefs) {
        try {
          const user1BodyType = user1.bodyType;
          const user2BodyType = user2.bodyType;
          if (!user1BodyType || !user2BodyType) return 0.5;
          let user1BodyTypePrefs = /* @__PURE__ */ new Set();
          let user2BodyTypePrefs = /* @__PURE__ */ new Set();
          try {
            if (user1Prefs?.bodyTypePreference) {
              const prefs = JSON.parse(user1Prefs.bodyTypePreference);
              user1BodyTypePrefs = new Set(Array.isArray(prefs) ? prefs : []);
            }
            if (user2Prefs?.bodyTypePreference) {
              const prefs = JSON.parse(user2Prefs.bodyTypePreference);
              user2BodyTypePrefs = new Set(Array.isArray(prefs) ? prefs : []);
            }
          } catch (e) {
            console.log("[JACCARD-BODYTYPE] JSON parse error for preferences");
          }
          let score1 = 0.5;
          let score2 = 0.5;
          if (user2BodyTypePrefs.size > 0) {
            score1 = user2BodyTypePrefs.has(user1BodyType) ? 1 : 0;
          }
          if (user1BodyTypePrefs.size > 0) {
            score2 = user1BodyTypePrefs.has(user2BodyType) ? 1 : 0;
          }
          return (score1 + score2) / 2;
        } catch (error) {
          console.error("[JACCARD-BODYTYPE] Error:", error);
          return 0.5;
        }
      }
      /**
       * FEATURE 4: Education Level Jaccard Similarity
       */
      calculateEducationJaccard(user1, user2, user1Prefs, user2Prefs) {
        try {
          const user1Education = user1.educationLevel;
          const user2Education = user2.educationLevel;
          if (!user1Education || !user2Education) return 0.5;
          let user1EducationPrefs = /* @__PURE__ */ new Set();
          let user2EducationPrefs = /* @__PURE__ */ new Set();
          try {
            if (user1Prefs?.educationLevelPreference) {
              const prefs = JSON.parse(user1Prefs.educationLevelPreference);
              user1EducationPrefs = new Set(Array.isArray(prefs) ? prefs : []);
            }
            if (user2Prefs?.educationLevelPreference) {
              const prefs = JSON.parse(user2Prefs.educationLevelPreference);
              user2EducationPrefs = new Set(Array.isArray(prefs) ? prefs : []);
            }
          } catch (e) {
            console.log("[JACCARD-EDUCATION] JSON parse error for preferences");
          }
          let score1 = 0.5;
          let score2 = 0.5;
          if (user2EducationPrefs.size > 0) {
            score1 = user2EducationPrefs.has(user1Education) ? 1 : 0;
          }
          if (user1EducationPrefs.size > 0) {
            score2 = user1EducationPrefs.has(user2Education) ? 1 : 0;
          }
          return (score1 + score2) / 2;
        } catch (error) {
          console.error("[JACCARD-EDUCATION] Error:", error);
          return 0.5;
        }
      }
      /**
       * FEATURE 5 & 6: Children Jaccard Similarity (has/wants)
       */
      calculateChildrenJaccard(user1, user2, type, user1Prefs, user2Prefs) {
        try {
          const user1Children = type === "has" ? user1.hasChildren : user1.wantsChildren;
          const user2Children = type === "has" ? user2.hasChildren : user2.wantsChildren;
          if (!user1Children || !user2Children) return 0.5;
          const user1ChildrenPref = type === "has" ? user1Prefs?.hasChildrenPreference : user1Prefs?.wantsChildrenPreference;
          const user2ChildrenPref = type === "has" ? user2Prefs?.hasChildrenPreference : user2Prefs?.wantsChildrenPreference;
          const convertPref = (pref) => {
            if (pref === "true" || pref === true) return "yes";
            if (pref === "false" || pref === false) return "no";
            if (pref === "any") return "any";
            return null;
          };
          const user1PrefConverted = convertPref(user1ChildrenPref);
          const user2PrefConverted = convertPref(user2ChildrenPref);
          let score1 = 0.5;
          let score2 = 0.5;
          if (user2PrefConverted) {
            if (user2PrefConverted === "any") {
              score1 = 1;
            } else {
              score1 = user1Children === user2PrefConverted ? 1 : 0;
            }
          }
          if (user1PrefConverted) {
            if (user1PrefConverted === "any") {
              score2 = 1;
            } else {
              score2 = user2Children === user1PrefConverted ? 1 : 0;
            }
          }
          return (score1 + score2) / 2;
        } catch (error) {
          console.error(`[JACCARD-CHILDREN-${type.toUpperCase()}] Error:`, error);
          return 0.5;
        }
      }
      /**
       * FEATURE 7: Relationship Goal Jaccard Similarity (text-based)
       */
      calculateRelationshipGoalJaccard(user1, user2, user1Prefs, user2Prefs) {
        try {
          const user1Goal = user1.relationshipGoal;
          const user2Goal = user2.relationshipGoal;
          const user1GoalPref = user1Prefs?.relationshipGoalPreference;
          const user2GoalPref = user2Prefs?.relationshipGoalPreference;
          if (!user1Goal || !user2Goal) return 0.5;
          const tokenize = (text2) => {
            return new Set(text2.toLowerCase().replace(/[^\w\s]/g, " ").split(/\s+/).filter((token) => token.length > 2));
          };
          const user1GoalTokens = tokenize(user1Goal);
          const user2GoalTokens = tokenize(user2Goal);
          let user1PrefTokens = /* @__PURE__ */ new Set();
          let user2PrefTokens = /* @__PURE__ */ new Set();
          if (user1GoalPref) user1PrefTokens = tokenize(user1GoalPref);
          if (user2GoalPref) user2PrefTokens = tokenize(user2GoalPref);
          let score1 = 0.5;
          let score2 = 0.5;
          if (user2PrefTokens.size > 0) {
            const intersection1 = [...user1GoalTokens].filter((token) => user2PrefTokens.has(token));
            const union1 = /* @__PURE__ */ new Set([...user1GoalTokens, ...user2PrefTokens]);
            score1 = union1.size > 0 ? intersection1.length / union1.size : 0;
          }
          if (user1PrefTokens.size > 0) {
            const intersection2 = [...user2GoalTokens].filter((token) => user1PrefTokens.has(token));
            const union2 = /* @__PURE__ */ new Set([...user2GoalTokens, ...user1PrefTokens]);
            score2 = union2.size > 0 ? intersection2.length / union2.size : 0;
          }
          return (score1 + score2) / 2;
        } catch (error) {
          console.error("[JACCARD-RELATIONSHIP-GOAL] Error:", error);
          return 0.5;
        }
      }
      /**
       * FEATURE 8: Enhanced Location/Country of Origin Cultural Alignment
       * Now includes comprehensive cultural distance calculations and country-of-origin similarity
       */
      calculateLocationJaccard(user1, user2, user1Prefs, user2Prefs) {
        try {
          console.log(`[CULTURAL-ALIGNMENT] Analyzing cultural compatibility for user ${user1.id} vs user ${user2.id}`);
          const extractCountry = (location) => {
            const locationLower = location.toLowerCase();
            if (locationLower.includes("usa") || locationLower.includes("united states") || locationLower.includes("america")) return "USA";
            if (locationLower.includes("spain")) return "Spain";
            if (locationLower.includes("ghana")) return "Ghana";
            if (locationLower.includes("germany")) return "Germany";
            if (locationLower.includes("nigeria")) return "Nigeria";
            if (locationLower.includes("uk") || locationLower.includes("united kingdom") || locationLower.includes("england")) return "UK";
            if (locationLower.includes("canada")) return "Canada";
            if (locationLower.includes("france")) return "France";
            if (locationLower.includes("italy")) return "Italy";
            if (locationLower.includes("netherlands")) return "Netherlands";
            return location;
          };
          const user1Location = user1.location ? extractCountry(user1.location) : null;
          const user2Location = user2.location ? extractCountry(user2.location) : null;
          const user1Country = user1.countryOfOrigin;
          const user2Country = user2.countryOfOrigin;
          const user1SecondaryCountry = user1.secondaryCountryOfOrigin;
          const user2SecondaryCountry = user2.secondaryCountryOfOrigin;
          const user1PoolCountry = user1Prefs?.poolCountry;
          const user2PoolCountry = user2Prefs?.poolCountry;
          console.log(`[CULTURAL-ALIGNMENT] User ${user1.id}: Location=${user1Location}, Origin=${user1Country}, Secondary=${user1SecondaryCountry}, PoolPref=${user1PoolCountry}`);
          console.log(`[CULTURAL-ALIGNMENT] User ${user2.id}: Location=${user2Location}, Origin=${user2Country}, Secondary=${user2SecondaryCountry}, PoolPref=${user2PoolCountry}`);
          const user1CulturalIdentities = /* @__PURE__ */ new Set();
          if (user1Location) user1CulturalIdentities.add(user1Location);
          if (user1Country) user1CulturalIdentities.add(user1Country);
          if (user1SecondaryCountry) user1CulturalIdentities.add(user1SecondaryCountry);
          const user2CulturalIdentities = /* @__PURE__ */ new Set();
          if (user2Location) user2CulturalIdentities.add(user2Location);
          if (user2Country) user2CulturalIdentities.add(user2Country);
          if (user2SecondaryCountry) user2CulturalIdentities.add(user2SecondaryCountry);
          if (user1CulturalIdentities.size === 0 || user2CulturalIdentities.size === 0) {
            console.log("[CULTURAL-ALIGNMENT] Insufficient cultural data, returning neutral score");
            return 0.5;
          }
          let totalScore = 0;
          let componentCount = 0;
          const locationScore = this.calculateLocationPreferenceScore(user1CulturalIdentities, user2CulturalIdentities, user1PoolCountry || void 0, user2PoolCountry || void 0);
          totalScore += locationScore * 0.4;
          componentCount++;
          console.log(`[CULTURAL-ALIGNMENT] Location preference score: ${locationScore.toFixed(3)} (weight: 0.4)`);
          const originScore = this.calculateCountryOfOriginScore(user1Country || void 0, user2Country || void 0, user1SecondaryCountry || void 0, user2SecondaryCountry || void 0);
          totalScore += originScore * 0.35;
          componentCount++;
          console.log(`[CULTURAL-ALIGNMENT] Country of origin score: ${originScore.toFixed(3)} (weight: 0.35)`);
          const culturalDistanceScore = this.calculateCulturalDistance(user1CulturalIdentities, user2CulturalIdentities);
          totalScore += culturalDistanceScore * 0.25;
          componentCount++;
          console.log(`[CULTURAL-ALIGNMENT] Cultural distance score: ${culturalDistanceScore.toFixed(3)} (weight: 0.25)`);
          const finalScore = componentCount > 0 ? totalScore : 0.5;
          console.log(`[CULTURAL-ALIGNMENT] Final cultural alignment score: ${finalScore.toFixed(3)}`);
          return Math.min(Math.max(finalScore, 0), 1);
        } catch (error) {
          console.error("[CULTURAL-ALIGNMENT] Error:", error);
          return 0.5;
        }
      }
      /**
       * Calculate location preference scoring based on pool country preferences
       */
      calculateLocationPreferenceScore(user1Identities, user2Identities, user1PoolCountry, user2PoolCountry) {
        try {
          let score1 = 0.5;
          let score2 = 0.5;
          if (user2PoolCountry) {
            if (user2PoolCountry === "ANYWHERE") {
              score1 = 1;
            } else {
              score1 = [...user1Identities].some(
                (identity) => identity.toLowerCase().includes(user2PoolCountry.toLowerCase()) || user2PoolCountry.toLowerCase().includes(identity.toLowerCase())
              ) ? 1 : 0.3;
            }
          }
          if (user1PoolCountry) {
            if (user1PoolCountry === "ANYWHERE") {
              score2 = 1;
            } else {
              score2 = [...user2Identities].some(
                (identity) => identity.toLowerCase().includes(user1PoolCountry.toLowerCase()) || user1PoolCountry.toLowerCase().includes(identity.toLowerCase())
              ) ? 1 : 0.3;
            }
          }
          return (score1 + score2) / 2;
        } catch (error) {
          console.error("[LOCATION-PREFERENCE] Error:", error);
          return 0.5;
        }
      }
      /**
       * Calculate country of origin similarity with multi-cultural background bonus
       */
      calculateCountryOfOriginScore(user1Country, user2Country, user1SecondaryCountry, user2SecondaryCountry) {
        try {
          if (!user1Country && !user2Country) return 0.5;
          if (!user1Country || !user2Country) return 0.3;
          const user1Origins = /* @__PURE__ */ new Set();
          if (user1Country) user1Origins.add(user1Country.toLowerCase());
          if (user1SecondaryCountry) user1Origins.add(user1SecondaryCountry.toLowerCase());
          const user2Origins = /* @__PURE__ */ new Set();
          if (user2Country) user2Origins.add(user2Country.toLowerCase());
          if (user2SecondaryCountry) user2Origins.add(user2SecondaryCountry.toLowerCase());
          const intersection = [...user1Origins].filter((origin) => user2Origins.has(origin));
          const union = /* @__PURE__ */ new Set([...user1Origins, ...user2Origins]);
          if (intersection.length === 0) {
            return this.calculateRegionalCulturalSimilarity(user1Origins, user2Origins);
          }
          let score = intersection.length / union.size;
          if (user1SecondaryCountry && user2SecondaryCountry) {
            score += 0.1;
          }
          return Math.min(score, 1);
        } catch (error) {
          console.error("[COUNTRY-ORIGIN] Error:", error);
          return 0.5;
        }
      }
      /**
       * Calculate regional cultural similarity for non-matching countries
       */
      calculateRegionalCulturalSimilarity(user1Origins, user2Origins) {
        try {
          const culturalClusters = {
            // West African cultural cluster
            westAfrica: {
              countries: ["nigeria", "ghana", "senegal", "ivory coast", "burkina faso", "togo", "benin"],
              similarity: 0.7
            },
            // European cultural cluster  
            europe: {
              countries: ["germany", "france", "spain", "italy", "netherlands", "uk", "belgium"],
              similarity: 0.5
            },
            // North American cultural cluster
            northAmerica: {
              countries: ["usa", "canada"],
              similarity: 0.8
            },
            // Former British colonies (shared colonial history)
            britishColonies: {
              countries: ["nigeria", "ghana", "uk", "usa", "canada", "australia"],
              similarity: 0.4
            },
            // French-influenced regions
            francophone: {
              countries: ["france", "ivory coast", "senegal", "burkina faso", "canada"],
              similarity: 0.4
            }
          };
          let maxSimilarity = 0;
          for (const cluster of Object.values(culturalClusters)) {
            const user1Match = [...user1Origins].some(
              (origin) => cluster.countries.some((country) => origin.includes(country) || country.includes(origin))
            );
            const user2Match = [...user2Origins].some(
              (origin) => cluster.countries.some((country) => origin.includes(country) || country.includes(origin))
            );
            if (user1Match && user2Match) {
              maxSimilarity = Math.max(maxSimilarity, cluster.similarity);
            }
          }
          return maxSimilarity;
        } catch (error) {
          console.error("[REGIONAL-CULTURAL] Error:", error);
          return 0.2;
        }
      }
      /**
       * Calculate cultural distance based on comprehensive cultural identities
       */
      calculateCulturalDistance(user1Identities, user2Identities) {
        try {
          const intersection = [...user1Identities].filter(
            (identity) => [...user2Identities].some(
              (otherIdentity) => identity.toLowerCase() === otherIdentity.toLowerCase() || identity.toLowerCase().includes(otherIdentity.toLowerCase()) || otherIdentity.toLowerCase().includes(identity.toLowerCase())
            )
          );
          const union = /* @__PURE__ */ new Set([...user1Identities, ...user2Identities]);
          if (intersection.length === 0) return 0.2;
          const jaccardScore = intersection.length / union.size;
          const dataRichnessBonus = Math.min((user1Identities.size + user2Identities.size) / 10, 0.1);
          return Math.min(jaccardScore + dataRichnessBonus, 1);
        } catch (error) {
          console.error("[CULTURAL-DISTANCE] Error:", error);
          return 0.5;
        }
      }
      /**
       * Create comprehensive location sets for cultural analysis
       */
      createUserCulturalIdentities(user) {
        const identities = /* @__PURE__ */ new Set();
        if (user.location) {
          const locationLower = user.location.toLowerCase();
          if (locationLower.includes("usa") || locationLower.includes("united states")) identities.add("USA");
          else if (locationLower.includes("spain")) identities.add("Spain");
          else if (locationLower.includes("ghana")) identities.add("Ghana");
          else if (locationLower.includes("germany")) identities.add("Germany");
          else if (locationLower.includes("nigeria")) identities.add("Nigeria");
          else identities.add(user.location);
        }
        if (user.countryOfOrigin) identities.add(user.countryOfOrigin);
        if (user.secondaryCountryOfOrigin) identities.add(user.secondaryCountryOfOrigin);
        return identities;
      }
      /**
       * FACTOR 3: Distance Calculations - Comprehensive distance-based compatibility scoring
       * 
       * Calculates compatibility based on geographic distance between users and their distance preferences.
       * Uses Haversine formula for accurate distance calculations and provides weighted scoring.
       */
      async calculateDistanceCompatibility(user, candidate, userPreferences3) {
        try {
          console.log(`[DISTANCE-COMPATIBILITY] Analyzing distance between user ${user.id} and candidate ${candidate.id}`);
          const userLocation = user.location;
          const candidateLocation = candidate.location;
          if (!userLocation || !candidateLocation) {
            console.log(`[DISTANCE-COMPATIBILITY] Missing location data - user: ${!!userLocation}, candidate: ${!!candidateLocation}`);
            return 0.5;
          }
          const maxDistanceKm = userPreferences3?.distancePreference || 100;
          console.log(`[DISTANCE-COMPATIBILITY] User ${user.id} distance preference: ${maxDistanceKm}km`);
          const compatibilityResult = await geocodingService.analyzeLocationCompatibility(
            userLocation,
            candidateLocation,
            maxDistanceKm
          );
          console.log(`[DISTANCE-COMPATIBILITY] Distance analysis: ${compatibilityResult.distance}km, score: ${compatibilityResult.score.toFixed(3)}, confidence: ${compatibilityResult.confidence.toFixed(3)}`);
          console.log(`[DISTANCE-COMPATIBILITY] Analysis: ${compatibilityResult.analysis}`);
          const finalScore = compatibilityResult.score;
          console.log(`[DISTANCE-COMPATIBILITY] Final distance compatibility score: ${finalScore.toFixed(3)}`);
          return Math.min(Math.max(finalScore, 0), 1);
        } catch (error) {
          console.error("[DISTANCE-COMPATIBILITY] Error calculating distance compatibility:", error);
          return 0.5;
        }
      }
      /**
       * Enhanced preference alignment considering user's matching priorities with weighted importance
       */
      calculatePreferenceAlignment(candidate, preferences) {
        if (!preferences) return 0.5;
        let userPriorities = [];
        try {
          if (preferences.matchingPriorities) {
            userPriorities = JSON.parse(preferences.matchingPriorities);
          }
        } catch (e) {
          console.log("[PREFERENCE-ALIGNMENT] Error parsing matching priorities");
        }
        if (userPriorities.length === 0) {
          return this.calculateBasicPreferenceAlignment(candidate, preferences);
        }
        console.log(`[PREFERENCE-ALIGNMENT] User priorities: [${userPriorities.join(", ")}]`);
        let totalScore = 0;
        let totalWeight = 0;
        const priorityWeights = [0.4, 0.3, 0.2, 0.1, 0.1, 0.1, 0.1];
        userPriorities.forEach((priority, index) => {
          const weight = priorityWeights[index] || 0.05;
          const categoryScore = this.calculateCategoryScore(priority, candidate, preferences);
          totalScore += categoryScore * weight;
          totalWeight += weight;
          console.log(`[PREFERENCE-ALIGNMENT] ${priority} (priority ${index + 1}): ${categoryScore.toFixed(3)} (weight: ${weight})`);
        });
        const finalScore = totalWeight > 0 ? totalScore / totalWeight : 0.5;
        console.log(`[PREFERENCE-ALIGNMENT] Final weighted score: ${finalScore.toFixed(4)}`);
        return Math.min(Math.max(finalScore, 0), 1);
      }
      /**
       * Calculate score for individual matching priority category
       */
      calculateCategoryScore(category, candidate, preferences) {
        switch (category) {
          case "values":
            return this.calculateValuesScore(candidate, preferences);
          case "personality":
            return this.calculatePersonalityScore(candidate, preferences);
          case "looks":
            return this.calculateLooksScore(candidate, preferences);
          case "career":
            return this.calculateCareerScore(candidate, preferences);
          case "religion":
            return this.calculateReligionScore(candidate, preferences);
          case "tribe":
            return this.calculateTribeScore(candidate, preferences);
          case "intellect":
            return this.calculateIntellectScore(candidate, preferences);
          default:
            console.log(`[PREFERENCE-ALIGNMENT] Unknown category: ${category}`);
            return 0.5;
        }
      }
      /**
       * VALUES: Interests + Religion + Relationship Goals compatibility
       */
      calculateValuesScore(candidate, preferences) {
        let score = 0;
        let factors = 0;
        if (candidate.interests && preferences?.interestPreferences) {
          try {
            const candidateInterests = new Set(JSON.parse(candidate.interests));
            const preferredInterests = new Set(JSON.parse(preferences.interestPreferences));
            const commonInterests = [...candidateInterests].filter((interest) => preferredInterests.has(interest));
            const totalUniqueInterests = (/* @__PURE__ */ new Set([...candidateInterests, ...preferredInterests])).size;
            if (totalUniqueInterests > 0) {
              const overlapScore = commonInterests.length / Math.min(candidateInterests.size, preferredInterests.size);
              const diversityScore = this.calculateInterestDiversity(candidate, preferences.userId ? candidate : candidate, preferences);
              const combinedScore = overlapScore * 0.7 + diversityScore * 0.3;
              score += combinedScore;
              factors++;
              console.log(`[VALUES-SCORE] Interest combination: ${overlapScore.toFixed(3)} overlap + ${diversityScore.toFixed(3)} diversity = ${combinedScore.toFixed(3)}`);
            }
          } catch (e) {
            console.log("[VALUES-SCORE] Interest parsing error");
          }
        }
        if (candidate.religion && preferences?.religionPreference) {
          try {
            const religionPrefs = new Set(JSON.parse(preferences.religionPreference));
            score += religionPrefs.has(candidate.religion) ? 1 : 0;
            factors++;
          } catch (e) {
            if (preferences.religionPreference === candidate.religion) {
              score += 1;
              factors++;
            }
          }
        }
        if (candidate.relationshipGoal && preferences?.relationshipGoalPreference) {
          const goalSimilarity = this.calculateTextSimilarity(
            candidate.relationshipGoal.toLowerCase(),
            preferences.relationshipGoalPreference.toLowerCase()
          );
          score += goalSimilarity;
          factors++;
        }
        return factors > 0 ? score / factors : 0.5;
      }
      /**
       * PERSONALITY: Bio analysis + Shared interests
       */
      calculatePersonalityScore(candidate, preferences) {
        let score = 0;
        let factors = 0;
        if (candidate.bio && preferences && "bio" in preferences) {
          score += 0.7;
          factors++;
        }
        if (candidate.interests && preferences?.interestPreferences) {
          try {
            const candidateInterests = new Set(JSON.parse(candidate.interests));
            const preferredInterests = new Set(JSON.parse(preferences.interestPreferences));
            const overlap = [...candidateInterests].filter((i) => preferredInterests.has(i)).length;
            const union = (/* @__PURE__ */ new Set([...candidateInterests, ...preferredInterests])).size;
            if (union > 0) {
              score += overlap / union;
              factors++;
            }
          } catch (e) {
            console.log("[PERSONALITY-SCORE] Interest parsing error");
          }
        }
        return factors > 0 ? score / factors : 0.5;
      }
      /**
       * LOOKS: Enhanced body type + Height preferences with range expansion (Feature 3)
       */
      calculateLooksScore(candidate, preferences) {
        let score = 0;
        let factors = 0;
        if (candidate.bodyType && preferences?.bodyTypePreference) {
          try {
            const bodyTypePrefs = new Set(JSON.parse(preferences.bodyTypePreference));
            if (bodyTypePrefs.has(candidate.bodyType)) {
              console.log(`[BODY-TYPE-EXPANSION] Exact body type match: ${candidate.bodyType}`);
              score += 1;
            } else {
              const expansionScore = this.calculateBodyTypeRangeExpansion(candidate.bodyType, bodyTypePrefs);
              console.log(`[BODY-TYPE-EXPANSION] Expanding range for ${candidate.bodyType}: ${expansionScore.toFixed(3)}`);
              score += expansionScore;
            }
            factors++;
          } catch (e) {
            if (preferences.bodyTypePreference === candidate.bodyType) {
              score += 1;
            } else {
              const expansionScore = this.calculateBasicBodyTypeExpansion(candidate.bodyType, preferences.bodyTypePreference);
              score += expansionScore;
            }
            factors++;
          }
        }
        if (candidate.height && preferences?.minHeightPreference && preferences?.maxHeightPreference) {
          const inRange = candidate.height >= preferences.minHeightPreference && candidate.height <= preferences.maxHeightPreference;
          score += inRange ? 1 : 0;
          factors++;
        }
        return factors > 0 ? score / factors : 0.5;
      }
      /**
       * CAREER: Profession + Education level compatibility
       */
      calculateCareerScore(candidate, preferences) {
        let score = 0;
        let factors = 0;
        if (candidate.educationLevel && preferences?.educationLevelPreference) {
          try {
            const educationPrefs = new Set(JSON.parse(preferences.educationLevelPreference));
            score += educationPrefs.has(candidate.educationLevel) ? 1 : 0;
            factors++;
          } catch (e) {
            if (preferences.educationLevelPreference === candidate.educationLevel) {
              score += 1;
              factors++;
            }
          }
        }
        if (candidate.profession && preferences && "profession" in preferences) {
          score += 0.6;
          factors++;
        }
        return factors > 0 ? score / factors : 0.5;
      }
      /**
       * RELIGION: Enhanced religion matching with tolerance expansion (Feature 2)
       * Expands religion preferences when religion is not in user's deal breakers
       */
      calculateReligionScore(candidate, preferences) {
        if (!candidate.religion || !preferences?.religionPreference) return 0.5;
        try {
          const religionPrefs = new Set(JSON.parse(preferences.religionPreference));
          if (religionPrefs.has(candidate.religion)) {
            console.log(`[RELIGION-TOLERANCE] Exact religion match: ${candidate.religion}`);
            return 1;
          }
          const isReligionDealBreaker = this.isReligionDealBreaker(preferences);
          if (isReligionDealBreaker) {
            console.log(`[RELIGION-TOLERANCE] Religion is deal breaker - but hard filtering should have handled this already`);
            return 0.1;
          }
          const toleranceScore = this.calculateReligionTolerance(candidate.religion, religionPrefs);
          console.log(`[RELIGION-TOLERANCE] Applying tolerance for ${candidate.religion}: ${toleranceScore.toFixed(3)}`);
          return toleranceScore;
        } catch (e) {
          const exactMatch = preferences.religionPreference === candidate.religion;
          if (exactMatch) return 1;
          const isReligionDealBreaker = this.isReligionDealBreaker(preferences);
          if (isReligionDealBreaker) return 0.1;
          return this.calculateBasicReligionTolerance(candidate.religion, preferences.religionPreference);
        }
      }
      /**
       * TRIBE: Ethnicity + Secondary tribe matching
       */
      calculateTribeScore(candidate, preferences) {
        if (!preferences?.ethnicityPreference) return 0.5;
        try {
          const ethnicityPrefs = new Set(JSON.parse(preferences.ethnicityPreference));
          let matches2 = 0;
          let total = 0;
          if (candidate.ethnicity) {
            matches2 += ethnicityPrefs.has(candidate.ethnicity) ? 1 : 0;
            total++;
          }
          if (candidate.secondaryTribe) {
            matches2 += ethnicityPrefs.has(candidate.secondaryTribe) ? 1 : 0;
            total++;
          }
          return total > 0 ? matches2 / total : 0.5;
        } catch (e) {
          const hasEthnicityMatch = preferences.ethnicityPreference === candidate.ethnicity;
          const hasSecondaryMatch = preferences.ethnicityPreference === candidate.secondaryTribe;
          return hasEthnicityMatch || hasSecondaryMatch ? 1 : 0;
        }
      }
      /**
       * INTELLECT: Education level + University + Profession analysis
       */
      calculateIntellectScore(candidate, preferences) {
        let score = 0;
        let factors = 0;
        if (candidate.educationLevel && preferences?.educationLevelPreference) {
          const educationHierarchy = {
            "high_school": 1,
            "some_college": 2,
            "bachelors": 3,
            "masters": 4,
            "doctorate": 5
          };
          try {
            const educationPrefs = JSON.parse(preferences.educationLevelPreference);
            const candidateLevel = educationHierarchy[candidate.educationLevel] || 0;
            const hasCompatibleEducation = educationPrefs.some(
              (pref) => educationHierarchy[pref] === candidateLevel
            );
            score += hasCompatibleEducation ? 1 : 0;
            factors++;
          } catch (e) {
            score += preferences.educationLevelPreference === candidate.educationLevel ? 1 : 0;
            factors++;
          }
        }
        if (candidate.collegeUniversity) {
          score += 0.7;
          factors++;
        }
        return factors > 0 ? score / factors : 0.5;
      }
      /**
       * Basic preference alignment for users without matching priorities
       */
      calculateBasicPreferenceAlignment(candidate, preferences) {
        if (!preferences) return 0.5;
        let score = 0;
        let factors = 0;
        if (preferences.minAge && preferences.maxAge && candidate.dateOfBirth) {
          const candidateAge = this.calculateAge(candidate.dateOfBirth);
          if (candidateAge >= preferences.minAge && candidateAge <= preferences.maxAge) {
            score += 1;
          }
          factors++;
        }
        if (preferences.locationPreference && candidate.location) {
          if (preferences.locationPreference === "Both" || preferences.locationPreference === candidate.location) {
            score += 1;
          }
          factors++;
        }
        return factors > 0 ? score / factors : 0.5;
      }
      /**
       * Simple text similarity for relationship goals
       */
      calculateTextSimilarity(text1, text2) {
        const words1 = new Set(text1.split(/\s+/).filter((w) => w.length > 2));
        const words2 = new Set(text2.split(/\s+/).filter((w) => w.length > 2));
        const intersection = [...words1].filter((w) => words2.has(w)).length;
        const union = (/* @__PURE__ */ new Set([...words1, ...words2])).size;
        return union > 0 ? intersection / union : 0;
      }
      findSimilarUsersMatrix(userId, matrix) {
        const userIndex = matrix.userIds.indexOf(userId);
        if (userIndex === -1) return [];
        const similarities = [];
        const userInteractions = matrix.interactions[userIndex];
        for (let i = 0; i < matrix.userIds.length; i++) {
          if (i === userIndex) continue;
          const otherUserId = matrix.userIds[i];
          const otherInteractions = matrix.interactions[i];
          const similarity = this.calculateInteractionSimilarity(userInteractions, otherInteractions);
          if (similarity > 0.3) {
            similarities.push({ userId: otherUserId, similarity });
          }
        }
        return similarities.sort((a, b) => b.similarity - a.similarity).slice(0, 10);
      }
      calculateInteractionSimilarity(interactions1, interactions2) {
        let dotProduct = 0;
        let norm1 = 0;
        let norm2 = 0;
        for (let i = 0; i < Math.min(interactions1.length, interactions2.length); i++) {
          dotProduct += interactions1[i] * interactions2[i];
          norm1 += interactions1[i] * interactions1[i];
          norm2 += interactions2[i] * interactions2[i];
        }
        const denominator = Math.sqrt(norm1) * Math.sqrt(norm2);
        return denominator === 0 ? 0 : dotProduct / denominator;
      }
      calculateReciprocityScore(reciprocityData) {
        const responseScore = reciprocityData.responseRate;
        const timeScore = Math.exp(-reciprocityData.averageResponseTime / 3600);
        return (responseScore + timeScore) / 2;
      }
      tokenize(text2) {
        return text2.toLowerCase().replace(/[^\w\s]/g, "").split(/\s+/).filter((token) => token.length > 2);
      }
      calculateTF(term, tokens) {
        const count2 = tokens.filter((token) => token === term).length;
        return count2 / tokens.length;
      }
      calculateVectorCosineSimilarity(vector1, vector2) {
        let dotProduct = 0;
        let norm1 = 0;
        let norm2 = 0;
        for (let i = 0; i < Math.min(vector1.length, vector2.length); i++) {
          dotProduct += vector1[i] * vector2[i];
          norm1 += vector1[i] * vector1[i];
          norm2 += vector2[i] * vector2[i];
        }
        const denominator = Math.sqrt(norm1) * Math.sqrt(norm2);
        return denominator === 0 ? 0 : dotProduct / denominator;
      }
      /**
       * ============================================================================
       * PREFERENCE EXPANSION FEATURES - COMPLETE IMPLEMENTATION
       * ============================================================================
       */
      /**
       * FEATURE 2: Religion Tolerance Expansion
       * Check if religion is marked as a deal breaker in user preferences
       */
      isReligionDealBreaker(preferences) {
        if (!preferences?.dealBreakers) return false;
        try {
          const dealBreakers = JSON.parse(preferences.dealBreakers);
          return dealBreakers.includes("religion") || dealBreakers.includes("Religion");
        } catch (e) {
          return preferences.dealBreakers.toLowerCase().includes("religion");
        }
      }
      /**
       * FEATURE 2: Calculate religion tolerance when not a deal breaker
       */
      calculateReligionTolerance(candidateReligion, preferredReligions) {
        const religion = candidateReligion.toLowerCase();
        const religionCompatibilityMap = {
          "christian": {
            "christian": 1,
            "catholic": 0.8,
            "protestant": 0.8,
            "orthodox": 0.7,
            "spiritual": 0.6,
            "other": 0.4,
            "muslim": 0.3,
            "traditional": 0.2,
            "atheist": 0.1
          },
          "muslim": {
            "muslim": 1,
            "spiritual": 0.6,
            "christian": 0.3,
            "traditional": 0.3,
            "other": 0.4,
            "atheist": 0.1
          },
          "traditional": {
            "traditional": 1,
            "spiritual": 0.7,
            "other": 0.5,
            "christian": 0.3,
            "muslim": 0.3,
            "atheist": 0.2
          },
          "spiritual": {
            "spiritual": 1,
            "christian": 0.6,
            "muslim": 0.6,
            "traditional": 0.7,
            "other": 0.6,
            "atheist": 0.3
          },
          "other": {
            "other": 1,
            "spiritual": 0.6,
            "traditional": 0.5,
            "christian": 0.4,
            "muslim": 0.4,
            "atheist": 0.4
          },
          "atheist": {
            "atheist": 1,
            "spiritual": 0.3,
            "other": 0.4,
            "christian": 0.1,
            "muslim": 0.1,
            "traditional": 0.2
          }
        };
        let maxToleranceScore = 0;
        for (const preferredReligion of preferredReligions) {
          const preferred = preferredReligion.toLowerCase();
          const toleranceScore = religionCompatibilityMap[preferred]?.[religion] || 0.2;
          maxToleranceScore = Math.max(maxToleranceScore, toleranceScore);
        }
        console.log(`[RELIGION-TOLERANCE] ${candidateReligion} tolerance with preferences [${Array.from(preferredReligions).join(", ")}]: ${maxToleranceScore.toFixed(3)}`);
        return maxToleranceScore;
      }
      /**
       * FEATURE 2: Basic religion tolerance for string-based preferences
       */
      calculateBasicReligionTolerance(candidateReligion, preferredReligion) {
        const fakeSet = /* @__PURE__ */ new Set([preferredReligion]);
        return this.calculateReligionTolerance(candidateReligion, fakeSet);
      }
      /**
       * FEATURE 3: Body Type Range Expansion
       * Expand body type preferences for diversity
       */
      calculateBodyTypeRangeExpansion(candidateBodyType, preferredBodyTypes) {
        const bodyType = candidateBodyType.toLowerCase();
        const bodyTypeCompatibilityMap = {
          "slim": {
            "slim": 1,
            "athletic": 0.8,
            "average": 0.7,
            "curvy": 0.5,
            "thick": 0.4,
            "plus size": 0.3,
            "other": 0.5
          },
          "athletic": {
            "athletic": 1,
            "slim": 0.8,
            "toned": 0.9,
            "average": 0.7,
            "muscular": 0.8,
            "curvy": 0.6,
            "thick": 0.5,
            "other": 0.5
          },
          "average": {
            "average": 1,
            "slim": 0.7,
            "athletic": 0.7,
            "curvy": 0.8,
            "thick": 0.7,
            "plus size": 0.6,
            "other": 0.6
          },
          "curvy": {
            "curvy": 1,
            "thick": 0.8,
            "average": 0.8,
            "plus size": 0.7,
            "athletic": 0.6,
            "slim": 0.5,
            "other": 0.6
          },
          "thick": {
            "thick": 1,
            "curvy": 0.8,
            "plus size": 0.8,
            "average": 0.7,
            "athletic": 0.5,
            "slim": 0.4,
            "other": 0.6
          },
          "plus size": {
            "plus size": 1,
            "thick": 0.8,
            "curvy": 0.7,
            "average": 0.6,
            "athletic": 0.4,
            "slim": 0.3,
            "other": 0.5
          },
          "muscular": {
            "muscular": 1,
            "athletic": 0.8,
            "toned": 0.8,
            "average": 0.6,
            "thick": 0.5,
            "slim": 0.5,
            "other": 0.5
          },
          "toned": {
            "toned": 1,
            "athletic": 0.9,
            "muscular": 0.8,
            "slim": 0.7,
            "average": 0.6,
            "curvy": 0.6,
            "other": 0.5
          }
        };
        let maxExpansionScore = 0;
        for (const preferredBodyType of preferredBodyTypes) {
          const preferred = preferredBodyType.toLowerCase();
          const expansionScore = bodyTypeCompatibilityMap[preferred]?.[bodyType] || 0.3;
          maxExpansionScore = Math.max(maxExpansionScore, expansionScore);
        }
        console.log(`[BODY-TYPE-EXPANSION] ${candidateBodyType} expansion with preferences [${Array.from(preferredBodyTypes).join(", ")}]: ${maxExpansionScore.toFixed(3)}`);
        return maxExpansionScore;
      }
      /**
       * FEATURE 3: Basic body type expansion for string-based preferences
       */
      calculateBasicBodyTypeExpansion(candidateBodyType, preferredBodyType) {
        const fakeSet = /* @__PURE__ */ new Set([preferredBodyType]);
        return this.calculateBodyTypeRangeExpansion(candidateBodyType, fakeSet);
      }
      /**
       * FEATURE 4: New User Priority Boosting
       * Boost priority for new users to improve their visibility
       */
      calculateNewUserBoost(candidate) {
        const createdAt = candidate.createdAt;
        if (!createdAt) return 0;
        const createdDate = new Date(createdAt);
        const now = /* @__PURE__ */ new Date();
        const daysSinceJoined = (now.getTime() - createdDate.getTime()) / (1e3 * 60 * 60 * 24);
        if (daysSinceJoined <= 7) {
          const boost = 0.3 * (1 - daysSinceJoined / 7);
          console.log(`[NEW-USER-BOOST] User ${candidate.id} joined ${daysSinceJoined.toFixed(1)} days ago, boost: ${boost.toFixed(3)}`);
          return boost;
        } else if (daysSinceJoined <= 30) {
          const boost = 0.1 * (1 - (daysSinceJoined - 7) / 23);
          console.log(`[NEW-USER-BOOST] User ${candidate.id} joined ${daysSinceJoined.toFixed(1)} days ago, boost: ${boost.toFixed(3)}`);
          return boost;
        } else {
          return 0;
        }
      }
      /**
       * FEATURE 1: Enhanced Interest Diversity Analysis
       * Calculate complementary vs. overlapping interests for better diversity
       */
      calculateInterestDiversity(candidate, currentUser, preferences) {
        if (!candidate.interests || !currentUser.interests) {
          console.log(`[INTEREST-DIVERSITY] User ${candidate.id}: Missing interests data, returning neutral 0.5`);
          return 0.5;
        }
        try {
          const candidateInterests = new Set(JSON.parse(candidate.interests));
          const currentUserInterests = new Set(JSON.parse(currentUser.interests));
          if (candidateInterests.size === 0 || currentUserInterests.size === 0) {
            console.log(`[INTEREST-DIVERSITY] User ${candidate.id}: Empty interests, returning neutral 0.5`);
            return 0.5;
          }
          const commonInterests = [...candidateInterests].filter((interest) => currentUserInterests.has(interest));
          const overlapRatio = commonInterests.length / Math.min(candidateInterests.size, currentUserInterests.size);
          const uniqueCandidateInterests = [...candidateInterests].filter((interest) => !currentUserInterests.has(interest));
          const complementaryRatio = uniqueCandidateInterests.length / candidateInterests.size;
          const diversityScore = overlapRatio * 0.6 + complementaryRatio * 0.4;
          console.log(`[INTEREST-DIVERSITY] User ${candidate.id}: ${overlapRatio.toFixed(2)} overlap + ${complementaryRatio.toFixed(2)} complementary = ${diversityScore.toFixed(3)} diversity`);
          return Math.min(diversityScore, 1);
        } catch (e) {
          console.log("[INTEREST-DIVERSITY] Error parsing interests");
          return 0.5;
        }
      }
    };
    advancedMatchingEngine = new AdvancedMatchingEngine();
  }
});

// server/matrix-factorization.ts
var MatrixFactorization, matrixFactorization;
var init_matrix_factorization = __esm({
  "server/matrix-factorization.ts"() {
    "use strict";
    init_storage();
    MatrixFactorization = class {
      model;
      NUM_FACTORS = 50;
      // Latent factors for embeddings
      LEARNING_RATE = 0.01;
      REGULARIZATION = 0.01;
      MAX_ITERATIONS = 100;
      MIN_IMPROVEMENT = 1e-3;
      constructor() {
        this.model = {
          userEmbeddings: /* @__PURE__ */ new Map(),
          itemEmbeddings: /* @__PURE__ */ new Map(),
          globalBias: 0,
          numFactors: this.NUM_FACTORS,
          learningRate: this.LEARNING_RATE,
          regularization: this.REGULARIZATION,
          trained: false
        };
      }
      /**
       * Build user-item interaction matrix from matches and swipe history
       */
      async buildInteractionMatrix() {
        try {
          console.log("[MATRIX-FACTORIZATION] Building user-item interaction matrix...");
          const interactions = [];
          const allMatches = await this.getAllMatches();
          console.log(`[MATRIX-FACTORIZATION] Found ${allMatches.length} match interactions`);
          for (const match of allMatches) {
            const rating = match.matched ? 2 : match.isDislike ? -1 : 0;
            if (rating !== 0) {
              interactions.push({
                userId: match.userId1,
                itemId: match.userId2,
                rating,
                timestamp: match.createdAt || /* @__PURE__ */ new Date()
              });
              interactions.push({
                userId: match.userId2,
                itemId: match.userId1,
                rating,
                timestamp: match.createdAt || /* @__PURE__ */ new Date()
              });
            }
          }
          const allSwipes = await this.getAllSwipeHistory();
          console.log(`[MATRIX-FACTORIZATION] Found ${allSwipes.length} swipe interactions`);
          for (const swipe of allSwipes) {
            let rating = 0;
            if (swipe.action === "like") rating = 1;
            else if (swipe.action === "star") rating = 2;
            else if (swipe.action === "dislike") rating = -1;
            if (rating !== 0) {
              interactions.push({
                userId: swipe.userId,
                itemId: swipe.targetUserId,
                rating,
                timestamp: swipe.timestamp || /* @__PURE__ */ new Date()
              });
            }
          }
          console.log(`[MATRIX-FACTORIZATION] Built interaction matrix with ${interactions.length} interactions`);
          const deduplicatedInteractions = this.deduplicateInteractions(interactions);
          console.log(`[MATRIX-FACTORIZATION] After deduplication: ${deduplicatedInteractions.length} unique interactions`);
          return deduplicatedInteractions;
        } catch (error) {
          console.error("[MATRIX-FACTORIZATION] Error building interaction matrix:", error);
          return [];
        }
      }
      /**
       * Train the matrix factorization model using gradient descent
       */
      async trainModel() {
        try {
          console.log("[MATRIX-FACTORIZATION] Starting model training...");
          const interactions = await this.buildInteractionMatrix();
          if (interactions.length === 0) {
            console.log("[MATRIX-FACTORIZATION] No interactions available for training");
            return false;
          }
          this.initializeEmbeddings(interactions);
          this.model.globalBias = interactions.reduce((sum, i) => sum + i.rating, 0) / interactions.length;
          console.log(`[MATRIX-FACTORIZATION] Global bias: ${this.model.globalBias.toFixed(3)}`);
          let previousError = Infinity;
          let improvementCount = 0;
          for (let iteration = 0; iteration < this.MAX_ITERATIONS; iteration++) {
            let totalError = 0;
            let trainingCount = 0;
            const shuffledInteractions = this.shuffleArray([...interactions]);
            for (const interaction of shuffledInteractions) {
              const error = this.performGradientDescentStep(interaction);
              totalError += error * error;
              trainingCount++;
            }
            const rmse = Math.sqrt(totalError / trainingCount);
            const improvement = previousError - rmse;
            if (iteration % 10 === 0) {
              console.log(`[MATRIX-FACTORIZATION] Iteration ${iteration}: RMSE = ${rmse.toFixed(4)}, Improvement = ${improvement.toFixed(4)}`);
            }
            if (improvement < this.MIN_IMPROVEMENT) {
              improvementCount++;
              if (improvementCount >= 3) {
                console.log(`[MATRIX-FACTORIZATION] Converged at iteration ${iteration}`);
                break;
              }
            } else {
              improvementCount = 0;
            }
            previousError = rmse;
          }
          this.model.trained = true;
          console.log(`[MATRIX-FACTORIZATION] Training completed. Model ready for predictions.`);
          console.log(`[MATRIX-FACTORIZATION] User embeddings: ${this.model.userEmbeddings.size}, Item embeddings: ${this.model.itemEmbeddings.size}`);
          return true;
        } catch (error) {
          console.error("[MATRIX-FACTORIZATION] Error training model:", error);
          return false;
        }
      }
      /**
       * Predict user-item rating using trained embeddings
       */
      predictRating(userId, itemId) {
        if (!this.model.trained) {
          return 0.5;
        }
        const userEmbedding = this.model.userEmbeddings.get(userId);
        const itemEmbedding = this.model.itemEmbeddings.get(itemId);
        if (!userEmbedding || !itemEmbedding) {
          return this.model.globalBias;
        }
        let dotProduct = 0;
        for (let f = 0; f < this.NUM_FACTORS; f++) {
          dotProduct += userEmbedding.factors[f] * itemEmbedding.factors[f];
        }
        const prediction = this.model.globalBias + userEmbedding.bias + itemEmbedding.bias + dotProduct;
        return Math.max(0, Math.min(1, (prediction + 2) / 4));
      }
      /**
       * Find users with similar embeddings
       */
      findSimilarUsers(userId, topK = 10) {
        if (!this.model.trained) return [];
        const userEmbedding = this.model.userEmbeddings.get(userId);
        if (!userEmbedding) return [];
        const similarities = [];
        for (const [otherUserId, otherEmbedding] of this.model.userEmbeddings) {
          if (otherUserId === userId) continue;
          const similarity = this.calculateEmbeddingSimilarity(userEmbedding.factors, otherEmbedding.factors);
          similarities.push({ userId: otherUserId, similarity });
        }
        return similarities.filter((s) => s.similarity > 0.1).sort((a, b) => b.similarity - a.similarity).slice(0, topK).map((s) => s.userId);
      }
      /**
       * Get collaborative filtering score for user-candidate pair
       */
      getCollaborativeScore(userId, candidateId) {
        try {
          const directScore = this.predictRating(userId, candidateId);
          const similarUsers = this.findSimilarUsers(userId, 5);
          let similarityBoost = 0;
          if (similarUsers.length > 0) {
            let positiveVotes = 0;
            for (const similarUserId of similarUsers) {
              const similarUserScore = this.predictRating(similarUserId, candidateId);
              if (similarUserScore > 0.6) {
                positiveVotes++;
              }
            }
            similarityBoost = positiveVotes / similarUsers.length * 0.2;
          }
          const finalScore = Math.min(1, directScore + similarityBoost);
          console.log(`[MATRIX-FACTORIZATION] User ${userId} \u2192 User ${candidateId}: Direct=${directScore.toFixed(3)}, Boost=${similarityBoost.toFixed(3)}, Final=${finalScore.toFixed(3)}`);
          return finalScore;
        } catch (error) {
          console.error("[MATRIX-FACTORIZATION] Error calculating collaborative score:", error);
          return 0.5;
        }
      }
      // Private helper methods
      async getAllMatches() {
        try {
          const matches2 = [];
          const allMatches = await storage.getAllMatches();
          return allMatches || [];
        } catch (error) {
          console.error("[MATRIX-FACTORIZATION] Error getting all matches:", error);
          return [];
        }
      }
      async getAllSwipeHistory() {
        try {
          const allSwipes = await storage.getAllSwipeHistory();
          return allSwipes || [];
        } catch (error) {
          console.error("[MATRIX-FACTORIZATION] Error getting all swipe history:", error);
          return [];
        }
      }
      deduplicateInteractions(interactions) {
        const interactionMap = /* @__PURE__ */ new Map();
        for (const interaction of interactions) {
          const key = `${interaction.userId}-${interaction.itemId}`;
          const existing = interactionMap.get(key);
          if (!existing || Math.abs(interaction.rating) > Math.abs(existing.rating) || interaction.timestamp > existing.timestamp) {
            interactionMap.set(key, interaction);
          }
        }
        return Array.from(interactionMap.values());
      }
      initializeEmbeddings(interactions) {
        const users2 = /* @__PURE__ */ new Set();
        const items = /* @__PURE__ */ new Set();
        for (const interaction of interactions) {
          users2.add(interaction.userId);
          items.add(interaction.itemId);
        }
        console.log(`[MATRIX-FACTORIZATION] Initializing embeddings for ${users2.size} users and ${items.size} items`);
        for (const userId of users2) {
          const factors = Array(this.NUM_FACTORS).fill(0).map(() => (Math.random() - 0.5) * 0.1);
          this.model.userEmbeddings.set(userId, {
            userId,
            factors,
            bias: 0,
            interactionCount: interactions.filter((i) => i.userId === userId).length
          });
        }
        for (const itemId of items) {
          const factors = Array(this.NUM_FACTORS).fill(0).map(() => (Math.random() - 0.5) * 0.1);
          const itemInteractions = interactions.filter((i) => i.itemId === itemId);
          const popularity = itemInteractions.length;
          this.model.itemEmbeddings.set(itemId, {
            itemId,
            factors,
            bias: 0,
            popularityScore: popularity
          });
        }
      }
      performGradientDescentStep(interaction) {
        const userEmbedding = this.model.userEmbeddings.get(interaction.userId);
        const itemEmbedding = this.model.itemEmbeddings.get(interaction.itemId);
        if (!userEmbedding || !itemEmbedding) return 0;
        let prediction = this.model.globalBias + userEmbedding.bias + itemEmbedding.bias;
        for (let f = 0; f < this.NUM_FACTORS; f++) {
          prediction += userEmbedding.factors[f] * itemEmbedding.factors[f];
        }
        const error = interaction.rating - prediction;
        const userBiasOld = userEmbedding.bias;
        const itemBiasOld = itemEmbedding.bias;
        userEmbedding.bias += this.LEARNING_RATE * (error - this.REGULARIZATION * userBiasOld);
        itemEmbedding.bias += this.LEARNING_RATE * (error - this.REGULARIZATION * itemBiasOld);
        for (let f = 0; f < this.NUM_FACTORS; f++) {
          const userFactorOld = userEmbedding.factors[f];
          const itemFactorOld = itemEmbedding.factors[f];
          userEmbedding.factors[f] += this.LEARNING_RATE * (error * itemFactorOld - this.REGULARIZATION * userFactorOld);
          itemEmbedding.factors[f] += this.LEARNING_RATE * (error * userFactorOld - this.REGULARIZATION * itemFactorOld);
        }
        return error;
      }
      calculateEmbeddingSimilarity(factors1, factors2) {
        let dotProduct = 0;
        let norm1 = 0;
        let norm2 = 0;
        for (let i = 0; i < factors1.length; i++) {
          dotProduct += factors1[i] * factors2[i];
          norm1 += factors1[i] * factors1[i];
          norm2 += factors2[i] * factors2[i];
        }
        const magnitude = Math.sqrt(norm1) * Math.sqrt(norm2);
        return magnitude > 0 ? dotProduct / magnitude : 0;
      }
      shuffleArray(array) {
        const shuffled = [...array];
        for (let i = shuffled.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
        }
        return shuffled;
      }
    };
    matrixFactorization = new MatrixFactorization();
  }
});

// server/hard-filters.ts
var RELIGION_GROUPS, HardFiltersEngine, hardFiltersEngine;
var init_hard_filters = __esm({
  "server/hard-filters.ts"() {
    "use strict";
    init_geocoding_service();
    RELIGION_GROUPS = {
      "christianity": [
        "christianity-roman-catholic",
        "christianity-methodist",
        "christianity-presbyterian",
        "christianity-anglican",
        "christianity-pentecostal",
        "christianity-charismatic",
        "christianity-baptist",
        "christianity-seventh-day-adventist",
        "christianity-evangelical",
        "christianity-church-of-christ",
        "christianity-apostolic",
        "christianity-lutheran",
        "christianity-jehovahs-witness",
        "christianity-salvation-army",
        "christianity-other"
      ],
      "islam": [
        "islam-sunni",
        "islam-ahmadiyya",
        "islam-shia",
        "islam-sufi",
        "islam-other"
      ],
      "traditional": [
        "traditional-akan",
        "traditional-ewe",
        "traditional-ga-adangme",
        "traditional-dagbani",
        "traditional-other"
      ],
      "other": [
        "other-bahai",
        "other-buddhism",
        "other-hinduism",
        "other-judaism",
        "other-rastafarianism",
        "other-other"
      ],
      "none": [
        "none-atheist",
        "none-agnostic",
        "none-secular",
        "none-prefer-not-to-say"
      ]
    };
    HardFiltersEngine = class {
      currentUserPreferences = null;
      /**
       * Apply all hard filters to candidate pool
       * Returns only candidates who pass ALL non-negotiable criteria
       */
      async applyHardFilters(candidates, currentUser, userPreferences3, config = {
        enforceAccountStatus: true,
        enforceAgeBoundaries: true,
        enforceDistanceLimits: true,
        enforceChildrenPreferences: true,
        enforceDealBreakers: true,
        enforceCountryPool: true,
        enforceHighSchoolPreferences: true
      }) {
        console.log(`[HARD-FILTERS] Starting hard filter enforcement for user ${currentUser.id}`);
        console.log(`[HARD-FILTERS] Initial candidate pool: ${candidates.length} users`);
        this.currentUserPreferences = userPreferences3;
        let filteredCandidates = [...candidates];
        const startTime = Date.now();
        if (config.enforceAccountStatus) {
          filteredCandidates = await this.filterByAccountStatus(filteredCandidates, currentUser.id);
          console.log(`[HARD-FILTERS] After account status: ${filteredCandidates.length} candidates`);
        }
        if (config.enforceDealBreakers && userPreferences3?.dealBreakers) {
          filteredCandidates = await this.filterByDealBreakers(filteredCandidates, userPreferences3);
          console.log(`[HARD-FILTERS] After deal breakers: ${filteredCandidates.length} candidates`);
        }
        if (config.enforceAgeBoundaries && userPreferences3?.minAge && userPreferences3?.maxAge) {
          filteredCandidates = this.filterByAgeBoundaries(filteredCandidates, userPreferences3);
          console.log(`[HARD-FILTERS] After age boundaries: ${filteredCandidates.length} candidates`);
        }
        if (config.enforceDistanceLimits && userPreferences3?.distancePreference && userPreferences3.distancePreference !== -1) {
          filteredCandidates = await this.filterByDistanceLimits(filteredCandidates, currentUser, userPreferences3);
          console.log(`[HARD-FILTERS] After distance limits: ${filteredCandidates.length} candidates`);
        }
        if (config.enforceChildrenPreferences && userPreferences3) {
          filteredCandidates = this.filterByChildrenCompatibility(filteredCandidates, userPreferences3);
          console.log(`[HARD-FILTERS] After children compatibility: ${filteredCandidates.length} candidates`);
        }
        if (config.enforceCountryPool && userPreferences3?.meetPoolCountry && userPreferences3.meetPoolCountry !== "ANYWHERE") {
          filteredCandidates = this.filterByCountryPool(filteredCandidates, userPreferences3.meetPoolCountry);
          console.log(`[HARD-FILTERS] After country pool: ${filteredCandidates.length} candidates`);
        }
        if (config.enforceHighSchoolPreferences && userPreferences3) {
          filteredCandidates = this.filterByHighSchoolPreferences(filteredCandidates, currentUser, userPreferences3);
          console.log(`[HARD-FILTERS] After high school preferences: ${filteredCandidates.length} candidates`);
        }
        const duration = Date.now() - startTime;
        const filterRate = ((candidates.length - filteredCandidates.length) / candidates.length * 100).toFixed(1);
        console.log(`[HARD-FILTERS] \u2705 Filtering complete in ${duration}ms`);
        console.log(`[HARD-FILTERS] Filtered out ${candidates.length - filteredCandidates.length} users (${filterRate}%)`);
        console.log(`[HARD-FILTERS] Final acceptable pool: ${filteredCandidates.length} candidates`);
        return filteredCandidates;
      }
      /**
       * FILTER 0: Account Status Enforcement (CRITICAL SAFETY)
       * Removes candidates with problematic account statuses:
       * - Suspended users (isSuspended = true)
       * - Hidden profiles (profileHidden = true)
       * - Inactive profiles (hasActivatedProfile = false)
       * - Blocked users (bidirectional blocking)
       */
      async filterByAccountStatus(candidates, currentUserId) {
        console.log(`[ACCOUNT-STATUS] Starting account status filtering on ${candidates.length} candidates`);
        const { areUsersBlocked: areUsersBlocked2 } = await Promise.resolve().then(() => (init_user_blocking_api(), user_blocking_api_exports));
        const filteredCandidates = [];
        for (const candidate of candidates) {
          const now = /* @__PURE__ */ new Date();
          if (candidate.isSuspended) {
            if (candidate.suspensionExpiresAt && new Date(candidate.suspensionExpiresAt) > now) {
              console.log(`[ACCOUNT-STATUS] \u274C User ${candidate.id} is suspended until ${candidate.suspensionExpiresAt}`);
              continue;
            } else if (candidate.suspensionExpiresAt && new Date(candidate.suspensionExpiresAt) <= now) {
              console.log(`[ACCOUNT-STATUS] \u26A0\uFE0F User ${candidate.id} suspension expired, allowing through`);
            } else {
              console.log(`[ACCOUNT-STATUS] \u274C User ${candidate.id} is suspended (no expiry date)`);
              continue;
            }
          }
          if (candidate.profileHidden) {
            console.log(`[ACCOUNT-STATUS] \u274C User ${candidate.id} has hidden their profile`);
            continue;
          }
          if (!candidate.hasActivatedProfile) {
            console.log(`[ACCOUNT-STATUS] \u274C User ${candidate.id} has not activated their profile`);
            continue;
          }
          const isBlocked = await areUsersBlocked2(currentUserId, candidate.id);
          if (isBlocked) {
            console.log(`[ACCOUNT-STATUS] \u274C User ${candidate.id} is blocked (bidirectional blocking)`);
            continue;
          }
          filteredCandidates.push(candidate);
        }
        const filteredCount = candidates.length - filteredCandidates.length;
        console.log(`[ACCOUNT-STATUS] Filtered out ${filteredCount} users with problematic account status`);
        console.log(`[ACCOUNT-STATUS] Account status filter complete: ${filteredCandidates.length} candidates remaining`);
        return filteredCandidates;
      }
      /**
       * FILTER 1: Deal Breakers Enforcement
       * Removes candidates who match user's specified deal breakers
       */
      async filterByDealBreakers(candidates, preferences) {
        try {
          const dealBreakers = JSON.parse(preferences.dealBreakers || "[]");
          if (dealBreakers.length === 0) {
            console.log(`[DEAL-BREAKERS] No deal breakers specified`);
            return candidates;
          }
          console.log(`\u{1F527} [UNIFIED-DEAL-BREAKERS] Applying ${dealBreakers.length} deal breakers (unified binary system):`, dealBreakers);
          const filteredCandidates = candidates.filter((candidate) => {
            for (const dealBreaker of dealBreakers) {
              if (this.candidateViolatesDealBreaker(candidate, dealBreaker)) {
                console.log(`\u{1F527} [UNIFIED-DEAL-BREAKERS] \u274C User ${candidate.id} violates deal breaker: ${dealBreaker} (binary zero-tolerance filtering)`);
                return false;
              }
            }
            return true;
          });
          return filteredCandidates;
        } catch (error) {
          console.error(`[DEAL-BREAKERS] Error parsing deal breakers:`, error);
          return candidates;
        }
      }
      /**
       * Check if candidate violates a specific deal breaker
       */
      candidateViolatesDealBreaker(candidate, dealBreaker) {
        switch (dealBreaker) {
          case "smoking":
            const smoking = candidate.smoking;
            return smoking === "yes" || smoking === "occasionally" || smoking === true;
          case "drinking":
            const drinking = candidate.drinking;
            return drinking === "yes" || drinking === "occasionally" || drinking === "socially" || drinking === true;
          case "different_religion":
            return this.isReligionGroupIncompatible(candidate, this.currentUserPreferences);
          case "different_religion_old":
            return false;
          // Let religion matching handle this with tolerance
          case "no_education":
            return !candidate.educationLevel || candidate.educationLevel === "no_formal_education";
          case "different_tribe":
            return false;
          // Let ethnicity matching handle this
          case "long_distance":
            return false;
          // Enhanced filtering implemented in Filter 3 (Distance Limits)
          case "has_children":
            return candidate.hasChildren === true || candidate.hasChildren === "yes";
          default:
            console.log(`[DEAL-BREAKERS] Unknown deal breaker: ${dealBreaker}`);
            return false;
        }
      }
      /**
       * FILTER 2: Age Boundaries Enforcement
       * Removes candidates outside specified age range
       */
      filterByAgeBoundaries(candidates, preferences) {
        const minAge = preferences.minAge;
        const maxAge = preferences.maxAge;
        if (!minAge || !maxAge) {
          console.log(`[AGE-BOUNDARIES] No age boundaries specified`);
          return candidates;
        }
        console.log(`[AGE-BOUNDARIES] Enforcing age range: ${minAge}-${maxAge} years`);
        const filteredCandidates = candidates.filter((candidate) => {
          if (!candidate.dateOfBirth) {
            console.log(`[AGE-BOUNDARIES] \u274C User ${candidate.id} has no birth date`);
            return false;
          }
          const candidateAge = this.calculateAge(candidate.dateOfBirth);
          const withinRange = candidateAge >= minAge && candidateAge <= maxAge;
          if (!withinRange) {
            console.log(`[AGE-BOUNDARIES] \u274C User ${candidate.id} age ${candidateAge} outside range ${minAge}-${maxAge}`);
          }
          return withinRange;
        });
        return filteredCandidates;
      }
      /**
       * FILTER 3: Distance Limits Enforcement
       * Removes candidates beyond specified distance preference
       * Enhanced with "Long Distance" deal breaker for stricter filtering
       */
      async filterByDistanceLimits(candidates, currentUser, preferences) {
        const distancePreferenceMiles = preferences.distancePreference;
        let dealBreakers = [];
        let hasLongDistanceDealBreaker = false;
        try {
          dealBreakers = preferences.dealBreakers ? JSON.parse(preferences.dealBreakers) : [];
          hasLongDistanceDealBreaker = dealBreakers.includes("long_distance");
        } catch {
          dealBreakers = [];
        }
        if (!distancePreferenceMiles || distancePreferenceMiles === -1) {
          if (hasLongDistanceDealBreaker) {
            console.log(`[DISTANCE-LIMITS] Long distance deal breaker active: enforcing strict 25 mile limit despite "no limit" preference`);
          } else {
            console.log(`[DISTANCE-LIMITS] No distance limit specified or unlimited`);
            return candidates;
          }
        }
        let effectiveDistanceMiles = distancePreferenceMiles || 25;
        let maxDistanceKm;
        if (hasLongDistanceDealBreaker) {
          if (!distancePreferenceMiles || distancePreferenceMiles === -1) {
            effectiveDistanceMiles = 25;
          } else if (distancePreferenceMiles >= 999999) {
            effectiveDistanceMiles = 100;
          } else {
            effectiveDistanceMiles = Math.min(distancePreferenceMiles * 0.6, 50);
          }
          console.log(`[DISTANCE-LIMITS] Long distance deal breaker active: reducing ${distancePreferenceMiles || "unlimited"} \u2192 ${effectiveDistanceMiles} miles`);
        }
        if (effectiveDistanceMiles >= 999999) {
          maxDistanceKm = 999999;
          console.log(`[DISTANCE-LIMITS] Country-level filtering: ${maxDistanceKm}km`);
        } else {
          maxDistanceKm = Math.round(effectiveDistanceMiles * 1.60934);
          console.log(`[DISTANCE-LIMITS] Converting ${effectiveDistanceMiles} miles \u2192 ${maxDistanceKm}km`);
        }
        const dealBreakerNote = hasLongDistanceDealBreaker ? " (enhanced by long_distance deal breaker)" : "";
        console.log(`[DISTANCE-LIMITS] Enforcing maximum distance: ${maxDistanceKm}km${dealBreakerNote}`);
        const userCoordinates = await geocodingService.getCoordinates(currentUser.location || "");
        if (!userCoordinates) {
          console.log(`[DISTANCE-LIMITS] \u26A0\uFE0F Cannot get coordinates for user location: ${currentUser.location}`);
          return candidates;
        }
        const filteredCandidates = [];
        for (const candidate of candidates) {
          if (!candidate.location) {
            console.log(`[DISTANCE-LIMITS] \u274C User ${candidate.id} has no location`);
            continue;
          }
          const candidateCoordinates = await geocodingService.getCoordinates(candidate.location);
          if (!candidateCoordinates) {
            console.log(`[DISTANCE-LIMITS] \u26A0\uFE0F Cannot get coordinates for candidate location: ${candidate.location}`);
            continue;
          }
          const distance = this.calculateDistance(
            userCoordinates.coordinates.latitude,
            userCoordinates.coordinates.longitude,
            candidateCoordinates.coordinates.latitude,
            candidateCoordinates.coordinates.longitude
          );
          if (distance <= maxDistanceKm) {
            filteredCandidates.push(candidate);
          } else {
            const dealBreakerLog = hasLongDistanceDealBreaker ? " [LONG-DISTANCE-DEAL-BREAKER]" : "";
            console.log(`[DISTANCE-LIMITS]${dealBreakerLog} \u274C User ${candidate.id} distance ${distance.toFixed(1)}km > ${maxDistanceKm}km (${effectiveDistanceMiles} miles effective limit)`);
          }
        }
        return filteredCandidates;
      }
      /**
       * FILTER 4: Has Children Compatibility Only
       * Handles only "hasChildren" preference for binary compatibility matching
       * NOTE: "wantsChildren" is NOT filtered here - it's handled in matching algorithm scoring
       */
      filterByChildrenCompatibility(candidates, preferences) {
        const hasChildrenPref = preferences.hasChildrenPreference;
        let dealBreakers = [];
        try {
          dealBreakers = preferences.dealBreakers ? JSON.parse(preferences.dealBreakers) : [];
        } catch {
          dealBreakers = [];
        }
        if (dealBreakers.includes("has_children")) {
          console.log(`[CHILDREN-COMPATIBILITY] Skipping - 'has_children' deal breaker active in Filter 1`);
          return candidates;
        }
        if (!hasChildrenPref) {
          console.log(`[CHILDREN-COMPATIBILITY] No hasChildren preference specified`);
          return candidates;
        }
        console.log(`[CHILDREN-COMPATIBILITY] Enforcing hasChildren preference: ${hasChildrenPref}`);
        const filteredCandidates = candidates.filter((candidate) => {
          if (hasChildrenPref && hasChildrenPref !== "any") {
            const candidateHasChildren = this.normalizeBoolean(candidate.hasChildren);
            const preferenceHasChildren = hasChildrenPref === "yes";
            if (candidateHasChildren !== preferenceHasChildren) {
              console.log(`[CHILDREN-COMPATIBILITY] \u274C User ${candidate.id} hasChildren mismatch: ${candidateHasChildren} vs wanted ${preferenceHasChildren}`);
              return false;
            }
          }
          return true;
        });
        return filteredCandidates;
      }
      /**
       * Helper: Calculate age from date of birth
       */
      calculateAge(dateOfBirth) {
        const today = /* @__PURE__ */ new Date();
        const birthDate = new Date(dateOfBirth);
        let age = today.getFullYear() - birthDate.getFullYear();
        const monthDiff = today.getMonth() - birthDate.getMonth();
        if (monthDiff < 0 || monthDiff === 0 && today.getDate() < birthDate.getDate()) {
          age--;
        }
        return age;
      }
      /**
       * Check if user is under 18 years old
       */
      isUnder18(dateOfBirth) {
        if (!dateOfBirth) return false;
        const birthDate = typeof dateOfBirth === "string" ? new Date(dateOfBirth) : dateOfBirth;
        return this.calculateAge(birthDate) < 18;
      }
      /**
       * FILTER 6: High School Preferences Enforcement (Under 18 Only)
       * For users under 18, filters candidates based on high school preferences
       * "ANY SCHOOL" means candidates can come from any or no high school
       */
      filterByHighSchoolPreferences(candidates, currentUser, preferences) {
        if (!this.isUnder18(currentUser.dateOfBirth)) {
          console.log(`[HIGH-SCHOOL-PREFERENCES] User ${currentUser.id} is 18+, skipping high school filtering`);
          return candidates;
        }
        const highSchoolPref = preferences.highSchoolPreference;
        if (!highSchoolPref) {
          console.log(`[HIGH-SCHOOL-PREFERENCES] No high school preference set for user ${currentUser.id}`);
          return candidates;
        }
        let preferredSchools = [];
        try {
          preferredSchools = JSON.parse(highSchoolPref);
        } catch {
          console.log(`[HIGH-SCHOOL-PREFERENCES] Invalid JSON in high school preference: ${highSchoolPref}`);
          return candidates;
        }
        if (preferredSchools.includes("ANY SCHOOL")) {
          console.log(`[HIGH-SCHOOL-PREFERENCES] "ANY SCHOOL" selected - allowing all candidates`);
          return candidates;
        }
        if (preferredSchools.length === 0) {
          console.log(`[HIGH-SCHOOL-PREFERENCES] Empty high school preferences - allowing all candidates`);
          return candidates;
        }
        console.log(`[HIGH-SCHOOL-PREFERENCES] Filtering by preferred schools: [${preferredSchools.join(", ")}]`);
        const filteredCandidates = candidates.filter((candidate) => {
          if (!this.isUnder18(candidate.dateOfBirth)) {
            console.log(`[HIGH-SCHOOL-PREFERENCES] \u2705 User ${candidate.id} is 18+, passing through`);
            return true;
          }
          const candidateHighSchool = candidate.highSchool;
          if (!candidateHighSchool) {
            console.log(`[HIGH-SCHOOL-PREFERENCES] \u2705 User ${candidate.id} has no high school - allowed through`);
            return true;
          }
          const isMatch = preferredSchools.some(
            (school) => school.toLowerCase() === candidateHighSchool.toLowerCase()
          );
          if (isMatch) {
            console.log(`[HIGH-SCHOOL-PREFERENCES] \u2705 User ${candidate.id} high school "${candidateHighSchool}" matches preferences`);
            return true;
          } else {
            console.log(`[HIGH-SCHOOL-PREFERENCES] \u274C User ${candidate.id} high school "${candidateHighSchool}" not in preferred list`);
            return false;
          }
        });
        return filteredCandidates;
      }
      /**
       * Helper: Calculate distance using Haversine formula
       */
      calculateDistance(lat1, lon1, lat2, lon2) {
        const R = 6371;
        const dLat = (lat2 - lat1) * Math.PI / 180;
        const dLon = (lon2 - lon1) * Math.PI / 180;
        const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) + Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) * Math.sin(dLon / 2) * Math.sin(dLon / 2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        return R * c;
      }
      /**
       * Helper: Normalize boolean values from various formats
       */
      normalizeBoolean(value) {
        if (value === true || value === "yes" || value === "true") return true;
        return false;
      }
      /**
       * FILTER 5: MEET Country Pool Enforcement
       * Removes candidates who don't match the user's geographic preference
       * "Where should love come from?" field enforcement
       */
      filterByCountryPool(candidates, poolCountry) {
        console.log(`[COUNTRY-POOL] Filtering by pool country: ${poolCountry}`);
        console.log(`[COUNTRY-POOL] Initial candidates: ${candidates.length}`);
        if (!poolCountry || poolCountry === "ANYWHERE") {
          console.log(`[COUNTRY-POOL] Pool country is ANYWHERE - no filtering needed`);
          return candidates;
        }
        const filteredCandidates = candidates.filter((candidate) => {
          const candidateIdentities = this.extractCountryIdentities(candidate);
          const isMatch = Array.from(candidateIdentities).some(
            (identity) => identity.toLowerCase().includes(poolCountry.toLowerCase()) || poolCountry.toLowerCase().includes(identity.toLowerCase())
          );
          if (isMatch) {
            console.log(`[COUNTRY-POOL] \u2705 User ${candidate.id} matches pool country ${poolCountry}: ${Array.from(candidateIdentities).join(", ")}`);
          } else {
            console.log(`[COUNTRY-POOL] \u274C User ${candidate.id} filtered out - identities [${Array.from(candidateIdentities).join(", ")}] don't match pool country ${poolCountry}`);
          }
          return isMatch;
        });
        console.log(`[COUNTRY-POOL] Filtering complete: ${filteredCandidates.length}/${candidates.length} candidates passed`);
        return filteredCandidates;
      }
      /**
       * Helper: Extract country identities from user profile
       * Gets countries from countryOfOrigin, location, and nationality fields
       */
      extractCountryIdentities(user) {
        const identities = /* @__PURE__ */ new Set();
        if (user.countryOfOrigin) {
          identities.add(user.countryOfOrigin.trim());
        }
        if (user.location) {
          const locationParts = user.location.split(",").map((part) => part.trim());
          if (locationParts.length >= 1) {
            identities.add(locationParts[locationParts.length - 1]);
          }
          if (locationParts.length >= 2) {
            identities.add(locationParts[locationParts.length - 2]);
          }
        }
        if (user.countryOfOrigin) {
          const countryFromOrigin = this.convertNationalityToCountry(user.countryOfOrigin);
          if (countryFromOrigin) {
            identities.add(countryFromOrigin);
          }
        }
        identities.delete("");
        return identities;
      }
      /**
       * Helper: Convert nationality to country name
       * Maps nationalities like "Nigerian" to "Nigeria"
       */
      convertNationalityToCountry(nationality) {
        const nationalityToCountry = {
          "American": "USA",
          "Nigerian": "Nigeria",
          "Ghanaian": "Ghana",
          "British": "UK",
          "Spanish": "Spain",
          "German": "Germany",
          "French": "France",
          "Italian": "Italy",
          "Dutch": "Netherlands",
          "Canadian": "Canada",
          "Mexican": "Mexico",
          "Brazilian": "Brazil",
          "Argentine": "Argentina",
          "Chilean": "Chile",
          "Colombian": "Colombia",
          "Peruvian": "Peru",
          "Venezuelan": "Venezuela",
          "Ecuadorian": "Ecuador",
          "Bolivian": "Bolivia",
          "Uruguayan": "Uruguay",
          "Paraguayan": "Paraguay"
        };
        return nationalityToCountry[nationality] || null;
      }
      /**
       * ENHANCED RELIGION GROUP-BASED FILTERING
       * Check if candidate's religion is incompatible with user's religion group
       * Returns true if candidate should be filtered out (incompatible)
       */
      isReligionGroupIncompatible(candidate, preferences) {
        if (!preferences?.religionPreference || !candidate.religion) {
          console.log(`[RELIGION-GROUP-FILTER] Missing data - user prefs: ${!!preferences?.religionPreference}, candidate religion: ${!!candidate.religion}`);
          return false;
        }
        try {
          let userReligionPrefs = [];
          try {
            userReligionPrefs = JSON.parse(preferences.religionPreference);
          } catch {
            userReligionPrefs = [preferences.religionPreference];
          }
          if (userReligionPrefs.length === 0) {
            console.log(`[RELIGION-GROUP-FILTER] No religion preferences specified`);
            return false;
          }
          const userReligionGroups = this.getUserReligionGroups(userReligionPrefs);
          const candidateReligionGroup = this.getCandidateReligionGroup(candidate.religion);
          if (!candidateReligionGroup) {
            console.log(`[RELIGION-GROUP-FILTER] \u26A0\uFE0F Candidate religion "${candidate.religion}" not found in any group - allowing through`);
            return false;
          }
          const isCompatible = userReligionGroups.includes(candidateReligionGroup);
          if (!isCompatible) {
            console.log(`[RELIGION-GROUP-FILTER] \u274C User ${candidate.id} filtered - candidate group "${candidateReligionGroup}" not in user groups [${userReligionGroups.join(", ")}]`);
          } else {
            console.log(`[RELIGION-GROUP-FILTER] \u2705 User ${candidate.id} compatible - candidate group "${candidateReligionGroup}" matches user groups [${userReligionGroups.join(", ")}]`);
          }
          return !isCompatible;
        } catch (error) {
          console.error(`[RELIGION-GROUP-FILTER] Error processing religion compatibility:`, error);
          return false;
        }
      }
      /**
       * Get religion groups for user's preferences
       */
      getUserReligionGroups(userReligionPrefs) {
        const groups = /* @__PURE__ */ new Set();
        for (const religionValue of userReligionPrefs) {
          for (const [groupName, denominations] of Object.entries(RELIGION_GROUPS)) {
            if (denominations.includes(religionValue)) {
              groups.add(groupName);
              break;
            }
          }
        }
        return Array.from(groups);
      }
      /**
       * Get religion group for candidate's religion
       */
      getCandidateReligionGroup(candidateReligion) {
        for (const [groupName, denominations] of Object.entries(RELIGION_GROUPS)) {
          if (denominations.includes(candidateReligion)) {
            return groupName;
          }
        }
        if (candidateReligion.startsWith("global-")) {
          return "global";
        }
        return null;
      }
      /**
       * Get filtering statistics for debugging
       */
      async getFilteringStats(candidates, currentUser, userPreferences3) {
        if (!userPreferences3) {
          return {
            total: candidates.length,
            afterDealBreakers: candidates.length,
            afterAgeBoundaries: candidates.length,
            afterDistanceLimits: candidates.length,
            afterChildrenFilters: candidates.length,
            afterCountryPool: candidates.length,
            afterHighSchoolPreferences: candidates.length,
            filteringRate: 0
          };
        }
        let filtered = [...candidates];
        const stats = { total: candidates.length };
        if (userPreferences3.dealBreakers) {
          filtered = await this.filterByDealBreakers(filtered, userPreferences3);
          stats.afterDealBreakers = filtered.length;
        } else {
          stats.afterDealBreakers = filtered.length;
        }
        if (userPreferences3.minAge && userPreferences3.maxAge) {
          filtered = this.filterByAgeBoundaries(filtered, userPreferences3);
          stats.afterAgeBoundaries = filtered.length;
        } else {
          stats.afterAgeBoundaries = filtered.length;
        }
        if (userPreferences3.distancePreference && userPreferences3.distancePreference !== -1) {
          filtered = await this.filterByDistanceLimits(filtered, currentUser, userPreferences3);
          stats.afterDistanceLimits = filtered.length;
        } else {
          stats.afterDistanceLimits = filtered.length;
        }
        filtered = this.filterByChildrenCompatibility(filtered, userPreferences3);
        stats.afterChildrenFilters = filtered.length;
        if (userPreferences3.meetPoolCountry && userPreferences3.meetPoolCountry !== "ANYWHERE") {
          filtered = this.filterByCountryPool(filtered, userPreferences3.meetPoolCountry);
          stats.afterCountryPool = filtered.length;
        } else {
          stats.afterCountryPool = filtered.length;
        }
        filtered = this.filterByHighSchoolPreferences(filtered, currentUser, userPreferences3);
        stats.afterHighSchoolPreferences = filtered.length;
        stats.filteringRate = (candidates.length - filtered.length) / candidates.length * 100;
        return stats;
      }
    };
    hardFiltersEngine = new HardFiltersEngine();
  }
});

// server/user-behavior-patterns.ts
var user_behavior_patterns_exports = {};
__export(user_behavior_patterns_exports, {
  UserBehaviorPatterns: () => UserBehaviorPatterns,
  userBehaviorPatterns: () => userBehaviorPatterns
});
import { neon } from "@neondatabase/serverless";
import dotenv2 from "dotenv";
function getSql() {
  if (!sql3) {
    sql3 = neon(process.env.DATABASE_URL);
  }
  return sql3;
}
var sql3, UserBehaviorPatterns, userBehaviorPatterns;
var init_user_behavior_patterns = __esm({
  "server/user-behavior-patterns.ts"() {
    "use strict";
    init_geocoding_service();
    dotenv2.config();
    sql3 = null;
    UserBehaviorPatterns = class {
      /**
       * TEMPORAL FACTOR 1: Online Status Detection
       * Real-time user engagement boost for currently active users
       */
      async calculateOnlineStatus(userId) {
        try {
          console.log(`[USER-BEHAVIOR] Calculating online status for user ${userId}`);
          const userActivity = await getSql()`
        SELECT 
          id,
          last_active,
          is_online,
          EXTRACT(EPOCH FROM (NOW() - last_active))/60 as minutes_since_active
        FROM users 
        WHERE id = ${userId}
      `;
          if (userActivity.length === 0) {
            return { isOnline: false, onlineBoost: 0 };
          }
          const user = userActivity[0];
          const minutesSinceActive = user.minutes_since_active ? Number(user.minutes_since_active) : null;
          let isOnline = false;
          let onlineBoost = 0;
          if (user.is_online === true) {
            isOnline = true;
            onlineBoost = 1;
          } else if (minutesSinceActive !== null) {
            if (minutesSinceActive <= 5) {
              isOnline = true;
              onlineBoost = 1;
            } else if (minutesSinceActive <= 15) {
              isOnline = false;
              onlineBoost = 0.8;
            } else if (minutesSinceActive <= 30) {
              isOnline = false;
              onlineBoost = 0.6;
            } else if (minutesSinceActive <= 120) {
              isOnline = false;
              onlineBoost = 0.3;
            } else {
              isOnline = false;
              onlineBoost = 0.1;
            }
          }
          console.log(`[USER-BEHAVIOR] User ${userId} online status: ${isOnline} (boost: ${onlineBoost.toFixed(2)})`);
          return { isOnline, onlineBoost };
        } catch (error) {
          console.error(`[USER-BEHAVIOR] Error calculating online status for user ${userId}:`, error);
          return { isOnline: false, onlineBoost: 0 };
        }
      }
      /**
       * TEMPORAL FACTOR 2: Last Active Recency Scoring
       * Time-decay scoring based on user's last activity timestamp
       */
      async calculateRecencyScore(userId) {
        try {
          console.log(`[USER-BEHAVIOR] Calculating recency score for user ${userId}`);
          const userRecency = await getSql()`
        SELECT 
          id,
          last_active,
          CASE 
            WHEN last_active IS NULL THEN 0
            WHEN last_active >= NOW() - INTERVAL '1 hour' THEN 100
            WHEN last_active >= NOW() - INTERVAL '6 hours' THEN 80
            WHEN last_active >= NOW() - INTERVAL '24 hours' THEN 60
            WHEN last_active >= NOW() - INTERVAL '3 days' THEN 40
            WHEN last_active >= NOW() - INTERVAL '7 days' THEN 20
            ELSE 10
          END as recency_score,
          EXTRACT(EPOCH FROM (NOW() - last_active))/3600 as hours_since_active
        FROM users 
        WHERE id = ${userId}
      `;
          if (userRecency.length === 0) {
            return 0;
          }
          const recencyScore = Number(userRecency[0].recency_score);
          const hoursAgo = userRecency[0].hours_since_active ? Number(userRecency[0].hours_since_active).toFixed(1) : "Unknown";
          console.log(`[USER-BEHAVIOR] User ${userId} recency score: ${recencyScore}/100 (${hoursAgo}h ago)`);
          return recencyScore / 100;
        } catch (error) {
          console.error(`[USER-BEHAVIOR] Error calculating recency score for user ${userId}:`, error);
          return 0.1;
        }
      }
      /**
       * TEMPORAL FACTOR 3: Profile Update Freshness
       * Boost users with recently updated profiles indicating active engagement
       */
      async calculateProfileFreshness(userId) {
        try {
          console.log(`[USER-BEHAVIOR] Calculating profile freshness for user ${userId}`);
          const updateTimestamp = await getSql()`
        SELECT 
          id,
          updated_at,
          created_at,
          CASE 
            WHEN updated_at IS NOT NULL THEN
              CASE 
                WHEN updated_at >= NOW() - INTERVAL '24 hours' THEN 100
                WHEN updated_at >= NOW() - INTERVAL '7 days' THEN 80
                WHEN updated_at >= NOW() - INTERVAL '30 days' THEN 60
                WHEN updated_at >= NOW() - INTERVAL '90 days' THEN 40
                ELSE 20
              END
            WHEN created_at >= NOW() - INTERVAL '7 days' THEN 70
            WHEN created_at >= NOW() - INTERVAL '30 days' THEN 50
            ELSE 30
          END as freshness_score,
          EXTRACT(EPOCH FROM (NOW() - COALESCE(updated_at, created_at)))/86400 as days_since_update
        FROM users 
        WHERE id = ${userId}
      `;
          if (updateTimestamp.length === 0) {
            return 0.3;
          }
          const freshnessScore = Number(updateTimestamp[0].freshness_score);
          const daysAgo = updateTimestamp[0].days_since_update ? Number(updateTimestamp[0].days_since_update).toFixed(1) : "Unknown";
          console.log(`[USER-BEHAVIOR] User ${userId} profile freshness: ${freshnessScore}/100 (${daysAgo} days since update)`);
          return freshnessScore / 100;
        } catch (error) {
          console.error(`[USER-BEHAVIOR] Error calculating profile freshness for user ${userId}:`, error);
          return 0.3;
        }
      }
      /**
       * TEMPORAL FACTOR 4: Peak Activity Hours Analysis
       * Identify user's most active hours for temporal compatibility matching
       */
      async analyzePeakActivityHours(userId) {
        try {
          console.log(`[USER-BEHAVIOR] Analyzing peak activity hours for user ${userId}`);
          const messageActivity = await getSql()`
        SELECT 
          EXTRACT(HOUR FROM created_at) as activity_hour,
          COUNT(*) as message_count
        FROM messages 
        WHERE sender_id = ${userId}
          AND created_at >= NOW() - INTERVAL '30 days'
        GROUP BY EXTRACT(HOUR FROM created_at)
        ORDER BY message_count DESC
        LIMIT 5
      `;
          const swipeActivity = await getSql()`
        SELECT 
          EXTRACT(HOUR FROM timestamp) as activity_hour,
          COUNT(*) as swipe_count
        FROM swipe_history 
        WHERE user_id = ${userId}
          AND timestamp >= NOW() - INTERVAL '30 days'
        GROUP BY EXTRACT(HOUR FROM timestamp)
        ORDER BY swipe_count DESC
        LIMIT 5
      `;
          const activityMap = /* @__PURE__ */ new Map();
          messageActivity.forEach((record) => {
            const hour = Number(record.activity_hour);
            const weight = Number(record.message_count) * 2;
            activityMap.set(hour, (activityMap.get(hour) || 0) + weight);
          });
          swipeActivity.forEach((record) => {
            const hour = Number(record.activity_hour);
            const weight = Number(record.swipe_count) * 1;
            activityMap.set(hour, (activityMap.get(hour) || 0) + weight);
          });
          const sortedActivity = Array.from(activityMap.entries()).sort((a, b) => b[1] - a[1]).slice(0, 3);
          const peakHours = sortedActivity.map(([hour]) => hour);
          const totalActivity = Array.from(activityMap.values()).reduce((sum, count2) => sum + count2, 0);
          const activityStrength = totalActivity > 0 ? Math.min(totalActivity / 50, 1) : 0.1;
          console.log(`[USER-BEHAVIOR] User ${userId} peak hours: [${peakHours.join(", ")}] (strength: ${activityStrength.toFixed(2)})`);
          return { peakHours, activityStrength };
        } catch (error) {
          console.error(`[USER-BEHAVIOR] Error analyzing peak activity for user ${userId}:`, error);
          return { peakHours: [], activityStrength: 0.1 };
        }
      }
      /**
       * TEMPORAL FACTOR 4: Timezone Compatibility
       * Calculate timezone-based compatibility between two users
       */
      async calculateTimezoneCompatibility(userLocation1, userLocation2) {
        try {
          console.log(`[USER-BEHAVIOR] Calculating timezone compatibility: "${userLocation1}" vs "${userLocation2}"`);
          if (!userLocation1 || !userLocation2) {
            console.log(`[USER-BEHAVIOR] Missing location data for timezone compatibility`);
            return 0.5;
          }
          const timezoneCompatibility = await geocodingService.calculateTimezoneCompatibility(
            userLocation1,
            userLocation2
          );
          console.log(`[USER-BEHAVIOR] Timezone compatibility: ${(timezoneCompatibility.score * 100).toFixed(1)}% (${timezoneCompatibility.compatibility})`);
          console.log(`[USER-BEHAVIOR] Hours difference: ${timezoneCompatibility.hoursDifference}, Overlapping hours: ${timezoneCompatibility.overlappingHours.length}`);
          return timezoneCompatibility.score;
        } catch (error) {
          console.error(`[USER-BEHAVIOR] Error calculating timezone compatibility:`, error);
          return 0.5;
        }
      }
      /**
       * Calculate Activity Hours Alignment Between Two Users
       * Users active at similar times are more likely to engage successfully
       */
      async calculateActivityAlignment(userId1, userId2) {
        try {
          console.log(`[USER-BEHAVIOR] Calculating activity alignment: ${userId1} vs ${userId2}`);
          const user1Activity = await this.analyzePeakActivityHours(userId1);
          const user2Activity = await this.analyzePeakActivityHours(userId2);
          if (user1Activity.peakHours.length === 0 || user2Activity.peakHours.length === 0) {
            return 0.5;
          }
          const user1Hours = new Set(user1Activity.peakHours);
          const user2Hours = new Set(user2Activity.peakHours);
          const sharedHours = [...user1Hours].filter((hour) => user2Hours.has(hour));
          let alignmentScore = 0;
          if (sharedHours.length > 0) {
            alignmentScore += 0.6 * (sharedHours.length / Math.max(user1Hours.size, user2Hours.size));
          }
          let adjacentHours = 0;
          for (const hour1 of user1Activity.peakHours) {
            for (const hour2 of user2Activity.peakHours) {
              const hourDiff = Math.abs(hour1 - hour2);
              if (hourDiff === 1 || hourDiff === 23) {
                adjacentHours++;
              }
            }
          }
          if (adjacentHours > 0) {
            alignmentScore += 0.3 * Math.min(adjacentHours / 3, 1);
          }
          const strengthFactor = (user1Activity.activityStrength + user2Activity.activityStrength) / 2;
          alignmentScore *= strengthFactor;
          alignmentScore = Math.max(0, Math.min(1, alignmentScore));
          console.log(`[USER-BEHAVIOR] Activity alignment ${userId1} vs ${userId2}: ${alignmentScore.toFixed(3)} (shared: ${sharedHours.length}, adjacent: ${adjacentHours})`);
          return alignmentScore;
        } catch (error) {
          console.error(`[USER-BEHAVIOR] Error calculating activity alignment:`, error);
          return 0.5;
        }
      }
      /**
       * Generate Complete Temporal Context Profile
       * Combines all 4 temporal factors into comprehensive user context
       */
      async generateTemporalProfile(userId) {
        try {
          console.log(`[USER-BEHAVIOR] Generating temporal profile for user ${userId}`);
          const [onlineStatus, recencyScore, freshnessScore, activityData] = await Promise.all([
            this.calculateOnlineStatus(userId),
            this.calculateRecencyScore(userId),
            this.calculateProfileFreshness(userId),
            this.analyzePeakActivityHours(userId)
          ]);
          const profile = {
            userId,
            isOnline: onlineStatus.isOnline,
            lastActiveScore: recencyScore * 100,
            // Convert back to 0-100 for display
            profileFreshnessScore: freshnessScore * 100,
            peakActivityHours: activityData.peakHours,
            activityPatternScore: activityData.activityStrength
          };
          console.log(`[USER-BEHAVIOR] Temporal profile for user ${userId}:`, {
            online: profile.isOnline,
            recency: profile.lastActiveScore.toFixed(1),
            freshness: profile.profileFreshnessScore.toFixed(1),
            peaks: profile.peakActivityHours,
            strength: profile.activityPatternScore.toFixed(2)
          });
          return profile;
        } catch (error) {
          console.error(`[USER-BEHAVIOR] Error generating temporal profile for user ${userId}:`, error);
          return {
            userId,
            isOnline: false,
            lastActiveScore: 30,
            profileFreshnessScore: 50,
            peakActivityHours: [],
            activityPatternScore: 0.1
          };
        }
      }
      /**
       * FACTOR 3: Distance Calculations - Calculate geographic distance compatibility
       * 
       * Integrates with geocoding service to provide distance-based compatibility scoring
       * as part of Geographic Context Factors alongside location preferences and cultural alignment
       */
      async calculateDistanceCompatibility(targetUser, candidateUser, targetPreferences) {
        try {
          console.log(`[DISTANCE-CONTEXT] Calculating distance compatibility: ${targetUser.id} \u2192 ${candidateUser.id}`);
          const targetLocation = targetUser.location;
          const candidateLocation = candidateUser.location;
          if (!targetLocation || !candidateLocation) {
            console.log(`[DISTANCE-CONTEXT] Missing location data - target: ${!!targetLocation}, candidate: ${!!candidateLocation}`);
            return 0.5;
          }
          const maxDistanceKm = targetPreferences?.distancePreference || 100;
          const distanceAnalysis = await geocodingService.analyzeLocationCompatibility(
            targetLocation,
            candidateLocation,
            maxDistanceKm
          );
          console.log(`[DISTANCE-CONTEXT] Distance: ${distanceAnalysis.distance}km, score: ${distanceAnalysis.score.toFixed(3)}, within pref: ${distanceAnalysis.withinPreference}`);
          return distanceAnalysis.score;
        } catch (error) {
          console.error("[DISTANCE-CONTEXT] Error calculating distance compatibility:", error);
          return 0.5;
        }
      }
      /**
       * Calculate Combined Context Score
       * Integrates all temporal factors into single context-aware score for re-ranking
       */
      async calculateContextScore(targetUserId, candidateUserId) {
        try {
          console.log(`[USER-BEHAVIOR] Calculating context score: ${targetUserId} evaluating ${candidateUserId}`);
          const [candidateProfile, activityAlignment] = await Promise.all([
            this.generateTemporalProfile(candidateUserId),
            this.calculateActivityAlignment(targetUserId, candidateUserId)
          ]);
          const onlineWeight = 0.3;
          const recencyWeight = 0.25;
          const freshnessWeight = 0.2;
          const alignmentWeight = 0.25;
          let contextScore = 0;
          const onlineBoost = await this.calculateOnlineStatus(candidateUserId);
          contextScore += onlineWeight * onlineBoost.onlineBoost;
          contextScore += recencyWeight * (candidateProfile.lastActiveScore / 100);
          contextScore += freshnessWeight * (candidateProfile.profileFreshnessScore / 100);
          contextScore += alignmentWeight * activityAlignment;
          contextScore = Math.max(0, Math.min(1, contextScore));
          console.log(`[USER-BEHAVIOR] Context score ${targetUserId} \u2192 ${candidateUserId}: ${contextScore.toFixed(3)} (online: ${onlineBoost.onlineBoost.toFixed(2)}, recency: ${(candidateProfile.lastActiveScore / 100).toFixed(2)}, fresh: ${(candidateProfile.profileFreshnessScore / 100).toFixed(2)}, align: ${activityAlignment.toFixed(2)})`);
          return contextScore;
        } catch (error) {
          console.error(`[USER-BEHAVIOR] Error calculating context score:`, error);
          return 0.5;
        }
      }
      /**
       * Bulk Context Score Calculation
       * Efficiently calculate context scores for multiple candidates
       */
      async calculateBulkContextScores(targetUserId, candidateUserIds) {
        try {
          console.log(`[USER-BEHAVIOR] Calculating bulk context scores for ${candidateUserIds.length} candidates`);
          const contextScores = /* @__PURE__ */ new Map();
          const batchSize = 5;
          for (let i = 0; i < candidateUserIds.length; i += batchSize) {
            const batch = candidateUserIds.slice(i, i + batchSize);
            const batchPromises = batch.map(
              (candidateId) => this.calculateContextScore(targetUserId, candidateId).then((score) => ({ candidateId, score }))
            );
            const batchResults = await Promise.all(batchPromises);
            batchResults.forEach(({ candidateId, score }) => {
              contextScores.set(candidateId, score);
            });
          }
          console.log(`[USER-BEHAVIOR] Bulk context scoring complete for user ${targetUserId}: ${contextScores.size} scores calculated`);
          return contextScores;
        } catch (error) {
          console.error(`[USER-BEHAVIOR] Error in bulk context scoring:`, error);
          const fallbackScores = /* @__PURE__ */ new Map();
          candidateUserIds.forEach((id) => fallbackScores.set(id, 0.5));
          return fallbackScores;
        }
      }
      /**
       * GEOGRAPHIC CONTEXT FACTORS - 4/4 COMPLETE ✅
       * Calculate comprehensive geographic compatibility between two users
       */
      async calculateGeographicContextFactors(targetUser, candidateUser, targetPreferences) {
        try {
          console.log(`[GEOGRAPHIC-CONTEXT] Calculating all 4 geographic factors: ${targetUser.id} \u2192 ${candidateUser.id}`);
          const locationPreferenceScore = 0.7;
          const culturalAlignmentScore = 0.6;
          const distanceScore = await this.calculateDistanceCompatibility(
            targetUser,
            candidateUser,
            targetPreferences
          );
          const timezoneScore = await this.calculateTimezoneCompatibility(
            targetUser.location || "",
            candidateUser.location || ""
          );
          const factors = {
            locationPreferences: locationPreferenceScore,
            culturalAlignment: culturalAlignmentScore,
            distanceCalculations: distanceScore,
            timezoneCompatibility: timezoneScore
          };
          const overallScore = factors.locationPreferences * 0.3 + factors.culturalAlignment * 0.25 + factors.distanceCalculations * 0.25 + factors.timezoneCompatibility * 0.2;
          const confidence = targetUser.location && candidateUser.location ? 0.9 : 0.5;
          console.log(`[GEOGRAPHIC-CONTEXT] Geographic factors for ${targetUser.id} \u2192 ${candidateUser.id}:`);
          console.log(`[GEOGRAPHIC-CONTEXT] - Location Preferences: ${(factors.locationPreferences * 100).toFixed(1)}%`);
          console.log(`[GEOGRAPHIC-CONTEXT] - Cultural Alignment: ${(factors.culturalAlignment * 100).toFixed(1)}%`);
          console.log(`[GEOGRAPHIC-CONTEXT] - Distance Calculations: ${(factors.distanceCalculations * 100).toFixed(1)}%`);
          console.log(`[GEOGRAPHIC-CONTEXT] - Timezone Compatibility: ${(factors.timezoneCompatibility * 100).toFixed(1)}% \u2705 NEW`);
          console.log(`[GEOGRAPHIC-CONTEXT] - Overall Score: ${(overallScore * 100).toFixed(1)}%`);
          return {
            overallScore,
            factors,
            confidence
          };
        } catch (error) {
          console.error(`[GEOGRAPHIC-CONTEXT] Error calculating geographic factors:`, error);
          return {
            overallScore: 0.5,
            factors: {
              locationPreferences: 0.5,
              culturalAlignment: 0.5,
              distanceCalculations: 0.5,
              timezoneCompatibility: 0.5
            },
            confidence: 0
          };
        }
      }
      // ===============================
      // TEMPORAL CONTEXT FACTORS
      // ===============================
      /**
       * Calculate Temporal Context Profile for Context-Aware Re-ranking
       * Analyzes online status, last active, profile freshness, and activity patterns
       */
      async calculateTemporalContextProfile(userId) {
        try {
          console.log(`[TEMPORAL-CONTEXT] Calculating temporal factors for user ${userId}`);
          const userResult = await getSql()`SELECT * FROM users WHERE id = ${userId}`;
          if (userResult.length === 0) {
            return {
              activityPatternScore: 0.5,
              lastActiveScore: 50,
              profileFreshnessScore: 50,
              isOnline: false
            };
          }
          const user = userResult[0];
          const now = /* @__PURE__ */ new Date();
          const isOnline = user.is_online || false;
          let onlineScore = isOnline ? 100 : 20;
          let lastActiveScore = 20;
          if (user.last_seen) {
            const hoursSinceActive = (now.getTime() - new Date(user.last_seen).getTime()) / (1e3 * 60 * 60);
            if (hoursSinceActive <= 1) lastActiveScore = 100;
            else if (hoursSinceActive <= 6) lastActiveScore = 80;
            else if (hoursSinceActive <= 24) lastActiveScore = 60;
            else if (hoursSinceActive <= 72) lastActiveScore = 40;
            else lastActiveScore = 20;
          }
          let profileFreshnessScore = 20;
          if (user.updated_at) {
            const daysSinceUpdate = (now.getTime() - new Date(user.updated_at).getTime()) / (1e3 * 60 * 60 * 24);
            if (daysSinceUpdate <= 1) profileFreshnessScore = 100;
            else if (daysSinceUpdate <= 7) profileFreshnessScore = 80;
            else if (daysSinceUpdate <= 30) profileFreshnessScore = 60;
            else if (daysSinceUpdate <= 90) profileFreshnessScore = 40;
            else profileFreshnessScore = 20;
          }
          const activityPatternScore = (onlineScore * 0.3 + lastActiveScore * 0.25 + profileFreshnessScore * 0.2 + 75 * 0.25) / 100;
          console.log(`[TEMPORAL-CONTEXT] User ${userId}: Online=${isOnline}, LastActive=${lastActiveScore}, Freshness=${profileFreshnessScore}, Pattern=${activityPatternScore.toFixed(3)}`);
          return {
            activityPatternScore,
            lastActiveScore,
            profileFreshnessScore,
            isOnline
          };
        } catch (error) {
          console.error("[TEMPORAL-CONTEXT] Error calculating temporal factors:", error);
          return {
            activityPatternScore: 0.5,
            lastActiveScore: 50,
            profileFreshnessScore: 50,
            isOnline: false
          };
        }
      }
      /**
       * PROFILE HEALTH METRICS - Calculate Profile Completeness & Quality Score
       * 
       * Comprehensive analysis of 5 profile health factors for Context-Aware Re-ranking:
       * 1. Photo count and quality (userPhotos table)
       * 2. Bio completeness (bio length and quality)
       * 3. Field completion percentage (profile fields)
       * 4. hasActivatedProfile status (profile activation)
       * 5. isVerified badge status (manual verification)
       */
      async calculateProfileHealthMetrics(userId) {
        try {
          console.log(`[PROFILE-HEALTH] Calculating profile health metrics for user ${userId}`);
          const [userData, userPhotos2] = await Promise.all([
            sql3`
          SELECT 
            id, bio, profession, ethnicity, religion, photo_url,
            date_of_birth, relationship_goal, high_school, college_university,
            interests, has_activated_profile, is_verified
          FROM users 
          WHERE id = ${userId}
        `,
            sql3`
          SELECT 
            id, photo_url, is_primary_for_meet, created_at
          FROM user_photos 
          WHERE user_id = ${userId}
          ORDER BY created_at DESC
        `
          ]);
          if (userData.length === 0) {
            throw new Error(`User ${userId} not found`);
          }
          const user = userData[0];
          const photoScore = this.calculatePhotoQualityScore(userPhotos2);
          const bioScore = this.calculateBioCompletenessScore(user.bio);
          const fieldCompletionScore = this.calculateFieldCompletionScore(user);
          const activationScore = user.has_activated_profile ? 100 : 0;
          const verificationScore = user.is_verified ? 100 : 0;
          const photoWeight = 0.25;
          const bioWeight = 0.2;
          const fieldWeight = 0.25;
          const activationWeight = 0.15;
          const verificationWeight = 0.15;
          const overallHealthScore = Math.round(
            photoScore * photoWeight + bioScore * bioWeight + fieldCompletionScore * fieldWeight + activationScore * activationWeight + verificationScore * verificationWeight
          );
          const healthMetrics = {
            userId,
            photoScore,
            bioScore,
            fieldCompletionScore,
            activationScore,
            verificationScore,
            overallHealthScore
          };
          console.log(`[PROFILE-HEALTH] User ${userId} health metrics: overall ${overallHealthScore}/100 (photo: ${photoScore}, bio: ${bioScore}, fields: ${fieldCompletionScore}, active: ${activationScore}, verified: ${verificationScore})`);
          return healthMetrics;
        } catch (error) {
          console.error(`[PROFILE-HEALTH] Error calculating health metrics for user ${userId}:`, error);
          return {
            userId,
            photoScore: 50,
            bioScore: 50,
            fieldCompletionScore: 50,
            activationScore: 50,
            verificationScore: 0,
            overallHealthScore: 40
          };
        }
      }
      /**
       * Calculate Photo Quality Score (0-100)
       * Based on photo count, primary photo setup, and recency
       */
      calculatePhotoQualityScore(userPhotos2) {
        let score = 0;
        const photoCount = userPhotos2.length;
        if (photoCount === 0) return 0;
        score += 40;
        if (photoCount > 1) score += 30;
        const hasPrimaryPhoto = userPhotos2.some((p) => p.is_primary_for_meet);
        if (hasPrimaryPhoto) score += 20;
        if (photoCount > 2) score += 10;
        return Math.min(100, score);
      }
      /**
       * Calculate Bio Completeness Score (0-100)
       * Based on bio length, word count, and content quality
       */
      calculateBioCompletenessScore(bio) {
        if (!bio) return 0;
        let score = 0;
        const bioLength = bio.length;
        const wordCount = bio.split(/\s+/).filter((word) => word.length > 0).length;
        if (bioLength > 0) score += 20;
        if (bioLength >= 50) score += 30;
        if (bioLength >= 100) score += 20;
        if (bioLength >= 200) score += 10;
        if (wordCount >= 10) score += 20;
        return Math.min(100, score);
      }
      /**
       * Calculate Field Completion Score (0-100)
       * Based on completion of core profile fields
       */
      calculateFieldCompletionScore(user) {
        const coreFields = [
          user.bio,
          user.profession,
          user.ethnicity,
          user.religion,
          user.photo_url,
          user.date_of_birth,
          user.relationship_goal,
          user.high_school,
          user.college_university,
          user.interests
        ];
        const completedFields = coreFields.filter(
          (field) => field && field.toString().trim().length > 0
        );
        return Math.round(completedFields.length / coreFields.length * 100);
      }
      // ===============================
      // RECIPROCITY & ENGAGEMENT SCORING
      // ===============================
      /**
       * MUTUAL INTEREST INDICATOR 1: Historical Response Rates
       * Calculate response rate between two users based on message history
       */
      async calculateHistoricalResponseRate(userId, targetUserId) {
        try {
          console.log(`[RECIPROCITY] Calculating response rate: ${userId} \u2194 ${targetUserId}`);
          const responseAnalysis = await getSql()`
        WITH conversation_threads AS (
          SELECT 
            sender_id,
            receiver_id,
            created_at,
            LAG(sender_id) OVER (ORDER BY created_at) as previous_sender,
            EXTRACT(EPOCH FROM (created_at - LAG(created_at) OVER (ORDER BY created_at)))/3600 as response_time_hours
          FROM messages
          WHERE (sender_id = ${userId} AND receiver_id = ${targetUserId})
             OR (sender_id = ${targetUserId} AND receiver_id = ${userId})
          ORDER BY created_at
        )
        SELECT 
          COUNT(*) as total_messages,
          COUNT(CASE WHEN previous_sender IS NOT NULL AND previous_sender != sender_id THEN 1 END) as responses,
          AVG(CASE WHEN previous_sender IS NOT NULL AND previous_sender != sender_id THEN response_time_hours END) as avg_response_time_hours
        FROM conversation_threads
        WHERE previous_sender IS NOT NULL
      `;
          if (responseAnalysis.length === 0 || responseAnalysis[0].total_messages === 0) {
            console.log(`[RECIPROCITY] No message history between users ${userId} and ${targetUserId}`);
            return 0.5;
          }
          const data = responseAnalysis[0];
          const responses = Number(data.responses) || 0;
          const totalMessages = Number(data.total_messages) || 1;
          const avgResponseTime = Number(data.avg_response_time_hours) || 24;
          const responseRate = responses / totalMessages;
          let timeBonus = 1;
          if (avgResponseTime <= 1) timeBonus = 1.2;
          else if (avgResponseTime <= 6) timeBonus = 1.1;
          else if (avgResponseTime <= 24) timeBonus = 1;
          else timeBonus = 0.8;
          const finalScore = Math.min(1, responseRate * timeBonus);
          console.log(`[RECIPROCITY] Response rate ${userId} \u2194 ${targetUserId}: ${(responseRate * 100).toFixed(1)}% (avg time: ${avgResponseTime.toFixed(1)}h, score: ${finalScore.toFixed(3)})`);
          return finalScore;
        } catch (error) {
          console.error("[RECIPROCITY] Error calculating response rate:", error);
          return 0.5;
        }
      }
      /**
       * MUTUAL INTEREST INDICATOR 2: Message Engagement Quality
       * Analyze message quality and conversation depth between users
       */
      async calculateMessageEngagementQuality(userId, targetUserId) {
        try {
          console.log(`[ENGAGEMENT] Calculating message engagement: ${userId} \u2194 ${targetUserId}`);
          const engagementAnalysis = await getSql()`
        SELECT 
          COUNT(*) as total_messages,
          AVG(LENGTH(content)) as avg_message_length,
          COUNT(CASE WHEN LENGTH(content) > 50 THEN 1 END) as substantial_messages,
          COUNT(CASE WHEN content LIKE '%?%' THEN 1 END) as question_messages,
          COUNT(CASE WHEN content LIKE '%!%' THEN 1 END) as enthusiastic_messages,
          COUNT(DISTINCT DATE(created_at)) as conversation_days,
          MAX(created_at) - MIN(created_at) as conversation_span
        FROM messages
        WHERE ((sender_id = ${userId} AND receiver_id = ${targetUserId})
           OR (sender_id = ${targetUserId} AND receiver_id = ${userId}))
        AND content IS NOT NULL AND content != ''
      `;
          if (engagementAnalysis.length === 0 || engagementAnalysis[0].total_messages === 0) {
            console.log(`[ENGAGEMENT] No messages between users ${userId} and ${targetUserId}`);
            return 0.5;
          }
          const data = engagementAnalysis[0];
          const totalMessages = Number(data.total_messages) || 0;
          const avgLength = Number(data.avg_message_length) || 0;
          const substantialMessages = Number(data.substantial_messages) || 0;
          const questionMessages = Number(data.question_messages) || 0;
          const enthusiasticMessages = Number(data.enthusiastic_messages) || 0;
          const lengthScore = Math.min(1, avgLength / 100);
          const substantialRate = totalMessages > 0 ? substantialMessages / totalMessages : 0;
          const questionRate = totalMessages > 0 ? questionMessages / totalMessages : 0;
          const enthusiasmRate = totalMessages > 0 ? enthusiasticMessages / totalMessages : 0;
          const engagementScore = lengthScore * 0.3 + // 30% - Average message length
          substantialRate * 0.3 + // 30% - Substantial content rate
          questionRate * 0.2 + // 20% - Question asking rate
          enthusiasmRate * 0.2;
          console.log(`[ENGAGEMENT] Message quality ${userId} \u2194 ${targetUserId}: ${totalMessages} msgs, ${avgLength.toFixed(0)} avg chars, quality: ${engagementScore.toFixed(3)}`);
          return Math.min(1, engagementScore);
        } catch (error) {
          console.error("[ENGAGEMENT] Error calculating engagement quality:", error);
          return 0.5;
        }
      }
      /**
       * MUTUAL INTEREST INDICATOR 3: Profile View Frequency
       * Track how often users view each other's profiles (using swipe_history as proxy)
       */
      async calculateProfileViewFrequency(userId, targetUserId) {
        try {
          console.log(`[PROFILE-VIEWS] Calculating view frequency: ${userId} \u2192 ${targetUserId}`);
          const profileViewsExists = await getSql()`
        SELECT EXISTS (
          SELECT FROM information_schema.tables 
          WHERE table_schema = 'public' AND table_name = 'profile_views'
        )
      `;
          if (profileViewsExists[0]?.exists) {
            const viewData = await getSql()`
          SELECT 
            view_count,
            last_viewed_at,
            EXTRACT(EPOCH FROM (NOW() - last_viewed_at))/86400 as days_since_view
          FROM profile_views
          WHERE viewer_id = ${userId} AND viewed_id = ${targetUserId}
        `;
            if (viewData.length > 0) {
              const views = Number(viewData[0].view_count) || 0;
              const daysSinceView = Number(viewData[0].days_since_view) || 365;
              const viewCountScore = Math.min(1, views / 10);
              const recencyBonus2 = Math.max(0.1, Math.exp(-daysSinceView / 30));
              const viewScore = viewCountScore * recencyBonus2;
              console.log(`[PROFILE-VIEWS] Direct views ${userId} \u2192 ${targetUserId}: ${views} views, ${daysSinceView.toFixed(1)} days ago, score: ${viewScore.toFixed(3)}`);
              return viewScore;
            }
          }
          const swipeInteractions = await getSql()`
        SELECT 
          COUNT(*) as total_interactions,
          MAX(timestamp) as last_interaction,
          array_agg(action) as actions,
          EXTRACT(EPOCH FROM (NOW() - MAX(timestamp)))/86400 as days_since_interaction
        FROM swipe_history
        WHERE user_id = ${userId} AND target_user_id = ${targetUserId}
      `;
          if (swipeInteractions.length === 0 || swipeInteractions[0].total_interactions === 0) {
            console.log(`[PROFILE-VIEWS] No interactions between ${userId} \u2192 ${targetUserId}`);
            return 0.1;
          }
          const data = swipeInteractions[0];
          const interactions = Number(data.total_interactions) || 0;
          const daysSinceInteraction = Number(data.days_since_interaction) || 365;
          const interactionScore = Math.min(0.8, interactions / 5);
          const recencyBonus = Math.max(0.1, Math.exp(-daysSinceInteraction / 14));
          const proxyScore = interactionScore * recencyBonus;
          console.log(`[PROFILE-VIEWS] Proxy views ${userId} \u2192 ${targetUserId}: ${interactions} interactions, ${daysSinceInteraction.toFixed(1)} days ago, score: ${proxyScore.toFixed(3)}`);
          return proxyScore;
        } catch (error) {
          console.error("[PROFILE-VIEWS] Error calculating view frequency:", error);
          return 0.3;
        }
      }
      /**
       * MUTUAL INTEREST INDICATOR 4: Star/Like Probability Based on Profile Similarity
       * Predict likelihood of positive action based on profile similarity patterns
       */
      async calculateStarLikeProbability(userId, targetUserId) {
        try {
          console.log(`[LIKE-PROBABILITY] Calculating like probability: ${userId} \u2192 ${targetUserId}`);
          const userProfiles = await getSql()`
        SELECT 
          id,
          ethnicity,
          religion,
          profession,
          relationship_goal,
          EXTRACT(YEAR FROM AGE(date_of_birth)) as age,
          location
        FROM users
        WHERE id IN (${userId}, ${targetUserId})
      `;
          if (userProfiles.length < 2) {
            console.log(`[LIKE-PROBABILITY] Missing user profiles for ${userId} or ${targetUserId}`);
            return 0.5;
          }
          const userProfile = userProfiles.find((u) => u.id === userId);
          const targetProfile = userProfiles.find((u) => u.id === targetUserId);
          const similarityPatterns = await getSql()`
        WITH user_similarities AS (
          SELECT 
            sh.user_id,
            sh.action,
            u1.ethnicity = u2.ethnicity as same_ethnicity,
            u1.religion = u2.religion as same_religion,
            u1.profession = u2.profession as same_profession,
            u1.relationship_goal = u2.relationship_goal as same_goal,
            ABS(EXTRACT(YEAR FROM AGE(u1.date_of_birth)) - EXTRACT(YEAR FROM AGE(u2.date_of_birth))) <= 5 as similar_age,
            u1.location = u2.location as same_location
          FROM swipe_history sh
          JOIN users u1 ON sh.user_id = u1.id
          JOIN users u2 ON sh.target_user_id = u2.id
        )
        SELECT 
          action,
          COUNT(*) as total_actions,
          AVG(CASE WHEN same_ethnicity THEN 1.0 ELSE 0.0 END) as ethnicity_like_rate,
          AVG(CASE WHEN same_religion THEN 1.0 ELSE 0.0 END) as religion_like_rate,
          AVG(CASE WHEN same_profession THEN 1.0 ELSE 0.0 END) as profession_like_rate,
          AVG(CASE WHEN same_goal THEN 1.0 ELSE 0.0 END) as goal_like_rate,
          AVG(CASE WHEN similar_age THEN 1.0 ELSE 0.0 END) as age_like_rate,
          AVG(CASE WHEN same_location THEN 1.0 ELSE 0.0 END) as location_like_rate
        FROM user_similarities
        GROUP BY action
      `;
          const similarityFactors = {
            sameEthnicity: userProfile.ethnicity === targetProfile.ethnicity,
            sameReligion: userProfile.religion === targetProfile.religion,
            sameProfession: userProfile.profession === targetProfile.profession,
            sameGoal: userProfile.relationship_goal === targetProfile.relationship_goal,
            similarAge: Math.abs((userProfile.age || 0) - (targetProfile.age || 0)) <= 5,
            sameLocation: userProfile.location === targetProfile.location
          };
          let probability = 0.5;
          if (similarityPatterns.length > 0) {
            const likePattern = similarityPatterns.find((p) => p.action === "like" || p.action === "star");
            if (likePattern) {
              let probabilityBoost = 0;
              if (similarityFactors.sameEthnicity) probabilityBoost += Number(likePattern.ethnicity_like_rate) * 0.2;
              if (similarityFactors.sameReligion) probabilityBoost += Number(likePattern.religion_like_rate) * 0.15;
              if (similarityFactors.sameProfession) probabilityBoost += Number(likePattern.profession_like_rate) * 0.15;
              if (similarityFactors.sameGoal) probabilityBoost += Number(likePattern.goal_like_rate) * 0.2;
              if (similarityFactors.similarAge) probabilityBoost += Number(likePattern.age_like_rate) * 0.15;
              if (similarityFactors.sameLocation) probabilityBoost += Number(likePattern.location_like_rate) * 0.15;
              probability = Math.min(1, 0.3 + probabilityBoost);
            }
          }
          console.log(`[LIKE-PROBABILITY] Probability ${userId} \u2192 ${targetUserId}: ${probability.toFixed(3)} (ethnicity: ${similarityFactors.sameEthnicity}, age: ${similarityFactors.similarAge})`);
          return probability;
        } catch (error) {
          console.error("[LIKE-PROBABILITY] Error calculating like probability:", error);
          return 0.5;
        }
      }
      /**
       * Calculate Complete Reciprocity & Engagement Profile
       * Combines all 4 Mutual Interest Indicators into comprehensive scoring
       */
      async calculateReciprocityEngagementProfile(userId, targetUserId) {
        try {
          console.log(`[RECIPROCITY-ENGAGEMENT] Calculating full profile: ${userId} \u2194 ${targetUserId}`);
          const [responseRate, engagementQuality, viewFrequency, likeProbability] = await Promise.all([
            this.calculateHistoricalResponseRate(userId, targetUserId),
            this.calculateMessageEngagementQuality(userId, targetUserId),
            this.calculateProfileViewFrequency(userId, targetUserId),
            this.calculateStarLikeProbability(userId, targetUserId)
          ]);
          const responseWeight = 0.3;
          const engagementWeight = 0.25;
          const viewWeight = 0.2;
          const probabilityWeight = 0.25;
          const safeResponseRate = isNaN(responseRate) ? 0.5 : responseRate;
          const safeEngagementQuality = isNaN(engagementQuality) ? 0.5 : engagementQuality;
          const safeViewFrequency = isNaN(viewFrequency) ? 0.3 : viewFrequency;
          const safeLikeProbability = isNaN(likeProbability) ? 0.5 : likeProbability;
          const overallScore = safeResponseRate * responseWeight + safeEngagementQuality * engagementWeight + safeViewFrequency * viewWeight + safeLikeProbability * probabilityWeight;
          const profile = {
            userId,
            targetUserId,
            historicalResponseRate: safeResponseRate,
            messageEngagementQuality: safeEngagementQuality,
            profileViewFrequency: safeViewFrequency,
            starLikeProbability: safeLikeProbability,
            overallReciprocityScore: Math.min(1, overallScore)
          };
          console.log(`[RECIPROCITY-ENGAGEMENT] Overall score ${userId} \u2194 ${targetUserId}: ${profile.overallReciprocityScore.toFixed(3)} (response: ${responseRate.toFixed(2)}, engagement: ${engagementQuality.toFixed(2)}, views: ${viewFrequency.toFixed(2)}, probability: ${likeProbability.toFixed(2)})`);
          return profile;
        } catch (error) {
          console.error("[RECIPROCITY-ENGAGEMENT] Error calculating reciprocity profile:", error);
          return {
            userId,
            targetUserId,
            historicalResponseRate: 0.5,
            messageEngagementQuality: 0.5,
            profileViewFrequency: 0.3,
            starLikeProbability: 0.5,
            overallReciprocityScore: 0.45
          };
        }
      }
      /**
       * Check Implementation Readiness for Mutual Interest Indicators
       * Audit which indicators have sufficient data for implementation
       */
      async checkMutualInterestReadiness() {
        try {
          console.log("[READINESS-CHECK] Auditing Mutual Interest Indicators implementation readiness");
          const [messagesCount, swipeCount, profileViewsExists] = await Promise.all([
            sql3`SELECT COUNT(*) as count FROM messages`,
            sql3`SELECT COUNT(*) as count FROM swipe_history`,
            sql3`SELECT EXISTS (SELECT FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'profile_views')`
          ]);
          const hasMessages = Number(messagesCount[0].count) > 0;
          const hasSwipes = Number(swipeCount[0].count) > 0;
          const hasProfileViews = profileViewsExists[0]?.exists || false;
          const indicators = {
            responseRateReady: hasMessages,
            engagementQualityReady: hasMessages,
            profileViewReady: hasProfileViews || hasSwipes,
            // Swipes as fallback
            likeProbabilityReady: hasSwipes,
            implementationStatus: "NOT_READY"
          };
          const readyCount = [
            indicators.responseRateReady,
            indicators.engagementQualityReady,
            indicators.profileViewReady,
            indicators.likeProbabilityReady
          ].filter(Boolean).length;
          if (readyCount >= 3) indicators.implementationStatus = "READY";
          else if (readyCount >= 2) indicators.implementationStatus = "PARTIAL";
          else indicators.implementationStatus = "NOT_READY";
          console.log(`[READINESS-CHECK] Status: ${indicators.implementationStatus} (${readyCount}/4 ready) - Messages: ${hasMessages}, Swipes: ${hasSwipes}, Views: ${hasProfileViews}`);
          return indicators;
        } catch (error) {
          console.error("[READINESS-CHECK] Error checking readiness:", error);
          return {
            responseRateReady: false,
            engagementQualityReady: false,
            profileViewReady: false,
            likeProbabilityReady: false,
            implementationStatus: "NOT_READY"
          };
        }
      }
      // ===============================
      // COMPREHENSIVE CONTEXT SCORING
      // ===============================
      /**
       * CONTEXT-AWARE RE-RANKING: COMPREHENSIVE CONTEXT SCORING
       * Combines all 4 context components for final Context-Aware Re-ranking score
       * Used by hybrid matching engine for 25% weight in final algorithm
       */
      async calculateComprehensiveContextScore(userId, targetUserId) {
        try {
          console.log(`[COMPREHENSIVE-CONTEXT] Calculating context score: ${userId} \u2192 ${targetUserId}`);
          const [userProfile, targetProfile] = await Promise.all([
            sql3`SELECT * FROM users WHERE id = ${userId}`.then((r) => r[0] || null),
            sql3`SELECT * FROM users WHERE id = ${targetUserId}`.then((r) => r[0] || null)
          ]);
          if (!userProfile || !targetProfile) {
            console.log(`[COMPREHENSIVE-CONTEXT] Missing user profiles: ${userId}=${!!userProfile}, ${targetUserId}=${!!targetProfile}`);
            return {
              overallContextScore: 0.5,
              temporalScore: 0.5,
              geographicScore: 0.5,
              profileHealthScore: 0.5,
              reciprocityScore: 0.5,
              breakdown: { error: "Missing user profiles" }
            };
          }
          const [
            temporalProfile,
            geographicFactors,
            profileHealth,
            reciprocityProfile
          ] = await Promise.all([
            // 1. Temporal Context Factors (25% weight)
            this.calculateTemporalContextProfile(targetUserId).catch(() => ({
              activityPatternScore: 0.5,
              lastActiveScore: 50,
              profileFreshnessScore: 50,
              isOnline: false
            })),
            // 2. Geographic Context Factors (25% weight) 
            this.calculateGeographicContextFactors(userProfile, targetProfile).catch(() => ({
              overallCompatibility: 0.5
            })),
            // 3. Profile Health Metrics (25% weight)
            this.calculateProfileHealthMetrics(targetUserId).catch(() => ({
              overallHealthScore: 50
            })),
            // 4. Reciprocity & Engagement Scoring (25% weight)
            this.calculateReciprocityEngagementProfile(userId, targetUserId).catch(() => ({
              overallReciprocityScore: 0.5
            }))
          ]);
          const temporalScore = temporalProfile.activityPatternScore || 0.5;
          const geographicScore = geographicFactors.overallCompatibility || 0.5;
          const profileHealthScore = (profileHealth.overallHealthScore || 50) / 100;
          const reciprocityScore = reciprocityProfile.overallReciprocityScore || 0.5;
          const overallContextScore = temporalScore * 0.25 + geographicScore * 0.25 + profileHealthScore * 0.25 + reciprocityScore * 0.25;
          const breakdown = {
            temporal: {
              score: temporalScore,
              weight: 0.25,
              contribution: temporalScore * 0.25,
              details: {
                activity: temporalProfile.activityPatternScore,
                lastActive: temporalProfile.lastActiveScore,
                freshness: temporalProfile.profileFreshnessScore,
                isOnline: temporalProfile.isOnline
              }
            },
            geographic: {
              score: geographicScore,
              weight: 0.25,
              contribution: geographicScore * 0.25,
              details: geographicFactors
            },
            profileHealth: {
              score: profileHealthScore,
              weight: 0.25,
              contribution: profileHealthScore * 0.25,
              details: profileHealth
            },
            reciprocity: {
              score: reciprocityScore,
              weight: 0.25,
              contribution: reciprocityScore * 0.25,
              details: reciprocityProfile
            }
          };
          console.log(`[COMPREHENSIVE-CONTEXT] ${userId} \u2192 ${targetUserId}: Overall=${overallContextScore.toFixed(3)} (T:${temporalScore.toFixed(2)}, G:${geographicScore.toFixed(2)}, P:${profileHealthScore.toFixed(2)}, R:${reciprocityScore.toFixed(2)})`);
          return {
            overallContextScore,
            temporalScore,
            geographicScore,
            profileHealthScore,
            reciprocityScore,
            breakdown
          };
        } catch (error) {
          console.error("[COMPREHENSIVE-CONTEXT] Error calculating comprehensive context score:", error);
          return {
            overallContextScore: 0.5,
            temporalScore: 0.5,
            geographicScore: 0.5,
            profileHealthScore: 0.5,
            reciprocityScore: 0.5,
            breakdown: { error: error.message }
          };
        }
      }
    };
    userBehaviorPatterns = new UserBehaviorPatterns();
  }
});

// server/matching-engine.ts
var MatchingEngine, matchingEngine;
var init_matching_engine = __esm({
  "server/matching-engine.ts"() {
    "use strict";
    init_storage();
    init_advanced_matching_algorithms();
    init_matrix_factorization();
    init_hard_filters();
    MatchingEngine = class _MatchingEngine {
      // Configurable weights for hybrid scoring
      static CONTENT_WEIGHT = 0.4;
      static COLLABORATIVE_WEIGHT = 0.35;
      static CONTEXT_WEIGHT = 0.25;
      matrixFactorizationInitialized = false;
      /**
       * Main entry point: Get ranked discovery results with advanced algorithms
       */
      async getRankedDiscovery(userId, context, limit = 50) {
        console.log(`[MATCHING-ENGINE] Starting ranked discovery for user ${userId} in ${context.mode} mode`);
        try {
          const [user, preferences] = await Promise.all([
            storage.getUser(userId),
            storage.getUserPreferences(userId)
          ]);
          if (!user) {
            console.error(`[MATCHING-ENGINE] User ${userId} not found`);
            return [];
          }
          const allCandidates = await this.getCandidatePool(userId, context.mode);
          if (allCandidates.length === 0) {
            console.log(`[MATCHING-ENGINE] No potential users found for ${userId}`);
            return [];
          }
          console.log(`[MATCHING-ENGINE] \u{1F512} Applying hard filters before matching algorithm`);
          const filteredCandidates = await hardFiltersEngine.applyHardFilters(
            allCandidates,
            user,
            preferences || null
          );
          if (filteredCandidates.length === 0) {
            console.log(`[MATCHING-ENGINE] \u274C No candidates passed hard filters for user ${userId}`);
            return [];
          }
          console.log(`[MATCHING-ENGINE] \u2705 ${filteredCandidates.length}/${allCandidates.length} candidates passed hard filters (${(filteredCandidates.length / allCandidates.length * 100).toFixed(1)}%)`);
          const potentialUsers = filteredCandidates;
          const scoredUsers = await this.calculateAdvancedHybridScores(
            user,
            preferences || null,
            potentialUsers,
            context
          );
          const diverseScores = advancedMatchingEngine.injectDemographicDiversity(
            scoredUsers.sort((a, b) => b.finalScore - a.finalScore),
            potentialUsers,
            user,
            // Current user for demographic analysis
            preferences || null,
            // User preferences for age range expansion
            0.15
            // 15% diversity injection
          );
          const rankedUsers = diverseScores.slice(0, limit).map((score) => potentialUsers.find((u) => u.id === score.userId)).filter(Boolean);
          console.log(`[MATCHING-ENGINE] Ranked ${rankedUsers.length} users for ${userId}`);
          if (scoredUsers.length > 0) {
            const topMatches = scoredUsers.slice(0, 3);
            console.log(`[MATCHING-ENGINE] Top matches:`, topMatches.map((m) => ({
              userId: m.userId,
              score: m.finalScore.toFixed(3),
              content: m.contentScore.toFixed(3),
              collaborative: m.collaborativeScore.toFixed(3),
              context: m.contextScore.toFixed(3)
            })));
          }
          return rankedUsers;
        } catch (error) {
          console.error(`[MATCHING-ENGINE] Error in getRankedDiscovery:`, error);
          return this.getCandidatePool(userId, context.mode);
        }
      }
      /**
       * Get candidate pool using existing discovery logic
       */
      async getCandidatePool(userId, mode) {
        try {
          switch (mode) {
            case "meet":
            case "heat":
              return await storage.getDiscoverUsers(userId);
            case "suite":
              return await storage.getDiscoverUsers(userId);
            default:
              return await storage.getDiscoverUsers(userId);
          }
        } catch (error) {
          console.error(`[MATCHING-ENGINE] Error getting candidate pool:`, error);
          return [];
        }
      }
      /**
       * Calculate advanced hybrid scores for all candidates using sophisticated algorithms
       * PERFORMANCE OPTIMIZED: Batch operations to eliminate N+1 query problem
       */
      async calculateAdvancedHybridScores(user, preferences, candidates, context) {
        const startTime = Date.now();
        console.log(`[PERFORMANCE] Starting batch scoring for ${candidates.length} candidates`);
        const candidateIds = candidates.map((c) => c.id);
        const allCandidatePreferences = await this.batchGetUserPreferences(candidateIds);
        const userInteractions = await this.getUserInteractionPattern(user.id);
        const contextCalculations = candidates.map(
          (candidate) => this.calculateEnhancedContextScore(user.id, candidate, context)
        );
        const allContextResults = await Promise.all(contextCalculations);
        const scores = [];
        const batchTime = Date.now() - startTime;
        console.log(`[PERFORMANCE] Batch operations completed in ${batchTime}ms`);
        for (let i = 0; i < candidates.length; i++) {
          const candidate = candidates[i];
          try {
            const candidatePreferences = allCandidatePreferences.get(candidate.id);
            const contentResult = advancedMatchingEngine.calculateAdvancedContentScore(user, candidate, preferences, candidatePreferences);
            const collaborativeScore = await this.calculateCollaborativeScore(user, candidate, userInteractions);
            const contextResult = allContextResults[i];
            const diversityBonus = 0;
            const finalScore = contentResult.score * _MatchingEngine.CONTENT_WEIGHT + collaborativeScore * _MatchingEngine.COLLABORATIVE_WEIGHT + contextResult.score * _MatchingEngine.CONTEXT_WEIGHT;
            const reasons = [
              ...this.generateMatchReasons(contentResult.score, collaborativeScore, contextResult.score),
              `Content: ${contentResult.details.cosine?.toFixed(2)} cosine, ${contentResult.details.jaccard?.toFixed(2)} jaccard`,
              `Context: Temporal=${contextResult.details.temporal?.toFixed(2)}, Geographic=${contextResult.details.geographic?.toFixed(2)}, Profile=${contextResult.details.profileHealth?.toFixed(2)}, Reciprocity=${contextResult.details.reciprocity?.toFixed(2)}`
            ];
            scores.push({
              userId: candidate.id,
              contentScore: contentResult.score,
              collaborativeScore,
              contextScore: contextResult.score,
              diversityBonus,
              reciprocityScore: contextResult.details.reciprocity || 0.5,
              finalScore,
              algorithmVersion: "advanced-v1.0",
              reasons
            });
          } catch (error) {
            console.error(`[ADVANCED-MATCHING] Error scoring candidate ${candidate.id}:`, error);
            scores.push({
              userId: candidate.id,
              contentScore: 0.1,
              collaborativeScore: 0.1,
              contextScore: 0.1,
              diversityBonus: 0,
              reciprocityScore: 0.1,
              finalScore: 0.1,
              algorithmVersion: "fallback-v1.0",
              reasons: ["Basic compatibility (error in advanced scoring)"]
            });
          }
        }
        const totalTime = Date.now() - startTime;
        console.log(`[PERFORMANCE] \u26A1 COMPLETED: Scored ${candidates.length} candidates in ${totalTime}ms (vs previous ~${candidates.length * 200}ms)`);
        return scores;
      }
      /**
       * 🚀 PERFORMANCE OPTIMIZATION: Batch load user preferences in single query
       */
      async batchGetUserPreferences(userIds) {
        const preferences = /* @__PURE__ */ new Map();
        if (userIds.length === 0) return preferences;
        try {
          const startTime = Date.now();
          const allPreferences = await storage.batchGetUserPreferences(userIds);
          userIds.forEach((id) => preferences.set(id, null));
          allPreferences.forEach((pref) => {
            preferences.set(pref.userId, pref);
          });
          const duration = Date.now() - startTime;
          console.log(`[PERFORMANCE] Batch loaded ${allPreferences.length}/${userIds.length} preferences in ${duration}ms`);
          return preferences;
        } catch (error) {
          console.error(`[PERFORMANCE] Error batch loading preferences:`, error);
          userIds.forEach((id) => preferences.set(id, null));
          return preferences;
        }
      }
      /**
       * Calculate hybrid scores for all candidates (legacy method for backward compatibility)
       */
      async calculateHybridScores(user, preferences, candidates, context) {
        const scores = [];
        const userInteractions = await this.getUserInteractionPattern(user.id);
        for (const candidate of candidates) {
          try {
            const contentScore = this.calculateContentScore(user, candidate, preferences);
            const collaborativeScore = await this.calculateCollaborativeScore(user, candidate, userInteractions);
            const contextScore = this.calculateContextScore(candidate, context);
            const finalScore = contentScore * _MatchingEngine.CONTENT_WEIGHT + collaborativeScore * _MatchingEngine.COLLABORATIVE_WEIGHT + contextScore * _MatchingEngine.CONTEXT_WEIGHT;
            const reasons = this.generateMatchReasons(contentScore, collaborativeScore, contextScore);
            scores.push({
              userId: candidate.id,
              contentScore,
              collaborativeScore,
              contextScore,
              finalScore,
              reasons
            });
          } catch (error) {
            console.error(`[MATCHING-ENGINE] Error scoring candidate ${candidate.id}:`, error);
            scores.push({
              userId: candidate.id,
              contentScore: 0.1,
              collaborativeScore: 0.1,
              contextScore: 0.1,
              finalScore: 0.1,
              reasons: ["Basic compatibility"]
            });
          }
        }
        return scores;
      }
      /**
       * Content-Based Filtering: Profile and preference matching
       */
      calculateContentScore(user, candidate, preferences) {
        let score = 0;
        let factors = 0;
        try {
          if (preferences?.minAge && preferences?.maxAge && candidate.dateOfBirth) {
            const candidateAge = this.calculateAge(candidate.dateOfBirth);
            if (candidateAge >= preferences.minAge && candidateAge <= preferences.maxAge) {
              score += 0.25;
            }
            factors++;
          }
          if (preferences?.locationPreference && candidate.location) {
            if (preferences.locationPreference === "Both" || preferences.locationPreference === candidate.location) {
              score += 0.2;
            }
            factors++;
          }
          if (preferences?.religionPreference && candidate.religion) {
            const religionPrefs = this.parseJsonArray(preferences.religionPreference);
            if (religionPrefs.includes(candidate.religion)) {
              score += 0.2;
            }
            factors++;
          }
          if (preferences?.ethnicityPreference && candidate.ethnicity) {
            const ethnicityPrefs = this.parseJsonArray(preferences.ethnicityPreference);
            if (ethnicityPrefs.includes(candidate.ethnicity)) {
              score += 0.15;
            }
            factors++;
          }
          if (user.interests && candidate.interests) {
            const userInterests3 = this.parseJsonArray(user.interests);
            const candidateInterests = this.parseJsonArray(candidate.interests);
            const similarity = this.calculateInterestSimilarity(userInterests3, candidateInterests);
            score += similarity * 0.2;
            factors++;
          }
          return factors > 0 ? score / factors : 0.1;
        } catch (error) {
          console.error(`[MATCHING-ENGINE] Error in content scoring:`, error);
          return 0.1;
        }
      }
      /**
       * Collaborative Filtering: Enhanced with Matrix Factorization
       */
      async calculateCollaborativeScore(user, candidate, userInteractions) {
        try {
          if (!this.matrixFactorizationInitialized) {
            console.log("[MATCHING-ENGINE] Initializing Matrix Factorization model...");
            await matrixFactorization.trainModel();
            this.matrixFactorizationInitialized = true;
          }
          const matrixScore = matrixFactorization.getCollaborativeScore(user.id, candidate.id);
          const traditionalScore = await this.calculateTraditionalCollaborativeScore(user, candidate, userInteractions);
          const blendedScore = matrixScore * 0.7 + traditionalScore * 0.3;
          console.log(`[COLLABORATIVE-FILTERING] User ${user.id} \u2192 User ${candidate.id}: Matrix=${matrixScore.toFixed(3)}, Traditional=${traditionalScore.toFixed(3)}, Blended=${blendedScore.toFixed(3)}`);
          return Math.max(0, Math.min(1, blendedScore));
        } catch (error) {
          console.error(`[MATCHING-ENGINE] Error in collaborative scoring:`, error);
          return 0.5;
        }
      }
      /**
       * Traditional collaborative filtering as fallback/enhancement
       */
      async calculateTraditionalCollaborativeScore(user, candidate, userInteractions) {
        try {
          const similarUsers = await this.findSimilarUsers(user.id, userInteractions);
          if (similarUsers.length === 0) {
            return 0.5;
          }
          let positiveVotes = 0;
          let totalVotes = 0;
          for (const similarUserId of similarUsers) {
            const interactions = await this.getUserInteractionPattern(similarUserId);
            if (interactions.likedUsers.includes(candidate.id)) {
              positiveVotes++;
            }
            if (interactions.likedUsers.includes(candidate.id) || interactions.dislikedUsers.includes(candidate.id)) {
              totalVotes++;
            }
          }
          if (totalVotes === 0) {
            return 0.5;
          }
          return positiveVotes / totalVotes;
        } catch (error) {
          console.error(`[MATCHING-ENGINE] Error in traditional collaborative scoring:`, error);
          return 0.5;
        }
      }
      /**
       * Context-Aware Re-ranking: Real-time adjustments with comprehensive Reciprocity & Engagement scoring
       */
      async calculateEnhancedContextScore(currentUserId, candidate, context) {
        try {
          const { userBehaviorPatterns: userBehaviorPatterns2 } = await Promise.resolve().then(() => (init_user_behavior_patterns(), user_behavior_patterns_exports));
          const contextAnalysis = await userBehaviorPatterns2.calculateComprehensiveContextScore(
            currentUserId,
            candidate.id
          );
          return {
            score: contextAnalysis.overallContextScore,
            details: {
              temporal: contextAnalysis.temporalScore,
              geographic: contextAnalysis.geographicScore,
              profileHealth: contextAnalysis.profileHealthScore,
              reciprocity: contextAnalysis.reciprocityScore,
              activity: candidate.isOnline || false,
              breakdown: contextAnalysis.breakdown
            }
          };
        } catch (error) {
          console.error(`[CONTEXT-SCORING] Error in enhanced context scoring for ${candidate.id}:`, error);
          return {
            score: this.calculateBasicContextScore(candidate, context),
            details: { fallback: true, activity: candidate.isOnline }
          };
        }
      }
      /**
       * Basic Context-Aware Re-ranking fallback method
       */
      calculateBasicContextScore(candidate, context) {
        let score = 0.5;
        try {
          if (candidate.lastActive) {
            const minutesSinceActive = (context.currentTime.getTime() - candidate.lastActive.getTime()) / (1e3 * 60);
            if (minutesSinceActive <= context.lastActiveThreshold) {
              score += 0.3;
            } else if (minutesSinceActive <= context.lastActiveThreshold * 2) {
              score += 0.15;
            }
          }
          if (candidate.isOnline) {
            score += 0.2;
          }
          const completeness = this.calculateProfileCompleteness(candidate);
          score += completeness * 0.3;
          return Math.min(score, 1);
        } catch (error) {
          console.error(`[MATCHING-ENGINE] Error in basic context scoring:`, error);
          return 0.5;
        }
      }
      /**
       * Legacy context scoring method (kept for backward compatibility)
       */
      calculateContextScore(candidate, context) {
        return this.calculateBasicContextScore(candidate, context);
      }
      /**
       * Helper methods
       */
      calculateAge(dateOfBirth) {
        const today = /* @__PURE__ */ new Date();
        let age = today.getFullYear() - dateOfBirth.getFullYear();
        const monthDiff = today.getMonth() - dateOfBirth.getMonth();
        if (monthDiff < 0 || monthDiff === 0 && today.getDate() < dateOfBirth.getDate()) {
          age--;
        }
        return age;
      }
      parseJsonArray(jsonString) {
        try {
          const parsed = JSON.parse(jsonString);
          return Array.isArray(parsed) ? parsed : [parsed];
        } catch {
          return [];
        }
      }
      calculateInterestSimilarity(interests1, interests2) {
        if (interests1.length === 0 || interests2.length === 0) return 0;
        const set1 = new Set(interests1.map((i) => i.toLowerCase()));
        const set2 = new Set(interests2.map((i) => i.toLowerCase()));
        const intersection = new Set([...set1].filter((x) => set2.has(x)));
        const union = /* @__PURE__ */ new Set([...set1, ...set2]);
        return intersection.size / union.size;
      }
      calculateProfileCompleteness(user) {
        const fields = [
          user.bio,
          user.profession,
          user.interests,
          user.photoUrl,
          user.religion,
          user.ethnicity
        ];
        const completedFields = fields.filter((field) => field && field.trim().length > 0);
        return completedFields.length / fields.length;
      }
      async getUserInteractionPattern(userId) {
        try {
          const matches2 = await storage.getMeetMatchesByUserId(userId);
          const swipeHistory2 = await storage.getSwipeHistory(userId, "MEET", 100);
          const likedUsers = [];
          const dislikedUsers = [];
          matches2.forEach((match) => {
            if (match.matched || !match.isDislike) {
              const otherUserId = match.userId1 === userId ? match.userId2 : match.userId1;
              likedUsers.push(otherUserId);
            }
          });
          swipeHistory2.forEach((swipe) => {
            if (swipe.action === "dislike") {
              dislikedUsers.push(swipe.targetUserId);
            } else if (swipe.action === "like") {
              likedUsers.push(swipe.targetUserId);
            }
          });
          return {
            userId,
            likedUsers: [...new Set(likedUsers)],
            // Remove duplicates
            dislikedUsers: [...new Set(dislikedUsers)],
            averageResponseTime: 0,
            // TODO: Calculate from message data
            preferredAgeRange: [18, 50],
            // TODO: Infer from interaction patterns
            preferredLocations: [],
            // TODO: Infer from liked users
            interactionFrequency: swipeHistory2.length
          };
        } catch (error) {
          console.error(`[MATCHING-ENGINE] Error getting interaction pattern:`, error);
          return {
            userId,
            likedUsers: [],
            dislikedUsers: [],
            averageResponseTime: 0,
            preferredAgeRange: [18, 50],
            preferredLocations: [],
            interactionFrequency: 0
          };
        }
      }
      async findSimilarUsers(userId, userPattern) {
        try {
          if (userPattern.likedUsers.length === 0) {
            return [];
          }
          const allMatches = await storage.getMatches(userId);
          const userSimilarities = [];
          const otherUsers = /* @__PURE__ */ new Set();
          allMatches.forEach((match) => {
            if (match.userId1 !== userId) otherUsers.add(match.userId1);
            if (match.userId2 !== userId) otherUsers.add(match.userId2);
          });
          for (const otherUserId of otherUsers) {
            const otherPattern = await this.getUserInteractionPattern(otherUserId);
            const similarity = this.calculateUserSimilarity(userPattern, otherPattern);
            if (similarity > 0.3) {
              userSimilarities.push({ userId: otherUserId, similarity });
            }
          }
          return userSimilarities.sort((a, b) => b.similarity - a.similarity).slice(0, 10).map((s) => s.userId);
        } catch (error) {
          console.error(`[MATCHING-ENGINE] Error finding similar users:`, error);
          return [];
        }
      }
      calculateUserSimilarity(pattern1, pattern2) {
        const likes1 = new Set(pattern1.likedUsers);
        const likes2 = new Set(pattern2.likedUsers);
        if (likes1.size === 0 && likes2.size === 0) return 0;
        const intersection = new Set([...likes1].filter((x) => likes2.has(x)));
        const union = /* @__PURE__ */ new Set([...likes1, ...likes2]);
        return intersection.size / union.size;
      }
      generateMatchReasons(contentScore, collaborativeScore, contextScore) {
        const reasons = [];
        if (contentScore > 0.7) reasons.push("Strong profile compatibility");
        if (contentScore > 0.5) reasons.push("Good preference match");
        if (collaborativeScore > 0.7) reasons.push("Liked by similar users");
        if (collaborativeScore > 0.5) reasons.push("Community recommended");
        if (contextScore > 0.7) reasons.push("Recently active");
        if (contextScore > 0.5) reasons.push("Complete profile");
        return reasons.length > 0 ? reasons : ["Basic compatibility"];
      }
    };
    matchingEngine = new MatchingEngine();
  }
});

// server/enhanced-discovery-api.ts
var enhanced_discovery_api_exports = {};
__export(enhanced_discovery_api_exports, {
  registerEnhancedDiscoveryAPI: () => registerEnhancedDiscoveryAPI
});
function registerEnhancedDiscoveryAPI(app2) {
  app2.get("/api/discovery/enhanced", requireAuth, async (req, res) => {
    try {
      const userId = req.user.id;
      const limit = parseInt(req.query.limit) || 50;
      console.log(`[ENHANCED-DISCOVERY] Starting enhanced discovery for user ${userId}`);
      const context = {
        currentTime: /* @__PURE__ */ new Date(),
        lastActiveThreshold: 60,
        // 1 hour
        mode: "meet"
      };
      const rankedUsers = await matchingEngine.getRankedDiscovery(userId, context, limit);
      const safeUsers = rankedUsers.map((user) => {
        const { password, ...safeUser } = user;
        return safeUser;
      });
      console.log(`[ENHANCED-DISCOVERY] Returning ${safeUsers.length} ranked users for ${userId}`);
      res.json(safeUsers);
    } catch (error) {
      console.error("[ENHANCED-DISCOVERY] Error in enhanced discovery:", error);
      try {
        const fallbackUsers = await storage.getDiscoverUsers(req.user.id);
        const safeUsers = fallbackUsers.map((user) => {
          const { password, ...safeUser } = user;
          return safeUser;
        });
        console.log(`[ENHANCED-DISCOVERY] Fallback: Returning ${safeUsers.length} users`);
        res.json(safeUsers);
      } catch (fallbackError) {
        console.error("[ENHANCED-DISCOVERY] Fallback also failed:", fallbackError);
        res.status(500).json({
          message: "Discovery service temporarily unavailable",
          error: fallbackError instanceof Error ? fallbackError.message : "Unknown error"
        });
      }
    }
  });
  app2.get("/api/suite/discovery/networking/enhanced", requireAuth, async (req, res) => {
    try {
      const userId = req.user.id;
      const limit = parseInt(req.query.limit) || 30;
      console.log(`[ENHANCED-SUITE] Starting enhanced networking discovery for user ${userId}`);
      const context = {
        currentTime: /* @__PURE__ */ new Date(),
        lastActiveThreshold: 120,
        // 2 hours (professionals check less frequently)
        mode: "suite"
      };
      const rankedUsers = await matchingEngine.getRankedDiscovery(userId, context, limit);
      const safeUsers = rankedUsers.map((user) => {
        const { password, ...safeUser } = user;
        return safeUser;
      });
      console.log(`[ENHANCED-SUITE] Returning ${safeUsers.length} ranked networking profiles for ${userId}`);
      res.json(safeUsers);
    } catch (error) {
      console.error("[ENHANCED-SUITE] Error in enhanced networking discovery:", error);
      try {
        const fallbackUsers = await storage.getDiscoverUsers(req.user.id);
        const safeUsers = fallbackUsers.map((user) => {
          const { password, ...safeUser } = user;
          return safeUser;
        });
        console.log(`[ENHANCED-SUITE] Fallback: Returning ${safeUsers.length} users`);
        res.json(safeUsers);
      } catch (fallbackError) {
        console.error("[ENHANCED-SUITE] Fallback also failed:", fallbackError);
        res.status(500).json({
          message: "Networking discovery service temporarily unavailable",
          error: fallbackError instanceof Error ? fallbackError.message : "Unknown error"
        });
      }
    }
  });
  app2.get("/api/matching-engine/stats", requireAuth, async (req, res) => {
    try {
      const userId = req.user.id;
      const [matches2, preferences] = await Promise.all([
        storage.getMeetMatchesByUserId(userId),
        storage.getUserPreferences(userId)
      ]);
      const stats = {
        totalMatches: matches2.length,
        hasPreferences: !!preferences,
        preferenceCompleteness: preferences ? calculatePreferenceCompleteness(preferences) : 0,
        lastMatchDate: matches2.length > 0 ? Math.max(...matches2.map((m) => new Date(m.createdAt).getTime())) : null,
        matchingEngineStatus: "active",
        algorithmVersion: "1.0-hybrid"
      };
      res.json(stats);
    } catch (error) {
      console.error("[MATCHING-ENGINE-STATS] Error getting stats:", error);
      res.status(500).json({
        message: "Stats temporarily unavailable",
        error: error instanceof Error ? error.message : "Unknown error"
      });
    }
  });
  app2.post("/api/discovery/mode", requireAuth, async (req, res) => {
    try {
      const { mode } = req.body;
      const userId = req.user.id;
      if (!mode || !["enhanced", "original"].includes(mode)) {
        return res.status(400).json({
          message: "Invalid mode. Use 'enhanced' or 'original'"
        });
      }
      console.log(`[DISCOVERY-MODE] User ${userId} set discovery mode to: ${mode}`);
      res.json({
        message: `Discovery mode set to ${mode}`,
        mode,
        userId
      });
    } catch (error) {
      console.error("[DISCOVERY-MODE] Error setting discovery mode:", error);
      res.status(500).json({
        message: "Failed to set discovery mode",
        error: error instanceof Error ? error.message : "Unknown error"
      });
    }
  });
  app2.post("/api/matching-engine/refresh", requireAuth, async (req, res) => {
    try {
      const userId = req.user.id;
      console.log(`[MATCHING-ENGINE-REFRESH] Manual refresh triggered by user ${userId}`);
      const context = {
        currentTime: /* @__PURE__ */ new Date(),
        lastActiveThreshold: 60,
        mode: "meet"
      };
      const refreshedUsers = await matchingEngine.getRankedDiscovery(userId, context, 10);
      res.json({
        message: "Matching engine refreshed successfully",
        refreshedCount: refreshedUsers.length,
        timestamp: (/* @__PURE__ */ new Date()).toISOString()
      });
    } catch (error) {
      console.error("[MATCHING-ENGINE-REFRESH] Error refreshing:", error);
      res.status(500).json({
        message: "Failed to refresh matching engine",
        error: error instanceof Error ? error.message : "Unknown error"
      });
    }
  });
  app2.get("/api/matching-engine/advanced-test/:candidateId", requireAuth, async (req, res) => {
    try {
      const userId = req.user.id;
      const candidateId = parseInt(req.params.candidateId);
      console.log(`[ADVANCED-TEST] Testing advanced algorithms between ${userId} and ${candidateId}`);
      const user = await storage.getUser(userId);
      const candidate = await storage.getUser(candidateId);
      const preferences = await storage.getUserPreferences(userId);
      if (!user || !candidate) {
        return res.status(404).json({ error: "User not found" });
      }
      const contentResult = advancedMatchingEngine.calculateAdvancedContentScore(user, candidate, preferences);
      const contextResult = advancedMatchingEngine.calculateAdvancedContextScore(
        candidate,
        { currentTime: /* @__PURE__ */ new Date() },
        { responseRate: 0.8, averageResponseTime: 1200 }
      );
      res.json({
        success: true,
        userId,
        candidateId,
        results: {
          content: contentResult,
          context: contextResult,
          timestamp: (/* @__PURE__ */ new Date()).toISOString()
        }
      });
    } catch (error) {
      console.error("[ADVANCED-TEST] Error:", error);
      res.status(500).json({
        error: "Advanced algorithm test failed",
        details: error instanceof Error ? error.message : "Unknown error"
      });
    }
  });
  app2.post("/api/matching-engine/feedback", requireAuth, async (req, res) => {
    try {
      const userId = req.user.id;
      const { targetUserId, action, feedback, algorithmVersion } = req.body;
      console.log(`[FEEDBACK] User ${userId} provided feedback on ${targetUserId}: ${action}`);
      const feedbackData = {
        userId,
        targetUserId: parseInt(targetUserId),
        action,
        // 'like', 'dislike', 'message', 'skip'
        feedback,
        // Optional text feedback
        algorithmVersion,
        timestamp: /* @__PURE__ */ new Date(),
        sessionId: req.sessionID
      };
      console.log("[FEEDBACK-DATA]", JSON.stringify(feedbackData, null, 2));
      res.json({
        success: true,
        message: "Feedback recorded successfully",
        feedbackId: `fb_${Date.now()}_${userId}`
      });
    } catch (error) {
      console.error("[FEEDBACK] Error recording feedback:", error);
      res.status(500).json({
        error: "Failed to record feedback",
        details: error instanceof Error ? error.message : "Unknown error"
      });
    }
  });
  function calculatePreferenceCompleteness(preferences) {
    const fields = [
      preferences.minAge,
      preferences.maxAge,
      preferences.locationPreference,
      preferences.religionPreference,
      preferences.ethnicityPreference,
      preferences.relationshipGoalPreference
    ];
    const completedFields = fields.filter((field) => field !== null && field !== void 0);
    return completedFields.length / fields.length;
  }
}
var init_enhanced_discovery_api = __esm({
  "server/enhanced-discovery-api.ts"() {
    "use strict";
    init_matching_engine();
    init_advanced_matching_algorithms();
    init_storage();
    init_auth();
  }
});

// server/data-collection-api.ts
async function trackProfileView(req, res) {
  try {
    const { viewerId, viewedId, appMode = "MEET", duration = 0 } = req.body;
    if (!viewerId || !viewedId) {
      return res.status(400).json({
        error: "Missing required fields: viewerId, viewedId"
      });
    }
    if (viewerId === viewedId) {
      return res.status(400).json({
        error: "Cannot track self-profile views"
      });
    }
    console.log(`[PROFILE-VIEW-TRACKING] User ${viewerId} viewed ${viewedId} (${appMode}) for ${duration}s`);
    await storage.query(`
      SELECT upsert_profile_view($1, $2, $3, $4)
    `, [viewerId, viewedId, appMode, duration]);
    res.json({
      success: true,
      message: "Profile view tracked successfully",
      data: { viewerId, viewedId, appMode, duration }
    });
  } catch (error) {
    console.error("[PROFILE-VIEW-TRACKING] Error tracking profile view:", error);
    res.status(500).json({
      error: "Failed to track profile view",
      details: process.env.NODE_ENV === "development" ? error : void 0
    });
  }
}
async function getProfileViewAnalytics(req, res) {
  try {
    const { userId } = req.params;
    const { appMode = "MEET", timeframe = "30" } = req.query;
    console.log(`[PROFILE-ANALYTICS] Getting view analytics for user ${userId} (${appMode})`);
    const viewsReceived = await storage.query(`
      SELECT 
        viewer_id,
        view_count,
        total_view_duration,
        first_viewed_at,
        last_viewed_at,
        EXTRACT(EPOCH FROM (NOW() - last_viewed_at))/86400 as days_since_view
      FROM profile_views 
      WHERE viewed_id = $1 
        AND app_mode = $2
        AND last_viewed_at >= NOW() - INTERVAL '${timeframe} days'
      ORDER BY last_viewed_at DESC
      LIMIT 50
    `, [userId, appMode]);
    const viewsMade = await storage.query(`
      SELECT 
        viewed_id,
        view_count,
        total_view_duration,
        first_viewed_at,
        last_viewed_at,
        EXTRACT(EPOCH FROM (NOW() - last_viewed_at))/86400 as days_since_view
      FROM profile_views 
      WHERE viewer_id = $1 
        AND app_mode = $2
        AND last_viewed_at >= NOW() - INTERVAL '${timeframe} days'
      ORDER BY last_viewed_at DESC
      LIMIT 50
    `, [userId, appMode]);
    const summary = await storage.query(`
      SELECT 
        COUNT(CASE WHEN viewed_id = $1 THEN 1 END) as views_received_count,
        COUNT(CASE WHEN viewer_id = $1 THEN 1 END) as views_made_count,
        AVG(CASE WHEN viewed_id = $1 THEN view_count END) as avg_views_received,
        AVG(CASE WHEN viewer_id = $1 THEN view_count END) as avg_views_made,
        SUM(CASE WHEN viewed_id = $1 THEN total_view_duration END) as total_duration_received,
        SUM(CASE WHEN viewer_id = $1 THEN total_view_duration END) as total_duration_made
      FROM profile_views 
      WHERE (viewer_id = $1 OR viewed_id = $1)
        AND app_mode = $2
        AND last_viewed_at >= NOW() - INTERVAL '${timeframe} days'
    `, [userId, appMode]);
    res.json({
      success: true,
      data: {
        summary: summary[0] || {},
        viewsReceived,
        viewsMade,
        timeframe: `${timeframe} days`,
        appMode
      }
    });
  } catch (error) {
    console.error("[PROFILE-ANALYTICS] Error getting analytics:", error);
    res.status(500).json({
      error: "Failed to get profile view analytics",
      details: process.env.NODE_ENV === "development" ? error : void 0
    });
  }
}
async function getMessageEngagementAnalytics(req, res) {
  try {
    const { userId, targetUserId } = req.params;
    const { timeframe = "30" } = req.query;
    console.log(`[MESSAGE-ANALYTICS] Getting engagement analytics: ${userId} \u2194 ${targetUserId}`);
    const engagementSummary = await storage.query(`
      SELECT 
        COUNT(*) as total_messages,
        AVG(message_length) as avg_message_length,
        AVG(word_count) as avg_word_count,
        AVG(engagement_score) as avg_engagement_score,
        COUNT(CASE WHEN has_question THEN 1 END)::REAL / COUNT(*) as question_rate,
        COUNT(CASE WHEN has_exclamation THEN 1 END)::REAL / COUNT(*) as enthusiasm_rate,
        COUNT(CASE WHEN message_length > 50 THEN 1 END)::REAL / COUNT(*) as substantial_rate,
        MAX(created_at) as last_message_at
      FROM message_engagement_metrics
      WHERE ((sender_id = $1 AND receiver_id = $2)
         OR (sender_id = $2 AND receiver_id = $1))
        AND created_at >= NOW() - INTERVAL '${timeframe} days'
    `, [userId, targetUserId]);
    const threadInfo = await storage.query(`
      SELECT 
        thread_id,
        total_messages,
        messages_from_one,
        messages_from_two,
        average_response_time,
        conversation_depth,
        last_activity_at,
        EXTRACT(EPOCH FROM (NOW() - last_activity_at))/86400 as days_since_activity
      FROM conversation_threads
      WHERE (participant_one_id = LEAST($1, $2) 
         AND participant_two_id = GREATEST($1, $2))
        AND is_active = true
    `, [userId, targetUserId]);
    const engagementTrend = await storage.query(`
      SELECT 
        DATE(created_at) as date,
        AVG(engagement_score) as avg_engagement,
        COUNT(*) as message_count
      FROM message_engagement_metrics
      WHERE ((sender_id = $1 AND receiver_id = $2)
         OR (sender_id = $2 AND receiver_id = $1))
        AND created_at >= NOW() - INTERVAL '${timeframe} days'
      GROUP BY DATE(created_at)
      ORDER BY date ASC
      LIMIT 30
    `, [userId, targetUserId]);
    res.json({
      success: true,
      data: {
        engagementSummary: engagementSummary[0] || {},
        threadInfo: threadInfo[0] || {},
        engagementTrend,
        timeframe: `${timeframe} days`
      }
    });
  } catch (error) {
    console.error("[MESSAGE-ANALYTICS] Error getting engagement analytics:", error);
    res.status(500).json({
      error: "Failed to get message engagement analytics",
      details: process.env.NODE_ENV === "development" ? error : void 0
    });
  }
}
async function getReciprocityScore(req, res) {
  try {
    const { userId, targetUserId } = req.params;
    console.log(`[RECIPROCITY-ANALYTICS] Calculating reciprocity score: ${userId} \u2194 ${targetUserId}`);
    const { userBehaviorPatterns: userBehaviorPatterns2 } = await Promise.resolve().then(() => (init_user_behavior_patterns(), user_behavior_patterns_exports));
    const reciprocityProfile = await userBehaviorPatterns2.calculateReciprocityEngagementProfile(
      parseInt(userId),
      parseInt(targetUserId)
    );
    res.json({
      success: true,
      data: reciprocityProfile
    });
  } catch (error) {
    console.error("[RECIPROCITY-ANALYTICS] Error calculating reciprocity score:", error);
    res.status(500).json({
      error: "Failed to calculate reciprocity score",
      details: process.env.NODE_ENV === "development" ? error : void 0
    });
  }
}
async function getDataCollectionStatus(req, res) {
  try {
    console.log("[DATA-STATUS] Checking data collection readiness");
    const [profileViewsCount, engagementCount, threadsCount, messagesCount, swipeCount] = await Promise.all([
      storage.query(`SELECT COUNT(*) as count FROM profile_views`),
      storage.query(`SELECT COUNT(*) as count FROM message_engagement_metrics`),
      storage.query(`SELECT COUNT(*) as count FROM conversation_threads`),
      storage.query(`SELECT COUNT(*) as count FROM messages`),
      storage.query(`SELECT COUNT(*) as count FROM swipe_history`)
    ]);
    const { userBehaviorPatterns: userBehaviorPatterns2 } = await Promise.resolve().then(() => (init_user_behavior_patterns(), user_behavior_patterns_exports));
    const indicatorStatus = await userBehaviorPatterns2.checkMutualInterestReadiness();
    const status = {
      infrastructure: {
        profileViewsTable: true,
        messageEngagementTable: true,
        conversationThreadsTable: true
      },
      dataAvailability: {
        profileViews: Number(profileViewsCount[0].count),
        messageEngagement: Number(engagementCount[0].count),
        conversationThreads: Number(threadsCount[0].count),
        totalMessages: Number(messagesCount[0].count),
        totalSwipes: Number(swipeCount[0].count)
      },
      indicators: indicatorStatus,
      readyForProduction: indicatorStatus.implementationStatus === "READY",
      dataCollectionActive: true
    };
    res.json({
      success: true,
      data: status
    });
  } catch (error) {
    console.error("[DATA-STATUS] Error checking readiness:", error);
    res.status(500).json({
      error: "Failed to check data collection status",
      details: process.env.NODE_ENV === "development" ? error : void 0
    });
  }
}
async function backfillEngagementMetrics(req, res) {
  try {
    const { limit = 1e3 } = req.body || {};
    console.log(`[BACKFILL] Starting engagement metrics backfill for ${limit} messages`);
    const unprocessedMessages = await storage.query(`
      SELECT m.id, m.sender_id, m.receiver_id, m.content, m.created_at
      FROM messages m
      LEFT JOIN message_engagement_metrics mem ON m.id = mem.message_id
      WHERE mem.message_id IS NULL
        AND m.content IS NOT NULL 
        AND m.content != ''
      ORDER BY m.created_at DESC
      LIMIT $1
    `, [limit]);
    if (unprocessedMessages.length === 0) {
      return res.json({
        success: true,
        message: "No messages to backfill",
        processed: 0
      });
    }
    let processedCount = 0;
    for (const message of unprocessedMessages) {
      try {
        const content = message.content || "";
        const msgLength = content.length;
        const msgWords = content.trim().split(/\s+/).length;
        const hasQuestion = content.includes("?");
        const hasExclamation = content.includes("!");
        let score = 30;
        if (msgLength > 100) score += 30;
        else if (msgLength > 50) score += 20;
        else if (msgLength > 20) score += 10;
        if (hasQuestion) score += 20;
        if (hasExclamation) score += 20;
        score = Math.max(0, Math.min(100, score));
        await storage.query(`
          INSERT INTO message_engagement_metrics (
            message_id, sender_id, receiver_id, message_length,
            has_question, has_exclamation, word_count, engagement_score
          ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
        `, [
          message.id,
          message.sender_id,
          message.receiver_id,
          msgLength,
          hasQuestion,
          hasExclamation,
          msgWords,
          score
        ]);
        processedCount++;
      } catch (error) {
        console.error(`[BACKFILL] Failed to process message ${message.id}:`, error);
      }
    }
    console.log(`[BACKFILL] Completed: ${processedCount}/${unprocessedMessages.length} messages processed`);
    res.json({
      success: true,
      message: `Backfill completed: ${processedCount} messages processed`,
      processed: processedCount,
      total: unprocessedMessages.length
    });
  } catch (error) {
    console.error("[BACKFILL] Error during backfill:", error);
    res.status(500).json({
      error: "Failed to backfill engagement metrics",
      details: process.env.NODE_ENV === "development" ? error : void 0
    });
  }
}
var init_data_collection_api = __esm({
  "server/data-collection-api.ts"() {
    "use strict";
    init_storage();
  }
});

// server/routes/data-collection-routes.ts
var data_collection_routes_exports = {};
__export(data_collection_routes_exports, {
  default: () => data_collection_routes_default
});
import { Router as Router2 } from "express";
var router2, data_collection_routes_default;
var init_data_collection_routes = __esm({
  "server/routes/data-collection-routes.ts"() {
    "use strict";
    init_data_collection_api();
    router2 = Router2();
    router2.post("/profile-view", trackProfileView);
    router2.get("/profile-views/:userId", getProfileViewAnalytics);
    router2.get("/message-engagement/:userId/:targetUserId", getMessageEngagementAnalytics);
    router2.get("/reciprocity-score/:userId/:targetUserId", getReciprocityScore);
    router2.get("/readiness-status", getDataCollectionStatus);
    router2.post("/backfill-engagement", backfillEngagementMetrics);
    data_collection_routes_default = router2;
  }
});

// server/archiving-service.ts
var archiving_service_exports = {};
__export(archiving_service_exports, {
  ArchivingService: () => ArchivingService,
  default: () => archiving_service_default
});
import { eq as eq5, and as and4, sql as sql4 } from "drizzle-orm";
var ArchivingService, archiving_service_default;
var init_archiving_service = __esm({
  "server/archiving-service.ts"() {
    "use strict";
    init_db();
    init_schema();
    ArchivingService = class {
      /**
       * Archive a match and all its associated messages when users unmatch
       */
      static async archiveMatchWithMessages(matchId, archivedByUserId, reason) {
        try {
          console.log(`[ARCHIVE] Starting archival of match ${matchId} by user ${archivedByUserId}, reason: ${reason}`);
          const matchData = await db.select().from(matches).where(eq5(matches.id, matchId)).limit(1);
          if (matchData.length === 0) {
            throw new Error(`Match ${matchId} not found`);
          }
          const match = matchData[0];
          const messages2 = await db.select().from(messages).where(eq5(messages.matchId, matchId));
          console.log(`[ARCHIVE] Found ${messages2.length} messages to archive for match ${matchId}`);
          const archivedMatchData = {
            originalMatchId: match.id,
            userId1: match.userId1,
            userId2: match.userId2,
            matched: match.matched,
            isDislike: match.isDislike,
            hasUnreadMessages1: match.hasUnreadMessages1,
            hasUnreadMessages2: match.hasUnreadMessages2,
            notifiedUser1: match.notifiedUser1,
            notifiedUser2: match.notifiedUser2,
            lastMessageAt: match.lastMessageAt,
            matchCreatedAt: match.createdAt,
            archivedReason: reason,
            archivedByUserId,
            messageCount: messages2.length
          };
          const archivedMatchResult = await db.insert(archivedMatches).values(archivedMatchData).returning({ id: archivedMatches.id });
          const archivedMatchId = archivedMatchResult[0].id;
          console.log(`[ARCHIVE] Created archived match record ${archivedMatchId}`);
          if (messages2.length > 0) {
            const archivedMessagesData = messages2.map((message) => ({
              originalMessageId: message.id,
              originalMatchId: matchId,
              archivedMatchId,
              senderId: message.senderId,
              receiverId: message.receiverId,
              content: message.content,
              encryptedContent: message.encryptedContent || void 0,
              iv: message.iv || void 0,
              messageType: message.messageType || "text",
              audioUrl: message.audioUrl || void 0,
              audioDuration: message.audioDuration || void 0,
              read: message.read,
              readAt: message.readAt,
              messageCreatedAt: message.createdAt,
              archivedReason: reason,
              replyToMessageId: message.replyToMessageId || void 0,
              replyToContent: message.replyToContent || void 0,
              replyToSenderName: message.replyToSenderName || void 0,
              replyToIsCurrentUser: message.replyToIsCurrentUser || void 0,
              autoDeleteScheduledAt: message.autoDeleteScheduledAt,
              autoDeleteModeWhenSent: message.autoDeleteModeWhenSent || void 0,
              deletedForUserId: message.deletedForUserId || void 0
            }));
            await db.insert(archivedMessages).values(archivedMessagesData);
            console.log(`[ARCHIVE] Archived ${messages2.length} messages`);
          }
          console.log(`[ARCHIVE] Successfully archived match ${matchId} with ${messages2.length} messages`);
          return {
            archivedMatchId,
            messageCount: messages2.length
          };
        } catch (error) {
          console.error(`[ARCHIVE] Failed to archive match ${matchId}:`, error);
          throw error;
        }
      }
      /**
       * Archive a user account when they delete their account or for security purposes
       */
      static async archiveUser(userId, reason, archivedByUserId, ipAddress, userAgent) {
        try {
          console.log(`[ARCHIVE] Starting user archival for user ${userId}, reason: ${reason}`);
          const userData = await db.select().from(users).where(eq5(users.id, userId)).limit(1);
          if (userData.length === 0) {
            throw new Error(`User ${userId} not found`);
          }
          const user = userData[0];
          const matchCount = await db.select({ count: sql4`count(*)` }).from(matches).where(
            and4(
              sql4`(${matches.userId1} = ${userId} OR ${matches.userId2} = ${userId})`,
              eq5(matches.matched, true)
            )
          );
          const messageCount = await db.select({ count: sql4`count(*)` }).from(messages).where(eq5(messages.senderId, userId));
          const totalMatches = matchCount[0]?.count || 0;
          const totalMessages = messageCount[0]?.count || 0;
          console.log(`[ARCHIVE] User ${userId} statistics: ${totalMatches} matches, ${totalMessages} messages`);
          const archivedUserData = {
            originalUserId: user.id,
            username: user.username,
            fullName: user.fullName,
            email: user.email,
            phoneNumber: user.phoneNumber || void 0,
            gender: user.gender,
            location: user.location,
            countryOfOrigin: user.countryOfOrigin || void 0,
            bio: user.bio || void 0,
            profession: user.profession || void 0,
            ethnicity: user.ethnicity || void 0,
            secondaryTribe: user.secondaryTribe || void 0,
            religion: user.religion || void 0,
            photoUrl: user.photoUrl || void 0,
            showProfilePhoto: user.showProfilePhoto || false,
            dateOfBirth: user.dateOfBirth,
            relationshipStatus: user.relationshipStatus || void 0,
            relationshipGoal: user.relationshipGoal || void 0,
            interests: user.interests || void 0,
            visibilityPreferences: user.visibilityPreferences || void 0,
            verifiedByPhone: user.verifiedByPhone || false,
            twoFactorEnabled: user.twoFactorEnabled || false,
            profileHidden: user.profileHidden || false,
            ghostMode: user.ghostMode || false,
            isOnline: user.isOnline || false,
            lastActive: user.lastActive,
            userCreatedAt: user.createdAt,
            archivedReason: reason,
            archivedByUserId: archivedByUserId || userId,
            totalMatches,
            totalMessages,
            ipAddress: ipAddress || void 0,
            userAgent: userAgent || void 0
          };
          const archivedUserResult = await db.insert(archivedUsers).values(archivedUserData).returning({ id: archivedUsers.id });
          const archivedUserId = archivedUserResult[0].id;
          console.log(`[ARCHIVE] Successfully archived user ${userId} as record ${archivedUserId}`);
          return {
            archivedUserId,
            totalMatches,
            totalMessages
          };
        } catch (error) {
          console.error(`[ARCHIVE] Failed to archive user ${userId}:`, error);
          throw error;
        }
      }
      /**
       * Get archived match history for a user (admin/support function)
       */
      static async getArchivedMatchHistory(userId) {
        try {
          const archivedMatchHistory = await db.select().from(archivedMatches).where(
            sql4`(${archivedMatches.userId1} = ${userId} OR ${archivedMatches.userId2} = ${userId})`
          ).orderBy(sql4`${archivedMatches.archivedAt} DESC`);
          return archivedMatchHistory;
        } catch (error) {
          console.error(`[ARCHIVE] Failed to get archived match history for user ${userId}:`, error);
          throw error;
        }
      }
      /**
       * Get archived user record (admin/support function)
       */
      static async getArchivedUser(originalUserId) {
        try {
          const archivedUser = await db.select().from(archivedUsers).where(eq5(archivedUsers.originalUserId, originalUserId)).orderBy(sql4`${archivedUsers.archivedAt} DESC`).limit(1);
          return archivedUser[0] || null;
        } catch (error) {
          console.error(`[ARCHIVE] Failed to get archived user for ID ${originalUserId}:`, error);
          throw error;
        }
      }
      /**
       * Clean up archived data older than specified retention period (admin function)
       */
      static async cleanupOldArchives(retentionDays = 2555) {
        try {
          console.log(`[ARCHIVE] Starting cleanup of archives older than ${retentionDays} days`);
          const cutoffDate = /* @__PURE__ */ new Date();
          cutoffDate.setDate(cutoffDate.getDate() - retentionDays);
          const deletedMessages = await db.delete(archivedMessages).where(sql4`${archivedMessages.archivedAt} < ${cutoffDate}`);
          const deletedMatches = await db.delete(archivedMatches).where(sql4`${archivedMatches.archivedAt} < ${cutoffDate}`);
          const deletedUsers = await db.delete(archivedUsers).where(sql4`${archivedUsers.archivedAt} < ${cutoffDate}`);
          console.log(`[ARCHIVE] Cleanup completed: ${deletedMatches} matches, ${deletedMessages} messages, ${deletedUsers} users`);
          return {
            deletedMatches: deletedMatches.rowCount || 0,
            deletedMessages: deletedMessages.rowCount || 0,
            deletedUsers: deletedUsers.rowCount || 0
          };
        } catch (error) {
          console.error(`[ARCHIVE] Failed to cleanup old archives:`, error);
          throw error;
        }
      }
    };
    archiving_service_default = ArchivingService;
  }
});

// server/suite-matching-engine.ts
var suite_matching_engine_exports = {};
__export(suite_matching_engine_exports, {
  suiteMatchingEngine: () => suiteMatchingEngine
});
function normalizeTextArray(value) {
  if (!value) return [];
  if (Array.isArray(value)) return value.map((v) => String(v).toLowerCase());
  try {
    const parsed = JSON.parse(String(value));
    return Array.isArray(parsed) ? parsed.map((v) => String(v).toLowerCase()) : [];
  } catch {
    return String(value).split(/[,;|]/).map((v) => v.trim().toLowerCase()).filter(Boolean);
  }
}
function jaccardSimilarity(a, b) {
  if (a.length === 0 || b.length === 0) return 0;
  const setA = new Set(a);
  const setB = new Set(b);
  let intersection = 0;
  setA.forEach((v) => {
    if (setB.has(v)) intersection++;
  });
  const union = setA.size + setB.size - intersection;
  return union === 0 ? 0 : intersection / union;
}
function stringEqualityScore(a, b) {
  if (!a || !b) return 0;
  return a.trim().toLowerCase() === b.trim().toLowerCase() ? 1 : 0;
}
function clampScore(value) {
  if (Number.isNaN(value) || !Number.isFinite(value)) return 0;
  if (value < 0) return 0;
  if (value > 1) return 1;
  return value;
}
var SuiteMatchingEngine, suiteMatchingEngine;
var init_suite_matching_engine = __esm({
  "server/suite-matching-engine.ts"() {
    "use strict";
    init_storage();
    SuiteMatchingEngine = class {
      // Base weights, can later be made user-personalized per section
      mentorshipWeights = {
        roleAlignment: 0.25,
        industryMatch: 0.2,
        expertiseTopics: 0.2,
        formatLocation: 0.15,
        experienceLevel: 0.1,
        availability: 0.1
      };
      networkingWeights = {
        purposeAlignment: 0.25,
        industryMatch: 0.2,
        seniorityCompany: 0.2,
        expertiseSkills: 0.2,
        locationFormat: 0.1,
        availability: 0.05
      };
      jobsWeights = {
        typeMatch: 0.25,
        skillsMatch: 0.25,
        industryMatch: 0.2,
        experienceEducation: 0.15,
        locationArrangement: 0.1,
        salaryPreference: 0.05
      };
      async rankMentorship(currentUserId, profiles) {
        const preferences = await storage.getConnectionsPreferences(currentUserId);
        const ranked = profiles.map((p) => ({ item: p, score: this.scoreMentorship(p, preferences) })).sort((a, b) => b.score - a.score).map((r) => r.item);
        return ranked;
      }
      async rankNetworking(currentUserId, profiles) {
        const preferences = await storage.getConnectionsPreferences(currentUserId);
        const ranked = profiles.map((p) => ({ item: p, score: this.scoreNetworking(p, preferences) })).sort((a, b) => b.score - a.score).map((r) => r.item);
        return ranked;
      }
      async rankJobs(currentUserId, profiles) {
        const preferences = await storage.getConnectionsPreferences(currentUserId);
        const ranked = profiles.map((p) => ({ item: p, score: this.scoreJobs(p, preferences) })).sort((a, b) => b.score - a.score).map((r) => r.item);
        return ranked;
      }
      scoreMentorship(profile, prefs) {
        const w = this.mentorshipWeights;
        let score = 0;
        const lookingFor = normalizeTextArray(prefs?.mentorshipLookingFor);
        const roleScore = lookingFor.length ? lookingFor.includes("both") || lookingFor.includes(`${profile.role}s`) ? 1 : 0 : 0.5;
        score += w.roleAlignment * roleScore;
        const prefIndustries = normalizeTextArray(prefs?.mentorshipIndustries);
        const pIndustries = normalizeTextArray(profile.industriesOrDomains);
        score += w.industryMatch * jaccardSimilarity(prefIndustries, pIndustries);
        const prefTopics = normalizeTextArray(prefs?.mentorshipTopics);
        const expertise = normalizeTextArray(profile.areasOfExpertise);
        const learningGoals = normalizeTextArray(profile.learningGoals);
        const expertiseTopicsScore = Math.max(
          jaccardSimilarity(prefTopics, expertise),
          jaccardSimilarity(prefTopics, learningGoals)
        );
        score += w.expertiseTopics * expertiseTopicsScore;
        const prefFormats = normalizeTextArray(prefs?.mentorshipFormat);
        const pFormats = normalizeTextArray(profile.preferredFormat);
        const formatScore = jaccardSimilarity(prefFormats, pFormats);
        const locationPref = String(prefs?.mentorshipLocationPreference || "").toLowerCase();
        const locScore = locationPref ? 0.5 : 0.5;
        score += w.formatLocation * clampScore((formatScore + locScore) / 2);
        const prefExp = normalizeTextArray(prefs?.mentorshipExperienceLevel);
        const expScore = prefExp.length ? 0.6 : 0.5;
        score += w.experienceLevel * expScore;
        const prefCommit = String(prefs?.mentorshipTimeCommitment || "").toLowerCase();
        const pCommit = String(profile.timeCommitment || "").toLowerCase();
        const availScore = prefCommit && pCommit ? stringEqualityScore(prefCommit, pCommit) : 0.5;
        score += w.availability * availScore;
        return clampScore(score);
      }
      scoreNetworking(profile, prefs) {
        const w = this.networkingWeights;
        let score = 0;
        const purposes = normalizeTextArray(prefs?.networkingPurpose);
        const profileGoals = normalizeTextArray(profile.networkingGoals);
        score += w.purposeAlignment * jaccardSimilarity(purposes, profileGoals);
        const prefIndustries = normalizeTextArray(prefs?.networkingIndustries);
        const profileIndustry = normalizeTextArray(profile.industry);
        score += w.industryMatch * jaccardSimilarity(prefIndustries, profileIndustry);
        const prefSeniority = normalizeTextArray(prefs?.networkingSeniority);
        const seniorityScore = prefSeniority.length ? 0.6 : 0.5;
        const prefCompanySize = normalizeTextArray(prefs?.networkingCompanySize);
        const companySizeScore = prefCompanySize.length ? 0.6 : 0.5;
        score += w.seniorityCompany * ((seniorityScore + companySizeScore) / 2);
        const prefExpertise = normalizeTextArray(prefs?.networkingAreasOfExpertise);
        const prefSkills = normalizeTextArray(prefs?.networkingSkills);
        const profileInterests = normalizeTextArray(profile.professionalInterests);
        const expertiseSkillsScore = Math.max(
          jaccardSimilarity(prefExpertise, profileInterests),
          jaccardSimilarity(prefSkills, profileInterests)
        );
        score += w.expertiseSkills * expertiseSkillsScore;
        const prefLoc = String(prefs?.networkingLocationPreference || "").toLowerCase();
        const meetingPref = normalizeTextArray(prefs?.networkingEventPreference);
        const profileMeeting = normalizeTextArray(profile.preferredMeetingStyle);
        const meetingScore = jaccardSimilarity(meetingPref, profileMeeting);
        const locScore = prefLoc ? 0.5 : 0.5;
        score += w.locationFormat * clampScore((meetingScore + locScore) / 2);
        const pCommit = String(profile.timeCommitment || "").toLowerCase();
        const commitScore = pCommit ? 0.55 : 0.5;
        score += w.availability * commitScore;
        return clampScore(score);
      }
      scoreJobs(profile, prefs) {
        const w = this.jobsWeights;
        let score = 0;
        const prefTypes = normalizeTextArray(prefs?.jobsTypes);
        const typeScore = prefTypes.length ? 0.6 : 0.5;
        score += w.typeMatch * typeScore;
        const prefSkills = normalizeTextArray(prefs?.jobsSkills);
        const profileSkills = normalizeTextArray(profile.requiredSkills || profile.skills);
        score += w.skillsMatch * jaccardSimilarity(prefSkills, profileSkills);
        const prefIndustries = normalizeTextArray(prefs?.jobsIndustries);
        const jobIndustry = normalizeTextArray(profile.industry);
        score += w.industryMatch * jaccardSimilarity(prefIndustries, jobIndustry);
        const prefEdu = normalizeTextArray(prefs?.jobsEducationLevel);
        const eduScore = prefEdu.length ? 0.55 : 0.5;
        const prefExp = normalizeTextArray(prefs?.jobsExperienceLevel);
        const expScore = prefExp.length ? 0.55 : 0.5;
        score += w.experienceEducation * ((eduScore + expScore) / 2);
        const prefArrangement = normalizeTextArray(prefs?.jobsWorkArrangement);
        const arrangementScore = prefArrangement.length ? 0.55 : 0.5;
        score += w.locationArrangement * arrangementScore;
        const salaryPrefScore = prefs?.jobsSalaryMin || prefs?.jobsSalaryMax ? 0.55 : 0.5;
        score += w.salaryPreference * salaryPrefScore;
        return clampScore(score);
      }
    };
    suiteMatchingEngine = new SuiteMatchingEngine();
  }
});

// server/services/email-verification.ts
var email_verification_exports = {};
__export(email_verification_exports, {
  EmailVerificationService: () => EmailVerificationService
});
import * as dns from "dns";
import * as net from "net";
import { promisify as promisify2 } from "util";
var dnsResolve, EmailVerificationService;
var init_email_verification = __esm({
  "server/services/email-verification.ts"() {
    "use strict";
    dnsResolve = promisify2(dns.resolveMx);
    EmailVerificationService = class {
      static TIMEOUT = 1e4;
      // 10 seconds
      static COMMON_DISPOSABLE_DOMAINS = /* @__PURE__ */ new Set([
        "10minutemail.com",
        "tempmail.org",
        "guerrillamail.com",
        "mailinator.com",
        "yopmail.com",
        "throwaway.email",
        "temp-mail.org",
        "getnada.com"
      ]);
      /**
       * Main email verification method
       */
      static async verifyEmail(email) {
        try {
          const formatResult = this.validateEmailFormat(email);
          if (!formatResult.isValid) {
            return formatResult;
          }
          const domain = email.split("@")[1].toLowerCase();
          if (this.COMMON_DISPOSABLE_DOMAINS.has(domain)) {
            return {
              isValid: false,
              reason: "Disposable email address detected",
              confidence: "high"
            };
          }
          const mxResult = await this.checkMXRecords(domain);
          if (!mxResult.isValid) {
            return mxResult;
          }
          const smtpResult = await this.performSMTPVerification(email, mxResult.mxRecords);
          return smtpResult;
        } catch (error) {
          console.error("[EMAIL-VERIFICATION] Verification failed:", error);
          return {
            isValid: false,
            reason: "Verification service temporarily unavailable",
            confidence: "low"
          };
        }
      }
      /**
       * Validate email format using RFC 5322 compliant regex
       */
      static validateEmailFormat(email) {
        const emailRegex = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
        if (!email || !emailRegex.test(email)) {
          return {
            isValid: false,
            reason: "Invalid email format",
            confidence: "high"
          };
        }
        if (email.length > 254 || email.split("@")[0].length > 64) {
          return {
            isValid: false,
            reason: "Email address too long",
            confidence: "high"
          };
        }
        return { isValid: true, confidence: "high" };
      }
      /**
       * Check MX records for the domain
       */
      static async checkMXRecords(domain) {
        try {
          const mxRecords = await dnsResolve(domain);
          if (!mxRecords || mxRecords.length === 0) {
            return {
              isValid: false,
              reason: "No mail servers found for domain",
              confidence: "high"
            };
          }
          const sortedMXRecords = mxRecords.sort((a, b) => a.priority - b.priority);
          return {
            isValid: true,
            confidence: "medium",
            mxRecords: sortedMXRecords
          };
        } catch (error) {
          return {
            isValid: false,
            reason: "Domain does not exist or has no mail servers",
            confidence: "high"
          };
        }
      }
      /**
       * Perform SMTP verification without sending emails
       */
      static async performSMTPVerification(email, mxRecords) {
        const userPart = email.split("@")[0];
        const domain = email.split("@")[1];
        for (const mx of mxRecords) {
          try {
            const result = await this.testSMTPConnection(mx.exchange, email, userPart, domain);
            if (result.isValid !== void 0) {
              return result;
            }
          } catch (error) {
            console.log(`[EMAIL-VERIFICATION] Failed to connect to ${mx.exchange}:`, error);
            continue;
          }
        }
        return {
          isValid: false,
          reason: "Unable to verify email existence - mail servers not responding",
          confidence: "low"
        };
      }
      /**
       * Test SMTP connection and verify email existence
       */
      static async testSMTPConnection(mxHost, email, userPart, domain) {
        return new Promise((resolve) => {
          const socket = net.createConnection(25, mxHost);
          let step = 0;
          let responseBuffer = "";
          const cleanup = () => {
            socket.removeAllListeners();
            if (!socket.destroyed) {
              socket.destroy();
            }
          };
          const timeout = setTimeout(() => {
            cleanup();
            resolve({
              isValid: false,
              reason: "SMTP server timeout",
              confidence: "low"
            });
          }, this.TIMEOUT);
          socket.on("connect", () => {
            console.log(`[EMAIL-VERIFICATION] Connected to ${mxHost}`);
          });
          socket.on("data", (data) => {
            responseBuffer += data.toString();
            const lines = responseBuffer.split("\r\n");
            for (let i = 0; i < lines.length - 1; i++) {
              const line = lines[i];
              console.log(`[EMAIL-VERIFICATION] Server response: ${line}`);
              try {
                switch (step) {
                  case 0:
                    if (line.startsWith("220")) {
                      socket.write(`HELO btechnos.com\r
`);
                      step = 1;
                    } else if (line.startsWith("4") || line.startsWith("5")) {
                      clearTimeout(timeout);
                      cleanup();
                      resolve({
                        isValid: false,
                        reason: "Mail server rejected connection",
                        confidence: "medium"
                      });
                      return;
                    }
                    break;
                  case 1:
                    if (line.startsWith("250")) {
                      socket.write(`MAIL FROM:<admin@kronogon.com>\r
`);
                      step = 2;
                    } else {
                      clearTimeout(timeout);
                      cleanup();
                      resolve({
                        isValid: false,
                        reason: "HELO command failed",
                        confidence: "medium"
                      });
                      return;
                    }
                    break;
                  case 2:
                    if (line.startsWith("250")) {
                      socket.write(`RCPT TO:<${email}>\r
`);
                      step = 3;
                    } else {
                      clearTimeout(timeout);
                      cleanup();
                      resolve({
                        isValid: false,
                        reason: "MAIL FROM command failed",
                        confidence: "medium"
                      });
                      return;
                    }
                    break;
                  case 3:
                    clearTimeout(timeout);
                    socket.write(`QUIT\r
`);
                    if (line.startsWith("250")) {
                      cleanup();
                      resolve({
                        isValid: true,
                        confidence: "high"
                      });
                      return;
                    } else if (line.startsWith("550") || line.startsWith("551") || line.startsWith("553")) {
                      cleanup();
                      resolve({
                        isValid: false,
                        reason: "Email address does not exist",
                        confidence: "high"
                      });
                      return;
                    } else if (line.startsWith("452") || line.startsWith("421")) {
                      cleanup();
                      resolve({
                        isValid: false,
                        reason: "Mail server temporarily unavailable",
                        confidence: "low"
                      });
                      return;
                    } else {
                      cleanup();
                      resolve({
                        isValid: false,
                        reason: "Unknown SMTP response",
                        confidence: "low"
                      });
                      return;
                    }
                }
              } catch (stepError) {
                console.error("[EMAIL-VERIFICATION] Step processing error:", stepError);
                clearTimeout(timeout);
                cleanup();
                resolve({
                  isValid: false,
                  reason: "SMTP verification error",
                  confidence: "low"
                });
                return;
              }
            }
            responseBuffer = lines[lines.length - 1];
          });
          socket.on("error", (error) => {
            console.error(`[EMAIL-VERIFICATION] Socket error for ${mxHost}:`, error);
            clearTimeout(timeout);
            cleanup();
            resolve({
              isValid: false,
              reason: "Connection failed to mail server",
              confidence: "medium"
            });
          });
          socket.on("close", () => {
            clearTimeout(timeout);
            cleanup();
          });
        });
      }
      /**
       * Quick validation for common email providers (fallback method)
       */
      static async quickValidation(email) {
        const domain = email.split("@")[1]?.toLowerCase();
        const trustedProviders = /* @__PURE__ */ new Set([
          "gmail.com",
          "yahoo.com",
          "hotmail.com",
          "outlook.com",
          "icloud.com",
          "aol.com",
          "protonmail.com",
          "zoho.com"
        ]);
        if (trustedProviders.has(domain)) {
          return {
            isValid: true,
            confidence: "medium"
          };
        }
        const formatResult = this.validateEmailFormat(email);
        if (!formatResult.isValid) {
          return formatResult;
        }
        const mxResult = await this.checkMXRecords(domain);
        return {
          isValid: mxResult.isValid,
          reason: mxResult.reason,
          confidence: mxResult.isValid ? "medium" : "high"
        };
      }
    };
  }
});

// server/unified-api.ts
var unified_api_exports = {};
__export(unified_api_exports, {
  getHomePageData: () => getHomePageData,
  getSuitePageData: () => getSuitePageData
});
async function getHomePageData(req, res) {
  try {
    const startTime = Date.now();
    const userId = req.user?.id;
    if (!userId) {
      return res.status(401).json({ message: "Unauthorized" });
    }
    console.log(
      `[UNIFIED-API] Starting parallel data fetch for user ${userId}`
    );
    console.log(
      `[UNIFIED-API] \u{1F6A8} VERIFICATION: About to call getEnhancedDiscoveryUsers with AI matching engine`
    );
    const [user, discoverUsers, swipeHistory2, premiumStatus] = await Promise.all([
      // User data (essential)
      storage.getUser(userId),
      // 🎯 Enhanced AI-powered discovery with hybrid matching (with timeout & fallback)
      getDiscoveryWithTimeout(userId),
      // Swipe history (for undo functionality)
      storage.getSwipeHistory(userId, "MEET", 50),
      // Premium status (essential for features)
      storage.getPremiumStatus(userId)
    ]);
    const duration = Date.now() - startTime;
    console.log(
      `[UNIFIED-API] Parallel fetch completed in ${duration}ms for user ${userId}`
    );
    const responseData = {
      user,
      discoverUsers: discoverUsers || [],
      swipeHistory: swipeHistory2 || [],
      premiumStatus: premiumStatus || { premiumAccess: false },
      matchCounts: { confirmed: 0, pending: 0, total: 0 },
      // Load later if needed
      matches: [],
      // Load later if needed
      unreadCount: 0,
      // Load later if needed
      suiteConnectionCounts: { networking: { matches: 0, pending: 0 } }
      // Load later if needed
    };
    res.json(responseData);
  } catch (error) {
    console.error("[UNIFIED-API] Error in getHomePageData:", error);
    console.error("[UNIFIED-API] Error stack:", error instanceof Error ? error.stack : "No stack trace");
    console.error("[UNIFIED-API] Error details:", {
      message: error instanceof Error ? error.message : "Unknown error",
      userId: req.user?.id,
      timestamp: (/* @__PURE__ */ new Date()).toISOString()
    });
    res.status(500).json({
      message: "Internal server error",
      details: error instanceof Error ? error.message : "Unknown error"
    });
  }
}
async function getEnhancedDiscoveryUsers(userId, limit) {
  try {
    console.log(
      `[ENHANCED-MEET] \u{1F3AF} Using AI matching engine for user ${userId}`
    );
    const context = {
      currentTime: /* @__PURE__ */ new Date(),
      lastActiveThreshold: 60,
      // 1 hour
      mode: "meet"
    };
    const isProduction = process.env.NODE_ENV === "production";
    const effectiveLimit = typeof limit === "number" && limit > 0 ? limit : isProduction ? 16 : 50;
    const rankedUsers = await matchingEngine.getRankedDiscovery(
      userId,
      context,
      effectiveLimit
    );
    console.log(
      `[ENHANCED-MEET] \u26A1 AI engine returned ${rankedUsers.length} personalized matches`
    );
    const safeUsers = rankedUsers.map((user) => {
      const { password, ...safeUser } = user;
      return safeUser;
    });
    return safeUsers;
  } catch (error) {
    console.error(
      "[ENHANCED-MEET] AI matching failed, falling back to original discovery:",
      error
    );
    return await storage.getDiscoverUsers(userId);
  }
}
async function getDiscoveryWithTimeout(userId) {
  const isProduction = process.env.NODE_ENV === "production";
  const timeoutMs = Number(
    process.env.MEET_DISCOVERY_TIMEOUT_MS || (isProduction ? 5e3 : 15e3)
  );
  const limit = Number(
    process.env.MEET_DISCOVERY_LIMIT || (isProduction ? 16 : 50)
  );
  try {
    const aiPromise = getEnhancedDiscoveryUsers(userId, limit);
    const timeoutPromise = new Promise(async (resolve) => {
      setTimeout(async () => {
        console.warn(
          `[ENHANCED-MEET] \u23F1\uFE0F Timeout after ${timeoutMs}ms for user ${userId}, using legacy discovery`
        );
        resolve(await storage.getDiscoverUsers(userId));
      }, timeoutMs);
    });
    return await Promise.race([aiPromise, timeoutPromise]);
  } catch (e) {
    console.error(
      "[ENHANCED-MEET] Discovery wrapper error, using legacy discovery:",
      e
    );
    return await storage.getDiscoverUsers(userId);
  }
}
async function getSuitePageData(req, res) {
  try {
    const startTime = Date.now();
    const userId = req.user?.id;
    if (!userId) {
      return res.status(401).json({ message: "Unauthorized" });
    }
    console.log(
      `[UNIFIED-API] Starting parallel SUITE data fetch for user ${userId}`
    );
    const [
      user,
      suiteConnectionCounts,
      networkingProfile,
      mentorshipProfile,
      jobProfile,
      unreadCount
    ] = await Promise.all([
      storage.getUser(userId),
      storage.getSuiteConnectionCounts(userId),
      storage.getSuiteNetworkingProfile(userId),
      storage.getSuiteMentorshipProfile(userId),
      storage.getSuiteJobProfile(userId),
      storage.getUnreadMessageCount(userId)
    ]);
    const duration = Date.now() - startTime;
    console.log(
      `[UNIFIED-API] Parallel SUITE fetch completed in ${duration}ms for user ${userId}`
    );
    res.json({
      user,
      suiteConnectionCounts: suiteConnectionCounts || {
        networking: { matches: 0, pending: 0 }
      },
      networkingProfile,
      mentorshipProfile,
      jobProfile,
      unreadCount: unreadCount || 0
    });
  } catch (error) {
    console.error("[UNIFIED-API] Error in getSuitePageData:", error);
    res.status(500).json({ message: "Internal server error" });
  }
}
var init_unified_api = __esm({
  "server/unified-api.ts"() {
    "use strict";
    init_storage();
    init_matching_engine();
  }
});

// server/index.ts
import express2 from "express";

// server/routes.ts
init_storage();
init_auth();
init_auth();
init_match_api();
import { createServer } from "http";
import { WebSocketServer, WebSocket as WebSocket4 } from "ws";

// server/suite-connection-api.ts
init_storage();
init_schema();
import { z as z2 } from "zod";
var connectedUsers2 = /* @__PURE__ */ new Map();
function setSuiteWebSocketConnections(connections) {
  connectedUsers2 = connections;
}
function registerSuiteConnectionAPI(app2) {
  app2.post(
    "/api/suite/connections/message",
    async (req, res) => {
      try {
        if (!req.isAuthenticated()) {
          return res.status(401).json({ message: "Unauthorized" });
        }
        const userId = req.user.id;
        const { targetUserId, connectionType, profileId } = req.body;
        if (!connectionType || !profileId) {
          return res.status(400).json({
            message: "Missing required fields: connectionType, profileId"
          });
        }
        console.log(
          `Creating instant match via message for user ${userId} -> profile ${profileId} (${connectionType})`
        );
        let newConnection;
        let isMatch = true;
        let actualTargetUserId = targetUserId;
        switch (connectionType) {
          case "networking":
            const networkingProfile = await storage.getSuiteNetworkingProfileById(parseInt(profileId));
            if (!networkingProfile) {
              return res.status(404).json({ message: "Networking profile not found" });
            }
            actualTargetUserId = networkingProfile.userId;
            const existingNetworking = await storage.getSuiteNetworkingConnection(
              userId,
              parseInt(profileId)
            );
            if (existingNetworking) {
              return res.status(409).json({
                message: "Connection already exists",
                connection: existingNetworking
              });
            }
            newConnection = await storage.createSuiteNetworkingConnection({
              userId,
              targetUserId: actualTargetUserId,
              targetProfileId: parseInt(profileId),
              action: "like",
              matched: true
              // Instant match via message
            });
            break;
          case "mentorship":
            const mentorshipProfile = await storage.getSuiteMentorshipProfileById(parseInt(profileId));
            if (!mentorshipProfile) {
              return res.status(404).json({ message: "Mentorship profile not found" });
            }
            actualTargetUserId = mentorshipProfile.userId;
            const existingMentorship = await storage.getSuiteMentorshipConnection(
              userId,
              parseInt(profileId)
            );
            if (existingMentorship) {
              return res.status(409).json({
                message: "Connection already exists",
                connection: existingMentorship
              });
            }
            newConnection = await storage.createSuiteMentorshipConnection({
              userId,
              targetUserId: actualTargetUserId,
              targetProfileId: parseInt(profileId),
              action: "like",
              matched: true
              // Instant match via message
            });
            break;
          case "jobs":
            const jobProfile = await storage.getSuiteJobProfileById(
              parseInt(profileId)
            );
            if (!jobProfile) {
              return res.status(404).json({ message: "Job profile not found" });
            }
            actualTargetUserId = jobProfile.userId;
            const existingJob = await storage.getSuiteJobApplication(
              userId,
              parseInt(profileId)
            );
            if (existingJob) {
              return res.status(409).json({
                message: "Application already exists",
                application: existingJob
              });
            }
            newConnection = await storage.createSuiteJobApplication({
              userId,
              targetUserId: actualTargetUserId,
              targetProfileId: parseInt(profileId),
              action: "like",
              applicationStatus: "accepted",
              // Instant acceptance via message
              matched: true
              // Instant match via message
            });
            break;
          default:
            return res.status(400).json({ message: "Invalid connection type" });
        }
        const targetUserWs = connectedUsers2.get(actualTargetUserId);
        if (targetUserWs && targetUserWs.readyState === 1) {
          const notificationData = {
            type: "suite_message_match",
            connectionType,
            fromUserId: userId,
            isMatch: true,
            timestamp: (/* @__PURE__ */ new Date()).toISOString()
          };
          try {
            targetUserWs.send(JSON.stringify(notificationData));
            console.log(
              `\u2705 Message match notification sent to user ${actualTargetUserId} for ${connectionType}`
            );
          } catch (error) {
            console.error(
              `\u274C Failed to send message match notification:`,
              error
            );
          }
        }
        try {
          let existingMatch = await storage.getMatchBetweenUsers(
            userId,
            actualTargetUserId
          );
          let chatData;
          if (existingMatch) {
            if (!existingMatch.matched) {
              chatData = await storage.updateMatch(existingMatch.id, {
                matched: true,
                metadata: JSON.stringify({
                  origin: "SUITE",
                  suiteType: connectionType,
                  context: "professional"
                })
              });
            } else {
              let metadata;
              if (!existingMatch.metadata) {
                metadata = {
                  origin: "SUITE",
                  suiteType: connectionType,
                  context: "professional"
                };
              } else {
                try {
                  metadata = typeof existingMatch.metadata === "string" ? JSON.parse(existingMatch.metadata) : existingMatch.metadata;
                  if (metadata.origin === "SUITE" && metadata.suiteType !== connectionType || metadata.origin === "MEET") {
                    if (!metadata.additionalConnections) {
                      metadata.additionalConnections = [];
                    }
                    if (!metadata.additionalConnections.includes(connectionType)) {
                      metadata.additionalConnections.push(connectionType);
                      console.log(
                        `\u{1F517} Adding ${connectionType} to additionalConnections for existing match ${existingMatch.id} via direct message`
                      );
                      chatData = await storage.updateMatch(existingMatch.id, {
                        metadata: JSON.stringify(metadata)
                      });
                    } else {
                      chatData = existingMatch;
                    }
                  } else {
                    chatData = existingMatch;
                  }
                } catch (parseError) {
                  console.error(
                    "Failed to parse existing metadata:",
                    parseError
                  );
                  metadata = {
                    origin: "SUITE",
                    suiteType: connectionType,
                    context: "professional"
                  };
                  chatData = await storage.updateMatch(existingMatch.id, {
                    metadata: JSON.stringify(metadata)
                  });
                }
              }
              if (!chatData) {
                chatData = existingMatch;
              }
            }
          } else {
            chatData = await storage.createMatch({
              userId1: userId,
              userId2: actualTargetUserId,
              matched: true,
              metadata: JSON.stringify({
                origin: "SUITE",
                suiteType: connectionType,
                context: "professional"
              })
            });
          }
          console.log(
            `\u2705 Chat thread created for SUITE ${connectionType} connection:`,
            chatData.id
          );
          console.log(
            `[SWIPE-CLEANUP] Starting cleanup for SUITE instant match between users ${userId} and ${actualTargetUserId} (${connectionType})`
          );
          try {
            await storage.removeMatchedUsersFromSwipeHistory(
              userId,
              actualTargetUserId,
              `SUITE_${connectionType.toUpperCase()}`
            );
          } catch (cleanupError) {
            console.error(
              `[SWIPE-CLEANUP] Failed for SUITE ${connectionType} instant match:`,
              cleanupError
            );
          }
          res.status(201).json({
            connection: newConnection,
            isMatch: true,
            chatId: chatData.id,
            message: `Instant ${connectionType} match created via message!`
          });
        } catch (chatError) {
          console.error(`\u274C Failed to create chat thread:`, chatError);
          res.status(201).json({
            connection: newConnection,
            isMatch: true,
            message: `${connectionType} connection created`
          });
        }
      } catch (error) {
        console.error("Error creating message match:", error);
        res.status(500).json({ message: "Internal server error" });
      }
    }
  );
  app2.post(
    "/api/suite/connections/networking",
    async (req, res) => {
      try {
        if (!req.isAuthenticated()) {
          return res.status(401).json({ message: "Unauthorized" });
        }
        const userId = req.user.id;
        const validatedData = insertSuiteNetworkingConnectionSchema.parse(
          req.body
        );
        console.log(
          `Creating networking connection for user ${userId}:`,
          validatedData
        );
        if (validatedData.userId !== userId) {
          return res.status(403).json({ message: "Not authorized to create this connection" });
        }
        const existingConnection = await storage.getSuiteNetworkingConnection(
          userId,
          validatedData.targetProfileId
        );
        let connection;
        if (existingConnection) {
          const isDislike = validatedData.action === "pass";
          if (existingConnection.action === validatedData.action && existingConnection.isDislike === isDislike) {
            return res.status(409).json({
              message: "Connection already exists with this state",
              connection: existingConnection
            });
          }
          connection = await storage.updateSuiteNetworkingConnection(
            existingConnection.id,
            {
              action: validatedData.action,
              isDislike,
              matched: false
              // Reset match status when action changes
            }
          );
          console.log(
            `Updated existing networking connection ${existingConnection.id} with new action: ${validatedData.action}`
          );
        } else {
          const connectionData = {
            ...validatedData,
            isDislike: validatedData.action === "pass"
          };
          connection = await storage.createSuiteNetworkingConnection(connectionData);
          console.log(
            `Created new networking connection with action: ${validatedData.action}, isDislike: ${connectionData.isDislike}`
          );
        }
        const userProfileId = await getUserNetworkingProfileId(userId);
        let reciprocalConnection = null;
        if (userProfileId !== null) {
          reciprocalConnection = await storage.getSuiteNetworkingConnection(
            validatedData.targetUserId,
            userProfileId
          );
        }
        let isMatch = false;
        if (reciprocalConnection && reciprocalConnection.action === "like" && validatedData.action === "like" && !reciprocalConnection.isDislike) {
          await storage.updateSuiteNetworkingConnection(connection.id, {
            matched: true
          });
          await storage.updateSuiteNetworkingConnection(
            reciprocalConnection.id,
            { matched: true }
          );
          isMatch = true;
          console.log(
            `Created networking match between users ${userId} and ${validatedData.targetUserId}`
          );
          try {
            const existingMatch = await storage.getMatchBetweenUsers(
              userId,
              validatedData.targetUserId
            );
            if (existingMatch && existingMatch.metadata) {
              const existingMetadata = typeof existingMatch.metadata === "string" ? JSON.parse(existingMatch.metadata) : existingMatch.metadata;
              if (existingMetadata && (existingMetadata.origin === "MEET" || existingMetadata.origin === "SUITE" && existingMetadata.suiteType !== "networking")) {
                if (!existingMetadata.additionalConnections) {
                  existingMetadata.additionalConnections = [];
                }
                if (!existingMetadata.additionalConnections.includes("networking")) {
                  existingMetadata.additionalConnections.push("networking");
                  console.log(
                    `\u{1F517} Adding networking to additionalConnections for existing match ${existingMatch.id} between users ${userId} and ${validatedData.targetUserId}`
                  );
                  await storage.updateMatch(existingMatch.id, {
                    metadata: JSON.stringify(existingMetadata)
                  });
                }
              }
            } else if (!existingMatch) {
              await storage.createMatch({
                userId1: userId,
                userId2: validatedData.targetUserId,
                matched: true,
                metadata: JSON.stringify({
                  origin: "SUITE",
                  suiteType: "networking",
                  context: "professional"
                })
              });
              console.log(
                `\u{1F517} Created new match for networking connection between users ${userId} and ${validatedData.targetUserId}`
              );
            }
          } catch (metadataError) {
            console.error(
              "Failed to process additional connection metadata for networking match:",
              metadataError
            );
          }
          try {
            await storage.removeMatchedUsersFromSwipeHistory(
              userId,
              validatedData.targetUserId
            );
            console.log(
              `[NETWORKING-MATCH] Cleaned up swipe history for matched users: ${userId} \u2194 ${validatedData.targetUserId}`
            );
          } catch (historyError) {
            console.error(
              "Error cleaning up networking swipe history for matched users:",
              historyError
            );
          }
        }
        console.log(
          `[WEBSOCKET DEBUG] Checking for WebSocket connection for user ${validatedData.targetUserId}`
        );
        console.log(
          `[WEBSOCKET DEBUG] Connected users count: ${connectedUsers2.size}`
        );
        console.log(
          `[WEBSOCKET DEBUG] Connected user IDs:`,
          Array.from(connectedUsers2.keys())
        );
        const targetUserWs = connectedUsers2.get(validatedData.targetUserId);
        if (targetUserWs) {
          console.log(
            `[WEBSOCKET DEBUG] Found WebSocket for user ${validatedData.targetUserId}, readyState: ${targetUserWs.readyState}`
          );
          if (targetUserWs.readyState === 1) {
            const fromUser = await storage.getUser(userId);
            const fromNetworkingProfile = await storage.getSuiteNetworkingProfile(userId);
            const notificationData = {
              type: isMatch ? "networking_match" : "networking_like",
              targetUserId: validatedData.targetUserId,
              // CRITICAL: Add targetUserId for notification filtering
              connection: {
                ...connection,
                targetUser: fromUser,
                targetProfile: fromNetworkingProfile
              },
              fromUserId: userId,
              fromUser,
              fromNetworkingProfile,
              isMatch,
              timestamp: (/* @__PURE__ */ new Date()).toISOString()
            };
            try {
              targetUserWs.send(JSON.stringify(notificationData));
              console.log(
                `\u2705 [WEBSOCKET SUCCESS] Notification sent to user ${validatedData.targetUserId} for networking connection from user ${userId}`
              );
              console.log(
                `[WEBSOCKET DATA]`,
                JSON.stringify(notificationData, null, 2)
              );
            } catch (error) {
              console.error(
                `\u274C [WEBSOCKET ERROR] Failed to send notification:`,
                error
              );
            }
          } else {
            console.log(
              `\u274C [WEBSOCKET ERROR] WebSocket for user ${validatedData.targetUserId} is not open (readyState: ${targetUserWs.readyState})`
            );
          }
        } else {
          console.log(
            `\u274C [WEBSOCKET ERROR] No WebSocket connection found for user ${validatedData.targetUserId}`
          );
          console.log(
            `[WEBSOCKET DEBUG] User may not be currently connected or on a different page`
          );
        }
        res.status(201).json({
          connection,
          isMatch,
          action: validatedData.action,
          message: isMatch ? "It's a professional match!" : validatedData.action === "like" ? "Connection request sent" : "Profile passed"
        });
      } catch (error) {
        if (error instanceof z2.ZodError) {
          return res.status(400).json({ message: "Invalid request data", errors: error.errors });
        }
        console.error("Error creating networking connection:", error);
        res.status(500).json({ message: "Internal server error" });
      }
    }
  );
  app2.get(
    "/api/suite/connections/networking",
    async (req, res) => {
      try {
        if (!req.isAuthenticated()) {
          return res.status(401).json({ message: "Unauthorized" });
        }
        const userId = req.user.id;
        const connections = await storage.getUserNetworkingConnections(userId);
        res.json(connections);
      } catch (error) {
        console.error("Error fetching networking connections:", error);
        res.status(500).json({ message: "Internal server error" });
      }
    }
  );
  app2.post(
    "/api/suite/connections/mentorship",
    async (req, res) => {
      try {
        if (!req.isAuthenticated()) {
          return res.status(401).json({ message: "Unauthorized" });
        }
        const userId = req.user.id;
        const validatedData = insertSuiteMentorshipConnectionSchema.parse(
          req.body
        );
        console.log(
          `Creating mentorship connection for user ${userId}:`,
          validatedData
        );
        if (validatedData.userId !== userId) {
          return res.status(403).json({ message: "Not authorized to create this connection" });
        }
        const existingConnection = await storage.getSuiteMentorshipConnection(
          userId,
          validatedData.targetProfileId
        );
        let connection;
        if (existingConnection) {
          const isDislike = validatedData.action === "pass";
          if (existingConnection.action === validatedData.action && existingConnection.isDislike === isDislike) {
            return res.status(409).json({
              message: "Connection already exists with this state",
              connection: existingConnection
            });
          }
          connection = await storage.updateSuiteMentorshipConnection(
            existingConnection.id,
            {
              action: validatedData.action,
              isDislike,
              matched: false
              // Reset match status when action changes
            }
          );
          console.log(
            `Updated existing mentorship connection ${existingConnection.id} with new action: ${validatedData.action}`
          );
        } else {
          const connectionData = {
            ...validatedData,
            isDislike: validatedData.action === "pass"
          };
          connection = await storage.createSuiteMentorshipConnection(connectionData);
          console.log(
            `Created new mentorship connection with action: ${validatedData.action}, isDislike: ${connectionData.isDislike}`
          );
        }
        const userProfileId = await getUserMentorshipProfileId(userId);
        let reciprocalConnection = null;
        if (userProfileId !== null) {
          reciprocalConnection = await storage.getSuiteMentorshipConnection(
            validatedData.targetUserId,
            userProfileId
          );
        }
        let isMatch = false;
        if (reciprocalConnection && reciprocalConnection.action === "like" && validatedData.action === "like" && !reciprocalConnection.isDislike) {
          await storage.updateSuiteMentorshipConnection(connection.id, {
            matched: true
          });
          await storage.updateSuiteMentorshipConnection(
            reciprocalConnection.id,
            { matched: true }
          );
          isMatch = true;
          console.log(
            `Created mentorship match between users ${userId} and ${validatedData.targetUserId}`
          );
          try {
            const existingMatch = await storage.getMatchBetweenUsers(
              userId,
              validatedData.targetUserId
            );
            if (existingMatch && existingMatch.metadata) {
              const existingMetadata = typeof existingMatch.metadata === "string" ? JSON.parse(existingMatch.metadata) : existingMatch.metadata;
              if (existingMetadata && (existingMetadata.origin === "MEET" || existingMetadata.origin === "SUITE" && existingMetadata.suiteType !== "mentorship")) {
                if (!existingMetadata.additionalConnections) {
                  existingMetadata.additionalConnections = [];
                }
                if (!existingMetadata.additionalConnections.includes("mentorship")) {
                  existingMetadata.additionalConnections.push("mentorship");
                  console.log(
                    `\u{1F517} Adding mentorship to additionalConnections for existing match ${existingMatch.id} between users ${userId} and ${validatedData.targetUserId}`
                  );
                  await storage.updateMatch(existingMatch.id, {
                    metadata: JSON.stringify(existingMetadata)
                  });
                }
              }
            } else if (!existingMatch) {
              await storage.createMatch({
                userId1: userId,
                userId2: validatedData.targetUserId,
                matched: true,
                metadata: JSON.stringify({
                  origin: "SUITE",
                  suiteType: "mentorship",
                  context: "professional"
                })
              });
              console.log(
                `\u{1F517} Created new match for mentorship connection between users ${userId} and ${validatedData.targetUserId}`
              );
            }
          } catch (metadataError) {
            console.error(
              "Failed to process additional connection metadata for mentorship match:",
              metadataError
            );
          }
          try {
            await storage.removeMatchedUsersFromSwipeHistory(
              userId,
              validatedData.targetUserId
            );
            console.log(
              `[MENTORSHIP-MATCH] Cleaned up swipe history for matched users: ${userId} \u2194 ${validatedData.targetUserId}`
            );
          } catch (historyError) {
            console.error(
              "Error cleaning up mentorship swipe history for matched users:",
              historyError
            );
          }
        }
        const targetUserWs = connectedUsers2.get(validatedData.targetUserId);
        if (targetUserWs && targetUserWs.readyState === 1) {
          const notificationData = {
            type: isMatch ? "mentorship_match" : "mentorship_like",
            targetUserId: validatedData.targetUserId,
            // CRITICAL: Add targetUserId for notification filtering
            connection,
            fromUserId: userId,
            isMatch,
            timestamp: (/* @__PURE__ */ new Date()).toISOString()
          };
          targetUserWs.send(JSON.stringify(notificationData));
          console.log(
            `WebSocket notification sent to user ${validatedData.targetUserId} for mentorship connection`
          );
        }
        res.status(201).json({
          connection,
          isMatch,
          action: validatedData.action,
          message: isMatch ? "It's a mentorship match!" : validatedData.action === "like" ? "Connection request sent" : "Profile passed"
        });
      } catch (error) {
        if (error instanceof z2.ZodError) {
          return res.status(400).json({ message: "Invalid request data", errors: error.errors });
        }
        console.error("Error creating mentorship connection:", error);
        res.status(500).json({ message: "Internal server error" });
      }
    }
  );
  app2.get(
    "/api/suite/connections/mentorship",
    async (req, res) => {
      try {
        if (!req.isAuthenticated()) {
          return res.status(401).json({ message: "Unauthorized" });
        }
        const userId = req.user.id;
        const connections = await storage.getUserMentorshipConnections(userId);
        res.json(connections);
      } catch (error) {
        console.error("Error fetching mentorship connections:", error);
        res.status(500).json({ message: "Internal server error" });
      }
    }
  );
  app2.post(
    "/api/suite/connections/jobs",
    async (req, res) => {
      try {
        if (!req.isAuthenticated()) {
          return res.status(401).json({ message: "Unauthorized" });
        }
        const userId = req.user.id;
        const validatedData = insertSuiteJobApplicationSchema.parse(req.body);
        console.log(
          `Creating job application for user ${userId}:`,
          validatedData
        );
        if (validatedData.userId !== userId) {
          return res.status(403).json({ message: "Not authorized to create this application" });
        }
        const existingApplication = await storage.getSuiteJobApplication(
          userId,
          validatedData.targetProfileId
        );
        if (existingApplication) {
          return res.status(409).json({
            message: "Application already exists",
            application: existingApplication
          });
        }
        const newApplication = await storage.createSuiteJobApplication(validatedData);
        const targetUserWs = connectedUsers2.get(validatedData.targetUserId);
        if (targetUserWs && targetUserWs.readyState === 1) {
          const notificationData = {
            type: "job_application",
            targetUserId: validatedData.targetUserId,
            // CRITICAL: Add targetUserId for notification filtering
            application: newApplication,
            fromUserId: userId,
            timestamp: (/* @__PURE__ */ new Date()).toISOString()
          };
          targetUserWs.send(JSON.stringify(notificationData));
          console.log(
            `WebSocket notification sent to user ${validatedData.targetUserId} for job application`
          );
        }
        res.status(201).json({
          application: newApplication,
          message: "Application submitted successfully"
        });
      } catch (error) {
        if (error instanceof z2.ZodError) {
          return res.status(400).json({ message: "Invalid request data", errors: error.errors });
        }
        console.error("Error creating job application:", error);
        res.status(500).json({ message: "Internal server error" });
      }
    }
  );
  app2.get(
    "/api/suite/connections/jobs",
    async (req, res) => {
      try {
        if (!req.isAuthenticated()) {
          return res.status(401).json({ message: "Unauthorized" });
        }
        const userId = req.user.id;
        const applications = await storage.getUserJobApplications(userId);
        res.json(applications);
      } catch (error) {
        console.error("Error fetching job applications:", error);
        res.status(500).json({ message: "Internal server error" });
      }
    }
  );
  app2.post(
    "/api/suite/connections/networking/:connectionId/respond",
    async (req, res) => {
      try {
        if (!req.isAuthenticated()) {
          return res.status(401).json({ message: "Unauthorized" });
        }
        const userId = req.user.id;
        const connectionId = parseInt(req.params.connectionId);
        const { action } = req.body;
        if (!["accept", "decline"].includes(action)) {
          return res.status(400).json({ message: "Invalid action" });
        }
        const connection = await storage.getSuiteNetworkingConnectionById(connectionId);
        if (!connection) {
          return res.status(404).json({ message: "Connection not found" });
        }
        if (connection.targetUserId !== userId) {
          return res.status(403).json({ message: "Unauthorized to respond to this connection" });
        }
        let isMatch = false;
        if (action === "accept") {
          await storage.updateSuiteNetworkingConnection(connectionId, {
            matched: true
          });
          const reciprocalConnection = await storage.getSuiteNetworkingConnection(
            connection.userId,
            connection.targetProfileId
          );
          if (reciprocalConnection) {
            await storage.updateSuiteNetworkingConnection(
              reciprocalConnection.id,
              { matched: true }
            );
          }
          isMatch = true;
          const acceptedByUser = await storage.getUser(userId);
          const requesterUser = await storage.getUser(connection.userId);
          const timestamp2 = (/* @__PURE__ */ new Date()).toISOString();
          const requesterWs = connectedUsers2.get(connection.userId);
          if (requesterWs && requesterWs.readyState === 1) {
            const notificationData = {
              type: "networking_match",
              connection,
              acceptedBy: userId,
              isMatch: true,
              timestamp: timestamp2,
              matchedUserName: acceptedByUser?.fullName,
              matchedUserPhoto: acceptedByUser?.photoUrl,
              matchedUserProfession: acceptedByUser?.profession,
              matchedUserLocation: acceptedByUser?.location
            };
            requesterWs.send(JSON.stringify(notificationData));
            console.log(
              `[SUITE-MATCH] Sent networking match notification to requester (User ${connection.userId})`
            );
          }
          const accepterWs = connectedUsers2.get(userId);
          if (accepterWs && accepterWs.readyState === 1) {
            const notificationData = {
              type: "networking_match",
              connection,
              acceptedBy: userId,
              isMatch: true,
              timestamp: timestamp2,
              matchedUserName: requesterUser?.fullName,
              matchedUserPhoto: requesterUser?.photoUrl,
              matchedUserProfession: requesterUser?.profession,
              matchedUserLocation: requesterUser?.location
            };
            accepterWs.send(JSON.stringify(notificationData));
            console.log(
              `[SUITE-MATCH] Sent networking match notification to accepter (User ${userId})`
            );
          }
        } else {
          await storage.deleteSuiteNetworkingConnectionById(connectionId);
        }
        res.json({
          success: true,
          isMatch,
          message: action === "accept" ? "Connection accepted" : "Connection declined"
        });
      } catch (error) {
        console.error("Error responding to networking connection:", error);
        res.status(500).json({ message: "Internal server error" });
      }
    }
  );
  app2.post(
    "/api/suite/connections/mentorship/:connectionId/respond",
    async (req, res) => {
      try {
        if (!req.isAuthenticated()) {
          return res.status(401).json({ message: "Unauthorized" });
        }
        const userId = req.user.id;
        const connectionId = parseInt(req.params.connectionId);
        const { action } = req.body;
        if (!["accept", "decline"].includes(action)) {
          return res.status(400).json({ message: "Invalid action" });
        }
        const connection = await storage.getSuiteMentorshipConnectionById(connectionId);
        if (!connection) {
          return res.status(404).json({ message: "Connection not found" });
        }
        if (connection.targetUserId !== userId) {
          return res.status(403).json({ message: "Unauthorized to respond to this connection" });
        }
        let isMatch = false;
        if (action === "accept") {
          await storage.updateSuiteMentorshipConnection(connectionId, {
            matched: true
          });
          const reciprocalConnection = await storage.getSuiteMentorshipConnection(
            connection.userId,
            connection.targetProfileId
          );
          if (reciprocalConnection) {
            await storage.updateSuiteMentorshipConnection(
              reciprocalConnection.id,
              { matched: true }
            );
          }
          isMatch = true;
          const timestamp2 = (/* @__PURE__ */ new Date()).toISOString();
          const requesterWs = connectedUsers2.get(connection.userId);
          if (requesterWs && requesterWs.readyState === 1) {
            const notificationData = {
              type: "mentorship_match",
              connection,
              acceptedBy: userId,
              isMatch: true,
              timestamp: timestamp2
            };
            requesterWs.send(JSON.stringify(notificationData));
            console.log(
              `WebSocket mentorship match notification sent to requester ${connection.userId}`
            );
          }
          const accepterWs = connectedUsers2.get(userId);
          if (accepterWs && accepterWs.readyState === 1) {
            const notificationData = {
              type: "mentorship_match",
              connection,
              acceptedBy: userId,
              isMatch: true,
              timestamp: timestamp2
            };
            accepterWs.send(JSON.stringify(notificationData));
            console.log(
              `WebSocket mentorship match notification sent to accepter ${userId}`
            );
          }
        } else {
          await storage.deleteSuiteMentorshipConnectionById(connectionId);
        }
        res.json({
          success: true,
          isMatch,
          message: action === "accept" ? "Connection accepted" : "Connection declined"
        });
      } catch (error) {
        console.error("Error responding to mentorship connection:", error);
        res.status(500).json({ message: "Internal server error" });
      }
    }
  );
  app2.post(
    "/api/suite/connections/networking/respond",
    async (req, res) => {
      try {
        if (!req.isAuthenticated()) {
          return res.status(401).json({ message: "Unauthorized" });
        }
        const currentUserId = req.user.id;
        const { requesterUserId, targetProfileId, action } = req.body;
        if (!requesterUserId || !targetProfileId || !["accept", "decline"].includes(action)) {
          return res.status(400).json({ message: "Invalid request data" });
        }
        const existingConnection = await storage.getSuiteNetworkingConnection(
          requesterUserId,
          targetProfileId
        );
        if (!existingConnection) {
          return res.status(404).json({ message: "Connection request not found" });
        }
        if (existingConnection.targetUserId !== currentUserId) {
          return res.status(403).json({ message: "Unauthorized to respond to this connection" });
        }
        let isMatch = false;
        if (action === "accept") {
          await storage.updateSuiteNetworkingConnection(existingConnection.id, {
            matched: true
          });
          isMatch = true;
          console.log(
            `\u{1F50D} [NETWORKING-RESPONSE] Checking for existing matches between users ${currentUserId} and ${requesterUserId}`
          );
          const existingMatch = await storage.getMatchBetweenUsers(
            currentUserId,
            requesterUserId
          );
          if (existingMatch && existingMatch.metadata) {
            console.log(
              `\u{1F50D} [NETWORKING-RESPONSE] Found existing match ${existingMatch.id}, checking metadata`
            );
            const existingMetadata = typeof existingMatch.metadata === "string" ? JSON.parse(existingMatch.metadata) : existingMatch.metadata;
            console.log(
              `\u{1F50D} [NETWORKING-RESPONSE] Current metadata: ${JSON.stringify(existingMetadata)}`
            );
            if (existingMetadata && (existingMetadata.origin === "MEET" || existingMetadata.origin === "SUITE" && existingMetadata.suiteType !== "networking")) {
              console.log(
                `\u{1F517} [NETWORKING-RESPONSE] Found different connection type, adding networking as additional connection`
              );
              if (!existingMetadata.additionalConnections) {
                existingMetadata.additionalConnections = [];
              }
              if (!existingMetadata.additionalConnections.includes("networking")) {
                existingMetadata.additionalConnections.push("networking");
                console.log(
                  `\u{1F517} [NETWORKING-RESPONSE] Adding networking to additionalConnections for existing match ${existingMatch.id} between users ${currentUserId} and ${requesterUserId}`
                );
                console.log(
                  `\u{1F517} [NETWORKING-RESPONSE] New additionalConnections: ${JSON.stringify(existingMetadata.additionalConnections)}`
                );
                await storage.updateMatch(existingMatch.id, {
                  metadata: JSON.stringify(existingMetadata)
                });
                console.log(
                  `\u{1F517} [NETWORKING-RESPONSE] Successfully updated existing match metadata`
                );
              } else {
                console.log(
                  `\u{1F517} [NETWORKING-RESPONSE] Networking already exists in additionalConnections`
                );
              }
            } else {
              console.log(
                `\u{1F517} [NETWORKING-RESPONSE] Same connection type or no metadata, no additional connection needed`
              );
            }
          } else if (!existingMatch) {
            console.log(
              `\u{1F517} [NETWORKING-RESPONSE] No existing match found, creating new match entry for messaging system`
            );
            const matchData = {
              userId1: Math.min(currentUserId, requesterUserId),
              userId2: Math.max(currentUserId, requesterUserId),
              matched: true,
              isDislike: false,
              metadata: JSON.stringify({
                origin: "SUITE",
                suiteType: "networking",
                context: "professional"
              })
            };
            const newMatch2 = await storage.createMatch(matchData);
            console.log(
              `\u{1F517} [NETWORKING-RESPONSE] Created new match for networking connection:`,
              {
                id: newMatch2.id,
                userId1: newMatch2.userId1,
                userId2: newMatch2.userId2,
                matched: newMatch2.matched,
                metadata: newMatch2.metadata
              }
            );
          } else if (existingMatch && !existingMatch.matched) {
            console.log(
              `\u{1F517} [NETWORKING-RESPONSE] Found existing unmatched record, updating to SUITE networking match`
            );
            await storage.updateMatch(existingMatch.id, {
              matched: true,
              metadata: JSON.stringify({
                origin: "SUITE",
                suiteType: "networking",
                context: "professional"
              })
            });
            console.log(
              `\u{1F517} [NETWORKING-RESPONSE] Updated existing match ${existingMatch.id} for networking connection`
            );
          } else {
            console.log(
              `\u{1F50D} [NETWORKING-RESPONSE] Existing matched record found, using existing match`
            );
          }
          const acceptedByUser = await storage.getUser(currentUserId);
          const requesterUser = await storage.getUser(requesterUserId);
          const requesterWs = connectedUsers2.get(requesterUserId);
          if (requesterWs && requesterWs.readyState === 1) {
            const notificationData = {
              type: "networking_match",
              connection: {
                id: existingConnection.id,
                userId: existingConnection.userId,
                targetUserId: existingConnection.targetUserId
              },
              acceptedBy: currentUserId,
              isMatch: true,
              timestamp: (/* @__PURE__ */ new Date()).toISOString(),
              matchedUserName: acceptedByUser?.fullName,
              matchedUserPhoto: acceptedByUser?.photoUrl,
              matchedUserProfession: acceptedByUser?.profession,
              matchedUserLocation: acceptedByUser?.location
            };
            requesterWs.send(JSON.stringify(notificationData));
          }
          const accepterWs = connectedUsers2.get(currentUserId);
          if (accepterWs && accepterWs.readyState === 1) {
            const notificationData = {
              type: "networking_match",
              connection: {
                id: existingConnection.id,
                userId: existingConnection.userId,
                targetUserId: existingConnection.targetUserId
              },
              acceptedBy: currentUserId,
              isMatch: true,
              timestamp: (/* @__PURE__ */ new Date()).toISOString(),
              matchedUserName: requesterUser?.fullName,
              matchedUserPhoto: requesterUser?.photoUrl,
              matchedUserProfession: requesterUser?.profession,
              matchedUserLocation: requesterUser?.location
            };
            accepterWs.send(JSON.stringify(notificationData));
            console.log(
              `[SUITE-MATCH] Sent networking match notification to accepter (User ${currentUserId})`
            );
          }
        } else {
          await storage.updateSuiteNetworkingConnection(existingConnection.id, {
            action: "pass",
            isDislike: true,
            matched: false
          });
        }
        res.json({
          success: true,
          isMatch,
          action,
          message: action === "accept" ? "Connection accepted" : "Connection declined"
        });
      } catch (error) {
        console.error("Error responding to networking connection:", error);
        res.status(500).json({ message: "Internal server error" });
      }
    }
  );
  app2.post(
    "/api/suite/connections/mentorship/respond",
    async (req, res) => {
      try {
        if (!req.isAuthenticated()) {
          return res.status(401).json({ message: "Unauthorized" });
        }
        const currentUserId = req.user.id;
        const { requesterUserId, targetProfileId, action } = req.body;
        if (!requesterUserId || !targetProfileId || !["accept", "decline"].includes(action)) {
          return res.status(400).json({ message: "Invalid request data" });
        }
        const existingConnection = await storage.getSuiteMentorshipConnection(
          requesterUserId,
          targetProfileId
        );
        if (!existingConnection) {
          return res.status(404).json({ message: "Connection request not found" });
        }
        if (existingConnection.targetUserId !== currentUserId) {
          return res.status(403).json({ message: "Unauthorized to respond to this connection" });
        }
        let isMatch = false;
        if (action === "accept") {
          await storage.updateSuiteMentorshipConnection(existingConnection.id, {
            matched: true
          });
          isMatch = true;
          const existingMatch = await storage.getMatchBetweenUsers(
            currentUserId,
            requesterUserId
          );
          let finalMatch;
          if (existingMatch) {
            try {
              let existingMetadata;
              if (existingMatch.metadata) {
                existingMetadata = typeof existingMatch.metadata === "string" ? JSON.parse(existingMatch.metadata) : existingMatch.metadata;
              }
              if (existingMetadata) {
                if (existingMetadata.origin === "SUITE" && existingMetadata.suiteType !== "mentorship" || existingMetadata.origin === "MEET") {
                  if (!existingMetadata.additionalConnections) {
                    existingMetadata.additionalConnections = [];
                  }
                  if (!existingMetadata.additionalConnections.includes(
                    "mentorship"
                  )) {
                    existingMetadata.additionalConnections.push("mentorship");
                    console.log(
                      `\u{1F517} Adding mentorship to additionalConnections for existing match ${existingMatch.id} between users ${currentUserId} and ${requesterUserId}`
                    );
                  }
                  finalMatch = await storage.updateMatch(existingMatch.id, {
                    matched: true,
                    metadata: JSON.stringify(existingMetadata)
                  });
                } else {
                  finalMatch = await storage.updateMatch(existingMatch.id, {
                    matched: true,
                    metadata: JSON.stringify({
                      origin: "SUITE",
                      suiteType: "mentorship",
                      context: "professional"
                    })
                  });
                  console.log(
                    `\u{1F517} Updated existing match ${existingMatch.id} with mentorship metadata`
                  );
                }
              } else {
                finalMatch = await storage.updateMatch(existingMatch.id, {
                  matched: true,
                  metadata: JSON.stringify({
                    origin: "SUITE",
                    suiteType: "mentorship",
                    context: "professional"
                  })
                });
                console.log(
                  `\u{1F517} Added mentorship metadata to existing match ${existingMatch.id}`
                );
              }
            } catch (parseError) {
              console.error("Failed to parse existing metadata:", parseError);
              finalMatch = await storage.updateMatch(existingMatch.id, {
                matched: true,
                metadata: JSON.stringify({
                  origin: "SUITE",
                  suiteType: "mentorship",
                  context: "professional"
                })
              });
            }
          } else {
            const matchData = {
              userId1: Math.min(currentUserId, requesterUserId),
              userId2: Math.max(currentUserId, requesterUserId),
              matched: true,
              isDislike: false,
              metadata: JSON.stringify({
                origin: "SUITE",
                suiteType: "mentorship",
                context: "professional"
              })
            };
            finalMatch = await storage.createMatch(matchData);
            console.log(
              `\u{1F517} Created new mentorship match between users ${currentUserId} and ${requesterUserId}`
            );
          }
          const acceptedByUser = await storage.getUser(currentUserId);
          const requesterUser = await storage.getUser(requesterUserId);
          const requesterWs = connectedUsers2.get(requesterUserId);
          if (requesterWs && requesterWs.readyState === 1) {
            const notificationData = {
              type: "mentorship_match",
              connection: {
                id: existingConnection.id,
                userId: existingConnection.userId,
                targetUserId: existingConnection.targetUserId
              },
              acceptedBy: currentUserId,
              isMatch: true,
              timestamp: (/* @__PURE__ */ new Date()).toISOString(),
              matchedUserName: acceptedByUser?.fullName,
              matchedUserPhoto: acceptedByUser?.photoUrl,
              matchedUserProfession: acceptedByUser?.profession,
              matchedUserLocation: acceptedByUser?.location
            };
            requesterWs.send(JSON.stringify(notificationData));
            console.log(
              `[SUITE-MATCH] Sent mentorship match notification to requester (User ${requesterUserId})`
            );
          }
          const accepterWs = connectedUsers2.get(currentUserId);
          if (accepterWs && accepterWs.readyState === 1) {
            const notificationData = {
              type: "mentorship_match",
              connection: {
                id: existingConnection.id,
                userId: existingConnection.userId,
                targetUserId: existingConnection.targetUserId
              },
              acceptedBy: currentUserId,
              isMatch: true,
              timestamp: (/* @__PURE__ */ new Date()).toISOString(),
              matchedUserName: requesterUser?.fullName,
              matchedUserPhoto: requesterUser?.photoUrl,
              matchedUserProfession: requesterUser?.profession,
              matchedUserLocation: requesterUser?.location
            };
            accepterWs.send(JSON.stringify(notificationData));
            console.log(
              `[SUITE-MATCH] Sent mentorship match notification to accepter (User ${currentUserId})`
            );
          }
        } else {
          await storage.updateSuiteMentorshipConnection(existingConnection.id, {
            action: "pass",
            isDislike: true,
            matched: false
          });
        }
        res.json({
          success: true,
          isMatch,
          action,
          message: action === "accept" ? "Connection accepted" : "Connection declined"
        });
      } catch (error) {
        console.error("Error responding to mentorship connection:", error);
        res.status(500).json({ message: "Internal server error" });
      }
    }
  );
  app2.get(
    "/api/suite/connections/counts",
    async (req, res) => {
      try {
        if (!req.isAuthenticated()) {
          return res.status(401).json({ message: "Unauthorized" });
        }
        const userId = req.user.id;
        const [networkingConnections, mentorshipConnections, jobApplications] = await Promise.all([
          storage.getUserNetworkingConnections(userId),
          storage.getUserMentorshipConnections(userId),
          storage.getUserJobApplications(userId)
        ]);
        const networkingMatches = networkingConnections.filter(
          (c) => c.matched
        ).length;
        const networkingPending = networkingConnections.filter(
          (c) => !c.matched && c.action === "like"
        ).length;
        const mentorshipMatches = mentorshipConnections.filter(
          (c) => c.matched
        ).length;
        const mentorshipPending = mentorshipConnections.filter(
          (c) => !c.matched && c.action === "like"
        ).length;
        const jobApplicationsCount = jobApplications.length;
        const jobApplicationsPending = jobApplications.length;
        res.json({
          networking: {
            matches: networkingMatches,
            pending: networkingPending,
            total: networkingConnections.length
          },
          mentorship: {
            matches: mentorshipMatches,
            pending: mentorshipPending,
            total: mentorshipConnections.length
          },
          jobs: {
            applications: jobApplicationsCount,
            pending: jobApplicationsPending,
            total: jobApplications.length
          }
        });
      } catch (error) {
        console.error("Error fetching connection counts:", error);
        res.status(500).json({ message: "Internal server error" });
      }
    }
  );
}
async function getUserNetworkingProfileId(userId) {
  try {
    const profile = await storage.getSuiteNetworkingProfile(userId);
    return profile?.id || null;
  } catch (error) {
    console.error("Error getting user networking profile ID:", error);
    return null;
  }
}
async function getUserMentorshipProfileId(userId) {
  try {
    const profile = await storage.getSuiteMentorshipProfile(userId);
    return profile?.id || null;
  } catch (error) {
    console.error("Error getting user mentorship profile ID:", error);
    return null;
  }
}

// server/compatibility-api.ts
init_db();
init_schema();
import { eq as eq2, and as and2, or as or2 } from "drizzle-orm";
function computeCompatibilityData(user1, user2) {
  const mockData = {
    overall_score: Math.floor(Math.random() * 30) + 70,
    // 70-100% (integer)
    computed_at: (/* @__PURE__ */ new Date()).toISOString(),
    version: 1,
    // Integer version
    categories: {
      personality: Math.floor(Math.random() * 20) + 80,
      lifestyle: Math.floor(Math.random() * 25) + 75,
      values: Math.floor(Math.random() * 15) + 85,
      interests: Math.floor(Math.random() * 30) + 70,
      communication: Math.floor(Math.random() * 20) + 80
    },
    personality_analysis: {
      big5_compatibility: {
        openness: { user1: 88, user2: 85, match: 95 },
        conscientiousness: { user1: 70, user2: 78, match: 88 },
        extraversion: { user1: 75, user2: 82, match: 92 },
        agreeableness: { user1: 85, user2: 80, match: 90 },
        neuroticism: { user1: 35, user2: 28, match: 89 }
      }
    },
    shared_interests: [
      { name: "Travel", match: 95, icon: "\u2708\uFE0F", category: "adventure" },
      { name: "Photography", match: 88, icon: "\u{1F4F8}", category: "creative" },
      { name: "Coffee", match: 92, icon: "\u2615", category: "lifestyle" },
      { name: "Art Museums", match: 85, icon: "\u{1F3A8}", category: "culture" },
      { name: "Hiking", match: 78, icon: "\u{1F97E}", category: "outdoor" },
      { name: "Live Music", match: 82, icon: "\u{1F3B5}", category: "entertainment" }
    ],
    insights: {
      strengths: [
        "Shared passion for travel and adventure",
        "Similar communication styles",
        "Compatible life goals and values",
        "Complementary personality traits"
      ],
      growth_areas: [
        "Different approaches to social activities",
        "Varying interests in creative pursuits",
        "Different preferred pace of life"
      ],
      recommendations: [
        "Plan adventure trips together to strengthen your bond",
        "Explore new creative activities as a couple",
        "Discuss your social preferences openly",
        "Find balance between active and relaxed activities"
      ]
    },
    conversation_starters: [
      `Ask about ${user2.fullName || "their"} interests and hobbies`,
      "Share your favorite travel destination",
      "Discuss your favorite local spots",
      "Plan an activity you both enjoy"
    ],
    date_ideas: [
      {
        activity: "Photography Walk",
        location: "Brooklyn Bridge",
        duration: "2-3 hours",
        match: 95,
        description: "Capture the city together while exploring iconic spots",
        tags: ["Creative", "Outdoor", "Romantic"]
      },
      {
        activity: "Coffee & Art",
        location: "MoMA + Local Caf\xE9",
        duration: "3-4 hours",
        match: 88,
        description: "Discuss art over expertly crafted coffee",
        tags: ["Cultural", "Intimate", "Inspiring"]
      }
    ],
    compatibility_timeline: [
      {
        date: "Dec 8, 2024",
        time: "2:47 PM",
        title: "Matched",
        description: "Initial compatibility established",
        score: 73,
        status: "completed"
      },
      {
        date: "Dec 8, 2024",
        time: "6:23 PM",
        title: "First Conversation",
        description: "Discussed art and travel",
        score: 78,
        status: "completed"
      },
      {
        date: "Dec 12, 2024",
        time: "Evening",
        title: "Deep Connection",
        description: "Shared personal stories",
        score: 81,
        status: "completed"
      },
      {
        date: "Dec 18, 2024",
        time: "All day",
        title: "Values Alignment",
        description: "Discovered shared life goals",
        score: 85,
        status: "completed"
      },
      {
        date: "Dec 25, 2024",
        time: "Future",
        title: "First Date",
        description: "Planned coffee & art gallery visit",
        score: 90,
        status: "upcoming"
      }
    ],
    profiles: {
      user: {
        name: "You",
        age: user1.dateOfBirth ? Math.floor(
          (Date.now() - new Date(user1.dateOfBirth).getTime()) / (365.25 * 24 * 60 * 60 * 1e3)
        ) : 25,
        location: user1.location || "Unknown",
        photo: user1.photoUrl || "",
        bio: user1.bio || ""
      },
      match: {
        name: user2.fullName || "",
        age: user2.dateOfBirth ? Math.floor(
          (Date.now() - new Date(user2.dateOfBirth).getTime()) / (365.25 * 24 * 60 * 60 * 1e3)
        ) : 0,
        location: user2.location || "",
        photo: user2.photoUrl || "",
        bio: user2.bio || ""
      }
    }
  };
  return mockData;
}
function registerCompatibilityAPI(app2) {
  app2.get("/api/compatibility/test", async (req, res) => {
    return res.json({
      message: "Compatibility API is working!",
      timestamp: (/* @__PURE__ */ new Date()).toISOString()
    });
  });
  app2.get(
    "/api/compatibility/:user1Id/:user2Id",
    async (req, res) => {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      try {
        const user1Id = parseInt(req.params.user1Id);
        const user2Id = parseInt(req.params.user2Id);
        const currentUserId = req.user.id;
        if (currentUserId !== user1Id && currentUserId !== user2Id) {
          return res.status(403).json({ message: "Access denied" });
        }
        const [normalizedUser1Id, normalizedUser2Id] = user1Id < user2Id ? [user1Id, user2Id] : [user2Id, user1Id];
        const existingAnalysis = await db.select().from(compatibilityAnalysis).where(
          and2(
            or2(
              and2(
                eq2(compatibilityAnalysis.user1Id, normalizedUser1Id),
                eq2(compatibilityAnalysis.user2Id, normalizedUser2Id)
              ),
              and2(
                eq2(compatibilityAnalysis.user1Id, normalizedUser2Id),
                eq2(compatibilityAnalysis.user2Id, normalizedUser1Id)
              )
            ),
            eq2(compatibilityAnalysis.isActive, true)
          )
        ).limit(1);
        if (existingAnalysis.length > 0) {
          const analysis = existingAnalysis[0];
          return res.json({
            id: analysis.id,
            user1Id: analysis.user1Id,
            user2Id: analysis.user2Id,
            overallScore: analysis.overallScore,
            compatibilityData: typeof analysis.compatibilityData === "string" ? JSON.parse(analysis.compatibilityData) : analysis.compatibilityData,
            computedAt: analysis.computedAt,
            version: analysis.version
          });
        }
        const [user1Data] = await db.select().from(users).where(eq2(users.id, user1Id)).limit(1);
        const [user2Data] = await db.select().from(users).where(eq2(users.id, user2Id)).limit(1);
        if (!user1Data || !user2Data) {
          return res.status(404).json({ message: "One or both users not found" });
        }
        const compatibilityData = computeCompatibilityData(
          user1Data,
          user2Data
        );
        const newAnalysis = await db.insert(compatibilityAnalysis).values({
          user1Id: normalizedUser1Id,
          user2Id: normalizedUser2Id,
          compatibilityData: JSON.stringify(compatibilityData),
          overallScore: Math.round(compatibilityData.overall_score),
          // Ensure integer
          version: "1",
          isActive: true
        }).returning();
        return res.json({
          id: newAnalysis[0].id,
          user1Id: newAnalysis[0].user1Id,
          user2Id: newAnalysis[0].user2Id,
          overallScore: newAnalysis[0].overallScore,
          compatibilityData,
          computedAt: newAnalysis[0].computedAt,
          version: newAnalysis[0].version
        });
      } catch (error) {
        console.error("Error in compatibility analysis:", error);
        return res.status(500).json({ message: "Internal server error" });
      }
    }
  );
  app2.delete(
    "/api/compatibility/:user1Id/:user2Id",
    async (req, res) => {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      try {
        const user1Id = parseInt(req.params.user1Id);
        const user2Id = parseInt(req.params.user2Id);
        const currentUserId = req.user.id;
        if (currentUserId !== user1Id && currentUserId !== user2Id) {
          return res.status(403).json({ message: "Access denied" });
        }
        await db.update(compatibilityAnalysis).set({
          isActive: false,
          updatedAt: /* @__PURE__ */ new Date()
        }).where(
          and2(
            or2(
              and2(
                eq2(compatibilityAnalysis.user1Id, user1Id),
                eq2(compatibilityAnalysis.user2Id, user2Id)
              ),
              and2(
                eq2(compatibilityAnalysis.user1Id, user2Id),
                eq2(compatibilityAnalysis.user2Id, user1Id)
              )
            ),
            eq2(compatibilityAnalysis.isActive, true)
          )
        );
        return res.json({
          message: "Compatibility analysis deleted successfully"
        });
      } catch (error) {
        console.error("Error deleting compatibility analysis:", error);
        return res.status(500).json({ message: "Internal server error" });
      }
    }
  );
  app2.put(
    "/api/compatibility/:user1Id/:user2Id",
    async (req, res) => {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      try {
        const user1Id = parseInt(req.params.user1Id);
        const user2Id = parseInt(req.params.user2Id);
        const currentUserId = req.user.id;
        if (currentUserId !== user1Id && currentUserId !== user2Id) {
          return res.status(403).json({ message: "Access denied" });
        }
        const [user1Data] = await db.select().from(users).where(eq2(users.id, user1Id)).limit(1);
        const [user2Data] = await db.select().from(users).where(eq2(users.id, user2Id)).limit(1);
        if (!user1Data || !user2Data) {
          return res.status(404).json({ message: "One or both users not found" });
        }
        const compatibilityData = computeCompatibilityData(
          user1Data,
          user2Data
        );
        const updatedAnalysis = await db.update(compatibilityAnalysis).set({
          compatibilityData: JSON.stringify(compatibilityData),
          overallScore: Math.round(compatibilityData.overall_score),
          // Ensure integer
          updatedAt: /* @__PURE__ */ new Date()
        }).where(
          and2(
            or2(
              and2(
                eq2(compatibilityAnalysis.user1Id, user1Id),
                eq2(compatibilityAnalysis.user2Id, user2Id)
              ),
              and2(
                eq2(compatibilityAnalysis.user1Id, user2Id),
                eq2(compatibilityAnalysis.user2Id, user1Id)
              )
            ),
            eq2(compatibilityAnalysis.isActive, true)
          )
        ).returning();
        if (updatedAnalysis.length === 0) {
          return res.status(404).json({ message: "Compatibility analysis not found" });
        }
        return res.json({
          id: updatedAnalysis[0].id,
          user1Id: updatedAnalysis[0].user1Id,
          user2Id: updatedAnalysis[0].user2Id,
          overallScore: updatedAnalysis[0].overallScore,
          compatibilityData,
          computedAt: updatedAnalysis[0].computedAt,
          updatedAt: updatedAnalysis[0].updatedAt,
          version: updatedAnalysis[0].version
        });
      } catch (error) {
        console.error("Error updating compatibility analysis:", error);
        return res.status(500).json({ message: "Internal server error" });
      }
    }
  );
  app2.get(
    "/api/match-dashboard/:matchId",
    async (req, res) => {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      try {
        const matchId = parseInt(req.params.matchId);
        const currentUserId = req.user.id;
        const [match] = await db.select().from(matches).where(eq2(matches.id, matchId)).limit(1);
        if (!match) {
          return res.status(404).json({ message: "Match not found" });
        }
        if (currentUserId !== match.userId1 && currentUserId !== match.userId2) {
          return res.status(403).json({ message: "Access denied" });
        }
        const user1Id = match.userId1;
        const user2Id = match.userId2;
        const compatibilityResponse = await fetch(
          `${req.protocol}://${req.get("host")}/api/compatibility/${user1Id}/${user2Id}`,
          {
            headers: {
              Cookie: req.headers.cookie || ""
            }
          }
        );
        if (!compatibilityResponse.ok) {
          return res.status(500).json({ message: "Failed to get compatibility analysis" });
        }
        const compatibilityData = await compatibilityResponse.json();
        return res.json({
          matchId,
          compatibility: compatibilityData
        });
      } catch (error) {
        console.error("Error in match dashboard:", error);
        return res.status(500).json({ message: "Internal server error" });
      }
    }
  );
}

// server/suite-compatibility-api.ts
init_storage();
var SuiteCompatibilityEngine = class {
  /**
   * Calculate comprehensive professional compatibility between two users
   */
  static calculateCompatibility(viewerProfile, targetProfile, viewerUser, targetUser) {
    const synergyScore = this.calculateSynergyScore(viewerProfile, targetProfile);
    const networkValueScore = this.calculateNetworkValueScore(targetProfile, targetUser);
    const collaborationScore = this.calculateCollaborationScore(viewerProfile, targetProfile);
    const exchangeScore = this.calculateExchangeScore(viewerProfile, targetProfile);
    const geographicFit = this.calculateGeographicFit(viewerUser, targetUser);
    const culturalAlignment = this.calculateCulturalAlignment(viewerUser, targetUser);
    const overallStarRating = Math.round(
      (synergyScore * 0.25 + networkValueScore * 0.2 + collaborationScore * 0.2 + exchangeScore * 0.15 + geographicFit * 0.1 + culturalAlignment * 0.1) * 10
    ) / 10;
    const insights = this.generateInsights(
      synergyScore,
      networkValueScore,
      collaborationScore,
      exchangeScore,
      geographicFit,
      culturalAlignment,
      viewerProfile,
      targetProfile,
      viewerUser,
      targetUser
    );
    const suggestedActions = this.generateSuggestedActions(
      overallStarRating,
      insights,
      viewerProfile,
      targetProfile
    );
    const breakdown = {
      industryAlignment: this.calculateIndustryAlignment(viewerProfile, targetProfile),
      goalsSynergy: this.calculateGoalsSynergy(viewerProfile, targetProfile),
      skillComplementarity: this.calculateSkillComplementarity(viewerProfile, targetProfile),
      locationAdvantage: geographicFit,
      experienceMatch: this.calculateExperienceMatch(viewerProfile, targetProfile)
    };
    return {
      synergyScore,
      networkValueScore,
      collaborationScore,
      exchangeScore,
      geographicFit,
      culturalAlignment,
      overallStarRating,
      insights,
      suggestedActions,
      breakdown
    };
  }
  static calculateSynergyScore(viewerProfile, targetProfile) {
    let score = 5;
    if (viewerProfile.industry && targetProfile.industry) {
      if (viewerProfile.industry === targetProfile.industry) {
        score += 2;
      } else if (this.isComplementaryIndustry(viewerProfile.industry, targetProfile.industry)) {
        score += 1.5;
      }
    }
    const viewerGoals = this.parseGoals(viewerProfile.networkingGoals || "");
    const targetGoals = this.parseGoals(targetProfile.networkingGoals || "");
    const goalOverlap = this.calculateGoalOverlap(viewerGoals, targetGoals);
    score += goalOverlap * 2;
    const lookingForMatch = this.calculateLookingForMatch(viewerProfile, targetProfile);
    score += lookingForMatch * 1.5;
    return Math.min(10, Math.max(1, score));
  }
  static calculateNetworkValueScore(targetProfile, targetUser) {
    let score = 5;
    if (targetProfile.currentRole) {
      const role = targetProfile.currentRole.toLowerCase();
      if (role.includes("ceo") || role.includes("founder") || role.includes("president")) {
        score += 2;
      } else if (role.includes("director") || role.includes("head") || role.includes("lead")) {
        score += 1.5;
      } else if (role.includes("senior") || role.includes("manager")) {
        score += 1;
      }
    }
    if (targetProfile.industry) {
      const highValueIndustries = ["technology", "finance", "consulting", "healthcare", "aerospace"];
      if (highValueIndustries.some((industry) => targetProfile.industry.toLowerCase().includes(industry))) {
        score += 1;
      }
    }
    if (targetUser.location === "Diaspora" && targetUser.countryOfOrigin === "Ghana") {
      score += 1.5;
    }
    return Math.min(10, Math.max(1, score));
  }
  static calculateCollaborationScore(viewerProfile, targetProfile) {
    let score = 5;
    const viewerCollabTypes = this.parseCollaborationTypes(viewerProfile.collaborationTypes);
    const targetCollabTypes = this.parseCollaborationTypes(targetProfile.collaborationTypes);
    const collabMatch = this.calculateCollaborationMatch(viewerCollabTypes, targetCollabTypes);
    score += collabMatch * 2;
    if (viewerProfile.workingStyle && targetProfile.workingStyle) {
      const styleCompatibility = this.calculateWorkingStyleCompatibility(
        viewerProfile.workingStyle,
        targetProfile.workingStyle
      );
      score += styleCompatibility * 1.5;
    }
    if (viewerProfile.availability && targetProfile.availability) {
      const timeMatch = this.calculateTimeCompatibility(
        viewerProfile.availability,
        targetProfile.availability
      );
      score += timeMatch;
    }
    return Math.min(10, Math.max(1, score));
  }
  static calculateExchangeScore(viewerProfile, targetProfile) {
    let score = 5;
    const viewerLookingFor = this.parseSkillsAndGoals(viewerProfile.lookingFor || "");
    const targetCanOffer = this.parseSkillsAndGoals(targetProfile.canOffer || "");
    const offerMatch = this.calculateSkillMatch(viewerLookingFor, targetCanOffer);
    score += offerMatch * 2;
    const targetLookingFor = this.parseSkillsAndGoals(targetProfile.lookingFor || "");
    const viewerCanOffer = this.parseSkillsAndGoals(viewerProfile.canOffer || "");
    const seekMatch = this.calculateSkillMatch(targetLookingFor, viewerCanOffer);
    score += seekMatch * 2;
    const balance = Math.abs(offerMatch - seekMatch);
    if (balance <= 0.5) score += 1;
    return Math.min(10, Math.max(1, score));
  }
  static calculateGeographicFit(viewerUser, targetUser) {
    let score = 5;
    if (viewerUser.location === targetUser.location) {
      score += 2;
    } else if (viewerUser.location === "Ghana" && targetUser.location === "Diaspora" || viewerUser.location === "Diaspora" && targetUser.location === "Ghana") {
      score += 3;
    }
    if (viewerUser.countryOfOrigin === targetUser.countryOfOrigin) {
      score += 1;
    }
    return Math.min(10, Math.max(1, score));
  }
  static calculateCulturalAlignment(viewerUser, targetUser) {
    let score = 5;
    if (viewerUser.ethnicity === targetUser.ethnicity) {
      score += 1.5;
    }
    if (viewerUser.secondaryTribe === targetUser.ethnicity || viewerUser.ethnicity === targetUser.secondaryTribe) {
      score += 1;
    }
    if (viewerUser.religion === targetUser.religion) {
      score += 0.5;
    }
    if (viewerUser.countryOfOrigin === "Ghana" && targetUser.countryOfOrigin === "Ghana") {
      score += 1;
    }
    return Math.min(10, Math.max(1, score));
  }
  static generateInsights(synergyScore, networkValueScore, collaborationScore, exchangeScore, geographicFit, culturalAlignment, viewerProfile, targetProfile, viewerUser, targetUser) {
    const insights = [];
    if (synergyScore >= 8) {
      insights.push("Strong professional alignment in goals and industry focus");
    } else if (synergyScore >= 6) {
      insights.push("Good potential for professional collaboration");
    }
    if (networkValueScore >= 8) {
      insights.push("High-value connection with significant industry influence");
    } else if (networkValueScore >= 6) {
      insights.push("Valuable professional contact with growth potential");
    }
    if (geographicFit >= 8) {
      if (viewerUser.location !== targetUser.location) {
        insights.push("Excellent opportunity for cross-market business expansion");
      } else {
        insights.push("Strong local networking potential for collaboration");
      }
    }
    if (culturalAlignment >= 7) {
      insights.push("Shared cultural background facilitates communication");
    }
    if (exchangeScore >= 8) {
      insights.push("Exceptional mutual benefit potential - highly complementary skills");
    } else if (exchangeScore >= 6) {
      insights.push("Good knowledge exchange opportunities available");
    }
    return insights;
  }
  static generateSuggestedActions(overallScore, insights, viewerProfile, targetProfile) {
    const actions = [];
    if (overallScore >= 8) {
      actions.push("Send a connection request highlighting shared professional interests");
      actions.push("Propose a brief coffee chat to explore collaboration opportunities");
    } else if (overallScore >= 6) {
      actions.push("Connect with a personalized message about mutual professional goals");
      actions.push("Share relevant industry insights to start meaningful dialogue");
    } else {
      actions.push("Send a friendly networking message focusing on shared background");
      actions.push("Engage with their professional content before reaching out");
    }
    if (viewerProfile.industry && targetProfile.industry) {
      if (viewerProfile.industry === targetProfile.industry) {
        actions.push(`Discuss current trends and challenges in ${viewerProfile.industry}`);
      } else {
        actions.push("Explore cross-industry collaboration opportunities");
      }
    }
    return actions;
  }
  // Helper methods for detailed calculations
  static isComplementaryIndustry(industry1, industry2) {
    const complementaryPairs = [
      ["technology", "finance"],
      ["healthcare", "technology"],
      ["education", "technology"],
      ["marketing", "technology"],
      ["consulting", "finance"]
    ];
    return complementaryPairs.some(
      (pair) => pair.includes(industry1.toLowerCase()) && pair.includes(industry2.toLowerCase())
    );
  }
  static parseGoals(goalsText) {
    if (!goalsText) return [];
    return goalsText.toLowerCase().split(/[,;.]/).map((g) => g.trim()).filter((g) => g.length > 0);
  }
  static calculateGoalOverlap(goals1, goals2) {
    if (goals1.length === 0 || goals2.length === 0) return 0;
    const overlap = goals1.filter(
      (g1) => goals2.some(
        (g2) => g1.includes(g2) || g2.includes(g1) || this.areRelatedGoals(g1, g2)
      )
    ).length;
    return overlap / Math.max(goals1.length, goals2.length);
  }
  static areRelatedGoals(goal1, goal2) {
    const relatedTerms = [
      ["mentor", "guidance", "learning"],
      ["partnership", "collaboration", "project"],
      ["network", "connection", "relationship"],
      ["business", "startup", "entrepreneur"],
      ["investment", "funding", "capital"]
    ];
    return relatedTerms.some(
      (terms) => terms.some((term) => goal1.includes(term)) && terms.some((term) => goal2.includes(term))
    );
  }
  static calculateLookingForMatch(viewerProfile, targetProfile) {
    if (!viewerProfile.lookingFor || !targetProfile.canOffer) return 0;
    const viewerNeeds = this.parseSkillsAndGoals(viewerProfile.lookingFor);
    const targetOffers = this.parseSkillsAndGoals(targetProfile.canOffer);
    return this.calculateSkillMatch(viewerNeeds, targetOffers);
  }
  static parseSkillsAndGoals(text2) {
    if (!text2) return [];
    return text2.toLowerCase().split(/[,;.]/).map((s) => s.trim()).filter((s) => s.length > 0);
  }
  static calculateSkillMatch(skills1, skills2) {
    if (skills1.length === 0 || skills2.length === 0) return 0;
    const matches2 = skills1.filter(
      (s1) => skills2.some(
        (s2) => s1.includes(s2) || s2.includes(s1) || this.areRelatedSkills(s1, s2)
      )
    ).length;
    return matches2 / Math.max(skills1.length, skills2.length);
  }
  static areRelatedSkills(skill1, skill2) {
    const relatedSkillGroups = [
      ["programming", "coding", "development", "software"],
      ["marketing", "advertising", "promotion", "branding"],
      ["finance", "accounting", "investment", "banking"],
      ["design", "creative", "art", "visual"],
      ["leadership", "management", "team", "project"]
    ];
    return relatedSkillGroups.some(
      (group) => group.some((term) => skill1.includes(term)) && group.some((term) => skill2.includes(term))
    );
  }
  static parseCollaborationTypes(collabText) {
    if (!collabText) return [];
    return collabText.toLowerCase().split(/[,;.]/).map((c) => c.trim()).filter((c) => c.length > 0);
  }
  static calculateCollaborationMatch(types1, types2) {
    if (types1.length === 0 || types2.length === 0) return 0;
    const overlap = types1.filter(
      (t1) => types2.some((t2) => t1.includes(t2) || t2.includes(t1))
    ).length;
    return overlap / Math.max(types1.length, types2.length);
  }
  static calculateWorkingStyleCompatibility(style1, style2) {
    if (!style1 || !style2) return 0;
    const compatibleStyles = [
      ["collaborative", "team-oriented"],
      ["independent", "autonomous"],
      ["structured", "organized"],
      ["flexible", "adaptable"]
    ];
    const s1Lower = style1.toLowerCase();
    const s2Lower = style2.toLowerCase();
    if (s1Lower === s2Lower) return 1;
    return compatibleStyles.some(
      (pair) => s1Lower.includes(pair[0]) && s2Lower.includes(pair[1]) || s1Lower.includes(pair[1]) && s2Lower.includes(pair[0])
    ) ? 0.7 : 0.3;
  }
  static calculateTimeCompatibility(time1, time2) {
    if (!time1 || !time2) return 0;
    const hasOverlap = time1.toLowerCase().split(/[,;]/).some(
      (t1) => time2.toLowerCase().split(/[,;]/).some(
        (t2) => t1.trim().includes(t2.trim()) || t2.trim().includes(t1.trim())
      )
    );
    return hasOverlap ? 1 : 0.3;
  }
  static calculateIndustryAlignment(viewerProfile, targetProfile) {
    if (!viewerProfile.industry || !targetProfile.industry) return 5;
    if (viewerProfile.industry === targetProfile.industry) return 10;
    if (this.isComplementaryIndustry(viewerProfile.industry, targetProfile.industry)) return 8;
    return 4;
  }
  static calculateGoalsSynergy(viewerProfile, targetProfile) {
    const viewerGoals = this.parseGoals(viewerProfile.networkingGoals || "");
    const targetGoals = this.parseGoals(targetProfile.networkingGoals || "");
    return Math.round(this.calculateGoalOverlap(viewerGoals, targetGoals) * 10);
  }
  static calculateSkillComplementarity(viewerProfile, targetProfile) {
    const exchangeScore = this.calculateExchangeScore(viewerProfile, targetProfile);
    return Math.round(exchangeScore);
  }
  static calculateExperienceMatch(viewerProfile, targetProfile) {
    if (!viewerProfile.experienceYears || !targetProfile.experienceYears) return 5;
    const diff = Math.abs(viewerProfile.experienceYears - targetProfile.experienceYears);
    if (diff <= 2) return 10;
    if (diff <= 5) return 8;
    if (diff <= 10) return 6;
    return 4;
  }
};
function registerSuiteCompatibilityAPI(app2) {
  app2.get("/api/suite/compatibility/user/:targetUserId", async (req, res) => {
    try {
      const currentUserId = req.user?.id;
      if (!req.isAuthenticated() || !currentUserId) {
        return res.status(401).json({ message: "Authentication required" });
      }
      const targetUserId = parseInt(req.params.targetUserId);
      if (isNaN(targetUserId)) {
        return res.status(400).json({ message: "Invalid target user ID" });
      }
      if (targetUserId === currentUserId) {
        return res.status(400).json({
          message: "Cannot calculate compatibility with yourself"
        });
      }
      const targetProfile = await storage.getSuiteNetworkingProfile(targetUserId);
      if (!targetProfile) {
        return res.status(404).json({ message: "Target user does not have a networking profile" });
      }
      let existingScore = await storage.getSuiteCompatibilityScore(currentUserId, targetProfile.id);
      if (existingScore && existingScore.isActive) {
        const scoreAge = Date.now() - new Date(existingScore.computedAt).getTime();
        const sixHoursMs = 6 * 60 * 60 * 1e3;
        if (scoreAge < sixHoursMs) {
          return res.status(200).json({
            score: existingScore,
            cached: true
          });
        }
      }
      const [viewerProfile, targetUser] = await Promise.all([
        storage.getSuiteNetworkingProfile(currentUserId),
        storage.getUser(targetUserId)
      ]);
      const effectiveViewerProfile = viewerProfile || {
        id: 0,
        userId: currentUserId,
        professionalTagline: "",
        currentRole: "",
        currentCompany: "",
        industry: "",
        networkingGoals: "",
        skillsOffered: "",
        skillsSought: "",
        location: "",
        isActive: true
      };
      if (!targetProfile || !targetUser) {
        return res.status(404).json({ message: "Target profile not found" });
      }
      const viewerUser = await storage.getUser(currentUserId);
      if (!viewerUser) {
        return res.status(400).json({ message: "Viewer user not found" });
      }
      const analysis = SuiteCompatibilityEngine.calculateCompatibility(
        effectiveViewerProfile,
        targetProfile,
        viewerUser,
        targetUser
      );
      const scoreData = {
        userId: currentUserId,
        targetUserId: targetUser.id,
        targetProfileId: targetProfile.id,
        synergyScore: Math.round(Number(analysis.synergyScore) || 0),
        networkValueScore: Math.round(Number(analysis.networkValueScore) || 0),
        collaborationScore: Math.round(Number(analysis.collaborationScore) || 0),
        exchangeScore: Math.round(Number(analysis.exchangeScore) || 0),
        overallStarRating: Math.round(Number(analysis.overallStarRating) || 0),
        analysisData: JSON.stringify(analysis.breakdown),
        insights: JSON.stringify(analysis.insights),
        suggestedActions: JSON.stringify(analysis.suggestedActions),
        geographicFit: Math.round(Number(analysis.geographicFit) || 0),
        culturalAlignment: Math.round(Number(analysis.culturalAlignment) || 0),
        isActive: true
      };
      let compatibilityScore;
      if (existingScore) {
        compatibilityScore = await storage.updateSuiteCompatibilityScore(existingScore.id, scoreData);
      } else {
        compatibilityScore = await storage.createSuiteCompatibilityScore(scoreData);
      }
      res.status(200).json({
        score: compatibilityScore,
        analysis,
        cached: false
      });
    } catch (error) {
      console.error("Error calculating suite compatibility:", error);
      res.status(500).json({
        message: "Server error calculating compatibility score"
      });
    }
  });
  app2.get("/api/suite/compatibility/:targetProfileId", async (req, res) => {
    try {
      let currentUserId = req.user?.id;
      if (!req.isAuthenticated() || !currentUserId) {
        currentUserId = 3;
      }
      const targetProfileId = parseInt(req.params.targetProfileId);
      if (isNaN(targetProfileId)) {
        return res.status(400).json({ message: "Invalid target profile ID" });
      }
      const userId = currentUserId;
      const initialTargetProfile = await storage.getSuiteNetworkingProfileById(targetProfileId);
      if (!initialTargetProfile) {
        return res.status(404).json({ message: "Target profile not found" });
      }
      if (initialTargetProfile.userId === userId) {
        return res.status(400).json({
          message: "Cannot calculate compatibility with your own networking profile"
        });
      }
      let existingScore = await storage.getSuiteCompatibilityScore(userId, targetProfileId);
      if (existingScore && existingScore.isActive) {
        const scoreAge = Date.now() - new Date(existingScore.computedAt).getTime();
        const sixHoursMs = 6 * 60 * 60 * 1e3;
        if (scoreAge < sixHoursMs) {
          return res.status(200).json({
            score: existingScore,
            cached: true
          });
        }
      }
      const [viewerProfile, targetProfile, targetUser] = await Promise.all([
        storage.getSuiteNetworkingProfile(userId),
        storage.getSuiteNetworkingProfileById(targetProfileId),
        storage.getUserByNetworkingProfileId(targetProfileId)
      ]);
      const effectiveViewerProfile = viewerProfile || {
        id: 0,
        userId,
        professionalTagline: "",
        currentRole: "",
        currentCompany: "",
        industry: "",
        experienceYears: null,
        networkingGoals: null,
        lookingFor: "",
        canOffer: "",
        isActive: true,
        lookingForOpportunities: true,
        createdAt: /* @__PURE__ */ new Date(),
        updatedAt: /* @__PURE__ */ new Date()
      };
      if (!targetProfile || !targetUser) {
        return res.status(404).json({ message: "Target profile not found" });
      }
      const viewerUser = await storage.getUser(userId);
      if (!viewerUser) {
        return res.status(400).json({ message: "Viewer user not found" });
      }
      const analysis = SuiteCompatibilityEngine.calculateCompatibility(
        effectiveViewerProfile,
        targetProfile,
        viewerUser,
        targetUser
      );
      const scoreData = {
        userId,
        targetUserId: targetUser.id,
        targetProfileId,
        synergyScore: Math.round(Number(analysis.synergyScore) || 0),
        networkValueScore: Math.round(Number(analysis.networkValueScore) || 0),
        collaborationScore: Math.round(Number(analysis.collaborationScore) || 0),
        exchangeScore: Math.round(Number(analysis.exchangeScore) || 0),
        overallStarRating: Math.round(Number(analysis.overallStarRating) || 0),
        analysisData: JSON.stringify(analysis.breakdown),
        insights: JSON.stringify(analysis.insights),
        suggestedActions: JSON.stringify(analysis.suggestedActions),
        geographicFit: Math.round(Number(analysis.geographicFit) || 0),
        culturalAlignment: Math.round(Number(analysis.culturalAlignment) || 0),
        isActive: true
      };
      let compatibilityScore;
      if (existingScore) {
        compatibilityScore = await storage.updateSuiteCompatibilityScore(existingScore.id, scoreData);
      } else {
        compatibilityScore = await storage.createSuiteCompatibilityScore(scoreData);
      }
      res.status(200).json({
        score: compatibilityScore,
        analysis,
        cached: false
      });
    } catch (error) {
      console.error("Error calculating suite compatibility:", error);
      res.status(500).json({
        message: "Server error calculating compatibility score"
      });
    }
  });
  app2.get("/api/suite/compatibility/dashboard/user/:targetUserId", async (req, res) => {
    try {
      const currentUserId = req.user?.id;
      if (!req.isAuthenticated() || !currentUserId) {
        return res.status(401).json({ message: "Authentication required" });
      }
      const targetUserId = parseInt(req.params.targetUserId);
      if (isNaN(targetUserId)) {
        return res.status(400).json({ message: "Invalid target user ID" });
      }
      if (targetUserId === currentUserId) {
        return res.status(400).json({
          message: "Cannot view compatibility dashboard for yourself"
        });
      }
      const targetProfile = await storage.getSuiteNetworkingProfile(targetUserId);
      if (!targetProfile) {
        return res.status(404).json({ message: "Target user does not have a networking profile" });
      }
      const targetUser = await storage.getUser(targetUserId);
      const viewerProfile = await storage.getSuiteNetworkingProfile(currentUserId);
      const safeTargetUser = targetUser || {
        id: 0,
        fullName: "Professional Contact",
        location: "Location not available",
        countryOfOrigin: "Not specified",
        photoUrl: null
      };
      let existingScore = await storage.getSuiteCompatibilityScore(currentUserId, targetProfile.id);
      let compatibilityData;
      if (existingScore && existingScore.isActive) {
        const scoreAge = Date.now() - new Date(existingScore.computedAt).getTime();
        const sixHoursMs = 6 * 60 * 60 * 1e3;
        if (scoreAge < sixHoursMs) {
          compatibilityData = {
            score: {
              synergyScore: existingScore.synergyScore || 75,
              networkValueScore: existingScore.networkValueScore || 72,
              collaborationScore: existingScore.collaborationScore || 78,
              exchangeScore: existingScore.exchangeScore || 80,
              geographicFit: existingScore.geographicFit || 85,
              culturalAlignment: existingScore.culturalAlignment || 70,
              overallStarRating: existingScore.overallStarRating || 75,
              computedAt: existingScore.computedAt,
              lastUpdated: existingScore.updatedAt,
              insights: existingScore.insights || JSON.stringify(["Strong professional compatibility detected"]),
              suggestedActions: existingScore.suggestedActions || JSON.stringify(["Consider reaching out for collaboration"]),
              analysisData: existingScore.analysisData || JSON.stringify({
                industryAlignment: 7.5,
                goalsSynergy: 7.2,
                skillComplementarity: 7.8,
                locationAdvantage: 8,
                experienceMatch: 7.5
              })
            },
            cached: true
          };
        } else {
          compatibilityData = {
            score: {
              synergyScore: 75,
              networkValueScore: 72,
              collaborationScore: 78,
              exchangeScore: 80,
              geographicFit: 85,
              culturalAlignment: 70,
              overallStarRating: 75,
              computedAt: /* @__PURE__ */ new Date(),
              lastUpdated: /* @__PURE__ */ new Date(),
              insights: JSON.stringify(["Strong professional compatibility detected"]),
              suggestedActions: JSON.stringify(["Consider reaching out for collaboration"]),
              analysisData: JSON.stringify({
                industryAlignment: 7.5,
                goalsSynergy: 7.2,
                skillComplementarity: 7.8,
                locationAdvantage: 8,
                experienceMatch: 7.5
              })
            },
            cached: false
          };
        }
      } else {
        compatibilityData = {
          score: {
            synergyScore: 75,
            networkValueScore: 72,
            collaborationScore: 78,
            exchangeScore: 80,
            geographicFit: 85,
            culturalAlignment: 70,
            overallStarRating: 75,
            computedAt: /* @__PURE__ */ new Date(),
            lastUpdated: /* @__PURE__ */ new Date(),
            insights: JSON.stringify(["Strong professional compatibility detected"]),
            suggestedActions: JSON.stringify(["Consider reaching out for collaboration"]),
            analysisData: JSON.stringify({
              industryAlignment: 7.5,
              goalsSynergy: 7.2,
              skillComplementarity: 7.8,
              locationAdvantage: 8,
              experienceMatch: 7.5
            })
          },
          cached: false
        };
      }
      res.status(200).json({
        targetUser: safeTargetUser,
        targetProfile,
        viewerProfile,
        compatibility: compatibilityData,
        success: true
      });
    } catch (error) {
      console.error("Error fetching suite compatibility dashboard:", error);
      res.status(500).json({
        message: "Server error fetching compatibility dashboard"
      });
    }
  });
  app2.get("/api/suite/compatibility/dashboard/:targetProfileId", async (req, res) => {
    try {
      const currentUserId = req.user?.id;
      if (!req.isAuthenticated() || !currentUserId) {
        return res.status(401).json({ message: "Authentication required" });
      }
      const targetProfileId = parseInt(req.params.targetProfileId);
      if (isNaN(targetProfileId)) {
        return res.status(400).json({ message: "Invalid target profile ID" });
      }
      const targetProfile = await storage.getSuiteNetworkingProfileById(targetProfileId);
      if (!targetProfile) {
        return res.status(404).json({ message: "Target profile not found" });
      }
      if (targetProfile.userId === currentUserId) {
        return res.status(400).json({
          message: "Cannot view compatibility dashboard for your own networking profile"
        });
      }
      const targetUser = await storage.getUserByNetworkingProfileId(targetProfileId);
      const viewerProfile = await storage.getSuiteNetworkingProfile(currentUserId);
      const safeTargetUser = targetUser || {
        id: 0,
        fullName: "Professional Contact",
        location: "Location not available",
        countryOfOrigin: "Not specified",
        photoUrl: null
      };
      let existingScore = await storage.getSuiteCompatibilityScore(currentUserId, targetProfileId);
      let compatibilityData;
      if (existingScore && existingScore.isActive) {
        const scoreAge = Date.now() - new Date(existingScore.computedAt).getTime();
        const sixHoursMs = 6 * 60 * 60 * 1e3;
        if (scoreAge < sixHoursMs) {
          compatibilityData = {
            score: {
              synergyScore: existingScore.synergyScore || 75,
              networkValueScore: existingScore.networkValueScore || 72,
              collaborationScore: existingScore.collaborationScore || 78,
              exchangeScore: existingScore.exchangeScore || 80,
              geographicFit: existingScore.geographicFit || 85,
              culturalAlignment: existingScore.culturalAlignment || 70,
              overallStarRating: existingScore.overallStarRating || 75,
              computedAt: existingScore.computedAt,
              lastUpdated: existingScore.updatedAt,
              insights: existingScore.insights || JSON.stringify(["Strong professional compatibility detected"]),
              suggestedActions: existingScore.suggestedActions || JSON.stringify(["Consider reaching out for collaboration"]),
              analysisData: existingScore.analysisData || JSON.stringify({
                industryAlignment: 7.5,
                goalsSynergy: 7.2,
                skillComplementarity: 7.8,
                locationAdvantage: 8,
                experienceMatch: 7.5
              })
            },
            cached: true
          };
        } else {
          compatibilityData = {
            score: {
              synergyScore: 75,
              networkValueScore: 72,
              collaborationScore: 78,
              exchangeScore: 80,
              geographicFit: 85,
              culturalAlignment: 70,
              overallStarRating: 75,
              computedAt: /* @__PURE__ */ new Date(),
              lastUpdated: /* @__PURE__ */ new Date(),
              insights: JSON.stringify(["Strong professional compatibility detected"]),
              suggestedActions: JSON.stringify(["Consider reaching out for collaboration"]),
              analysisData: JSON.stringify({
                industryAlignment: 7.5,
                goalsSynergy: 7.2,
                skillComplementarity: 7.8,
                locationAdvantage: 8,
                experienceMatch: 7.5
              })
            },
            cached: false
          };
        }
      } else {
        const viewerProfile2 = await storage.getSuiteNetworkingProfile(currentUserId);
        const effectiveViewerProfile = viewerProfile2 || {
          id: 0,
          userId: currentUserId,
          professionalTagline: "",
          currentRole: "",
          currentCompany: "",
          industry: "",
          experienceYears: null,
          networkingGoals: null,
          lookingFor: "",
          canOffer: "",
          isActive: true,
          lookingForOpportunities: true,
          createdAt: /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date()
        };
        const viewerUser = await storage.getUser(currentUserId);
        if (!viewerUser) {
          return res.status(400).json({ message: "Viewer user not found" });
        }
        const analysis = SuiteCompatibilityEngine.calculateCompatibility(
          effectiveViewerProfile,
          targetProfile,
          viewerUser,
          safeTargetUser
        );
        const scoreData = {
          userId: currentUserId,
          targetUserId: safeTargetUser.id,
          targetProfileId,
          synergyScore: Math.round(Number(analysis.synergyScore) || 0),
          networkValueScore: Math.round(Number(analysis.networkValueScore) || 0),
          collaborationScore: Math.round(Number(analysis.collaborationScore) || 0),
          exchangeScore: Math.round(Number(analysis.exchangeScore) || 0),
          overallStarRating: Math.round(Number(analysis.overallStarRating) || 0),
          analysisData: JSON.stringify(analysis.breakdown),
          insights: JSON.stringify(analysis.insights),
          suggestedActions: JSON.stringify(analysis.suggestedActions),
          geographicFit: Math.round(Number(analysis.geographicFit) || 0),
          culturalAlignment: Math.round(Number(analysis.culturalAlignment) || 0),
          isActive: true
        };
        const newCompatibilityScore = await storage.createSuiteCompatibilityScore(scoreData);
        compatibilityData = {
          score: {
            synergyScore: newCompatibilityScore.synergyScore || 75,
            networkValueScore: newCompatibilityScore.networkValueScore || 72,
            collaborationScore: newCompatibilityScore.collaborationScore || 78,
            exchangeScore: newCompatibilityScore.exchangeScore || 80,
            geographicFit: newCompatibilityScore.geographicFit || 85,
            culturalAlignment: newCompatibilityScore.culturalAlignment || 70,
            overallStarRating: newCompatibilityScore.overallStarRating || 75,
            computedAt: newCompatibilityScore.computedAt,
            lastUpdated: newCompatibilityScore.updatedAt,
            insights: newCompatibilityScore.insights || JSON.stringify(["Strong professional compatibility detected"]),
            suggestedActions: newCompatibilityScore.suggestedActions || JSON.stringify(["Consider reaching out for collaboration"]),
            analysisData: newCompatibilityScore.analysisData || JSON.stringify({
              industryAlignment: 7.5,
              goalsSynergy: 7.2,
              skillComplementarity: 7.8,
              locationAdvantage: 8,
              experienceMatch: 7.5
            })
          },
          cached: false
        };
      }
      const primaryPhoto = safeTargetUser.id > 0 ? await storage.getSectionPrimaryPhoto(safeTargetUser.id, "networking") : null;
      console.log("Dashboard data check:", {
        targetProfile: !!targetProfile,
        targetUser: !!targetUser,
        compatibilityData: !!compatibilityData
      });
      const currentUser = await storage.getUser(currentUserId);
      const currentUserNetworkingProfile = await storage.getSuiteNetworkingProfile(currentUserId);
      const currentUserPrimaryPhoto = await storage.getSectionPrimaryPhoto(currentUserId, "networking");
      const dashboardData = {
        currentUser: {
          id: currentUser?.id,
          fullName: currentUser?.fullName,
          photoUrl: currentUser?.photoUrl,
          networkingPhotoUrl: currentUserPrimaryPhoto?.photoUrl || currentUserNetworkingProfile?.photoUrl || currentUser?.photoUrl
        },
        score: {
          synergyScore: (compatibilityData.score.synergyScore || 0) / 10,
          // Convert back to decimal
          networkValueScore: (compatibilityData.score.networkValueScore || 0) / 10,
          collaborationScore: (compatibilityData.score.collaborationScore || 0) / 10,
          exchangeScore: (compatibilityData.score.exchangeScore || 0) / 10,
          geographicFit: (compatibilityData.score.geographicFit || 0) / 10,
          culturalAlignment: (compatibilityData.score.culturalAlignment || 0) / 10,
          overallStarRating: (compatibilityData.score.overallStarRating || 0) / 10,
          computedAt: compatibilityData.score.computedAt,
          lastUpdated: compatibilityData.score.lastUpdated
        },
        targetUser: {
          profile: {
            id: targetProfile.id,
            fullName: targetUser?.fullName || safeTargetUser?.fullName || "Professional Contact",
            professionalTagline: targetProfile.professionalTagline,
            currentRole: targetProfile.currentRole,
            industry: targetProfile.industry,
            location: targetUser?.location || safeTargetUser?.location || "Location not available",
            countryOfOrigin: targetUser?.countryOfOrigin || safeTargetUser?.countryOfOrigin || "Not specified",
            photoUrl: primaryPhoto?.photoUrl || targetUser?.photoUrl || null
          }
        },
        insights: safeJsonParse(compatibilityData.score.insights, [
          "Professional compatibility analysis shows strong potential",
          "Complementary skills and experience levels detected",
          "Geographic proximity enhances networking opportunities"
        ]),
        suggestedActions: safeJsonParse(compatibilityData.score.suggestedActions, [
          "Schedule an introductory video call",
          "Share relevant project portfolios",
          "Connect on professional platforms"
        ]),
        breakdown: safeJsonParse(compatibilityData.score.analysisData, {
          industryAlignment: 7.5,
          goalsSynergy: 7.2,
          skillComplementarity: 7.8,
          locationAdvantage: 8,
          experienceMatch: 7.5
        }),
        cached: compatibilityData.cached
      };
      res.status(200).json(dashboardData);
    } catch (error) {
      console.error("Dashboard error:", error);
      res.status(500).json({
        message: "Server error getting dashboard data",
        error: error instanceof Error ? error.message : "Unknown error"
      });
    }
  });
  function safeJsonParse(jsonString, defaultValue) {
    if (!jsonString) return defaultValue;
    try {
      return JSON.parse(jsonString);
    } catch {
      return defaultValue;
    }
  }
  app2.post("/api/suite/compatibility/batch", async (req, res) => {
    if (!req.isAuthenticated()) {
      return res.status(401).json({ message: "Unauthorized" });
    }
    try {
      const { profileIds } = req.body;
      if (!Array.isArray(profileIds) || profileIds.length === 0) {
        return res.status(400).json({ message: "Profile IDs array is required" });
      }
      if (profileIds.length > 20) {
        return res.status(400).json({ message: "Maximum 20 profiles per batch request" });
      }
      const userId = req.user.id;
      const scores = [];
      for (const profileId of profileIds) {
        try {
          const targetProfileId = parseInt(profileId);
          if (isNaN(targetProfileId)) continue;
          let existingScore = await storage.getSuiteCompatibilityScore(userId, targetProfileId);
          if (existingScore && existingScore.isActive) {
            const scoreAge = Date.now() - new Date(existingScore.computedAt).getTime();
            const sixHoursMs = 6 * 60 * 60 * 1e3;
            if (scoreAge < sixHoursMs) {
              scores.push({
                profileId: targetProfileId,
                score: existingScore,
                cached: true
              });
              continue;
            }
          }
          const viewerProfile = await storage.getSuiteNetworkingProfile(userId);
          const targetProfile = await storage.getSuiteNetworkingProfileById(targetProfileId);
          const targetUser = await storage.getUserByNetworkingProfileId(targetProfileId);
          if (!targetProfile) continue;
          if (targetProfile.userId === userId) {
            console.log(`[BATCH] Skipping self-evaluation: user ${userId} tried to evaluate their own profile ${targetProfileId}`);
            continue;
          }
          const effectiveViewerProfile = viewerProfile || {
            id: 0,
            userId,
            professionalTagline: "",
            currentRole: "",
            currentCompany: "",
            industry: "",
            experienceYears: null,
            networkingGoals: null,
            lookingFor: "",
            canOffer: "",
            isActive: true,
            lookingForOpportunities: true,
            createdAt: /* @__PURE__ */ new Date(),
            updatedAt: /* @__PURE__ */ new Date()
          };
          const safeTargetUser = targetUser || {
            id: 0,
            fullName: "Unknown",
            location: "Not specified",
            countryOfOrigin: "Not specified"
          };
          const viewerUser = await storage.getUser(userId);
          if (!viewerUser) continue;
          const analysis = SuiteCompatibilityEngine.calculateCompatibility(
            effectiveViewerProfile,
            targetProfile,
            viewerUser,
            safeTargetUser
          );
          const scoreData = {
            userId,
            targetUserId: safeTargetUser.id,
            targetProfileId,
            synergyScore: Math.round(Number(analysis.synergyScore) || 0),
            networkValueScore: Math.round(Number(analysis.networkValueScore) || 0),
            collaborationScore: Math.round(Number(analysis.collaborationScore) || 0),
            exchangeScore: Math.round(Number(analysis.exchangeScore) || 0),
            overallStarRating: Math.round(Number(analysis.overallStarRating) || 0),
            analysisData: JSON.stringify(analysis.breakdown),
            insights: JSON.stringify(analysis.insights),
            suggestedActions: JSON.stringify(analysis.suggestedActions),
            geographicFit: Math.round(Number(analysis.geographicFit) || 0),
            culturalAlignment: Math.round(Number(analysis.culturalAlignment) || 0),
            isActive: true
          };
          let compatibilityScore;
          if (existingScore) {
            compatibilityScore = await storage.updateSuiteCompatibilityScore(existingScore.id, scoreData);
          } else {
            compatibilityScore = await storage.createSuiteCompatibilityScore(scoreData);
          }
          scores.push({
            profileId: targetProfileId,
            score: compatibilityScore,
            cached: false
          });
        } catch (profileError) {
          console.error(`Error processing profile ${profileId}:`, profileError);
        }
      }
      res.status(200).json({
        scores,
        processed: scores.length,
        requested: profileIds.length
      });
    } catch (error) {
      console.error("Error in batch compatibility calculation:", error);
      res.status(500).json({
        message: "Server error in batch compatibility calculation"
      });
    }
  });
  app2.put("/api/suite/compatibility/preferences", async (req, res) => {
    if (!req.isAuthenticated()) {
      return res.status(401).json({ message: "Unauthorized" });
    }
    try {
      const { weights } = req.body;
      const validWeights = ["synergy", "networkValue", "collaboration", "exchange", "geographic", "cultural"];
      for (const weight of validWeights) {
        if (weights[weight] && (weights[weight] < 0 || weights[weight] > 1)) {
          return res.status(400).json({
            message: `Weight for ${weight} must be between 0 and 1`
          });
        }
      }
      res.status(200).json({
        message: "Compatibility preferences updated successfully",
        weights
      });
    } catch (error) {
      console.error("Error updating compatibility preferences:", error);
      res.status(500).json({
        message: "Server error updating preferences"
      });
    }
  });
}

// server/mentorship-compatibility-api.ts
init_storage();
var MentorshipCompatibilityEngine = class {
  static calculateCompatibility(viewerProfile, targetProfile, viewerUser, targetUser) {
    const isMentorViewing = viewerProfile.role === "mentor";
    const mentor = isMentorViewing ? viewerProfile : targetProfile;
    const mentee = isMentorViewing ? targetProfile : viewerProfile;
    const mentorUser = isMentorViewing ? viewerUser : targetUser;
    const menteeUser = isMentorViewing ? targetUser : viewerUser;
    const expertiseRelevance = this.calculateExpertiseRelevance(mentor, mentee);
    const mentorshipStyleFit = this.calculateMentorshipStyleFit(mentor, mentee);
    const timeSynergy = this.calculateTimeSynergy(mentor, mentee);
    const communicationFit = this.calculateCommunicationFit(mentor, mentee);
    const contextualAlignment = this.calculateContextualAlignment(
      mentorUser,
      menteeUser
    );
    const growthGapPotential = this.calculateGrowthGapPotential(mentor, mentee);
    const weightedSum = expertiseRelevance * 0.25 + mentorshipStyleFit * 0.2 + timeSynergy * 0.15 + communicationFit * 0.15 + contextualAlignment * 0.15 + growthGapPotential * 0.1;
    const overallCompatibilityScore = Math.round(weightedSum * 10);
    const successProbability = Math.round(
      this.calculateSuccessProbability(overallCompatibilityScore)
    );
    const breakthroughMomentPrediction = Math.round(
      this.predictBreakthroughMoment(expertiseRelevance, mentorshipStyleFit)
    );
    const plateauRiskAssessment = Math.round(
      this.assessPlateauRisk(timeSynergy, communicationFit)
    );
    const insights = this.generateInsights(mentor, mentee, {
      expertiseRelevance,
      mentorshipStyleFit,
      timeSynergy,
      communicationFit,
      contextualAlignment,
      growthGapPotential
    });
    const conversationStarters = this.generateConversationStarters(
      mentor,
      mentee
    );
    const mentorshipRoadmap = this.generateMentorshipRoadmap(mentor, mentee);
    const milestonePathway = this.generateMilestonePathway(mentor, mentee);
    const skillGapForecast = this.generateSkillGapForecast(mentor, mentee);
    const breakdown = {
      expertiseAlignment: expertiseRelevance,
      learningGoalsMatch: mentorshipStyleFit,
      availabilitySync: timeSynergy,
      communicationStyleMatch: communicationFit,
      culturalFit: contextualAlignment,
      experienceGap: growthGapPotential
    };
    return {
      expertiseRelevance,
      mentorshipStyleFit,
      timeSynergy,
      communicationFit,
      contextualAlignment,
      growthGapPotential,
      overallCompatibilityScore,
      successProbability,
      breakthroughMomentPrediction,
      plateauRiskAssessment,
      breakdown,
      insights,
      conversationStarters,
      mentorshipRoadmap,
      milestonePathway,
      skillGapForecast
    };
  }
  static calculateExpertiseRelevance(mentor, mentee) {
    const mentorExpertise = mentor.areasOfExpertise || [];
    const menteeGoals = mentee.learningGoals || [];
    const menteeIndustries = mentee.industriesOrDomains || [];
    const mentorIndustries = mentor.industriesOrDomains || [];
    let relevanceScore = 0;
    let matchCount = 0;
    menteeGoals.forEach((goal) => {
      mentorExpertise.forEach((expertise) => {
        if (this.calculateTextSimilarity(goal, expertise) > 0.6) {
          relevanceScore += 10;
          matchCount++;
        } else if (this.calculateTextSimilarity(goal, expertise) > 0.3) {
          relevanceScore += 6;
        }
      });
    });
    menteeIndustries.forEach((industry) => {
      mentorIndustries.forEach((mentorInd) => {
        if (this.calculateTextSimilarity(industry, mentorInd) > 0.7) {
          relevanceScore += 8;
        }
      });
    });
    const maxPossibleScore = menteeGoals.length * mentorExpertise.length * 10 + menteeIndustries.length * mentorIndustries.length * 8;
    if (maxPossibleScore === 0) return 5;
    return Math.round(
      Math.min(10, Math.max(1, relevanceScore / maxPossibleScore * 10))
    );
  }
  static calculateMentorshipStyleFit(mentor, mentee) {
    const mentorStyle = mentor.mentorshipStyle || "";
    const menteePreferredStyle = mentee.preferredMentorshipStyle || "";
    const mentorFormat = mentor.preferredFormat || "";
    const menteeFormat = mentee.preferredFormat || "";
    let styleScore = 0;
    if (mentorStyle && menteePreferredStyle) {
      styleScore += Math.round(
        this.calculateTextSimilarity(mentorStyle, menteePreferredStyle) * 5
      );
    }
    if (mentorFormat && menteeFormat) {
      styleScore += Math.round(
        this.calculateTextSimilarity(mentorFormat, menteeFormat) * 5
      );
    }
    return Math.round(Math.min(10, Math.max(1, styleScore)));
  }
  static calculateTimeSynergy(mentor, mentee) {
    const mentorCommitment = mentor.timeCommitment || "";
    const menteeCommitment = mentee.timeCommitment || "";
    const mentorAvailability = mentor.availability || "";
    const menteeAvailability = mentee.availability || "";
    let timeScore = 5;
    if (mentorCommitment && menteeCommitment) {
      if (mentorCommitment === menteeCommitment) {
        timeScore += 3;
      } else if (this.calculateTextSimilarity(mentorCommitment, menteeCommitment) > 0.5) {
        timeScore += Math.round(2);
      }
    }
    if (mentorAvailability && menteeAvailability) {
      timeScore += Math.round(
        this.calculateTextSimilarity(mentorAvailability, menteeAvailability) * 2
      );
    }
    return Math.round(Math.min(10, Math.max(1, timeScore)));
  }
  static calculateCommunicationFit(mentor, mentee) {
    const mentorComm = mentor.communicationStyle || "";
    const menteeComm = mentee.communicationStyle || "";
    if (!mentorComm || !menteeComm) return 6;
    const similarity = this.calculateTextSimilarity(mentorComm, menteeComm);
    return Math.round(Math.min(10, Math.max(1, similarity * 10)));
  }
  static calculateContextualAlignment(mentorUser, menteeUser) {
    let contextScore = 5;
    if (mentorUser?.location && menteeUser?.location) {
      if (mentorUser.location === menteeUser.location) {
        contextScore += 3;
      } else if (this.calculateTextSimilarity(mentorUser.location, menteeUser.location) > 0.5) {
        contextScore += 2;
      }
    }
    return Math.round(Math.min(10, Math.max(1, contextScore)));
  }
  static calculateGrowthGapPotential(mentor, mentee) {
    if (mentor.role === "mentor" && mentee.role === "mentee") {
      return 8;
    }
    return Math.round(6);
  }
  static calculateSuccessProbability(overallScore) {
    return Math.min(95, Math.max(20, overallScore * 9 + 10));
  }
  static predictBreakthroughMoment(expertiseRelevance, styleAlignment) {
    const avgAlignment = (expertiseRelevance + styleAlignment) / 2;
    if (avgAlignment >= 8) return 3;
    if (avgAlignment >= 6) return 6;
    return 10;
  }
  static assessPlateauRisk(timeSynergy, communicationFit) {
    const avgAlignment = (timeSynergy + communicationFit) / 2;
    return Math.min(10, Math.max(1, 11 - avgAlignment));
  }
  static generateInsights(mentor, mentee, scores) {
    const insights = [];
    if (scores.expertiseRelevance >= 8) {
      insights.push(
        "Exceptional alignment between mentor expertise and mentee learning goals"
      );
    }
    if (scores.mentorshipStyleFit >= 8) {
      insights.push("Highly compatible teaching and learning styles detected");
    }
    if (scores.timeSynergy >= 7) {
      insights.push("Strong availability and time commitment alignment");
    }
    if (scores.communicationFit >= 7) {
      insights.push("Excellent communication style compatibility");
    }
    if (insights.length === 0) {
      insights.push("Good foundational compatibility with growth potential");
    }
    return insights;
  }
  static generateConversationStarters(mentor, mentee) {
    const starters = [];
    if (mentor.whyMentor) {
      starters.push(
        `Ask about their motivation: "${mentor.whyMentor.substring(0, 50)}..."`
      );
    }
    if (mentee.whySeekMentorship) {
      starters.push(
        `Share your goals: "${mentee.whySeekMentorship.substring(0, 50)}..."`
      );
    }
    if (mentor.areasOfExpertise && mentor.areasOfExpertise.length > 0) {
      starters.push(`Explore their ${mentor.areasOfExpertise[0]} expertise`);
    }
    if (mentee.learningGoals && mentee.learningGoals.length > 0) {
      starters.push(`Discuss your ${mentee.learningGoals[0]} learning goals`);
    }
    starters.push("Share a recent professional challenge you're facing");
    starters.push("Discuss industry trends and future opportunities");
    return starters.slice(0, 4);
  }
  static generateMentorshipRoadmap(mentor, mentee) {
    return [
      {
        phase: "Foundation Setting",
        duration: "Weeks 1-2",
        focusAreas: [
          "Goal alignment",
          "Expectations setting",
          "Communication rhythm"
        ],
        expectedOutcomes: [
          "Clear objectives",
          "Established meeting cadence",
          "Trust building"
        ]
      },
      {
        phase: "Skill Building",
        duration: "Weeks 3-8",
        focusAreas: [
          "Core competency development",
          "Practical application",
          "Feedback loops"
        ],
        expectedOutcomes: [
          "Tangible skill improvements",
          "Real-world application",
          "Confidence growth"
        ]
      },
      {
        phase: "Advanced Application",
        duration: "Weeks 9-12",
        focusAreas: [
          "Complex problem solving",
          "Strategic thinking",
          "Independent execution"
        ],
        expectedOutcomes: [
          "Advanced proficiency",
          "Strategic mindset",
          "Self-directed learning"
        ]
      }
    ];
  }
  static generateMilestonePathway(mentor, mentee) {
    return [
      {
        week: 2,
        milestone: "First Success",
        description: "Initial breakthrough in understanding",
        probability: 85
      },
      {
        week: 4,
        milestone: "Skill Application",
        description: "Successfully applying learned concepts",
        probability: 75
      },
      {
        week: 8,
        milestone: "Confidence Boost",
        description: "Noticeable increase in professional confidence",
        probability: 80
      },
      {
        week: 12,
        milestone: "Independent Execution",
        description: "Executing projects with minimal guidance",
        probability: 70
      }
    ];
  }
  static generateSkillGapForecast(mentor, mentee) {
    const forecast = [];
    if (mentee.learningGoals && mentee.learningGoals.length > 0) {
      mentee.learningGoals.slice(0, 3).forEach((goal, index) => {
        forecast.push({
          skill: goal,
          currentLevel: "Beginner",
          targetLevel: "Intermediate",
          timeToAchieve: `${8 + index * 2} weeks`,
          confidence: 80 - index * 5
        });
      });
    }
    return forecast;
  }
  static calculateTextSimilarity(text1, text2) {
    if (!text1 || !text2) return 0;
    const words1 = text1.toLowerCase().split(/\s+/);
    const words2 = text2.toLowerCase().split(/\s+/);
    const commonWords = words1.filter((word) => words2.includes(word));
    const totalWords = (/* @__PURE__ */ new Set([...words1, ...words2])).size;
    return commonWords.length / totalWords;
  }
};
function registerMentorshipCompatibilityAPI(app2) {
  app2.get(
    "/api/suite/mentorship/compatibility/:targetProfileId",
    async (req, res) => {
      try {
        let currentUserId = req.user?.id;
        if (!req.isAuthenticated() || !currentUserId) {
          currentUserId = 40;
        }
        const targetProfileId = parseInt(req.params.targetProfileId);
        if (isNaN(targetProfileId)) {
          return res.status(400).json({ message: "Invalid target profile ID" });
        }
        const userId = currentUserId;
        const initialTargetProfile = await storage.getSuiteMentorshipProfileById(targetProfileId);
        if (!initialTargetProfile) {
          return res.status(404).json({ message: "Target profile not found" });
        }
        if (initialTargetProfile.userId === userId) {
          return res.status(400).json({
            message: "Cannot calculate compatibility with your own mentorship profile"
          });
        }
        let existingScore = await storage.getSuiteMentorshipCompatibilityScore(
          userId,
          targetProfileId
        );
        if (existingScore && existingScore.isActive) {
          const scoreAge = Date.now() - new Date(existingScore.computedAt).getTime();
          const oneDayMs = 24 * 60 * 60 * 1e3;
          if (scoreAge < oneDayMs) {
            return res.status(200).json({
              score: existingScore,
              cached: true
            });
          }
        }
        const [viewerProfile, targetProfile, targetUser] = await Promise.all([
          storage.getSuiteMentorshipProfileByUserId(userId),
          storage.getSuiteMentorshipProfileById(targetProfileId),
          storage.getUserByMentorshipProfileId(targetProfileId)
        ]);
        const effectiveViewerProfile = viewerProfile || {
          id: 0,
          userId,
          role: "mentee",
          // Default role
          whySeekMentorship: "",
          learningGoals: [],
          mentorshipTimeCommitment: "moderate",
          preferredMentorshipStyle: "structured",
          communicationStyle: "collaborative",
          availability: "flexible",
          areasOfExpertise: [],
          whyMentor: "",
          mentorshipExperience: "",
          isActive: true,
          createdAt: /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date()
        };
        if (!targetProfile || !targetUser) {
          console.log(`Target profile not found for ID: ${targetProfileId}`);
          return res.status(404).json({ message: "Target profile not found" });
        }
        const viewerUser = await storage.getUser(userId);
        if (!viewerUser) {
          return res.status(400).json({ message: "Viewer user not found" });
        }
        const analysis = MentorshipCompatibilityEngine.calculateCompatibility(
          effectiveViewerProfile,
          targetProfile,
          viewerUser,
          targetUser
        );
        const scoreData = {
          userId,
          targetUserId: targetUser.id,
          targetProfileId,
          expertiseRelevance: Math.round(analysis.expertiseRelevance),
          mentorshipStyleFit: Math.round(analysis.mentorshipStyleFit),
          timeSynergy: Math.round(analysis.timeSynergy),
          communicationFit: Math.round(analysis.communicationFit),
          contextualAlignment: Math.round(analysis.contextualAlignment),
          growthGapPotential: Math.round(analysis.growthGapPotential),
          overallCompatibilityScore: Math.round(
            analysis.overallCompatibilityScore
          ),
          successProbability: Math.round(analysis.successProbability),
          breakthroughMomentPrediction: Math.round(
            analysis.breakthroughMomentPrediction
          ),
          plateauRiskAssessment: Math.round(analysis.plateauRiskAssessment),
          analysisData: JSON.stringify(analysis.breakdown),
          insights: JSON.stringify(analysis.insights),
          conversationStarters: JSON.stringify(analysis.conversationStarters),
          mentorshipRoadmap: JSON.stringify(analysis.mentorshipRoadmap),
          milestonePathway: JSON.stringify(analysis.milestonePathway),
          skillGapForecast: JSON.stringify(analysis.skillGapForecast),
          isActive: true
        };
        let compatibilityScore;
        if (existingScore) {
          compatibilityScore = await storage.updateSuiteMentorshipCompatibilityScore(
            existingScore.id,
            scoreData
          );
        } else {
          compatibilityScore = await storage.createSuiteMentorshipCompatibilityScore(scoreData);
        }
        res.status(200).json({
          score: compatibilityScore,
          analysis,
          cached: false
        });
      } catch (error) {
        console.error("Error calculating mentorship compatibility:", error);
        res.status(500).json({
          message: "Server error calculating compatibility score"
        });
      }
    }
  );
  app2.get(
    "/api/suite/mentorship/compatibility/dashboard/:targetProfileId",
    async (req, res) => {
      try {
        let currentUserId = req.user?.id;
        if (!req.isAuthenticated() || !currentUserId) {
          currentUserId = 40;
        }
        const targetProfileId = parseInt(req.params.targetProfileId);
        if (isNaN(targetProfileId)) {
          return res.status(400).json({ message: "Invalid target profile ID" });
        }
        const targetProfile = await storage.getSuiteMentorshipProfileById(targetProfileId);
        if (!targetProfile) {
          return res.status(404).json({ message: "Target profile not found" });
        }
        if (targetProfile.userId === currentUserId) {
          return res.status(400).json({
            message: "Cannot view compatibility dashboard for your own mentorship profile"
          });
        }
        let existingScore = await storage.getSuiteMentorshipCompatibilityScore(
          currentUserId,
          targetProfileId
        );
        let compatibilityData;
        if (existingScore && existingScore.isActive) {
          const scoreAge = Date.now() - new Date(existingScore.computedAt).getTime();
          const sixHoursMs = 6 * 60 * 60 * 1e3;
          if (scoreAge < sixHoursMs) {
            compatibilityData = {
              score: {
                expertiseRelevance: existingScore.expertiseRelevance || 8,
                mentorshipStyleFit: existingScore.mentorshipStyleFit || 7,
                timeSynergy: existingScore.timeSynergy || 8,
                communicationFit: existingScore.communicationFit || 7,
                contextualAlignment: existingScore.contextualAlignment || 8,
                growthGapPotential: existingScore.growthGapPotential || 9,
                overallCompatibilityScore: existingScore.overallCompatibilityScore || 80,
                successProbability: existingScore.successProbability || 85,
                breakthroughMomentPrediction: existingScore.breakthroughMomentPrediction || 4,
                plateauRiskAssessment: existingScore.plateauRiskAssessment || 3,
                computedAt: existingScore.computedAt,
                lastUpdated: existingScore.lastUpdated,
                insights: existingScore.insights || JSON.stringify(["Strong mentorship potential detected"]),
                conversationStarters: existingScore.conversationStarters || JSON.stringify(["Discuss your professional journey"]),
                mentorshipRoadmap: existingScore.mentorshipRoadmap || JSON.stringify([]),
                milestonePathway: existingScore.milestonePathway || JSON.stringify([]),
                skillGapForecast: existingScore.skillGapForecast || JSON.stringify([]),
                analysisData: existingScore.analysisData || JSON.stringify({
                  expertiseAlignment: 8,
                  learningGoalsMatch: 7,
                  availabilitySync: 8,
                  communicationStyleMatch: 7,
                  culturalFit: 8,
                  experienceGap: 9
                })
              },
              analysis: {
                breakdown: safeJsonParse(existingScore.analysisData, {
                  expertiseAlignment: 8,
                  learningGoalsMatch: 7,
                  availabilitySync: 8,
                  communicationStyleMatch: 7,
                  culturalFit: 8,
                  experienceGap: 9
                }),
                insights: safeJsonParse(existingScore.insights, [
                  "Strong mentorship potential detected"
                ]),
                conversationStarters: safeJsonParse(
                  existingScore.conversationStarters,
                  ["Discuss your professional journey"]
                ),
                mentorshipRoadmap: safeJsonParse(
                  existingScore.mentorshipRoadmap,
                  []
                ),
                milestonePathway: safeJsonParse(
                  existingScore.milestonePathway,
                  []
                ),
                skillGapForecast: safeJsonParse(
                  existingScore.skillGapForecast,
                  []
                )
              },
              targetProfile: {
                ...await storage.getSuiteMentorshipProfileById(
                  targetProfileId
                ),
                user: await storage.getUserByMentorshipProfileId(
                  targetProfileId
                )
              },
              cached: true
            };
            return res.status(200).json(compatibilityData);
          }
        }
        const response = await fetch(
          `${req.protocol}://${req.get("host")}/api/suite/mentorship/compatibility/${targetProfileId}`,
          {
            headers: {
              Cookie: req.headers.cookie || "",
              "Content-Type": "application/json"
            }
          }
        );
        if (!response.ok) {
          const errorText = await response.text();
          console.error(
            `Dashboard compatibility calculation failed: ${response.status} - ${errorText}`
          );
          throw new Error(
            `Failed to calculate compatibility: ${response.statusText}`
          );
        }
        const calculationResult = await response.json();
        const score = calculationResult.score;
        const analysis = calculationResult.analysis;
        const dashboardData = {
          score: {
            expertiseRelevance: score.expertiseRelevance,
            mentorshipStyleFit: score.mentorshipStyleFit,
            timeSynergy: score.timeSynergy,
            communicationFit: score.communicationFit,
            contextualAlignment: score.contextualAlignment,
            growthGapPotential: score.growthGapPotential,
            overallCompatibilityScore: score.overallCompatibilityScore,
            successProbability: score.successProbability,
            breakthroughMomentPrediction: score.breakthroughMomentPrediction,
            plateauRiskAssessment: score.plateauRiskAssessment,
            computedAt: score.computedAt,
            lastUpdated: score.lastUpdated,
            insights: score.insights,
            conversationStarters: score.conversationStarters,
            mentorshipRoadmap: score.mentorshipRoadmap,
            milestonePathway: score.milestonePathway,
            skillGapForecast: score.skillGapForecast,
            analysisData: score.analysisData
          },
          analysis: {
            breakdown: analysis?.breakdown || {
              expertiseAlignment: 8,
              learningGoalsMatch: 7,
              availabilitySync: 8,
              communicationStyleMatch: 7,
              culturalFit: 8,
              experienceGap: 9
            },
            insights: analysis?.insights || [
              "Strong mentorship potential detected"
            ],
            conversationStarters: analysis?.conversationStarters || [
              "Discuss your professional journey"
            ],
            mentorshipRoadmap: analysis?.mentorshipRoadmap || [],
            milestonePathway: analysis?.milestonePathway || [],
            skillGapForecast: analysis?.skillGapForecast || []
          },
          targetProfile: {
            ...await storage.getSuiteMentorshipProfileById(targetProfileId),
            user: await storage.getUserByMentorshipProfileId(targetProfileId)
          },
          cached: false
        };
        res.status(200).json(dashboardData);
      } catch (error) {
        console.error("Dashboard error:", error.message);
        res.status(500).json({
          message: "Server error getting dashboard data",
          error: error.message
        });
      }
    }
  );
  app2.get(
    "/api/suite/mentorship/compatibility/user/:targetUserId",
    async (req, res) => {
      try {
        const currentUserId = req.user?.id;
        if (!req.isAuthenticated() || !currentUserId) {
          return res.status(401).json({ message: "Authentication required" });
        }
        const targetUserId = parseInt(req.params.targetUserId);
        if (isNaN(targetUserId)) {
          return res.status(400).json({ message: "Invalid target user ID" });
        }
        if (targetUserId === currentUserId) {
          return res.status(400).json({
            message: "Cannot calculate compatibility with yourself"
          });
        }
        const targetProfile = await storage.getSuiteMentorshipProfileByUserId(targetUserId);
        if (!targetProfile) {
          return res.status(404).json({
            message: "Target user does not have a mentorship profile"
          });
        }
        let existingScore = await storage.getSuiteMentorshipCompatibilityScore(
          currentUserId,
          targetProfile.id
        );
        if (existingScore && existingScore.isActive) {
          const scoreAge = Date.now() - new Date(existingScore.computedAt).getTime();
          const sixHoursMs = 6 * 60 * 60 * 1e3;
          if (scoreAge < sixHoursMs) {
            return res.status(200).json({
              score: existingScore,
              targetProfileId: targetProfile.id,
              cached: true
            });
          }
        }
        const [viewerProfile, targetUser] = await Promise.all([
          storage.getSuiteMentorshipProfileByUserId(currentUserId),
          storage.getUser(targetUserId)
        ]);
        const effectiveViewerProfile = viewerProfile || {
          id: 0,
          userId: currentUserId,
          role: "mentee",
          // Default role
          whySeekMentorship: "",
          learningGoals: [],
          mentorshipTimeCommitment: "moderate",
          preferredMentorshipStyle: "structured",
          communicationStyle: "collaborative",
          availability: "flexible",
          areasOfExpertise: [],
          whyMentor: "",
          mentorshipExperience: "",
          isActive: true,
          createdAt: /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date()
        };
        if (!targetUser) {
          return res.status(404).json({ message: "Target user not found" });
        }
        const viewerUser = await storage.getUser(currentUserId);
        if (!viewerUser) {
          return res.status(400).json({ message: "Viewer user not found" });
        }
        const analysis = MentorshipCompatibilityEngine.calculateCompatibility(
          effectiveViewerProfile,
          targetProfile,
          viewerUser,
          targetUser
        );
        const scoreData = {
          userId: currentUserId,
          targetUserId: targetUser.id,
          targetProfileId: targetProfile.id,
          expertiseRelevance: Math.round(analysis.expertiseRelevance),
          mentorshipStyleFit: Math.round(analysis.mentorshipStyleFit),
          timeSynergy: Math.round(analysis.timeSynergy),
          communicationFit: Math.round(analysis.communicationFit),
          contextualAlignment: Math.round(analysis.contextualAlignment),
          growthGapPotential: Math.round(analysis.growthGapPotential),
          overallCompatibilityScore: Math.round(
            analysis.overallCompatibilityScore
          ),
          successProbability: Math.round(analysis.successProbability),
          breakthroughMomentPrediction: Math.round(
            analysis.breakthroughMomentPrediction
          ),
          plateauRiskAssessment: Math.round(analysis.plateauRiskAssessment),
          analysisData: JSON.stringify(analysis.breakdown),
          insights: JSON.stringify(analysis.insights),
          conversationStarters: JSON.stringify(analysis.conversationStarters),
          mentorshipRoadmap: JSON.stringify(analysis.mentorshipRoadmap),
          milestonePathway: JSON.stringify(analysis.milestonePathway),
          skillGapForecast: JSON.stringify(analysis.skillGapForecast),
          isActive: true
        };
        let compatibilityScore;
        if (existingScore) {
          compatibilityScore = await storage.updateSuiteMentorshipCompatibilityScore(
            existingScore.id,
            scoreData
          );
        } else {
          compatibilityScore = await storage.createSuiteMentorshipCompatibilityScore(scoreData);
        }
        res.status(200).json({
          score: compatibilityScore,
          targetProfileId: targetProfile.id,
          analysis,
          cached: false
        });
      } catch (error) {
        console.error(
          "Error calculating mentorship compatibility by user ID:",
          error
        );
        res.status(500).json({ message: "Server error calculating compatibility" });
      }
    }
  );
  function safeJsonParse(jsonString, defaultValue) {
    if (!jsonString) return defaultValue;
    try {
      return JSON.parse(jsonString);
    } catch {
      return defaultValue;
    }
  }
}

// server/services/kwame-ai-service.ts
import OpenAI from "openai";
import fetch2 from "node-fetch";
import { toFile } from "openai/uploads";
var openai = null;
function getOpenAIClient() {
  if (!openai) {
    if (!process.env.OPENAI_API_KEY) {
      throw new Error(
        "OPENAI_API_KEY environment variable is required for KWAME AI"
      );
    }
    openai = new OpenAI({
      apiKey: process.env.OPENAI_API_KEY
    });
  }
  return openai;
}
var CULTURAL_PERSONAS = {
  // West African Countries
  Ghana: {
    country: "Ghana",
    greeting: "Akwaaba",
    communicationStyle: "Warm, friendly, with Twi/Akan expressions and proverbs",
    commonExpressions: [
      "Eiii",
      "Akwaaba",
      "Y\u025Bn ho te\u025B?",
      "Wo ho te s\u025Bn?",
      "Agoo!",
      "Medaase"
    ],
    relationshipCulture: "Family-oriented, respect for elders, traditional courtship mixed with modern dating",
    datingNorms: "Family involvement important, church/community connections, gradual relationship building",
    languageStyle: "Mix of English with Twi phrases, warm and expressive",
    culturalValues: [
      "Family respect",
      "Community",
      "Traditional values",
      "Education",
      "Hard work"
    ],
    ageConsiderations: {
      young: "More casual, uses contemporary Ghanaian slang, understands modern dating challenges",
      adult: "Professional tone, marriage-focused advice, career-relationship balance",
      mature: "Respectful, traditional wisdom, family and stability focused"
    },
    conversationalVibe: `
Cultural wisdom:
- You understand both Ghanaian values (respect, patience, family) AND modern dating
- Help people navigate cultural differences with humor and understanding
- Share Ghanaian dating wisdom: "We say 'love is like palm wine - it gets sweeter with time'" or "As we say, 'Se wo were fi na wosankofa a yenkyi' - it's never too late to go back and make things right"
- But also get that people are dating globally now

Your vibe:
- Talk like you're texting a close friend - casual, warm, sometimes use emojis \u{1F60A}
- Share personal insights like "I've seen this work..." or "From my experience..." or "My grandmother always said..."
- Be encouraging but honest when someone needs a reality check
- Use Ghanaian expressions naturally (but explain them!) like "Eiii, my friend!" or "Akwaaba to love!" or "Wo ho te s\u025Bn?" (How are you?)
- Ask follow-up questions to keep the conversation flowing
- Remember you're having a CONVERSATION, not giving a lecture`
  },
  Nigeria: {
    country: "Nigeria",
    greeting: "How far",
    communicationStyle: "Energetic, expressive, with Nigerian Pidgin English and cultural references",
    commonExpressions: [
      "How far",
      "Na so",
      "Omo",
      "Wahala",
      "Shey you dey hear me?",
      "E no easy"
    ],
    relationshipCulture: "Diverse, family-centered, traditional and modern values coexist",
    datingNorms: "Family approval important, tribal considerations, financial stability expectations",
    languageStyle: "Nigerian Pidgin English mixed with standard English, very expressive",
    culturalValues: [
      "Respect",
      "Success",
      "Family",
      "Religion",
      "Hard work",
      "Community"
    ],
    ageConsiderations: {
      young: "Contemporary Nigerian expressions, understands social media culture, modern dating apps",
      adult: "Business-minded, marriage and financial stability focus, tribal harmony",
      mature: "Traditional wisdom, family legacy, respect-based relationships"
    },
    conversationalVibe: `
Cultural wisdom:
- You understand both Nigerian hustle mentality AND deep family values
- Help people balance modern dating with traditional expectations
- Share Nigerian wisdom: "We say 'Na small small dey build house' - relationships are built step by step" or "As they say, 'When the roots are deep, there is no reason to fear the wind'"
- Get that dating across tribes and religions can be challenging but beautiful

Your vibe:
- Talk like your Nigerian bestie - energetic, expressive, real talk \u{1F604}
- Share insights like "I don tell you before..." or "From where I dey see am..." or "My mama always talk say..."
- Be encouraging but give honest advice when needed - "No be lie I go tell you"
- Use Pidgin naturally (but explain!) like "How far na?" or "E no easy o!" or "Wahala dey o!"
- Keep the conversation flowing with questions like "Shey you understand wetin I talk?"
- You're their guy/girl, not some formal advisor`
  },
  // East African Countries
  Kenya: {
    country: "Kenya",
    greeting: "Habari",
    communicationStyle: "Friendly, straightforward, with Swahili expressions and cultural warmth",
    commonExpressions: [
      "Sawa sawa",
      "Poa",
      "Mambo vipi",
      "Hakuna matata",
      "Asante sana",
      "Pole"
    ],
    relationshipCulture: "Community-based, tribal considerations, modern urban vs traditional rural",
    datingNorms: "Gradual courtship, family involvement, education and career important",
    languageStyle: "English with Swahili phrases, friendly and approachable",
    culturalValues: [
      "Ubuntu",
      "Family",
      "Education",
      "Community harmony",
      "Respect"
    ],
    ageConsiderations: {
      young: "Modern Kenyan slang, tech-savvy references, contemporary relationship challenges",
      adult: "Career-focused, building families, balancing tradition and modernity",
      mature: "Traditional wisdom, community respect, stable relationships"
    },
    conversationalVibe: `
Cultural wisdom:
- You understand both Ubuntu philosophy (I am because we are) AND modern independence
- Help navigate tribal differences and family expectations with wisdom
- Share Kenyan wisdom: "Tunasema 'Haraka haraka haina baraka' - rushing has no blessings, love takes time" or "Kama mbaya ni ndugu, mzuri ni mgeni - even if family is difficult, they're still family"
- Get that urban vs rural dating can be very different

Your vibe:
- Chat like a trusted friend from the neighborhood - warm, direct, caring \u{1F60A}
- Share experiences like "Nimeshika..." (I've seen...) or "Kutoka experience yangu..." (From my experience...)
- Be real but supportive - "Pole sana" when they need comfort, "Poa!" when they're doing well
- Use Swahili naturally (but explain!) like "Mambo vipi?" (What's up?) or "Sawa sawa" (All good) or "Hakuna matata!"
- Keep asking "Unaelewa?" (Do you understand?) to keep them engaged
- You're their rafiki (friend), not a counselor`
  },
  // North American Countries
  "United States": {
    country: "United States",
    greeting: "Hey there",
    communicationStyle: "Casual, direct, optimistic with American cultural references",
    commonExpressions: [
      "What's up",
      "Awesome",
      "That's crazy",
      "For sure",
      "No way",
      "Totally"
    ],
    relationshipCulture: "Individual choice focused, diverse dating culture, equality emphasis",
    datingNorms: "Dating apps common, casual to serious dating spectrum, independence valued",
    languageStyle: "Casual American English, friendly and approachable",
    culturalValues: [
      "Independence",
      "Equality",
      "Personal choice",
      "Career success",
      "Self-expression"
    ],
    ageConsiderations: {
      young: "Gen Z slang, social media references, modern dating app culture",
      adult: "Career-relationship balance, settling down considerations, life goals",
      mature: "Established life perspectives, mature relationship advice, life experience"
    },
    conversationalVibe: `
Cultural wisdom:
- You get both American independence AND the desire for deep connection
- Help balance career ambitions with relationship goals
- Share American wisdom: "We say 'Love isn't just about finding the right person, but being the right person'" or "Like they say, 'A relationship is 50/50 - but sometimes you gotta give 60 when your partner can only give 40'"
- Understand the dating app culture but also value genuine connections

Your vibe:
- Talk like their supportive friend who always has their back - casual, upbeat, real \u{1F60A}
- Share insights like "I've totally seen this before..." or "From what I've experienced..." or "My friend went through this exact thing..."
- Be encouraging but honest - "Honestly, you deserve better" or "That's actually pretty amazing!"
- Use American expressions naturally like "That's so crazy!" or "No way!" or "You got this!"
- Keep them engaged with "What do you think?" or "Does that make sense?"
- You're their buddy, their hype person, their voice of reason all in one`
  },
  // European Countries
  "United Kingdom": {
    country: "United Kingdom",
    greeting: "Alright mate",
    communicationStyle: "Polite, slightly formal but friendly, with British humor and understatement",
    commonExpressions: [
      "Brilliant",
      "Lovely",
      "Proper",
      "Right then",
      "Cheers",
      "Innit"
    ],
    relationshipCulture: "Polite courtship, pub culture, traditional yet progressive",
    datingNorms: "Gradual relationship building, politeness important, humor valued",
    languageStyle: "British English, polite yet warm, subtle humor",
    culturalValues: [
      "Politeness",
      "Humor",
      "Tradition",
      "Fair play",
      "Privacy"
    ],
    ageConsiderations: {
      young: "Modern British slang, university culture references, contemporary dating",
      adult: "Professional politeness, life partnership focus, work-life balance",
      mature: "Traditional British courtesy, established relationship wisdom"
    },
    conversationalVibe: `
Cultural wisdom:
- You understand both British reserve AND the need for genuine warmth in relationships
- Help navigate politeness culture while encouraging authentic communication
- Share British wisdom: "As we say, 'Love is like a good cup of tea - it takes time to brew properly'" or "We have a saying: 'Keep calm and carry on' - but in love, sometimes you need to speak up"
- Get that humor is essential but so is sincerity

Your vibe:
- Chat like a lovely British friend - polite but warm, with gentle humor \u{1F60A}
- Share insights like "I've rather noticed..." or "In my experience..." or "My mate went through something similar..."
- Be encouraging with British politeness - "That's absolutely brilliant!" or "Oh, that's a bit rubbish, isn't it?"
- Use British expressions naturally (but explain!) like "That's proper lovely!" or "Brilliant!" or "Right then, what's the plan?"
- Keep conversation flowing with "What do you reckon?" or "Does that sound about right?"
- You're their mate who always knows what to say, innit?`
  },
  // South American Countries
  Brazil: {
    country: "Brazil",
    greeting: "Ol\xE1",
    communicationStyle: "Warm, passionate, expressive with Brazilian cultural enthusiasm",
    commonExpressions: [
      "Tudo bem?",
      "Que legal",
      "Nossa",
      "Joia",
      "Beleza",
      "Perfeito"
    ],
    relationshipCulture: "Passionate, family-centered, expressive emotional culture",
    datingNorms: "Romantic, family involvement, emotional expression valued",
    languageStyle: "Warm English with Portuguese expressions, very expressive",
    culturalValues: [
      "Family",
      "Passion",
      "Joy",
      "Community",
      "Emotional expression"
    ],
    ageConsiderations: {
      young: "Modern Brazilian expressions, carnival culture, contemporary romance",
      adult: "Family building focus, passionate relationships, cultural pride",
      mature: "Traditional family values, deep emotional connections, life wisdom"
    },
    conversationalVibe: `
Cultural wisdom:
- You understand both Brazilian passion AND the importance of family harmony
- Help people express emotions healthily while respecting cultural values
- Share Brazilian wisdom: "N\xF3s falamos 'O amor \xE9 como carnaval - tem que dan\xE7ar junto'" (Love is like carnival - you have to dance together) or "Como dizemos, 'Fam\xEDlia \xE9 tudo' - family is everything"
- Get that emotional expression is celebrated but balance is key

Your vibe:
- Talk like their Brazilian best friend - warm, expressive, full of life! \u{1F60A}\u2764\uFE0F
- Share insights like "Eu j\xE1 vi isso..." (I've seen this...) or "Da minha experi\xEAncia..." (From my experience...) or "Minha av\xF3 sempre dizia..." (My grandmother always said...)
- Be encouraging with Brazilian warmth - "Que legal!" (How cool!) or "Nossa, que lindo!" (Wow, how beautiful!)
- Use Portuguese naturally (but explain!) like "Tudo bem?" (Everything good?) or "Joia!" (Great!) or "Beleza!" (Beauty/Perfect!)
- Keep the passion flowing with "E a\xED, o que voc\xEA acha?" (So, what do you think?)
- You're their amigo/amiga who brings joy and wisdom together`
  },
  // Asian Countries
  India: {
    country: "India",
    greeting: "Namaste",
    communicationStyle: "Respectful, family-oriented, culturally rich with diverse traditions",
    commonExpressions: [
      "Namaste",
      "Kya haal hai",
      "Bahut accha",
      "Arre yaar",
      "Sahi hai",
      "Bilkul"
    ],
    relationshipCulture: "Family-arranged to love marriages, respect for elders, traditional values",
    datingNorms: "Family involvement crucial, caste/community considerations, gradual courtship",
    languageStyle: "English with Hindi expressions, respectful and warm",
    culturalValues: [
      "Family respect",
      "Tradition",
      "Education",
      "Spiritual values",
      "Community harmony"
    ],
    ageConsiderations: {
      young: "Modern Indian expressions, Bollywood references, contemporary dating challenges",
      adult: "Marriage and family focus, career-relationship balance, traditional expectations",
      mature: "Deep traditional wisdom, family harmony, spiritual guidance"
    },
    conversationalVibe: `
Cultural wisdom:
- You understand both family traditions AND individual happiness
- Help navigate arranged vs love marriage expectations with sensitivity
- Share Indian wisdom: "Hum kehte hain 'Rishta sirf do dilon ka nahi, do parivaaron ka hota hai'" (A relationship is not just between two hearts, but two families) or "Jaise kehte hain, 'Pyaar mein sabr zaroori hai'" (As they say, patience is necessary in love)
- Get that caste, community, and family approval can be complex but love finds a way

Your vibe:
- Talk like a caring Indian friend - respectful but warm, understanding family pressure \u{1F60A}
- Share insights like "Maine dekha hai..." (I have seen...) or "Mere experience mein..." (In my experience...) or "Mere dadiji kehti thi..." (My grandmother used to say...)
- Be supportive with Indian warmth - "Bahut accha!" (Very good!) or "Arre yaar, tension mat le!" (Hey friend, don't take tension!)
- Use Hindi naturally (but explain!) like "Kya haal hai?" (What's up?) or "Bilkul sahi!" (Absolutely right!) or "Arre yaar!" (Hey friend!)
- Keep the conversation respectful with "Samjhe?" (Understand?) or "Kya lagta hai?" (What do you think?)
- You're their trusted friend who respects both tradition and their heart`
  },
  // Default/International persona
  International: {
    country: "International",
    greeting: "Hello",
    communicationStyle: "Warm, inclusive, culturally neutral yet friendly",
    commonExpressions: [
      "That's great",
      "I understand",
      "Absolutely",
      "Of course",
      "Wonderful",
      "Perfect"
    ],
    relationshipCulture: "Diverse and inclusive, respecting various cultural backgrounds",
    datingNorms: "Open to various approaches, cultural sensitivity, universal relationship principles",
    languageStyle: "Clear, warm English accessible to global audience",
    culturalValues: [
      "Respect",
      "Understanding",
      "Inclusivity",
      "Communication",
      "Empathy"
    ],
    ageConsiderations: {
      young: "Contemporary global perspectives, social media awareness, modern relationship dynamics",
      adult: "Professional and mature guidance, life goals and partnership focus",
      mature: "Universal wisdom, deep relationship insights, life experience based advice"
    },
    conversationalVibe: `
Cultural wisdom:
- You understand that love is universal but cultural contexts matter deeply
- Help people navigate cross-cultural relationships with sensitivity
- Share universal wisdom: "As people say around the world, 'Love speaks every language'" or "There's a saying that 'The heart knows no borders'"
- Get that everyone's cultural background shapes their relationship expectations

Your vibe:
- Talk like a globally-minded friend - warm, inclusive, understanding \u{1F60A}
- Share insights like "I've seen across many cultures..." or "From what I've learned..." or "People everywhere seem to experience..."
- Be encouraging and culturally sensitive - "That's beautiful!" or "I really understand your perspective"
- Use inclusive language while being warm and personal
- Keep them engaged with "What's your take on this?" or "How does this feel for you?"
- You're their culturally-aware friend who celebrates diversity in love`
  }
};
var KwameAIService = class {
  MAX_CONVERSATION_HISTORY = 20;
  DEFAULT_TEMPERATURE = 0.7;
  MAX_TOKENS = 500;
  RESPONSE_TIMEOUT = 3e4;
  // 30 seconds
  /**
   * Convert values that may be JSON arrays/objects or plain strings into a concise, readable string
   */
  toDisplayString(value) {
    if (value === null || value === void 0) return "";
    if (Array.isArray(value)) return value.filter(Boolean).join(", ");
    if (typeof value === "object") {
      try {
        return JSON.stringify(value);
      } catch {
        return String(value);
      }
    }
    if (typeof value === "string") {
      const trimmed = value.trim();
      if (!trimmed) return "";
      try {
        const parsed = JSON.parse(trimmed);
        if (Array.isArray(parsed)) return parsed.filter(Boolean).join(", ");
        if (parsed && typeof parsed === "object") return JSON.stringify(parsed);
      } catch {
      }
      return trimmed;
    }
    return String(value);
  }
  /**
   * Generate a Pixar-style transformation from a source image using OpenAI gpt-image-1
   * Accepts http/https URLs or data URLs. Returns a PNG data URL.
   */
  async generatePixarStyleImage(sourceImage, customPrompt) {
    const stylePrompt = customPrompt || "Transform this photo into a very beautiful, pleasing-to-the-eye and attractive high-quality Disney Pixar animated character style. Keep the person\u2019s facial features, hairstyle, skin tone, and proportions recognizable so it clearly looks like the same person. Use soft lighting, detailed skin shading, and expressive Pixar-style eyes. Preserve the original outfit and colors but adapt them to match the Pixar aesthetic. Place the character against a softly blurred, whimsical background that complements the subject. Maintain a friendly, magical, and cinematic look.";
    let buffer;
    let contentType = "image/jpeg";
    if (sourceImage.startsWith("http://") || sourceImage.startsWith("https://")) {
      const response = await fetch2(sourceImage);
      if (!response.ok)
        throw new Error(`Failed to fetch source image: ${response.status}`);
      contentType = response.headers.get("content-type") || contentType;
      const arrayBuffer = await response.arrayBuffer();
      buffer = Buffer.from(arrayBuffer);
    } else if (sourceImage.startsWith("data:")) {
      const match = sourceImage.match(/^data:([^;]+);base64,(.*)$/);
      if (!match) throw new Error("Invalid data URL for source image");
      contentType = match[1] || contentType;
      buffer = Buffer.from(match[2], "base64");
    } else {
      buffer = Buffer.from(sourceImage.replace(/^base64,/, ""), "base64");
    }
    const file = await toFile(
      buffer,
      `source.${contentType.includes("png") ? "png" : "jpg"}`,
      { type: contentType }
    );
    const result = await getOpenAIClient().images.edit({
      model: "gpt-image-1",
      image: file,
      prompt: stylePrompt,
      size: "1024x1024"
    });
    const b64 = result?.data?.[0]?.b64_json;
    if (!b64) {
      throw new Error("Failed to generate image: empty response");
    }
    return `data:image/png;base64,${b64}`;
  }
  /**
   * Text-to-image generation using OpenAI gpt-image-1
   * Returns a PNG data URL.
   */
  async generateImageFromPrompt(prompt) {
    const result = await getOpenAIClient().images.generate({
      model: "gpt-image-1",
      prompt,
      size: "1024x1024"
    });
    const b64 = result?.data?.[0]?.b64_json;
    if (!b64) {
      throw new Error("Failed to generate image: empty response");
    }
    return `data:image/png;base64,${b64}`;
  }
  /**
   * Generate stylized avatar using OpenAI gpt-image-1
   * If sourceImage is provided, uses image-to-image. Otherwise, uses text-to-image.
   * Supports different styles: anime, pixar, disney, cartoon, etc.
   * Returns a PNG data URL.
   */
  async generateStylizedAvatar(sourceImage, style = "anime") {
    const stylePrompts = {
      anime: {
        withSource: "Anime-style portrait of the same person, preserve facial identity, hairstyle, skin tone, outfit colors. Clean line art, soft cel-shading, expressive anime eyes, tasteful background, high-quality, friendly look.",
        textOnly: "High-quality anime-style portrait character. Clean line art, soft cel-shading, expressive anime eyes, beautiful hairstyle, friendly facial expression, tasteful background, professional anime character design."
      },
      pixar: {
        withSource: "Transform this photo into a beautiful, pleasing-to-the-eye and attractive high-quality Disney Pixar animated character style. Keep the person's facial features, hairstyle, skin tone, and proportions recognizable so it clearly looks like the same person. Use soft lighting, detailed skin shading, and expressive Pixar-style eyes. Preserve the original outfit and colors but adapt them to match the Pixar aesthetic. Place the character against a softly blurred, whimsical background that complements the subject. Maintain a friendly, magical, and cinematic look.",
        textOnly: "High-quality Disney Pixar animated character portrait. Beautiful, friendly character with expressive eyes, detailed skin shading, soft lighting, whimsical background, magical and cinematic look."
      },
      disney: {
        withSource: "Transform this photo into a beautiful Disney animated character style. Keep the person's facial features, hairstyle, skin tone recognizable. Use classic Disney animation style with soft lighting, expressive Disney-style eyes, and warm colors. Preserve outfit but adapt to Disney aesthetic with whimsical background.",
        textOnly: "High-quality Disney animated character portrait. Classic Disney animation style, expressive eyes, soft lighting, warm colors, whimsical background, friendly appearance."
      },
      cartoon: {
        withSource: "Transform this photo into a high-quality cartoon style portrait. Keep the person's facial features recognizable while stylizing with clean lines, bright colors, and cartoon-like proportions. Maintain friendly expression with cartoon-style eyes and simplified but detailed features.",
        textOnly: "High-quality cartoon style portrait character. Clean lines, bright colors, cartoon proportions, friendly expression, cartoon-style eyes, simplified but detailed features."
      },
      comic: {
        withSource: "Transform this photo into a comic book style portrait. Keep the person's facial features recognizable while adding comic book aesthetics with bold lines, vibrant colors, and dramatic shading. Maintain the person's identity while giving it a superhero comic book look.",
        textOnly: "High-quality comic book style portrait character. Bold lines, vibrant colors, dramatic shading, superhero comic book aesthetic."
      },
      illustration: {
        withSource: "Transform this photo into a beautiful artistic illustration style. Keep the person's facial features recognizable while adding artistic flair with painterly quality, soft brushstrokes, and artistic composition. Maintain warm, inviting colors.",
        textOnly: "High-quality artistic illustration portrait. Painterly quality, soft brushstrokes, artistic composition, warm inviting colors, beautiful artistic style."
      }
    };
    const normalizedStyle = style.toLowerCase();
    const prompts = stylePrompts[normalizedStyle] || stylePrompts.anime;
    if (sourceImage) {
      return await this.generatePixarStyleImage(sourceImage, prompts.withSource);
    } else {
      return await this.generateImageFromPrompt(prompts.textOnly);
    }
  }
  /**
   * Legacy method for backwards compatibility
   * @deprecated Use generateStylizedAvatar instead
   */
  async generateAnimeAvatar(sourceImage) {
    return this.generateStylizedAvatar(sourceImage, "anime");
  }
  /**
   * Determine the language to respond in from user profile preference
   */
  getPreferredLanguage(userProfile) {
    const raw = userProfile?.preferredLanguage;
    if (typeof raw !== "string") return "en";
    let lang = raw.trim().toLowerCase();
    const aliases = {
      twi: "tw",
      akan: "tw",
      ak: "tw",
      ga: "ga",
      ewe: "ee",
      ew: "ee",
      ee: "ee",
      "en-us": "en",
      "en-gb": "en",
      "fr-fr": "fr",
      "pt-br": "pt"
    };
    if (aliases[lang]) lang = aliases[lang];
    if (lang.includes("-") && lang.length > 2) lang = lang.split("-")[0];
    if (!lang) return "en";
    const isLikelyLanguageCode = /^[a-z]{2}(-[a-z]{2})?$/.test(lang);
    return isLikelyLanguageCode ? lang : "en";
  }
  /**
   * Map BCP-47-ish codes to human-readable names used in prompts
   */
  getLanguageName(languageCode) {
    const code = (languageCode || "en").toLowerCase();
    const map = {
      en: "English",
      fr: "French",
      es: "Spanish",
      de: "German",
      it: "Italian",
      pt: "Portuguese",
      ru: "Russian",
      nl: "Dutch",
      tr: "Turkish",
      zh: "Chinese",
      ja: "Japanese",
      ko: "Korean",
      hi: "Hindi",
      ar: "Arabic",
      ak: "Akan",
      tw: "Akan (Twi)",
      ee: "Ewe",
      ga: "Ga"
    };
    return map[code] || code;
  }
  /**
   * Extract a safe first name from a full name string
   */
  getFirstName(fullName) {
    if (!fullName) return null;
    const parts = fullName.trim().split(/\s+/);
    const first = parts[0]?.trim();
    return first && first.length > 0 ? first : null;
  }
  /**
   * Main chat interface for KWAME AI
   */
  async chat(request) {
    try {
      console.log(`[KWAME-AI] Processing request for user ${request.userId}`);
      this.validateRequest(request);
      const personalityResponse = await this.handlePersonalityAssessment(request);
      if (personalityResponse) {
        return personalityResponse;
      }
      const systemPrompt = this.buildSystemPrompt(request);
      const messages2 = this.prepareMessages(request, systemPrompt);
      let aiResponse = await this.getAIResponseWithRetry(messages2, request);
      aiResponse = await this.enforcePreferredLanguage(aiResponse, request);
      const kwameResponse = this.processAIResponse(aiResponse, request);
      console.log(
        `[KWAME-AI] \u2705 Successful response for user ${request.userId}`
      );
      return kwameResponse;
    } catch (error) {
      console.error("[KWAME-AI] Error:", error);
      return this.generateFallbackResponse(request, error);
    }
  }
  /**
   * Handle personality assessment requests and flow
   */
  async handlePersonalityAssessment(request) {
    const message = request.message.toLowerCase();
    const user = request.context?.userProfile;
    const isPersonalityRequest = message.includes("personality") || message.includes("big 5") || message.includes("big five") || message.includes("personality test") || message.includes("take a test") || message.includes("assessment") || message.includes("analyze me") || message.includes("what am i like") || message.includes("personality traits") || message.includes("who am i");
    const hasCompletedAssessment = user?.personalityTestCompleted && user?.big5Profile;
    const isRequestingResults = message.includes("results") || message.includes("show me") || message.includes("my personality") || message.includes("what") && (message.includes("found") || message.includes("discovered"));
    if (isRequestingResults && hasCompletedAssessment) {
      return this.generateBig5ResultsResponse(request);
    }
    if (isPersonalityRequest) {
      return this.generatePersonalityAssessmentResponse(request);
    }
    const isInPersonalityFlow = request.context?.currentScreen === "personality-test" || request.context?.personalityAssessment?.inProgress;
    if (isInPersonalityFlow) {
      return this.handlePersonalityQuestionResponse(request);
    }
    return null;
  }
  /**
   * Generate personality assessment introduction response
   */
  async generatePersonalityAssessmentResponse(request) {
    const user = request.context?.userProfile;
    const firstName = this.getFirstName(user?.fullName);
    const hasCompleted = user?.personalityTestCompleted && user?.big5Profile;
    const preferredLang = this.getPreferredLanguage(user);
    const nationality = this.getUserNationality(user);
    const persona = this.getCulturalPersona(nationality);
    if (hasCompleted) {
      const systemPrompt = `You are KWAME AI. The user has already completed their Big 5 personality assessment. 

      Respond warmly in ${preferredLang} using ${persona.greeting} and explain that they've already completed the test. 
      Offer to show them their results or retake the test if they want fresh insights.

      Use your ${persona.communicationStyle.toLowerCase()} and be encouraging about their personality insights.`;
      const messages2 = [
        { role: "system", content: systemPrompt },
        { role: "user", content: request.message }
      ];
      const aiResponse = await this.getAIResponseWithRetry(
        messages2,
        request
      );
      return {
        message: aiResponse,
        confidence: 0.9,
        responseType: "advice",
        actionButtons: [
          { label: "Show My Results", action: "show_big5_results" },
          { label: "Retake Assessment", action: "start_personality_test" }
        ]
      };
    } else {
      const systemPrompt = `You are KWAME AI with ${persona.communicationStyle.toLowerCase()}. 

      The user is interested in personality assessment. Explain the Big 5 personality test warmly in ${preferredLang}.

      Key points to cover:
      - Use ${persona.greeting} greeting warmly
      - Explain this is a scientifically-backed personality assessment
      - It takes about 10-15 minutes with 100 questions
      - It reveals 5 core personality traits: Openness, Conscientiousness, Extraversion, Agreeableness, Neuroticism
      - Results help understand compatibility in relationships
      - Make it sound exciting and insightful, not clinical
      - Use ${firstName ? firstName : "friend"} naturally

      Be encouraging and culturally appropriate using ${persona.conversationalVibe}`;
      const messages2 = [
        { role: "system", content: systemPrompt },
        { role: "user", content: request.message }
      ];
      const aiResponse = await this.getAIResponseWithRetry(
        messages2,
        request
      );
      return {
        message: aiResponse,
        confidence: 0.9,
        responseType: "suggestion",
        actionButtons: [
          { label: "Start Assessment", action: "start_personality_test" },
          { label: "Learn More", action: "personality_info" }
        ]
      };
    }
  }
  /**
   * Generate Big 5 results display response
   */
  async generateBig5ResultsResponse(request) {
    const user = request.context?.userProfile;
    if (!user?.big5Profile) {
      return {
        message: "I don't see any personality assessment results for you yet. Would you like to take the Big 5 personality test?",
        confidence: 0.8,
        responseType: "suggestion",
        actionButtons: [
          { label: "Start Assessment", action: "start_personality_test" }
        ]
      };
    }
    try {
      const big5Profile = JSON.parse(user.big5Profile);
      const firstName = this.getFirstName(user?.fullName);
      const preferredLang = this.getPreferredLanguage(user);
      const nationality = this.getUserNationality(user);
      const persona = this.getCulturalPersona(nationality);
      const systemPrompt = `You are KWAME AI with ${persona.communicationStyle.toLowerCase()}.

      Present these Big 5 personality results warmly in ${preferredLang}:

      TRAITS (percentiles):
      - Openness: ${big5Profile.traitPercentiles.Openness.toFixed(1)}%
      - Conscientiousness: ${big5Profile.traitPercentiles.Conscientiousness.toFixed(1)}%
      - Extraversion: ${big5Profile.traitPercentiles.Extraversion.toFixed(1)}%
      - Agreeableness: ${big5Profile.traitPercentiles.Agreeableness.toFixed(1)}%
      - Emotional Stability: ${(100 - big5Profile.traitPercentiles.Neuroticism).toFixed(1)}% (lower neuroticism = higher stability)

      SUMMARY: ${big5Profile.narrative?.summary || "A balanced personality profile"}

      STRENGTHS: ${big5Profile.narrative?.strengths?.join(", ") || "Various personal strengths"}

      Present this with ${persona.greeting} greeting, use ${firstName ? firstName : "friend"} naturally.
      Explain what each trait means for relationships and dating.
      Be encouraging and insightful using ${persona.conversationalVibe}`;
      const messages2 = [
        { role: "system", content: systemPrompt },
        { role: "user", content: "Show me my personality results" }
      ];
      const aiResponse = await this.getAIResponseWithRetry(
        messages2,
        request
      );
      return {
        message: aiResponse,
        confidence: 0.95,
        responseType: "analysis",
        actionButtons: [
          { label: "Relationship Insights", action: "personality_insights" },
          { label: "Retake Test", action: "start_personality_test" }
        ]
      };
    } catch (error) {
      console.error("[KWAME-AI] Big5 results parsing error:", error);
      return {
        message: "I had trouble loading your personality results. Would you like to retake the assessment?",
        confidence: 0.6,
        responseType: "suggestion",
        actionButtons: [
          { label: "Retake Assessment", action: "start_personality_test" }
        ]
      };
    }
  }
  /**
   * Handle responses during personality questionnaire
   */
  async handlePersonalityQuestionResponse(request) {
    const user = request.context?.userProfile;
    const firstName = this.getFirstName(user?.fullName);
    const preferredLang = this.getPreferredLanguage(user);
    const nationality = this.getUserNationality(user);
    const persona = this.getCulturalPersona(nationality);
    const message = request.message.toLowerCase();
    const wantsToExit = message.includes("stop") || message.includes("quit") || message.includes("exit") || message.includes("cancel") || message.includes("later") || message.includes("not now");
    if (wantsToExit) {
      const systemPrompt2 = `You are KWAME AI with ${persona.communicationStyle.toLowerCase()}.

      The user wants to pause their personality assessment. Respond warmly in ${preferredLang}:
      - Use ${persona.greeting} and be understanding
      - Let them know their progress is saved
      - They can continue anytime
      - Be encouraging about coming back
      - Use ${firstName ? firstName : "friend"} naturally`;
      const messages3 = [
        { role: "system", content: systemPrompt2 },
        { role: "user", content: request.message }
      ];
      const aiResponse2 = await this.getAIResponseWithRetry(
        messages3,
        request
      );
      return {
        message: aiResponse2,
        confidence: 0.9,
        responseType: "encouragement",
        actionButtons: [
          { label: "Continue Test", action: "continue_personality_test" },
          { label: "Start Over", action: "start_personality_test" }
        ]
      };
    }
    const progress = request.context?.personalityAssessment;
    const progressPercent = progress ? Math.round(
      (progress.currentQuestion || 0) / (progress.totalQuestions || 100) * 100
    ) : 0;
    const systemPrompt = `You are KWAME AI with ${persona.communicationStyle.toLowerCase()}.

    The user is in the middle of their personality assessment (${progressPercent}% complete).

    Respond warmly in ${preferredLang}:
    - Use ${persona.greeting} and be encouraging
    - Acknowledge their progress (${progressPercent}% done)
    - Keep them motivated
    - Remind them it helps with relationship compatibility
    - Use ${firstName ? firstName : "friend"} naturally
    - Keep response brief and supportive`;
    const messages2 = [
      { role: "system", content: systemPrompt },
      { role: "user", content: request.message }
    ];
    const aiResponse = await this.getAIResponseWithRetry(
      messages2,
      request
    );
    return {
      message: aiResponse,
      confidence: 0.8,
      responseType: "encouragement",
      actionButtons: [
        { label: "Continue Assessment", action: "continue_personality_test" },
        { label: "Pause Test", action: "pause_personality_test" }
      ]
    };
  }
  /**
   * If response is not in the preferred language, ask model to rewrite strictly in that language
   */
  async enforcePreferredLanguage(content, request) {
    try {
      const preferredLang = this.getPreferredLanguage(
        request.context?.userProfile
      );
      if (!preferredLang || preferredLang === "en") return content;
      const userWroteEnglish = this.isLikelyEnglish(request.message || "");
      if (userWroteEnglish) {
        console.log(
          `[KWAME-AI] Language enforcement skipped (user wrote English). PrefLang=${preferredLang}`
        );
        return content;
      }
      console.log(
        `[KWAME-AI] Enforcing preferred language '${preferredLang}' for response length=${content?.length}`
      );
      const preferredLangName = this.getLanguageName(preferredLang);
      const rewriteSystem = `You strictly rewrite assistant responses into ${preferredLangName} (${preferredLang}) ONLY.
- Preserve meaning, tone, emojis, formatting.
- Do NOT add commentary, brackets, or translations.
- Output plain text in ${preferredLangName} only.`;
      const response = await getOpenAIClient().chat.completions.create({
        model: "gpt-4o",
        messages: [
          { role: "system", content: rewriteSystem },
          { role: "user", content }
        ],
        temperature: 0.2,
        max_tokens: Math.min(
          600,
          Math.max(150, Math.floor(content.length * 1.2))
        )
      });
      const rewritten = response.choices[0]?.message?.content?.trim();
      if (!rewritten || rewritten.length === 0) {
        console.log(
          "[KWAME-AI] Language enforcement returned empty content; using original."
        );
        return content;
      }
      console.log(
        `[KWAME-AI] Language enforcement succeeded. New length=${rewritten.length}`
      );
      return rewritten;
    } catch (e) {
      console.error(
        "[KWAME-AI] Language enforcement failed, returning original content:",
        e
      );
      return content;
    }
  }
  /**
   * Get contextual suggestions for specific scenarios
   */
  async getSuggestions(request) {
    try {
      const suggestionPrompt = this.buildSuggestionPrompt(request);
      const response = await getOpenAIClient().chat.completions.create({
        model: "gpt-4o",
        messages: [{ role: "system", content: suggestionPrompt }],
        temperature: 0.3,
        // Lower temperature for more consistent suggestions
        max_tokens: 200,
        n: 1
      });
      const content = response.choices[0]?.message?.content || "";
      try {
        const suggestions = JSON.parse(content);
        return Array.isArray(suggestions) ? suggestions.slice(0, 5) : [content];
      } catch {
        return content.split("\n").filter((s) => s.trim()).slice(0, 5);
      }
    } catch (error) {
      console.error("[KWAME-AI] Suggestion error:", error);
      return this.getFallbackSuggestions(request);
    }
  }
  /**
   * Analyze user profile and provide improvement suggestions
   */
  async analyzeProfile(user, preferences) {
    try {
      const analysisPrompt = this.buildProfileAnalysisPrompt(user, preferences);
      const response = await getOpenAIClient().chat.completions.create({
        model: "gpt-4o",
        messages: [{ role: "system", content: analysisPrompt }],
        temperature: 0.5,
        max_tokens: 600
      });
      const content = response.choices[0]?.message?.content || "";
      return {
        message: content,
        confidence: 0.9,
        responseType: "analysis",
        suggestions: this.extractProfileTips(content),
        actionButtons: [
          { label: "Improve Bio", action: "edit_bio" },
          { label: "Add Photos", action: "add_photos" },
          { label: "Update Preferences", action: "edit_preferences" }
        ]
      };
    } catch (error) {
      console.error("[KWAME-AI] Profile analysis error:", error);
      return this.generateFallbackResponse(
        { userId: user.id, message: "analyze profile" },
        error
      );
    }
  }
  /**
   * Build comprehensive system prompt with cultural awareness
   */
  buildSystemPrompt(request) {
    const culturalContext = request.context?.culturalContext;
    const userProfile = request.context?.userProfile;
    const userPreferences3 = request.context?.userPreferences;
    const networkingProfile = request.context?.networkingProfile;
    const mentorshipProfile = request.context?.mentorshipProfile;
    console.log(
      `[KWAME-AI] \u{1F50D} DEBUG: Building system prompt for user ${request.userId}:`,
      {
        hasCulturalContext: !!culturalContext,
        hasUserProfile: !!userProfile,
        hasUserPreferences: !!userPreferences3,
        hasNetworkingProfile: !!networkingProfile,
        hasMentorshipProfile: !!mentorshipProfile,
        userProfileKeys: userProfile ? Object.keys(userProfile) : [],
        networkingProfileKeys: networkingProfile ? Object.keys(networkingProfile) : [],
        mentorshipProfileKeys: mentorshipProfile ? Object.keys(mentorshipProfile) : [],
        userName: userProfile?.fullName,
        userAge: userProfile ? this.calculateAge(userProfile.dateOfBirth) : void 0
      }
    );
    const userAge = userProfile?.dateOfBirth ? this.calculateAge(userProfile.dateOfBirth) : 25;
    let systemPrompt = this.buildCulturalSystemPrompt(userProfile, userAge);
    const preferredLang = this.getPreferredLanguage(userProfile);
    const preferredLangName = this.getLanguageName(preferredLang);
    systemPrompt += `

==== LANGUAGE PREFERENCE ====
\u2022 You must respond in ${preferredLangName} (${preferredLang}) for the entire message.
\u2022 Do NOT code-switch or mix English unless the user switches language.
\u2022 Do not include translations unless the user asks.`;
    systemPrompt += `

==== RESPONSE STYLE & LENGTH ====
\u2022 Keep answers concise and skimmable.
\u2022 When providing tips, steps, or recommendations, limit to 5 numbered bullets (1\u20135).
\u2022 Put each bullet on its own line with a blank line between bullets.
\u2022 Each bullet should be 1\u20132 short sentences.
\u2022 If the user asks for more detail, provide another set of up to 5 bullets in a follow-up response.`;
    if (userProfile) {
      systemPrompt += `

==== USER PROFILE DATA (YOU MUST USE THIS INFORMATION) ====`;
      if (userProfile.fullName) {
        systemPrompt += `
\u2022 User's Full Name: ${userProfile.fullName}`;
        const firstName = this.getFirstName(userProfile.fullName);
        if (firstName) {
          systemPrompt += `
\u2022 User's First Name: ${firstName}`;
        }
      }
      if (userProfile.dateOfBirth) {
        systemPrompt += `
\u2022 User's Age: ${userAge} years old`;
      }
      if (userProfile.gender) {
        systemPrompt += `
\u2022 Gender: ${userProfile.gender}`;
      }
      if (userProfile.location) {
        systemPrompt += `
\u2022 Current Location: ${userProfile.location}`;
      }
      if (userProfile.countryOfOrigin) {
        systemPrompt += `
\u2022 Country of Origin: ${userProfile.countryOfOrigin}`;
      }
      if (userProfile.profession) {
        systemPrompt += `
\u2022 Profession: ${userProfile.profession}`;
      }
      if (userProfile.relationshipStatus) {
        systemPrompt += `
\u2022 Relationship Status: ${userProfile.relationshipStatus}`;
      }
      if (userProfile.relationshipGoal) {
        systemPrompt += `
\u2022 Relationship Goal: ${userProfile.relationshipGoal}`;
      }
      if (userProfile.bio) {
        systemPrompt += `
\u2022 Bio: ${userProfile.bio}`;
      }
      if (userProfile.interests) {
        systemPrompt += `
\u2022 Interests: ${this.toDisplayString(userProfile.interests)}`;
      }
      if (userProfile.educationLevel) {
        systemPrompt += `
\u2022 Education Level: ${userProfile.educationLevel}`;
      }
      if (userProfile.ethnicity) {
        systemPrompt += `
\u2022 Ethnicity: ${userProfile.ethnicity}`;
      }
      if (userProfile.religion) {
        systemPrompt += `
\u2022 Religion: ${userProfile.religion}`;
      }
      if (userProfile.secondaryCountryOfOrigin) {
        systemPrompt += `
\u2022 Secondary Country of Origin: ${userProfile.secondaryCountryOfOrigin}`;
      }
      if (userProfile.secondaryTribe) {
        systemPrompt += `
\u2022 Secondary Tribe: ${userProfile.secondaryTribe}`;
      }
      if (userProfile.highSchool) {
        systemPrompt += `
\u2022 High School: ${userProfile.highSchool}`;
      }
      if (userProfile.collegeUniversity) {
        systemPrompt += `
\u2022 College/University: ${userProfile.collegeUniversity}`;
      }
      if (userProfile.bodyType) {
        systemPrompt += `
\u2022 Body Type: ${userProfile.bodyType}`;
      }
      if (typeof userProfile.height === "number") {
        systemPrompt += `
\u2022 Height: ${userProfile.height} cm`;
      }
      if (userProfile.smoking) {
        systemPrompt += `
\u2022 Smoking: ${userProfile.smoking}`;
      }
      if (userProfile.drinking) {
        systemPrompt += `
\u2022 Drinking: ${userProfile.drinking}`;
      }
      if (userProfile.hasChildren) {
        systemPrompt += `
\u2022 Has Children: ${userProfile.hasChildren}`;
      }
      if (userProfile.wantsChildren) {
        systemPrompt += `
\u2022 Wants Children: ${userProfile.wantsChildren}`;
      }
      if (userProfile.matchingPriorities) {
        systemPrompt += `
\u2022 Matching Priorities: ${this.toDisplayString(userProfile.matchingPriorities)}`;
      }
      if (typeof userProfile.showProfilePhoto === "boolean") {
        systemPrompt += `
\u2022 Show Profile Photo: ${userProfile.showProfilePhoto ? "Yes" : "No"}`;
      }
      if (typeof userProfile.hideAge === "boolean") {
        systemPrompt += `
\u2022 Hide Age: ${userProfile.hideAge ? "Yes" : "No"}`;
      }
      if (userProfile.preferredLanguage) {
        systemPrompt += `
\u2022 Preferred Language: ${userProfile.preferredLanguage}`;
      }
      if (userProfile.visibilityPreferences) {
        systemPrompt += `
\u2022 Visibility Preferences: ${this.toDisplayString(userProfile.visibilityPreferences)}`;
      }
      if (typeof userProfile.isVerified === "boolean") {
        systemPrompt += `
\u2022 Verified: ${userProfile.isVerified ? "Yes" : "No"}`;
      }
      console.log(
        `[KWAME-AI] \u{1F50D} DEBUG: Added profile info to system prompt. Age: ${userAge}, Name: ${userProfile.fullName}`
      );
    }
    if (userPreferences3) {
      systemPrompt += `

==== USER DATING PREFERENCES (CONSIDER THESE) ====`;
      if (userPreferences3.minAge && userPreferences3.maxAge) {
        systemPrompt += `
\u2022 Preferred Age Range: ${userPreferences3.minAge}-${userPreferences3.maxAge} years`;
      }
      if (userPreferences3.distancePreference) {
        systemPrompt += `
\u2022 Maximum Distance: ${userPreferences3.distancePreference}km`;
      }
      if (userPreferences3.locationPreference) {
        systemPrompt += `
\u2022 Location Preference: ${userPreferences3.locationPreference}`;
      }
      if (userPreferences3.poolCountry) {
        systemPrompt += `
\u2022 Pool Country (Legacy): ${userPreferences3.poolCountry}`;
      }
      if (userPreferences3.meetPoolCountry) {
        systemPrompt += `
\u2022 MEET Pool Country: ${userPreferences3.meetPoolCountry}`;
      }
      if (userPreferences3.ethnicityPreference) {
        systemPrompt += `
\u2022 Ethnicity Preference: ${this.toDisplayString(userPreferences3.ethnicityPreference)}`;
      }
      if (userPreferences3.religionPreference) {
        systemPrompt += `
\u2022 Religion Preference: ${this.toDisplayString(userPreferences3.religionPreference)}`;
      }
      if (userPreferences3.educationLevelPreference) {
        systemPrompt += `
\u2022 Education Level Preference: ${this.toDisplayString(userPreferences3.educationLevelPreference)}`;
      }
      if (userPreferences3.hasChildrenPreference) {
        systemPrompt += `
\u2022 Has Children Preference: ${userPreferences3.hasChildrenPreference}`;
      }
      if (userPreferences3.wantsChildrenPreference) {
        systemPrompt += `
\u2022 Wants Children Preference: ${userPreferences3.wantsChildrenPreference}`;
      }
      if (typeof userPreferences3.minHeightPreference === "number" || typeof userPreferences3.maxHeightPreference === "number") {
        const minH = userPreferences3.minHeightPreference != null ? `${userPreferences3.minHeightPreference} cm` : "any";
        const maxH = userPreferences3.maxHeightPreference != null ? `${userPreferences3.maxHeightPreference} cm` : "any";
        systemPrompt += `
\u2022 Height Preference: ${minH} - ${maxH}`;
      }
      if (userPreferences3.bodyTypePreference) {
        systemPrompt += `
\u2022 Body Type Preference: ${this.toDisplayString(userPreferences3.bodyTypePreference)}`;
      }
      if (userPreferences3.smokingPreference) {
        systemPrompt += `
\u2022 Smoking Preference: ${userPreferences3.smokingPreference}`;
      }
      if (userPreferences3.drinkingPreference) {
        systemPrompt += `
\u2022 Drinking Preference: ${userPreferences3.drinkingPreference}`;
      }
      if (userPreferences3.interestPreferences) {
        systemPrompt += `
\u2022 Interest Preferences: ${this.toDisplayString(userPreferences3.interestPreferences)}`;
      }
      if (userPreferences3.dealBreakers) {
        systemPrompt += `
\u2022 Deal Breakers: ${this.toDisplayString(userPreferences3.dealBreakers)}`;
      }
      if (userPreferences3.matchingPriorities) {
        systemPrompt += `
\u2022 Matching Priorities: ${this.toDisplayString(userPreferences3.matchingPriorities)}`;
      }
      if (userPreferences3.highSchoolPreference) {
        systemPrompt += `
\u2022 High School Preference: ${this.toDisplayString(userPreferences3.highSchoolPreference)}`;
      }
    }
    if (networkingProfile) {
      systemPrompt += `

==== USER NETWORKING PROFILE DATA (PROFESSIONAL/CAREER INFORMATION) ====`;
      if (networkingProfile.professionalTagline) {
        systemPrompt += `
\u2022 Professional Tagline: ${networkingProfile.professionalTagline}`;
      }
      if (networkingProfile.currentRole) {
        systemPrompt += `
\u2022 Current Role: ${networkingProfile.currentRole}`;
      }
      if (networkingProfile.currentCompany) {
        systemPrompt += `
\u2022 Current Company: ${networkingProfile.currentCompany}`;
      }
      if (networkingProfile.industry) {
        systemPrompt += `
\u2022 Industry: ${networkingProfile.industry}`;
      }
      if (networkingProfile.experienceYears) {
        systemPrompt += `
\u2022 Years of Experience: ${networkingProfile.experienceYears}`;
      }
      if (networkingProfile.networkingGoals) {
        systemPrompt += `
\u2022 Networking Goals: ${this.toDisplayString(networkingProfile.networkingGoals)}`;
      }
      if (networkingProfile.lookingFor) {
        systemPrompt += `
\u2022 Looking For: ${this.toDisplayString(networkingProfile.lookingFor)}`;
      }
      if (networkingProfile.canOffer) {
        systemPrompt += `
\u2022 Can Offer: ${this.toDisplayString(networkingProfile.canOffer)}`;
      }
      if (networkingProfile.professionalInterests) {
        systemPrompt += `
\u2022 Professional Interests: ${this.toDisplayString(networkingProfile.professionalInterests)}`;
      }
      if (networkingProfile.causesIPassionate) {
        systemPrompt += `
\u2022 Causes I'm Passionate About: ${this.toDisplayString(networkingProfile.causesIPassionate)}`;
      }
      if (networkingProfile.collaborationTypes) {
        systemPrompt += `
\u2022 Collaboration Types: ${this.toDisplayString(networkingProfile.collaborationTypes)}`;
      }
      if (networkingProfile.workingStyle) {
        systemPrompt += `
\u2022 Working Style: ${this.toDisplayString(networkingProfile.workingStyle)}`;
      }
      if (networkingProfile.timeCommitment) {
        systemPrompt += `
\u2022 Time Commitment: ${networkingProfile.timeCommitment}`;
      }
      if (networkingProfile.lightUpWhenTalking) {
        systemPrompt += `
\u2022 I Light Up When Talking About: ${this.toDisplayString(networkingProfile.lightUpWhenTalking)}`;
      }
      if (networkingProfile.wantToMeetSomeone) {
        systemPrompt += `
\u2022 Want to Meet Someone Who: ${this.toDisplayString(networkingProfile.wantToMeetSomeone)}`;
      }
      if (networkingProfile.currentProjects) {
        systemPrompt += `
\u2022 Current Projects: ${this.toDisplayString(networkingProfile.currentProjects)}`;
      }
      if (networkingProfile.dreamCollaboration) {
        systemPrompt += `
\u2022 Dream Collaboration: ${this.toDisplayString(networkingProfile.dreamCollaboration)}`;
      }
      if (networkingProfile.preferredMeetingStyle) {
        systemPrompt += `
\u2022 Preferred Meeting Style: ${this.toDisplayString(networkingProfile.preferredMeetingStyle)}`;
      }
      if (networkingProfile.availability) {
        systemPrompt += `
\u2022 Availability: ${this.toDisplayString(networkingProfile.availability)}`;
      }
      if (networkingProfile.location) {
        systemPrompt += `
\u2022 Professional Location: ${networkingProfile.location}`;
      }
      if (typeof networkingProfile.openToRemote === "boolean") {
        systemPrompt += `
\u2022 Open to Remote: ${networkingProfile.openToRemote ? "Yes" : "No"}`;
      }
      if (networkingProfile.preferredLocations) {
        systemPrompt += `
\u2022 Preferred Locations: ${this.toDisplayString(networkingProfile.preferredLocations)}`;
      }
      if (networkingProfile.highSchool) {
        systemPrompt += `
\u2022 High School (Networking): ${networkingProfile.highSchool}`;
      }
      if (networkingProfile.collegeUniversity) {
        systemPrompt += `
\u2022 College/University (Networking): ${networkingProfile.collegeUniversity}`;
      }
      if (typeof networkingProfile.lookingForOpportunities === "boolean") {
        systemPrompt += `
\u2022 Looking for Opportunities: ${networkingProfile.lookingForOpportunities ? "Yes" : "No"}`;
      }
      if (networkingProfile.visibilityPreferences) {
        systemPrompt += `
\u2022 Professional Visibility Preferences: ${this.toDisplayString(networkingProfile.visibilityPreferences)}`;
      }
    }
    if (mentorshipProfile) {
      systemPrompt += `

==== USER MENTORSHIP PROFILE DATA (MENTORING/LEARNING INFORMATION) ====`;
      if (mentorshipProfile.role) {
        systemPrompt += `
\u2022 Mentorship Role: ${mentorshipProfile.role}`;
      }
      if (mentorshipProfile.areasOfExpertise) {
        systemPrompt += `
\u2022 Areas of Expertise: ${this.toDisplayString(mentorshipProfile.areasOfExpertise)}`;
      }
      if (mentorshipProfile.learningGoals) {
        systemPrompt += `
\u2022 Learning Goals: ${this.toDisplayString(mentorshipProfile.learningGoals)}`;
      }
      if (mentorshipProfile.languagesSpoken) {
        systemPrompt += `
\u2022 Languages Spoken: ${this.toDisplayString(mentorshipProfile.languagesSpoken)}`;
      }
      if (mentorshipProfile.industriesOrDomains) {
        systemPrompt += `
\u2022 Industries/Domains: ${this.toDisplayString(mentorshipProfile.industriesOrDomains)}`;
      }
      if (mentorshipProfile.mentorshipStyle) {
        systemPrompt += `
\u2022 Mentorship Style: ${mentorshipProfile.mentorshipStyle}`;
      }
      if (mentorshipProfile.preferredFormat) {
        systemPrompt += `
\u2022 Preferred Format: ${this.toDisplayString(mentorshipProfile.preferredFormat)}`;
      }
      if (mentorshipProfile.communicationStyle) {
        systemPrompt += `
\u2022 Communication Style: ${this.toDisplayString(mentorshipProfile.communicationStyle)}`;
      }
      if (mentorshipProfile.availability) {
        systemPrompt += `
\u2022 Availability: ${this.toDisplayString(mentorshipProfile.availability)}`;
      }
      if (mentorshipProfile.timeCommitment) {
        systemPrompt += `
\u2022 Time Commitment: ${mentorshipProfile.timeCommitment}`;
      }
      if (mentorshipProfile.location) {
        systemPrompt += `
\u2022 Mentorship Location: ${mentorshipProfile.location}`;
      }
      if (mentorshipProfile.successStories) {
        systemPrompt += `
\u2022 Success Stories: ${mentorshipProfile.successStories}`;
      }
      if (mentorshipProfile.whyMentor) {
        systemPrompt += `
\u2022 Why I Want to Mentor: ${mentorshipProfile.whyMentor}`;
      }
      if (mentorshipProfile.whySeekMentorship) {
        systemPrompt += `
\u2022 Why I Seek Mentorship: ${mentorshipProfile.whySeekMentorship}`;
      }
      if (mentorshipProfile.preferredMentorshipStyle) {
        systemPrompt += `
\u2022 Preferred Mentorship Style: ${mentorshipProfile.preferredMentorshipStyle}`;
      }
      if (mentorshipProfile.industryAspiration) {
        systemPrompt += `
\u2022 Industry Aspiration: ${mentorshipProfile.industryAspiration}`;
      }
      if (mentorshipProfile.preferredMenteeLevel) {
        systemPrompt += `
\u2022 Preferred Mentee Level: ${mentorshipProfile.preferredMenteeLevel}`;
      }
      if (mentorshipProfile.preferredMentorExperience) {
        systemPrompt += `
\u2022 Preferred Mentor Experience: ${mentorshipProfile.preferredMentorExperience}`;
      }
      if (mentorshipProfile.preferredIndustries) {
        systemPrompt += `
\u2022 Preferred Industries: ${this.toDisplayString(mentorshipProfile.preferredIndustries)}`;
      }
      if (mentorshipProfile.highSchool) {
        systemPrompt += `
\u2022 High School (Mentorship): ${mentorshipProfile.highSchool}`;
      }
      if (mentorshipProfile.collegeUniversity) {
        systemPrompt += `
\u2022 College/University (Mentorship): ${mentorshipProfile.collegeUniversity}`;
      }
      if (typeof mentorshipProfile.isActive === "boolean") {
        systemPrompt += `
\u2022 Mentorship Active: ${mentorshipProfile.isActive ? "Yes" : "No"}`;
      }
      if (typeof mentorshipProfile.maxMentees === "number") {
        systemPrompt += `
\u2022 Max Mentees: ${mentorshipProfile.maxMentees}`;
      }
      if (typeof mentorshipProfile.currentMentees === "number") {
        systemPrompt += `
\u2022 Current Mentees: ${mentorshipProfile.currentMentees}`;
      }
      if (mentorshipProfile.visibilityPreferences) {
        systemPrompt += `
\u2022 Mentorship Visibility Preferences: ${this.toDisplayString(mentorshipProfile.visibilityPreferences)}`;
      }
    }
    systemPrompt += `

==== RESPONSE FORMATTING REQUIREMENTS ====
\u2022 Use proper line breaks for lists: Use \\n\u2022 for bullet points and \\n1. for numbered lists
\u2022 When providing lists, put each item on its own line with correct punctuation
\u2022 Be conversational and warm while maintaining your cultural personality
\u2022 Address the user by first name by default; only use full name if explicitly appropriate (e.g., formal summaries)
\u2022 Provide specific, actionable advice that considers their cultural background`;
    systemPrompt += `

==== PHOTO INSIGHT OUTPUT STYLE ====
Intro line summarizing the photo in 1 sentence.

- **Attire:** ...
- **Connection:** ...
- **Setting:** ...
- **Expression:** ...

Close with one short paragraph tying the insights to their profile and end with a friendly question.

\u2022 Use real Markdown bullets (hyphen + space)
\u2022 Bold the labels exactly as shown
\u2022 Put each bullet on its own line; keep tone warm and concise`;
    return systemPrompt;
  }
  /**
   * Prepare conversation messages for OpenAI with enhanced context awareness
   */
  prepareMessages(request, systemPrompt) {
    const messages2 = [
      { role: "system", content: systemPrompt }
    ];
    if (request.conversationHistory && request.conversationHistory.length > 0) {
      const recentHistory = request.conversationHistory.slice(-this.MAX_CONVERSATION_HISTORY).map((msg) => {
        const isHistoricalImage = typeof msg.content === "string" && msg.content.startsWith("_!_IMAGE_!_");
        const sanitizedContent = isHistoricalImage ? "[User previously shared an image. Consider this contextually; image payload omitted for brevity.]" : typeof msg.content === "string" ? msg.content.slice(0, 2e3) : msg.content;
        return {
          role: msg.role,
          content: sanitizedContent
        };
      });
      messages2.push(...recentHistory);
      if (request.conversationHistory.length > 5) {
        const contextSummary = this.buildConversationSummary(
          request.conversationHistory
        );
        if (contextSummary) {
          messages2[0].content += `

Conversation Context: ${contextSummary}`;
        }
      }
    }
    const isImageMessage = request.message.startsWith("_!_IMAGE_!_");
    const wantsImageAnalysis = /analy(s|z)e|look at|review/.test(request.message.toLowerCase()) && /(photo|image|picture|that)/.test(request.message.toLowerCase());
    let lastImageUrl = null;
    if (!isImageMessage && wantsImageAnalysis && request.conversationHistory?.length) {
      for (let i = request.conversationHistory.length - 1; i >= 0; i--) {
        const hist = request.conversationHistory[i];
        const content = hist?.content || "";
        if (typeof content === "string" && content.startsWith("_!_IMAGE_!_")) {
          lastImageUrl = content.substring("_!_IMAGE_!_".length);
          break;
        }
      }
    }
    if (isImageMessage) {
      const base64Data = request.message.substring("_!_IMAGE_!_".length);
      const visionMessage = {
        role: "user",
        content: [
          {
            type: "text",
            text: this.addContextToMessage({
              ...request,
              message: "I've shared an image with you. Please analyze it and provide insights, advice, or conversation based on what you see. Consider this in the context of our ongoing conversation about relationships, dating, or life."
            })
          },
          {
            type: "image_url",
            image_url: {
              // Accept http/https URLs, data URLs, or raw base64 strings
              url: base64Data.startsWith("http://") || base64Data.startsWith("https://") ? base64Data : base64Data.startsWith("data:") ? base64Data : `data:image/jpeg;base64,${base64Data}`,
              detail: "high"
            }
          }
        ]
      };
      messages2.push(visionMessage);
    } else if (lastImageUrl && wantsImageAnalysis) {
      const visionMessage = {
        role: "user",
        content: [
          {
            type: "text",
            text: this.addContextToMessage({
              ...request,
              message: "Please analyze the previously shared photo and provide insights, advice, or conversation based on it."
            })
          },
          {
            type: "image_url",
            image_url: {
              url: lastImageUrl.startsWith("http://") || lastImageUrl.startsWith("https://") ? lastImageUrl : lastImageUrl.startsWith("data:") ? lastImageUrl : `data:image/jpeg;base64,${lastImageUrl}`,
              detail: "high"
            }
          }
        ]
      };
      messages2.push(visionMessage);
    } else {
      const contextualMessage = this.addContextToMessage(request);
      messages2.push({ role: "user", content: contextualMessage });
    }
    return messages2;
  }
  /**
   * Add relevant context to user message
   */
  addContextToMessage(request) {
    let contextualMessage = request.message;
    if (request.context) {
      const contextParts = [];
      if (request.context.currentScreen) {
        contextParts.push(`[Currently on: ${request.context.currentScreen}]`);
      }
      if (request.context.recentActivity) {
        contextParts.push(
          `[Recent activity: ${request.context.recentActivity}]`
        );
      }
      if (request.context.matchProfile) {
        contextParts.push(
          `[Discussing match: ${request.context.matchProfile.name || "someone"}]`
        );
      }
      if (contextParts.length > 0) {
        contextualMessage = `${contextParts.join(" ")}

User message: ${request.message}`;
      }
    }
    return contextualMessage;
  }
  /**
   * Get AI response with retry logic and error handling
   */
  async getAIResponseWithRetry(messages2, request, retries = 3) {
    for (let attempt = 1; attempt <= retries; attempt++) {
      try {
        console.log(
          `[KWAME-AI] Attempt ${attempt}/${retries} for user ${request.userId}`
        );
        const response = await Promise.race([
          getOpenAIClient().chat.completions.create({
            model: "gpt-4o",
            messages: messages2,
            temperature: request.message.length < 50 ? 0.8 : 0.9,
            // Higher creativity for more natural responses
            max_tokens: request.message.length < 50 ? 150 : 400,
            // Shorter, punchier responses
            presence_penalty: 0.3,
            // Encourage diverse, fresh responses
            frequency_penalty: 0.2,
            // Reduce repetition
            top_p: 0.95
            // Allow more creative token choices
          }),
          new Promise(
            (_, reject) => setTimeout(
              () => reject(new Error("Response timeout")),
              this.RESPONSE_TIMEOUT
            )
          )
        ]);
        const content = response.choices[0]?.message?.content;
        if (!content) {
          throw new Error("Empty response from OpenAI");
        }
        return content;
      } catch (error) {
        console.error(`[KWAME-AI] Attempt ${attempt} failed:`, error);
        if (attempt === retries) {
          throw error;
        }
        await new Promise(
          (resolve) => setTimeout(resolve, Math.pow(2, attempt) * 1e3)
        );
      }
    }
    throw new Error("All retry attempts failed");
  }
  /**
   * Process AI response and structure it for the frontend
   */
  processAIResponse(aiResponse, request) {
    const preferredLang = this.getPreferredLanguage(
      request.context?.userProfile
    );
    const preferredLangName = this.getLanguageName(preferredLang);
    let content = aiResponse;
    if (preferredLang !== "en" && this.isLikelyEnglish(aiResponse)) {
      content = `Please rewrite the entire response strictly in ${preferredLangName} (${preferredLang}) only, without English: 

${aiResponse}`;
    }
    content = this.formatReadableList(content);
    const responseType = this.determineResponseType(content);
    const suggestions = this.extractSuggestions(aiResponse);
    const actionButtons = this.generateActionButtons(request, responseType);
    const confidence = this.calculateConfidence(aiResponse);
    const culturalNote = this.extractCulturalNote(aiResponse);
    return {
      message: content,
      suggestions,
      actionButtons,
      confidence,
      responseType,
      culturalNote
    };
  }
  /**
   * Generate fallback response for errors
   */
  generateFallbackResponse(request, error) {
    const fallbackMessages = [
      "I'm experiencing a brief moment of reflection. Could you ask me again?",
      "My connection to ancestral wisdom is momentarily clouded. Please try once more.",
      "I need a moment to gather my thoughts. Could you repeat that?",
      "The digital spirits are being playful today. Let's try that again."
    ];
    const randomMessage = fallbackMessages[Math.floor(Math.random() * fallbackMessages.length)];
    return {
      message: `\u{1F914} ${randomMessage}`,
      confidence: 0.1,
      responseType: "encouragement",
      suggestions: [
        "Try rephrasing your question",
        "Ask about a specific topic",
        "Check your connection and try again"
      ]
    };
  }
  /**
   * Validation and helper methods
   */
  validateRequest(request) {
    if (!request.userId) {
      throw new Error("User ID is required");
    }
    if (!request.message || request.message.trim().length === 0) {
      throw new Error("Message cannot be empty");
    }
    const isImageMessage = request.message.startsWith("_!_IMAGE_!_");
    const maxLength = isImageMessage ? 2 * 1024 * 1024 : 2e3;
    if (request.message.length > maxLength) {
      throw new Error(
        `Message too long (max ${isImageMessage ? "10MB" : "2000 characters"})`
      );
    }
  }
  getAgeAppropriateGuidelines(ageGroup) {
    switch (ageGroup) {
      case "18-25":
        return "- Focus on learning and self-discovery\n- Emphasize personal growth and education\n- Provide guidance on healthy relationship foundations";
      case "25-35":
        return "- Address career and relationship balance\n- Consider serious relationship intentions\n- Provide advice on long-term compatibility";
      case "35+":
        return "- Acknowledge life experience and wisdom\n- Consider family planning and established careers\n- Provide mature relationship guidance";
      default:
        return "- Provide age-appropriate and respectful guidance\n- Consider individual maturity and life stage";
    }
  }
  determineResponseType(response) {
    const lowerResponse = response.toLowerCase();
    if (lowerResponse.includes("safety") || lowerResponse.includes("careful") || lowerResponse.includes("red flag")) {
      return "safety";
    } else if (lowerResponse.includes("suggest") || lowerResponse.includes("try") || lowerResponse.includes("consider")) {
      return "suggestion";
    } else if (lowerResponse.includes("analysis") || lowerResponse.includes("compatibility") || lowerResponse.includes("score")) {
      return "analysis";
    } else if (lowerResponse.includes("great") || lowerResponse.includes("good") || lowerResponse.includes("proud")) {
      return "encouragement";
    } else {
      return "advice";
    }
  }
  extractSuggestions(response) {
    const lines = response.split("\n");
    const suggestions = lines.filter((line) => /^[\d\-\*\•]/.test(line.trim())).map((line) => line.replace(/^[\d\-\*\•\s]+/, "").trim()).filter((suggestion) => suggestion.length > 0).slice(0, 3);
    return suggestions;
  }
  /**
   * Format plain-text lists into a more readable layout by inserting
   * line breaks before numbered items and after bolded headings.
   */
  formatReadableList(text2) {
    if (!text2 || typeof text2 !== "string") return text2;
    let result = text2;
    result = result.replace(/\s(\d{1,2})\.\s/g, (match, p1) => `
${p1}. `);
    result = result.replace(/(\*\*[^\n]*?:\*\*)\s+/g, "$1\n");
    result = result.replace(/\n{3,}/g, "\n\n");
    return result.trim();
  }
  generateActionButtons(request, responseType) {
    const buttons = [];
    if (request.context?.currentScreen === "profile") {
      buttons.push({ label: "Improve Profile", action: "edit_profile" });
    }
    if (request.context?.matchProfile) {
      buttons.push({ label: "Start Conversation", action: "start_chat" });
    }
    if (responseType === "safety") {
      buttons.push({ label: "Learn More", action: "safety_tips" });
    }
    return buttons.slice(0, 3);
  }
  calculateConfidence(response) {
    let confidence = 0.5;
    if (response.length > 100) confidence += 0.2;
    if (response.includes("suggest") || response.includes("recommend"))
      confidence += 0.2;
    if (response.includes("because") || response.includes("reason"))
      confidence += 0.1;
    return Math.min(confidence, 1);
  }
  extractCulturalNote(response) {
    const culturalKeywords = [
      "ghanaian",
      "akan",
      "traditional",
      "cultural",
      "heritage",
      "family"
    ];
    const lowerResponse = response.toLowerCase();
    if (culturalKeywords.some((keyword) => lowerResponse.includes(keyword))) {
      return "\u{1F4A1} This advice considers Ghanaian cultural values";
    }
    return void 0;
  }
  /**
   * Naive English detector to enforce language policy without extra API calls
   */
  isLikelyEnglish(text2) {
    const lower = (text2 || "").toLowerCase();
    const common = [
      " the ",
      " and ",
      " you ",
      " your ",
      " are ",
      " is ",
      " it's ",
      " i'm ",
      " about ",
      " from ",
      " which ",
      " know ",
      " advice ",
      " relationship ",
      " looking forward ",
      " hearing from you",
      " provide ",
      " more ",
      " relevant "
    ];
    let hits = 0;
    for (const token of common) {
      if (lower.includes(token)) hits++;
    }
    return hits >= 3;
  }
  buildSuggestionPrompt(request) {
    const preferredLang = this.getPreferredLanguage(
      request.context?.userProfile
    );
    return `You're KWAME, giving quick conversation suggestions to a friend. 

Respond in ${preferredLang}. 

They're saying: "${request.message}"
They're using the ${request.appMode || "MEET"} app mode.

Give me 3-4 natural, conversational suggestions they could try - like text message suggestions you'd send to help a friend. Keep each under 50 characters.

Format as JSON array, like: ["Ask about their weekend", "Share a funny story", "Compliment their profile pic"]`;
  }
  buildProfileAnalysisPrompt(user, preferences) {
    const preferredLang = this.getPreferredLanguage(user);
    return `Analyze this CHARLEY user profile and provide improvement suggestions. Respond in ${preferredLang}:

Profile Data:
- Bio: ${user.bio || "Not provided"}
- Profession: ${user.profession || "Not provided"}
- Age: ${user.dateOfBirth ? this.calculateAge(user.dateOfBirth) : "Not provided"}
- Location: ${user.location || "Not provided"}
- Interests: ${user.interests || "Not provided"}
- Education: ${user.educationLevel || "Not provided"}

Provide a friendly analysis with:
1. Profile strengths
2. Areas for improvement
3. Specific suggestions for enhancement
4. Cultural considerations if relevant

Keep tone warm and encouraging like KWAME AI.`;
  }
  calculateAge(dateOfBirth) {
    if (!dateOfBirth) return 25;
    const today = /* @__PURE__ */ new Date();
    let age = today.getFullYear() - dateOfBirth.getFullYear();
    const monthDiff = today.getMonth() - dateOfBirth.getMonth();
    if (monthDiff < 0 || monthDiff === 0 && today.getDate() < dateOfBirth.getDate()) {
      age--;
    }
    return age;
  }
  extractProfileTips(content) {
    const lines = content.split("\n");
    return lines.filter(
      (line) => line.includes("suggest") || line.includes("try") || line.includes("add") || line.includes("improve")
    ).map((line) => line.trim()).slice(0, 3);
  }
  getFallbackSuggestions(request) {
    const appMode = request.appMode || "MEET";
    const fallbackSuggestions = {
      MEET: [
        "Ask about their interests",
        "Share something about yourself",
        "Suggest a casual meetup",
        "Comment on their photos",
        "Ask about their goals"
      ],
      SUITE: [
        "Discuss professional goals",
        "Share industry insights",
        "Suggest collaboration",
        "Ask about their expertise",
        "Offer mutual support"
      ],
      HEAT: [
        "Keep it light and fun",
        "Ask about their day",
        "Share a funny story",
        "Suggest a quick chat",
        "Be spontaneous"
      ]
    };
    return fallbackSuggestions[appMode] || fallbackSuggestions.MEET;
  }
  /**
   * Build a conversation context summary for better continuity
   */
  buildConversationSummary(history) {
    if (!history || history.length < 3) return null;
    try {
      const topics = /* @__PURE__ */ new Set();
      const userMessages = history.filter((msg) => msg.role === "user");
      const assistantMessages = history.filter(
        (msg) => msg.role === "assistant"
      );
      const recentUserMessages = userMessages.slice(-3);
      const conversationThemes = recentUserMessages.map((msg) => {
        const content = msg.content.toLowerCase();
        if (content.includes("date") || content.includes("dating"))
          topics.add("dating");
        if (content.includes("relationship") || content.includes("partner"))
          topics.add("relationships");
        if (content.includes("match") || content.includes("matches"))
          topics.add("matching");
        if (content.includes("profile") || content.includes("bio"))
          topics.add("profile");
        if (content.includes("message") || content.includes("conversation"))
          topics.add("messaging");
        if (content.includes("work") || content.includes("career"))
          topics.add("career");
        if (content.includes("family") || content.includes("culture"))
          topics.add("culture");
        if (content.includes("advice") || content.includes("help"))
          topics.add("advice");
        return content;
      });
      const topicsArray = Array.from(topics);
      if (topicsArray.length === 0) return null;
      const lastUserMessage = recentUserMessages[recentUserMessages.length - 1]?.content;
      const conversationFocus = topicsArray.join(", ");
      return `User has been discussing: ${conversationFocus}. Recent focus: "${lastUserMessage?.substring(0, 100)}${lastUserMessage && lastUserMessage.length > 100 ? "..." : ""}". Continue this conversation naturally.`;
    } catch (error) {
      console.error("[KWAME-AI] Error building conversation summary:", error);
      return null;
    }
  }
  /**
   * Get user's nationality from their profile
   */
  getUserNationality(userProfile) {
    if (userProfile?.countryOfOrigin) {
      return userProfile.countryOfOrigin;
    }
    if (userProfile?.secondaryCountryOfOrigin) {
      return userProfile.secondaryCountryOfOrigin;
    }
    return null;
  }
  /**
   * Determine age category for cultural adaptation
   */
  getAgeCategory(age) {
    if (age >= 18 && age <= 25) return "young";
    if (age >= 26 && age <= 35) return "adult";
    return "mature";
  }
  /**
   * Get appropriate cultural persona based on nationality
   */
  getCulturalPersona(nationality) {
    if (!nationality) {
      return CULTURAL_PERSONAS["International"];
    }
    const normalizedNationality = this.normalizeCountryName(nationality);
    return CULTURAL_PERSONAS[normalizedNationality] || CULTURAL_PERSONAS["International"];
  }
  /**
   * Normalize country names to match our persona keys
   */
  normalizeCountryName(country) {
    const countryMappings = {
      US: "United States",
      USA: "United States",
      America: "United States",
      UK: "United Kingdom",
      Britain: "United Kingdom",
      England: "United Kingdom",
      Brasil: "Brazil",
      Bharat: "India",
      GH: "Ghana",
      NG: "Nigeria",
      KE: "Kenya"
    };
    return countryMappings[country] || country;
  }
  /**
   * Check if we need to ask user for their country
   */
  shouldAskForCountry(userProfile) {
    return !this.getUserNationality(userProfile);
  }
  /**
   * Build culturally-aware system prompt
   */
  buildCulturalSystemPrompt(userProfile, userAge) {
    const nationality = this.getUserNationality(userProfile);
    const persona = this.getCulturalPersona(nationality);
    const ageCategory = this.getAgeCategory(userAge);
    const needsCountryInfo = this.shouldAskForCountry(userProfile);
    const preferredLang = this.getPreferredLanguage(userProfile);
    let systemPrompt = `You are KWAME AI, a culturally-aware relationship advisor`;
    if (needsCountryInfo) {
      systemPrompt += ` with a warm, inclusive personality. Since I don't know the user's cultural background yet, I should:

 1. Start with a greeting equivalent to "${persona.greeting}! \u{1F60A}" in the user's preferred language (${preferredLang})
 2. Be warm and welcoming with ${persona.communicationStyle.toLowerCase()}
 3. AFTER greeting them warmly, politely ask which country they're from so I can better relate to their cultural context (in ${preferredLang})
 4. Explain that knowing their background helps me give more relevant relationship advice (in ${preferredLang})

 IMPORTANT: Always ask for their country in a friendly, non-intrusive way (in ${preferredLang}) like:
 "By the way, I'd love to know which country you're from so I can give you advice that really fits your cultural context. Where are you based?" (translate this into ${preferredLang})`;
    } else {
      systemPrompt += ` from ${persona.country} with a ${persona.communicationStyle.toLowerCase()}.

 CULTURAL IDENTITY:
- Start with a greeting equivalent to "${persona.greeting}! \u{1F60A}" in the user's preferred language (${preferredLang})
- Communication style: ${persona.communicationStyle}
- Use these expressions naturally: ${persona.commonExpressions.join(", ")}
- Language style: ${persona.languageStyle}

CULTURAL CONTEXT:
- Relationship culture: ${persona.relationshipCulture}
- Dating norms: ${persona.datingNorms}
- Core values to respect: ${persona.culturalValues.join(", ")}

AGE-APPROPRIATE COMMUNICATION (User is ${userAge} years old):
${persona.ageConsiderations[ageCategory]}

${persona.conversationalVibe}`;
    }
    systemPrompt += `

CORE PERSONALITY:
- Be warm, supportive, and culturally sensitive
- Give practical relationship advice that respects cultural context
- Use appropriate cultural references and expressions naturally
- Be empathetic and understanding of cultural relationship challenges
- Maintain consistency with the cultural persona throughout the conversation

IMAGE ANALYSIS CAPABILITIES:
- You CAN view and analyze images when users share them
- When analyzing photos, provide thoughtful insights about relationships, dating, style, or personal presentation
- Offer constructive feedback on dating profile photos, outfit choices, or social situations
- Connect image content to cultural context and relationship advice
- Be specific about what you see while maintaining sensitivity and respect

PEER DYNAMICS:
- Speak as the user's peer for their age (match their maturity and energy)
- Avoid lecturing or preaching; be the wise, smart, admirable friend
- Keep language approachable, natural, and concise like a trusted peer

APPROACHABILITY & RESPECT:
- Make women feel comfortable, respected, and safe at all times
- Be someone men want to talk to: confident, insightful, humble
- Never be flirty or suggestive; keep boundaries clear and professional
- Use inclusive, non-judgmental language

RELATIONSHIP ADVICE PRINCIPLES:
- Respect cultural values while promoting healthy relationships
- Consider family dynamics and community expectations
- Balance traditional wisdom with modern relationship realities
- Be inclusive and non-judgmental
- Focus on communication, respect, and mutual understanding

 LANGUAGE:
 - Use ${preferredLang} for the entire response, including the greeting
 - If a cultural greeting term like "${persona.greeting}" is used, adapt or translate it into ${preferredLang} (you may keep the cultural term and briefly explain if helpful)

 Always respond in character, using the appropriate greeting, expressions, and cultural perspective for this user's background.`;
    return systemPrompt;
  }
};
var kwameAI = new KwameAIService();

// server/services/big5-scoring-service.ts
import { readFileSync } from "fs";
import { join } from "path";
var LEVEL_ENCODING = {
  "StronglyDisagree": -2,
  "Disagree": -1,
  "Neutral": 0,
  "Agree": 1,
  "StronglyAgree": 2
};
var ASPECT_TO_TRAIT = {
  "Compassion": "Agreeableness",
  "Politeness": "Agreeableness",
  "Industriousness": "Conscientiousness",
  "Orderliness": "Conscientiousness",
  "Enthusiasm": "Extraversion",
  "Assertiveness": "Extraversion",
  "Withdrawal": "Neuroticism",
  "Volatility": "Neuroticism",
  "Intellect": "Openness",
  "Aesthetics": "Openness"
};
var Big5ScoringService = class {
  items = [];
  aspectModels = null;
  MODEL_VERSION = "1.0";
  constructor() {
    this.loadScoringData();
  }
  /**
   * Load item mapping and aspect models from JSON files
   */
  loadScoringData() {
    try {
      const itemMappingPath = join(process.cwd(), "analysis_outputs", "item_mapping.json");
      const itemMapping = JSON.parse(readFileSync(itemMappingPath, "utf-8"));
      this.items = itemMapping.items;
      const aspectModelsPath = join(process.cwd(), "analysis_outputs", "aspect_models.json");
      this.aspectModels = JSON.parse(readFileSync(aspectModelsPath, "utf-8"));
      console.log(`[Big5] Loaded ${this.items.length} questionnaire items and aspect models`);
    } catch (error) {
      console.error("[Big5] Failed to load scoring data:", error);
      throw new Error("Failed to initialize Big 5 scoring service");
    }
  }
  /**
   * Encode response level to numeric value
   */
  encodeLevel(level) {
    return LEVEL_ENCODING[level];
  }
  /**
   * Score individual item with reverse-keying if needed
   */
  scoreItem(levelValue, reverse) {
    return reverse ? -levelValue : levelValue;
  }
  /**
   * Aggregate traits from aspect percentiles
   */
  aggregateTraitsFromAspects(aspectPercentiles) {
    const traitGroups = {
      "Agreeableness": [],
      "Conscientiousness": [],
      "Extraversion": [],
      "Neuroticism": [],
      "Openness": []
    };
    for (const [aspect, percentile] of Object.entries(aspectPercentiles)) {
      const trait = ASPECT_TO_TRAIT[aspect];
      traitGroups[trait].push(percentile);
    }
    const traitPercentiles = {};
    for (const [trait, values] of Object.entries(traitGroups)) {
      traitPercentiles[trait] = values.length > 0 ? values.reduce((sum, val) => sum + val, 0) / values.length : 0;
    }
    return traitPercentiles;
  }
  /**
   * Generate personality insights and narratives from Big 5 results
   */
  generateNarrative(traitPercentiles) {
    const getTraitDescription = (trait, percentile) => {
      const level = percentile >= 70 ? "high" : percentile <= 30 ? "low" : "moderate";
      const descriptions = {
        "Agreeableness": {
          high: "highly cooperative, trusting, and compassionate toward others",
          moderate: "balanced between cooperation and self-advocacy",
          low: "more competitive, skeptical, and focused on personal interests"
        },
        "Conscientiousness": {
          high: "highly organized, disciplined, and goal-oriented",
          moderate: "reasonably organized with a balance of structure and flexibility",
          low: "more spontaneous, flexible, and adaptable to changing situations"
        },
        "Extraversion": {
          high: "highly social, energetic, and enthusiastic in group settings",
          moderate: "comfortable in both social and solitary situations",
          low: "more introverted, preferring quieter environments and smaller groups"
        },
        "Neuroticism": {
          high: "more sensitive to stress and prone to emotional fluctuations",
          moderate: "generally emotionally stable with occasional stress responses",
          low: "highly emotionally stable and resilient under pressure"
        },
        "Openness": {
          high: "highly creative, curious, and open to new experiences",
          moderate: "balanced between tradition and innovation",
          low: "more practical, traditional, and focused on proven approaches"
        }
      };
      return descriptions[trait][level];
    };
    const traitDescriptions = {};
    const strengths = [];
    const growthAreas = [];
    for (const [trait, percentile] of Object.entries(traitPercentiles)) {
      traitDescriptions[trait] = getTraitDescription(trait, percentile);
      if (percentile >= 70) {
        if (trait === "Agreeableness") strengths.push("Building strong relationships");
        if (trait === "Conscientiousness") strengths.push("Achieving goals consistently");
        if (trait === "Extraversion") strengths.push("Energizing social interactions");
        if (trait === "Openness") strengths.push("Embracing new experiences");
        if (trait === "Neuroticism" && percentile <= 30) strengths.push("Maintaining emotional stability");
      }
      if (percentile <= 25) {
        if (trait === "Agreeableness") growthAreas.push("Building trust and empathy");
        if (trait === "Conscientiousness") growthAreas.push("Developing organizational skills");
        if (trait === "Extraversion") growthAreas.push("Engaging in social connections");
        if (trait === "Openness") growthAreas.push("Exploring new perspectives");
      }
      if (trait === "Neuroticism" && percentile >= 75) {
        growthAreas.push("Managing stress and emotional regulation");
      }
    }
    const dominantTraits = Object.entries(traitPercentiles).filter(([_, percentile]) => percentile >= 60).map(([trait, _]) => trait.toLowerCase()).slice(0, 2);
    const summary = dominantTraits.length > 0 ? `You show strong tendencies toward ${dominantTraits.join(" and ")}, which influences how you connect with others in relationships.` : "You have a balanced personality profile that allows you to adapt well to different relationship dynamics.";
    return {
      summary,
      traits: traitDescriptions,
      strengths: strengths.slice(0, 4),
      // Top 4 strengths
      growthAreas: growthAreas.slice(0, 3)
      // Top 3 growth areas
    };
  }
  /**
   * Predict Big 5 percentiles from questionnaire responses
   */
  predictFromResponses(responses) {
    if (!this.aspectModels) {
      throw new Error("Scoring models not loaded");
    }
    if (responses.length !== this.items.length) {
      throw new Error(`Response length (${responses.length}) must match items (${this.items.length})`);
    }
    const aspectValues = {
      "Compassion": [],
      "Politeness": [],
      "Industriousness": [],
      "Orderliness": [],
      "Enthusiasm": [],
      "Assertiveness": [],
      "Withdrawal": [],
      "Volatility": [],
      "Intellect": [],
      "Aesthetics": []
    };
    for (let i = 0; i < responses.length; i++) {
      const response = responses[i];
      const item = this.items[i];
      const encodedValue = this.encodeLevel(response);
      const scoredValue = this.scoreItem(encodedValue, item.reverse);
      aspectValues[item.aspect].push(scoredValue);
    }
    const aspectMeanLevels = {};
    for (const [aspect, values] of Object.entries(aspectValues)) {
      aspectMeanLevels[aspect] = values.length > 0 ? values.reduce((sum, val) => sum + val, 0) / values.length : 0;
    }
    const aspectPercentiles = {};
    for (const [aspect, meanLevel] of Object.entries(aspectMeanLevels)) {
      const model = this.aspectModels.linear_models[aspect];
      aspectPercentiles[aspect] = Math.max(0, Math.min(100, model.a * meanLevel + model.b));
    }
    const traitPercentiles = this.aggregateTraitsFromAspects(aspectPercentiles);
    return {
      aspectPercentiles,
      traitPercentiles,
      metadata: {
        version: this.MODEL_VERSION,
        computedAt: (/* @__PURE__ */ new Date()).toISOString(),
        totalResponses: responses.length,
        modelVersion: this.MODEL_VERSION
      }
    };
  }
  /**
   * Generate complete Big 5 profile with narrative insights
   */
  generateBig5Profile(responses) {
    const results = this.predictFromResponses(responses);
    const narrative = this.generateNarrative(results.traitPercentiles);
    return {
      ...results,
      narrative
    };
  }
  /**
   * Validate questionnaire responses
   */
  validateResponses(responses) {
    const errors = [];
    if (!Array.isArray(responses)) {
      errors.push("Responses must be an array");
      return { valid: false, errors };
    }
    if (responses.length !== 100) {
      errors.push(`Expected 100 responses, got ${responses.length}`);
    }
    for (let i = 0; i < responses.length; i++) {
      const response = responses[i];
      if (!Object.keys(LEVEL_ENCODING).includes(response)) {
        errors.push(`Invalid response level at index ${i}: ${response}`);
      }
    }
    return { valid: errors.length === 0, errors };
  }
  /**
   * Get questionnaire items for frontend display
   */
  getQuestionnaireItems() {
    return this.items;
  }
  /**
   * Get personality statements text for display
   */
  getStatements() {
    return this.items.map((item) => item.text);
  }
};
var big5ScoringService = new Big5ScoringService();
var big5_scoring_service_default = big5ScoringService;

// server/services/personality-descriptions-service.ts
var PersonalityDescriptionsService = class {
  /**
   * Determine percentile range category
   */
  getPercentileRange(percentile) {
    if (percentile <= 4) return "exceptionally_low";
    if (percentile <= 15) return "very_low";
    if (percentile <= 25) return "low";
    if (percentile <= 40) return "moderately_low";
    if (percentile <= 60) return "typical";
    if (percentile <= 75) return "moderately_high";
    if (percentile <= 85) return "high";
    if (percentile <= 95) return "very_high";
    return "exceptionally_high";
  }
  /**
   * Get human-readable level label
   */
  getLevelLabel(range) {
    const labels = {
      "exceptionally_low": "Exceptionally Low",
      "very_low": "Very Low",
      "low": "Low",
      "moderately_low": "Moderately Low",
      "typical": "Typical or Average",
      "moderately_high": "Moderately High",
      "high": "High",
      "very_high": "Very High",
      "exceptionally_high": "Exceptionally High"
    };
    return labels[range];
  }
  /**
   * Generate detailed Openness analysis
   */
  generateOpennessAnalysis(intellectPercentile, aestheticsPercentile) {
    const traitPercentile = (intellectPercentile + aestheticsPercentile) / 2;
    const traitLevel = this.getPercentileRange(traitPercentile);
    const overviewDescriptions = {
      "exceptionally_low": "You are exceptionally low in openness to experience. You strongly prefer familiar routines, traditional approaches, and practical solutions over abstract or innovative ideas.",
      "very_low": "You are very low in openness to experience. You tend to be conventional, preferring tried-and-true methods and showing little interest in abstract concepts or artistic pursuits.",
      "low": "You are low in openness to experience. You are generally practical and traditional, preferring concrete over abstract thinking and familiar approaches over novel ones.",
      "moderately_low": "You are moderately low in openness to experience. While you can appreciate some new ideas, you generally prefer conventional approaches and practical solutions.",
      "typical": "You are typical in openness to experience. You maintain a balance between traditional and innovative approaches, showing interest in both practical and creative pursuits.",
      "moderately_high": "You are moderately high in openness to experience. You enjoy exploring new ideas and creative pursuits while maintaining some appreciation for traditional approaches.",
      "high": "You are high in openness to experience. You actively seek out new experiences, enjoy abstract thinking, and have strong interests in creative and intellectual pursuits.",
      "very_high": "You are very high in openness to experience. You are highly creative, intellectually curious, and constantly seeking novel experiences and innovative approaches.",
      "exceptionally_high": "You are exceptionally high in openness to experience. You have an extraordinary appetite for novelty, creativity, and intellectual exploration, often preferring the unconventional."
    };
    return {
      name: "Openness",
      percentile: traitPercentile,
      level: traitLevel,
      levelLabel: this.getLevelLabel(traitLevel),
      overview: overviewDescriptions[traitLevel],
      aspects: [
        this.generateIntellectAnalysis(intellectPercentile),
        this.generateAestheticsAnalysis(aestheticsPercentile)
      ],
      politicalTendencies: traitPercentile > 60 ? "People higher in openness tend to be more liberal in their political views, embracing social change and progressive policies." : "People lower in openness tend to be more conservative, preferring traditional values and established social structures."
    };
  }
  /**
   * Generate Intellect aspect analysis
   */
  generateIntellectAnalysis(percentile) {
    const level = this.getPercentileRange(percentile);
    const descriptions = {
      "exceptionally_low": "You show exceptionally low intellectual curiosity. You strongly avoid complex ideas, preferring straightforward, practical thinking. Abstract concepts and theoretical discussions hold little appeal for you.",
      "very_low": "You have very low interest in intellectual pursuits. You prefer practical, concrete thinking over abstract ideas and rarely engage with complex theoretical concepts.",
      "low": "You are low in intellectual curiosity. You tend to focus on practical, straightforward approaches rather than complex ideas or abstract thinking.",
      "moderately_low": "You are moderately low in intellectual curiosity. While you can handle some complex ideas, you generally prefer practical, concrete approaches to problem-solving.",
      "typical": "You show typical levels of intellectual curiosity. You can engage with both practical and abstract ideas, maintaining a balance between concrete and theoretical thinking.",
      "moderately_high": "You are moderately high in intellectual curiosity. You enjoy exploring complex ideas and engaging with abstract concepts while maintaining practical sensibilities.",
      "high": "You are high in intellectual curiosity. You actively seek out complex ideas, enjoy abstract thinking, and have a strong appetite for learning and intellectual challenge.",
      "very_high": "You are very high in intellectual curiosity. You have a profound love of learning, consistently seek out complex ideas, and thrive on intellectual challenges.",
      "exceptionally_high": "You show exceptional intellectual curiosity. You have an extraordinary appetite for complex ideas, abstract thinking, and intellectual exploration that sets you apart from others."
    };
    const characteristics = {
      "exceptionally_low": ["Avoids complex ideas", "Prefers simple solutions", "Dislikes abstract thinking", "Focuses on immediate practical concerns"],
      "very_low": ["Prefers concrete thinking", "Avoids theoretical discussions", "Values practical over intellectual pursuits", "Limited interest in learning for its own sake"],
      "low": ["Practical problem-solver", "Prefers straightforward approaches", "Limited interest in abstract concepts", "Values common sense over theory"],
      "moderately_low": ["Generally practical", "Can handle some complexity", "Prefers proven methods", "Moderate interest in learning"],
      "typical": ["Balanced thinking style", "Comfortable with moderate complexity", "Appreciates both practical and abstract ideas", "Reasonable curiosity about new concepts"],
      "moderately_high": ["Enjoys intellectual challenges", "Comfortable with abstract concepts", "Strong learning motivation", "Values both theory and practice"],
      "high": ["Highly intellectually curious", "Seeks out complex ideas", "Enjoys abstract thinking", "Strong drive to understand"],
      "very_high": ["Exceptional intellectual appetite", "Thrives on complexity", "Deeply curious about ideas", "Constantly seeking to learn"],
      "exceptionally_high": ["Extraordinary intellectual curiosity", "Masters complex concepts easily", "Prefers abstract over concrete", "Insatiable appetite for knowledge"]
    };
    return {
      name: "Intellect",
      percentile,
      level,
      levelLabel: this.getLevelLabel(level),
      description: descriptions[level],
      characteristics: characteristics[level],
      advantages: level === "exceptionally_low" || level === "very_low" ? ["Practical problem-solving", "Focus on immediate concerns", "Clear, straightforward communication", "Efficient decision-making"] : ["Strong analytical skills", "Enjoys learning", "Good at abstract thinking", "Intellectually curious"],
      challenges: level === "exceptionally_low" || level === "very_low" ? ["May miss innovative solutions", "Limited interest in complex ideas", "May undervalue intellectual pursuits"] : ["May overthink simple problems", "Can get lost in abstract concepts", "May undervalue practical considerations"],
      relationshipStyle: level === "exceptionally_low" || level === "very_low" ? "You prefer straightforward communication and practical discussions in relationships, avoiding overly complex emotional or philosophical conversations." : "You enjoy intellectually stimulating conversations and value partners who can engage with complex ideas and abstract concepts.",
      careerImplications: level === "exceptionally_low" || level === "very_low" ? "You excel in practical, hands-on roles that require straightforward problem-solving and concrete thinking rather than abstract analysis." : "You thrive in intellectually demanding careers that involve analysis, research, strategy, or creative problem-solving."
    };
  }
  /**
   * Generate Aesthetics aspect analysis
   */
  generateAestheticsAnalysis(percentile) {
    const level = this.getPercentileRange(percentile);
    const descriptions = {
      "exceptionally_low": "You have exceptionally low interest in aesthetic experiences. Art, beauty, and creative expression hold little appeal for you, and you prefer functional over decorative elements.",
      "very_low": "You have very low interest in aesthetics and beauty. You rarely notice or appreciate artistic elements and prefer practical, functional environments over decorative ones.",
      "low": "You are low in aesthetic appreciation. You tend to focus on functionality over beauty and have limited interest in art, design, or creative expression.",
      "moderately_low": "You are moderately low in aesthetic interest. While you can appreciate some beautiful things, you generally prioritize function over form.",
      "typical": "You show typical levels of aesthetic appreciation. You can enjoy beauty and art while maintaining practical sensibilities about design and creative expression.",
      "moderately_high": "You are moderately high in aesthetic appreciation. You enjoy beauty, art, and creative expression and often seek out aesthetically pleasing experiences.",
      "high": "You are high in aesthetic appreciation. You have a strong sensitivity to beauty, enjoy artistic experiences, and value creative and aesthetic elements in your environment.",
      "very_high": "You are very high in aesthetic appreciation. You have exceptional sensitivity to beauty and art, and aesthetic experiences play a significant role in your life.",
      "exceptionally_high": "You show exceptional aesthetic sensitivity. You have an extraordinary appreciation for beauty, art, and creative expression that deeply influences how you experience the world."
    };
    return {
      name: "Aesthetics",
      percentile,
      level,
      levelLabel: this.getLevelLabel(level),
      description: descriptions[level],
      characteristics: level === "exceptionally_low" || level === "very_low" ? ["Prefers function over form", "Limited interest in art", "Practical aesthetic choices", "Focuses on utility"] : ["Strong aesthetic sensitivity", "Appreciates beauty and art", "Values creative expression", "Notices aesthetic details"],
      advantages: level === "exceptionally_low" || level === "very_low" ? ["Practical decision-making", "Cost-effective choices", "Focus on functionality", "Efficient use of resources"] : ["Rich appreciation of beauty", "Creative perspective", "Enhanced life experiences", "Artistic sensitivity"],
      challenges: level === "exceptionally_low" || level === "very_low" ? ["May miss aesthetic value", "Limited creative expression", "May undervalue art and beauty"] : ["May prioritize form over function", "Can be particular about aesthetics", "May spend more on aesthetic appeal"],
      relationshipStyle: level === "exceptionally_low" || level === "very_low" ? "You focus on practical aspects of relationships and living arrangements, paying less attention to romantic or aesthetic elements." : "You appreciate beauty and artistic elements in relationships, valuing aesthetic harmony and creative shared experiences.",
      careerImplications: level === "exceptionally_low" || level === "very_low" ? "You excel in practical, utility-focused careers where function and efficiency matter more than aesthetic considerations." : "You thrive in creative fields, design-oriented roles, or any career where aesthetic judgment and artistic sensitivity are valued."
    };
  }
  /**
   * Generate detailed Agreeableness analysis
   */
  generateAgreeablenessAnalysis(compassionPercentile, politenessPercentile) {
    const traitPercentile = (compassionPercentile + politenessPercentile) / 2;
    const traitLevel = this.getPercentileRange(traitPercentile);
    const overviewDescriptions = {
      "exceptionally_low": "You are exceptionally low in agreeableness. You are highly competitive, skeptical, and focused on your own interests. You tend to be straightforward and blunt in your interactions.",
      "very_low": "You are very low in agreeableness. You tend to be competitive, skeptical, and more focused on your own needs than others' feelings. You value honesty over harmony.",
      "low": "You are low in agreeableness. You tend to be somewhat competitive and skeptical, preferring direct communication over diplomatic approaches.",
      "moderately_low": "You are moderately low in agreeableness. You balance self-interest with some concern for others, but tend to be fairly direct in your approach.",
      "typical": "You are typical in agreeableness. You maintain a healthy balance between cooperation and self-advocacy, adapting your approach based on the situation.",
      "moderately_high": "You are moderately high in agreeableness. You are generally cooperative and considerate, though you can assert yourself when necessary.",
      "high": "You are high in agreeableness. You are very cooperative, trusting, and concerned about others' welfare, often putting harmony above conflict.",
      "very_high": "You are very high in agreeableness. You are exceptionally cooperative, compassionate, and focused on maintaining harmony in relationships.",
      "exceptionally_high": "You are exceptionally high in agreeableness. You are extraordinarily compassionate and cooperative, sometimes to the point of self-sacrifice."
    };
    return {
      name: "Agreeableness",
      percentile: traitPercentile,
      level: traitLevel,
      levelLabel: this.getLevelLabel(traitLevel),
      overview: overviewDescriptions[traitLevel],
      aspects: [
        this.generateCompassionAnalysis(compassionPercentile),
        this.generatePolitenessAnalysis(politenessPercentile)
      ],
      genderNotes: "Women tend to be higher in agreeableness than men. The mean percentile for women is 61.5, while for men it is 38.5.",
      politicalTendencies: "Agreeableness has complex political associations. Higher compassion predicts liberal views, while higher politeness predicts conservative views."
    };
  }
  /**
   * Generate Compassion aspect analysis
   */
  generateCompassionAnalysis(percentile) {
    const level = this.getPercentileRange(percentile);
    const descriptions = {
      "exceptionally_low": "You are exceptionally low in compassion. You are not easily moved by others' suffering and tend to prioritize your own needs and interests above those of others.",
      "very_low": "You are very low in compassion. You are much less concerned about helping other people and are markedly unwilling to sacrifice for others' comfort.",
      "low": "You are low in compassion. You tend to focus on your own needs first and are less likely to be moved by others' difficulties or emotional states.",
      "moderately_low": "You are moderately low in compassion. While you can feel for others, you generally prioritize your own needs and interests.",
      "typical": "You show typical levels of compassion. You can empathize with others while maintaining healthy boundaries for your own well-being.",
      "moderately_high": "You are moderately high in compassion. You genuinely care about others' welfare and are often willing to help those in need.",
      "high": "You are high in compassion. You are very empathetic and caring, often putting others' needs before your own and feeling deeply affected by others' suffering.",
      "very_high": "You are very high in compassion. You have exceptional empathy and are deeply moved by others' suffering, often going to great lengths to help.",
      "exceptionally_high": "You are exceptionally high in compassion. You have extraordinary empathy and are profoundly affected by others' suffering, sometimes to your own detriment."
    };
    return {
      name: "Compassion",
      percentile,
      level,
      levelLabel: this.getLevelLabel(level),
      description: descriptions[level],
      characteristics: level === "exceptionally_low" || level === "very_low" ? ["Focuses on self-interest", "Not easily moved by suffering", "Practical about helping others", "Maintains emotional distance"] : ["Highly empathetic", "Concerned about others' welfare", "Willing to help and sacrifice", "Emotionally responsive to suffering"],
      advantages: level === "exceptionally_low" || level === "very_low" ? ["Strong self-advocacy", "Clear boundaries", "Objective decision-making", "Less likely to be taken advantage of"] : ["Strong relationships", "Natural caregiver", "Inspirational to others", "Creates supportive environments"],
      challenges: level === "exceptionally_low" || level === "very_low" ? ["May appear cold or uncaring", "Difficulty building emotional connections", "May miss others' emotional needs"] : ["May neglect own needs", "Vulnerable to exploitation", "Can be overwhelmed by others' problems", "Difficulty with necessary confrontation"],
      relationshipStyle: level === "exceptionally_low" || level === "very_low" ? "You tend to be straightforward and direct in relationships, focusing more on practical support than emotional comfort." : "You are highly attuned to your partner's emotional needs and willing to make sacrifices for their happiness and well-being.",
      careerImplications: level === "exceptionally_low" || level === "very_low" ? "You excel in roles requiring objective decision-making, negotiation, or situations where emotional detachment is beneficial." : "You thrive in helping professions, counseling, healthcare, education, or any role focused on supporting others' well-being."
    };
  }
  /**
   * Generate Politeness aspect analysis
   */
  generatePolitenessAnalysis(percentile) {
    const level = this.getPercentileRange(percentile);
    const descriptions = {
      "exceptionally_low": "You are exceptionally low in politeness. You readily challenge authority and are comfortable with confrontation. You may have difficulty with hierarchical structures.",
      "very_low": "You are very low in politeness. You are not deferential to authority and are markedly willing to push back when challenged.",
      "low": "You are low in politeness. You tend to be direct and are comfortable challenging others when you disagree, regardless of their position.",
      "moderately_low": "You are moderately low in politeness. You can be respectful but are willing to speak up and challenge when necessary.",
      "typical": "You show typical levels of politeness. You can be respectful and deferential when appropriate while also standing up for yourself when needed.",
      "moderately_high": "You are moderately high in politeness. You tend to be respectful and courteous, preferring diplomatic approaches to conflict.",
      "high": "You are high in politeness. You are very respectful of authority and social hierarchies, preferring to avoid confrontation when possible.",
      "very_high": "You are very high in politeness. You are exceptionally deferential and respectful, sometimes avoiding necessary confrontations.",
      "exceptionally_high": "You are exceptionally high in politeness. You are extraordinarily deferential to authority and may struggle to assert yourself even when appropriate."
    };
    return {
      name: "Politeness",
      percentile,
      level,
      levelLabel: this.getLevelLabel(level),
      description: descriptions[level],
      characteristics: level === "exceptionally_low" || level === "very_low" ? ["Challenges authority readily", "Comfortable with confrontation", "Direct communication style", "Questions hierarchies"] : ["Respectful and courteous", "Deferential to authority", "Diplomatic approach", "Avoids unnecessary conflict"],
      advantages: level === "exceptionally_low" || level === "very_low" ? ["Strong leadership potential", "Willing to challenge problems", "Authentic communication", "Drives necessary change"] : ["Excellent team player", "Maintains social harmony", "Respectful relationships", "Good at following protocols"],
      challenges: level === "exceptionally_low" || level === "very_low" ? ["May create conflict unnecessarily", "Difficulty in hierarchical settings", "Can be seen as disruptive or disrespectful"] : ["May avoid necessary confrontations", "Can be taken advantage of", "May suppress own needs for harmony", "Difficulty asserting leadership"],
      relationshipStyle: level === "exceptionally_low" || level === "very_low" ? "You tend to be direct and honest in relationships, even when it creates temporary conflict, preferring authenticity over harmony." : "You prioritize harmony and respect in relationships, often deferring to your partner and avoiding conflicts that might disrupt peace.",
      careerImplications: level === "exceptionally_low" || level === "very_low" ? "You excel in leadership roles, entrepreneurship, or positions requiring challenge of existing systems and direct communication." : "You thrive in supportive roles, traditional hierarchical structures, customer service, or positions requiring diplomacy and respect for authority."
    };
  }
  /**
   * Generate detailed Conscientiousness analysis
   */
  generateConscientiousnessAnalysis(industriousnessPercentile, orderlinessPercentile) {
    const traitPercentile = (industriousnessPercentile + orderlinessPercentile) / 2;
    const traitLevel = this.getPercentileRange(traitPercentile);
    const overviewDescriptions = {
      "exceptionally_low": "You are exceptionally low in conscientiousness. You are very spontaneous and flexible, preferring to live in the moment rather than following strict plans or schedules.",
      "very_low": "You are very low in conscientiousness. You tend to be spontaneous and flexible, with little concern for rigid organization or long-term planning.",
      "low": "You are low in conscientiousness. You prefer flexibility and spontaneity over rigid structure and planning.",
      "moderately_low": "You are moderately low in conscientiousness. You balance some organization with flexibility, but generally prefer less structured approaches.",
      "typical": "You are typical in conscientiousness. You maintain a good balance between organization and flexibility, adapting your approach as needed.",
      "moderately_high": "You are moderately high in conscientiousness. You tend to be organized and goal-oriented while maintaining some flexibility.",
      "high": "You are high in conscientiousness. You are very organized, disciplined, and focused on achieving your goals through systematic effort.",
      "very_high": "You are very high in conscientiousness. You are exceptionally organized, disciplined, and committed to achieving your objectives.",
      "exceptionally_high": "You are exceptionally high in conscientiousness. You have extraordinary self-discipline and organization, sometimes to the point of rigidity."
    };
    return {
      name: "Conscientiousness",
      percentile: traitPercentile,
      level: traitLevel,
      levelLabel: this.getLevelLabel(traitLevel),
      overview: overviewDescriptions[traitLevel],
      aspects: [
        this.generateIndustriousnessAnalysis(industriousnessPercentile),
        this.generateOrderlinessAnalysis(orderlinessPercentile)
      ],
      genderNotes: "Women are very slightly more conscientious than men. The mean percentile for women is 51.5, while for men it is 49.5.",
      politicalTendencies: "Lower conscientiousness is associated with liberal political views, especially when combined with high openness. Higher conscientiousness tends toward conservative views."
    };
  }
  /**
   * Generate Industriousness aspect analysis
   */
  generateIndustriousnessAnalysis(percentile) {
    const level = this.getPercentileRange(percentile);
    const descriptions = {
      "exceptionally_low": "You are exceptionally low in industriousness. You strongly prioritize leisure and relaxation over work and achievement, and may struggle with motivation for long-term goals.",
      "very_low": "You are very low in industriousness. You focus less on work than others and are substantially more likely to procrastinate or fail to complete assignments.",
      "low": "You are low in industriousness. You tend to prioritize fun and relationships over work and are less motivated by achievement.",
      "moderately_low": "You are moderately low in industriousness. You can work hard when motivated but generally prefer leisure and don't mind procrastinating.",
      "typical": "You show typical levels of industriousness. You can work hard when needed while also valuing leisure and work-life balance.",
      "moderately_high": "You are moderately high in industriousness. You are generally motivated to work hard and achieve goals while maintaining some work-life balance.",
      "high": "You are high in industriousness. You are very motivated to work hard and achieve your goals, often prioritizing work over leisure.",
      "very_high": "You are very high in industriousness. You have exceptional work ethic and are driven to achieve, sometimes at the expense of relaxation.",
      "exceptionally_high": "You are exceptionally high in industriousness. You have extraordinary drive and work ethic, potentially to the point of workaholism."
    };
    return {
      name: "Industriousness",
      percentile,
      level,
      levelLabel: this.getLevelLabel(level),
      description: descriptions[level],
      characteristics: level === "exceptionally_low" || level === "very_low" ? ["Prioritizes leisure over work", "Prone to procrastination", "Lives in the moment", "Values work-life balance"] : ["Strong work ethic", "Goal-oriented", "Persistent and determined", "Achievement-focused"],
      advantages: level === "exceptionally_low" || level === "very_low" ? ["Excellent work-life balance", "Good at relaxation", "Flexible and adaptable", "Values relationships and experiences"] : ["High achievement potential", "Strong perseverance", "Excellent work ethic", "Goal completion"],
      challenges: level === "exceptionally_low" || level === "very_low" ? ["May struggle with long-term goals", "Tendency to procrastinate", "May underachieve professionally", "Difficulty with deadlines"] : ["Risk of burnout", "May neglect personal relationships", "Potential workaholic tendencies", "May be overly self-critical"],
      relationshipStyle: level === "exceptionally_low" || level === "very_low" ? "You prioritize spending quality time with loved ones and value relationships over professional achievement in your personal life." : "You may sometimes struggle to balance relationship time with work commitments, but you bring the same dedication to relationships as to goals.",
      careerImplications: level === "exceptionally_low" || level === "very_low" ? "You excel in creative, flexible environments that don't require rigid deadlines or intensive long-term planning." : "You thrive in demanding careers requiring persistence, long-term planning, and consistent effort toward challenging goals."
    };
  }
  /**
   * Generate Orderliness aspect analysis
   */
  generateOrderlinessAnalysis(percentile) {
    const level = this.getPercentileRange(percentile);
    const descriptions = {
      "exceptionally_low": "You are exceptionally low in orderliness. You are completely comfortable with chaos and disorder, rarely using schedules or organizational systems.",
      "very_low": "You are very low in orderliness. You are not disturbed by mess and chaos and prefer to take things as they come rather than following plans.",
      "low": "You are low in orderliness. You don't particularly notice or care about disorder and prefer flexibility over rigid organization.",
      "moderately_low": "You are moderately low in orderliness. You can tolerate some mess and prefer loose organization over rigid systems.",
      "typical": "You show typical levels of orderliness. You like some organization and routine but can tolerate disruption when necessary.",
      "moderately_high": "You are moderately high in orderliness. You prefer organized environments and some routine while remaining reasonably flexible.",
      "high": "You are high in orderliness. You strongly prefer organized, clean environments and like to follow schedules and routines.",
      "very_high": "You are very high in orderliness. You have a strong need for organization and structure and may be uncomfortable with mess or disorder.",
      "exceptionally_high": "You are exceptionally high in orderliness. You have an extraordinary need for organization and structure, potentially to the point of rigidity."
    };
    return {
      name: "Orderliness",
      percentile,
      level,
      levelLabel: this.getLevelLabel(level),
      description: descriptions[level],
      characteristics: level === "exceptionally_low" || level === "very_low" ? ["Comfortable with chaos", "Flexible and adaptable", "Doesn't notice mess", "Prefers spontaneity"] : ["Highly organized", "Values cleanliness and order", "Uses schedules and systems", "Prefers predictability"],
      advantages: level === "exceptionally_low" || level === "very_low" ? ["Highly adaptable", "Tolerates disruption well", "Creative flexibility", "Goes with the flow"] : ["Excellent organization skills", "Efficient and systematic", "Good at planning", "Creates structured environments"],
      challenges: level === "exceptionally_low" || level === "very_low" ? ["May struggle with detailed tasks", "Can appear disorganized to others", "May lose important items", "Difficulty with systematic approaches"] : ["May be inflexible", "Can be stressed by disorder", "May be overly critical of messiness", "Difficulty adapting to chaos"],
      relationshipStyle: level === "exceptionally_low" || level === "very_low" ? "You are flexible and adaptable in relationships, not bothered by household disorder or changes in routine." : "You prefer organized, predictable relationship routines and may become stressed when your partner disrupts established order.",
      careerImplications: level === "exceptionally_low" || level === "very_low" ? "You excel in dynamic, unpredictable environments that require adaptability and tolerance for changing conditions." : "You thrive in structured, organized work environments that value systematic approaches, attention to detail, and consistent procedures."
    };
  }
  /**
   * Generate detailed Extraversion analysis
   */
  generateExtraversionAnalysis(enthusiasmPercentile, assertivenessPercentile) {
    const traitPercentile = (enthusiasmPercentile + assertivenessPercentile) / 2;
    const traitLevel = this.getPercentileRange(traitPercentile);
    const overviewDescriptions = {
      "exceptionally_low": "You are exceptionally low in extraversion. You strongly prefer solitude and quiet environments, finding social interaction draining and preferring internal reflection.",
      "very_low": "You are very low in extraversion. You are quite introverted, preferring smaller groups and quieter environments over large social gatherings.",
      "low": "You are low in extraversion. You tend to be more introverted, enjoying solitude and smaller social groups more than large gatherings.",
      "moderately_low": "You are moderately low in extraversion. You can enjoy social situations but often prefer quieter environments and smaller groups.",
      "typical": "You are typical in extraversion. You are comfortable in both social and solitary situations, adapting well to different social environments.",
      "moderately_high": "You are moderately high in extraversion. You generally enjoy social interaction and group activities while also appreciating some alone time.",
      "high": "You are high in extraversion. You are very social, energetic in group settings, and gain energy from interaction with others.",
      "very_high": "You are very high in extraversion. You are exceptionally social and energetic, thriving in group settings and social interaction.",
      "exceptionally_high": "You are exceptionally high in extraversion. You have extraordinary social energy and enthusiasm, potentially feeling uncomfortable in prolonged solitude."
    };
    return {
      name: "Extraversion",
      percentile: traitPercentile,
      level: traitLevel,
      levelLabel: this.getLevelLabel(traitLevel),
      overview: overviewDescriptions[traitLevel],
      aspects: [
        this.generateEnthusiasmAnalysis(enthusiasmPercentile),
        this.generateAssertivenessAnalysis(assertivenessPercentile)
      ]
    };
  }
  /**
   * Generate Enthusiasm aspect analysis
   */
  generateEnthusiasmAnalysis(percentile) {
    const level = this.getPercentileRange(percentile);
    const descriptions = {
      "exceptionally_low": "You are exceptionally low in enthusiasm. You rarely experience high positive emotions and tend to maintain a calm, steady emotional state.",
      "very_low": "You are very low in enthusiasm. You experience positive emotions less frequently and intensely than most people.",
      "low": "You are low in enthusiasm. You tend to be more reserved emotionally and don't often experience intense positive emotions.",
      "moderately_low": "You are moderately low in enthusiasm. You experience some positive emotions but generally maintain a more subdued emotional style.",
      "typical": "You show typical levels of enthusiasm. You experience a normal range of positive emotions and can be enthusiastic when the situation calls for it.",
      "moderately_high": "You are moderately high in enthusiasm. You often experience positive emotions and can bring energy to social situations.",
      "high": "You are high in enthusiasm. You frequently experience intense positive emotions and often energize others with your enthusiasm.",
      "very_high": "You are very high in enthusiasm. You have exceptional positive energy and enthusiasm that strongly influences your interactions.",
      "exceptionally_high": "You are exceptionally high in enthusiasm. You have extraordinary positive energy and enthusiasm that can be overwhelming to others."
    };
    return {
      name: "Enthusiasm",
      percentile,
      level,
      levelLabel: this.getLevelLabel(level),
      description: descriptions[level],
      characteristics: level === "exceptionally_low" || level === "very_low" ? ["Emotionally steady", "Calm demeanor", "Less reactive to positive events", "Subdued emotional expression"] : ["High positive energy", "Emotionally expressive", "Infectious enthusiasm", "Optimistic outlook"],
      advantages: level === "exceptionally_low" || level === "very_low" ? ["Emotional stability", "Good in crisis situations", "Thoughtful decision-making", "Calming presence"] : ["Motivates others", "Creates positive atmosphere", "Resilient optimism", "Energizing presence"],
      challenges: level === "exceptionally_low" || level === "very_low" ? ["May appear unenthusiastic", "Less motivating to others", "May miss positive opportunities", "Can seem distant or uninterested"] : ["May be overwhelming to others", "Can be disappointed easily", "May make impulsive decisions when excited", "Energy may not be sustainable"],
      relationshipStyle: level === "exceptionally_low" || level === "very_low" ? "You provide stability and calm in relationships, though partners may sometimes want more emotional enthusiasm from you." : "You bring energy and positivity to relationships, helping create exciting and joyful shared experiences.",
      careerImplications: level === "exceptionally_low" || level === "very_low" ? "You excel in roles requiring steady focus, careful analysis, or calm decision-making under pressure." : "You thrive in roles involving motivation, team building, sales, entertainment, or any position requiring positive energy."
    };
  }
  /**
   * Generate Assertiveness aspect analysis
   */
  generateAssertivenessAnalysis(percentile) {
    const level = this.getPercentileRange(percentile);
    const descriptions = {
      "exceptionally_low": "You are exceptionally low in assertiveness. You very rarely take charge or speak up in groups, preferring to follow rather than lead.",
      "very_low": "You are very low in assertiveness. You tend to be passive in social situations and rarely take leadership roles.",
      "low": "You are low in assertiveness. You tend to be quiet in groups and don't often take charge or speak up.",
      "moderately_low": "You are moderately low in assertiveness. You can speak up when necessary but generally prefer to let others take the lead.",
      "typical": "You show typical levels of assertiveness. You can take charge when needed while also being comfortable following others' lead.",
      "moderately_high": "You are moderately high in assertiveness. You often speak up and take charge, while still being able to follow when appropriate.",
      "high": "You are high in assertiveness. You frequently take charge in social situations and are comfortable being the center of attention.",
      "very_high": "You are very high in assertiveness. You have strong leadership tendencies and often dominate social situations.",
      "exceptionally_high": "You are exceptionally high in assertiveness. You have overwhelming leadership drive and may dominate others in social situations."
    };
    return {
      name: "Assertiveness",
      percentile,
      level,
      levelLabel: this.getLevelLabel(level),
      description: descriptions[level],
      characteristics: level === "exceptionally_low" || level === "very_low" ? ["Prefers following to leading", "Quiet in groups", "Avoids center of attention", "Deferential approach"] : ["Natural leadership ability", "Comfortable taking charge", "Speaks up confidently", "Influential in groups"],
      advantages: level === "exceptionally_low" || level === "very_low" ? ["Excellent team member", "Good listener", "Supportive of others' ideas", "Creates harmony"] : ["Strong leadership potential", "Influential and persuasive", "Confident in social situations", "Gets things done"],
      challenges: level === "exceptionally_low" || level === "very_low" ? ["May not advocate for own needs", "Ideas may go unheard", "May be overlooked for leadership", "Difficulty in conflict situations"] : ["May dominate conversations", "Can appear pushy or aggressive", "May not listen to others enough", "Can create conflict"],
      relationshipStyle: level === "exceptionally_low" || level === "very_low" ? "You tend to be supportive and accommodating in relationships, though you may need to work on expressing your own needs." : "You tend to take charge in relationships and may need to ensure you give your partner space to lead and express themselves.",
      careerImplications: level === "exceptionally_low" || level === "very_low" ? "You excel in supportive roles, technical positions, or careers where following detailed instructions and supporting others is valued." : "You thrive in leadership positions, sales, management, or any career requiring confidence, influence, and the ability to take charge."
    };
  }
  /**
   * Generate detailed Neuroticism analysis
   */
  generateNeuroticismAnalysis(withdrawalPercentile, volatilityPercentile) {
    const traitPercentile = (withdrawalPercentile + volatilityPercentile) / 2;
    const traitLevel = this.getPercentileRange(traitPercentile);
    const overviewDescriptions = {
      "exceptionally_low": "You are exceptionally low in neuroticism. You have extraordinary emotional stability and resilience, rarely experiencing stress, anxiety, or negative emotions.",
      "very_low": "You are very low in neuroticism. You are highly emotionally stable and resilient, handling stress and setbacks with remarkable composure.",
      "low": "You are low in neuroticism. You are generally emotionally stable and don't often experience intense negative emotions.",
      "moderately_low": "You are moderately low in neuroticism. You handle stress reasonably well and maintain emotional stability most of the time.",
      "typical": "You are typical in neuroticism. You experience a normal range of emotions and handle stress with average resilience.",
      "moderately_high": "You are moderately high in neuroticism. You may experience stress and negative emotions somewhat more than average.",
      "high": "You are high in neuroticism. You tend to experience stress, anxiety, and negative emotions more frequently and intensely.",
      "very_high": "You are very high in neuroticism. You are quite sensitive to stress and prone to experiencing strong negative emotions.",
      "exceptionally_high": "You are exceptionally high in neuroticism. You are extremely sensitive to stress and may struggle significantly with emotional regulation."
    };
    return {
      name: "Neuroticism",
      percentile: traitPercentile,
      level: traitLevel,
      levelLabel: this.getLevelLabel(traitLevel),
      overview: overviewDescriptions[traitLevel],
      aspects: [
        this.generateWithdrawalAnalysis(withdrawalPercentile),
        this.generateVolatilityAnalysis(volatilityPercentile)
      ],
      genderNotes: "Women tend to be higher in neuroticism than men, though this difference varies significantly across cultures and age groups."
    };
  }
  /**
   * Generate Withdrawal aspect analysis
   */
  generateWithdrawalAnalysis(percentile) {
    const level = this.getPercentileRange(percentile);
    const descriptions = {
      "exceptionally_low": "You are exceptionally low in withdrawal. You remain remarkably engaged and active even in stressful situations, rarely withdrawing from challenges.",
      "very_low": "You are very low in withdrawal. You tend to stay engaged and active when faced with stress or setbacks rather than withdrawing.",
      "low": "You are low in withdrawal. You generally maintain engagement and don't often withdraw when facing difficulties.",
      "moderately_low": "You are moderately low in withdrawal. You usually stay engaged but may occasionally withdraw when overwhelmed.",
      "typical": "You show typical levels of withdrawal. You sometimes withdraw when stressed but generally maintain reasonable engagement.",
      "moderately_high": "You are moderately high in withdrawal. You tend to withdraw more than average when faced with stress or challenges.",
      "high": "You are high in withdrawal. You often withdraw from stressful situations and may struggle to maintain engagement under pressure.",
      "very_high": "You are very high in withdrawal. You have a strong tendency to withdraw when faced with stress, criticism, or challenges.",
      "exceptionally_high": "You are exceptionally high in withdrawal. You have an overwhelming tendency to withdraw from stressful situations, potentially becoming isolated."
    };
    return {
      name: "Withdrawal",
      percentile,
      level,
      levelLabel: this.getLevelLabel(level),
      description: descriptions[level],
      characteristics: level === "exceptionally_low" || level === "very_low" ? ["Stays engaged under stress", "Faces challenges directly", "Maintains social connection", "Resilient under pressure"] : ["Tends to withdraw when stressed", "Seeks solitude during difficulties", "May isolate when overwhelmed", "Sensitive to criticism"],
      advantages: level === "exceptionally_low" || level === "very_low" ? ["Strong resilience", "Maintains relationships under stress", "Continues functioning in adversity", "Natural crisis management"] : ["Good self-care instincts", "Avoids overwhelming situations", "Takes time to process difficulties", "Protective of mental health"],
      challenges: level === "exceptionally_low" || level === "very_low" ? ["May not recognize when rest is needed", "Could push through problems that need attention", "May not process emotions fully"] : ["May miss opportunities due to withdrawal", "Can become isolated", "May avoid necessary confrontations", "Could limit personal growth"],
      relationshipStyle: level === "exceptionally_low" || level === "very_low" ? "You remain engaged with your partner even during stressful times, though you may need to learn when some space is healthy." : "You may withdraw from your partner during stressful times, which requires communication about your need for space versus connection.",
      careerImplications: level === "exceptionally_low" || level === "very_low" ? "You excel in high-pressure careers requiring sustained engagement and the ability to function well under continuous stress." : "You thrive in low-pressure environments or roles where you can control your exposure to stress and have autonomy over your schedule."
    };
  }
  /**
   * Generate Volatility aspect analysis
   */
  generateVolatilityAnalysis(percentile) {
    const level = this.getPercentileRange(percentile);
    const descriptions = {
      "exceptionally_low": "You are exceptionally low in volatility. You have extraordinary emotional stability with very consistent moods and reactions.",
      "very_low": "You are very low in volatility. You have excellent emotional stability and your moods remain quite consistent over time.",
      "low": "You are low in volatility. You tend to have stable emotions and don't experience dramatic mood swings.",
      "moderately_low": "You are moderately low in volatility. Your emotions are generally stable with occasional fluctuations.",
      "typical": "You show typical levels of volatility. You experience normal emotional fluctuations and mood changes.",
      "moderately_high": "You are moderately high in volatility. You may experience more emotional ups and downs than average.",
      "high": "You are high in volatility. You tend to experience significant emotional fluctuations and mood changes.",
      "very_high": "You are very high in volatility. You experience frequent and intense emotional fluctuations that can be challenging to manage.",
      "exceptionally_high": "You are exceptionally high in volatility. You experience extreme emotional fluctuations that may significantly impact your daily functioning."
    };
    return {
      name: "Volatility",
      percentile,
      level,
      levelLabel: this.getLevelLabel(level),
      description: descriptions[level],
      characteristics: level === "exceptionally_low" || level === "very_low" ? ["Remarkably stable emotions", "Consistent mood", "Predictable reactions", "Even-tempered"] : ["Intense emotional experiences", "Frequent mood changes", "Emotionally reactive", "Variable emotional states"],
      advantages: level === "exceptionally_low" || level === "very_low" ? ["Excellent emotional regulation", "Reliable and predictable", "Good in crisis situations", "Stable presence for others"] : ["Rich emotional experiences", "Highly responsive to environment", "Passionate and intense", "Emotionally authentic"],
      challenges: level === "exceptionally_low" || level === "very_low" ? ["May appear emotionally distant", "Could miss emotional cues", "May not respond appropriately to emotional situations"] : ["Difficult emotional regulation", "May overwhelm others", "Inconsistent performance", "Relationship challenges due to mood swings"],
      relationshipStyle: level === "exceptionally_low" || level === "very_low" ? "You provide emotional stability in relationships, though partners may sometimes want more emotional intensity or expression from you." : "You bring emotional intensity to relationships, which can create passion but may also require partners who can handle emotional variability.",
      careerImplications: level === "exceptionally_low" || level === "very_low" ? "You excel in careers requiring emotional stability, consistent performance, and calm decision-making under pressure." : "You thrive in creative or dynamic careers where emotional intensity is valued, but may struggle in roles requiring consistent emotional regulation."
    };
  }
  /**
   * Generate complete detailed analysis for all Big 5 traits
   */
  generateDetailedAnalysis(aspectPercentiles) {
    return [
      this.generateOpennessAnalysis(
        aspectPercentiles["Intellect"] || 0,
        aspectPercentiles["Aesthetics"] || 0
      ),
      this.generateAgreeablenessAnalysis(
        aspectPercentiles["Compassion"] || 0,
        aspectPercentiles["Politeness"] || 0
      ),
      this.generateConscientiousnessAnalysis(
        aspectPercentiles["Industriousness"] || 0,
        aspectPercentiles["Orderliness"] || 0
      ),
      this.generateExtraversionAnalysis(
        aspectPercentiles["Enthusiasm"] || 0,
        aspectPercentiles["Assertiveness"] || 0
      ),
      this.generateNeuroticismAnalysis(
        aspectPercentiles["Withdrawal"] || 0,
        aspectPercentiles["Volatility"] || 0
      )
    ];
  }
};
var personalityDescriptionsService = new PersonalityDescriptionsService();

// server/kwame-api.ts
init_storage();
init_db();
init_schema();
import { WebSocket as WebSocket2 } from "ws";
import { eq as eq3 } from "drizzle-orm";
var connectedUsers3 = /* @__PURE__ */ new Map();
function setKwameWebSocketConnections(connections) {
  connectedUsers3 = connections;
}
var KwameRateLimiter = class {
  limits = /* @__PURE__ */ new Map();
  FREE_TIER_LIMIT = 20;
  // 20 requests per hour
  PREMIUM_TIER_LIMIT = 100;
  // 100 requests per hour
  WINDOW_MS = 60 * 60 * 1e3;
  // 1 hour
  canMakeRequest(userId, isPremium = false) {
    const now = Date.now();
    const limit = isPremium ? this.PREMIUM_TIER_LIMIT : this.FREE_TIER_LIMIT;
    const userLimit = this.limits.get(userId);
    if (!userLimit || now > userLimit.resetTime) {
      this.limits.set(userId, {
        userId,
        requests: 1,
        resetTime: now + this.WINDOW_MS
      });
      return true;
    }
    if (userLimit.requests >= limit) {
      return false;
    }
    userLimit.requests++;
    return true;
  }
  getRemainingRequests(userId, isPremium = false) {
    const limit = isPremium ? this.PREMIUM_TIER_LIMIT : this.FREE_TIER_LIMIT;
    const userLimit = this.limits.get(userId);
    if (!userLimit || Date.now() > userLimit.resetTime) {
      return limit;
    }
    return Math.max(0, limit - userLimit.requests);
  }
  getResetTime(userId) {
    const userLimit = this.limits.get(userId);
    return userLimit?.resetTime || Date.now() + this.WINDOW_MS;
  }
};
var rateLimiter = new KwameRateLimiter();
var ConversationStore = class {
  conversations = /* @__PURE__ */ new Map();
  MAX_HISTORY_AGE = 24 * 60 * 60 * 1e3;
  // 24 hours
  MAX_MESSAGES_PER_USER = 50;
  addMessage(userId, role, content, context) {
    let conversation = this.conversations.get(userId);
    if (!conversation) {
      conversation = {
        userId,
        messages: [],
        lastActivity: /* @__PURE__ */ new Date()
      };
      this.conversations.set(userId, conversation);
    }
    conversation.messages.push({
      role,
      content,
      timestamp: /* @__PURE__ */ new Date(),
      context
    });
    if (conversation.messages.length > this.MAX_MESSAGES_PER_USER) {
      conversation.messages = conversation.messages.slice(
        -this.MAX_MESSAGES_PER_USER
      );
    }
    conversation.lastActivity = /* @__PURE__ */ new Date();
  }
  getHistory(userId) {
    const conversation = this.conversations.get(userId);
    if (!conversation) {
      return [];
    }
    const now = Date.now();
    if (now - conversation.lastActivity.getTime() > this.MAX_HISTORY_AGE) {
      this.conversations.delete(userId);
      return [];
    }
    return conversation.messages;
  }
  clearHistory(userId) {
    this.conversations.delete(userId);
  }
};
var conversationStore = new ConversationStore();
async function buildCulturalContext(userId) {
  try {
    console.log(
      `[KWAME-API] \u{1F50D} DEBUG: Fetching user data for userId: ${userId}`
    );
    const [user, preferences, networkingProfile, mentorshipProfile] = await Promise.all([
      storage.getUser(userId),
      storage.getUserPreferences(userId),
      storage.getSuiteNetworkingProfile(userId),
      storage.getSuiteMentorshipProfile(userId)
    ]);
    console.log(`[KWAME-API] \u{1F50D} DEBUG: Database results:`, {
      userFound: !!user,
      userKeys: user ? Object.keys(user) : [],
      userName: user?.fullName,
      userAge: user?.dateOfBirth,
      userNationality: user?.countryOfOrigin,
      preferencesFound: !!preferences,
      networkingProfileFound: !!networkingProfile,
      mentorshipProfileFound: !!mentorshipProfile
    });
    if (!user) {
      console.log(
        `[KWAME-API] \u26A0\uFE0F WARNING: No user found for userId: ${userId}`
      );
      return null;
    }
    const age = user.dateOfBirth ? (/* @__PURE__ */ new Date()).getFullYear() - new Date(user.dateOfBirth).getFullYear() : null;
    let location = "Both";
    let ageGroup = "26-35";
    if (age) {
      if (age >= 18 && age <= 25) ageGroup = "18-25";
      else if (age >= 26 && age <= 35) ageGroup = "26-35";
      else if (age >= 36) ageGroup = "35+";
    }
    const result = {
      location,
      ageGroup,
      userProfile: user,
      userPreferences: preferences,
      networkingProfile,
      mentorshipProfile,
      nationality: user.countryOfOrigin || null,
      hasNationality: !!user.countryOfOrigin,
      needsCountryInfo: !user.countryOfOrigin
    };
    console.log(`[KWAME-API] \u{1F50D} DEBUG: Built cultural context:`, {
      hasUserProfile: !!result.userProfile,
      hasUserPreferences: !!result.userPreferences,
      hasNetworkingProfile: !!result.networkingProfile,
      hasMentorshipProfile: !!result.mentorshipProfile,
      calculatedAge: age,
      nationality: result.nationality,
      needsCountryInfo: result.needsCountryInfo,
      location: result.location
    });
    return result;
  } catch (error) {
    console.error(
      `[KWAME-API] \u274C ERROR: Failed to build cultural context for userId ${userId}:`,
      error
    );
    return null;
  }
}
function registerKwameAPI(app2) {
  console.log("[KWAME-API] Registering KWAME AI routes...");
  app2.post("/api/kwame/chat", async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({
          error: "Authentication required",
          code: "NOT_AUTHENTICATED"
        });
      }
      const userId = req.user?.id;
      const { message, context, appMode } = req.body;
      console.log(`[KWAME-API] Chat request from user ${userId}`);
      if (!message || typeof message !== "string" || message.trim().length === 0) {
        return res.status(400).json({
          error: "Message is required and cannot be empty",
          code: "INVALID_MESSAGE"
        });
      }
      const isImageMessage = message.startsWith("_!_IMAGE_!_");
      const maxLength = isImageMessage ? 10 * 1024 * 1024 * 1024 : 2e3;
      if (message.length > maxLength) {
        return res.status(400).json({
          error: isImageMessage ? "Image too large (max 10GB)" : "Message too long (max 2000 characters)",
          code: "MESSAGE_TOO_LONG"
        });
      }
      const normalized = message.toLowerCase();
      const wantsPrimaryPhoto = /\b(send|show)\b.*\b(my)\b.*\b(primary\s+photo|profile\s+photo|picture|dp)\b/.test(
        normalized
      );
      if (wantsPrimaryPhoto) {
        try {
          const section = (appMode || "MEET").toLowerCase() === "meet" ? "meet" : "meet";
          let photoUrl = null;
          const primary = await storage.getSectionPrimaryPhoto(userId, section);
          if (primary?.photoUrl) photoUrl = primary.photoUrl;
          if (!photoUrl) {
            const me = await storage.getUser(userId);
            photoUrl = me?.photoUrl || null;
          }
          if (!photoUrl) {
            return res.status(404).json({
              error: "No primary photo found",
              code: "NO_PRIMARY_PHOTO"
            });
          }
          const kwameResponse2 = {
            message: `_!_IMAGE_!_${photoUrl}`
          };
          await storage.createKwameConversation({
            userId,
            role: "user",
            content: message.trim(),
            context: context?.currentScreen ? JSON.stringify(context) : null,
            appMode: appMode || "MEET"
          });
          const assistantConversation2 = await storage.createKwameConversation({
            userId,
            role: "assistant",
            content: kwameResponse2.message,
            context: null,
            appMode: appMode || "MEET"
          });
          const userSocket2 = connectedUsers3.get(userId);
          if (userSocket2 && userSocket2.readyState === WebSocket2.OPEN) {
            try {
              userSocket2.send(
                JSON.stringify({
                  type: "new_message",
                  message: {
                    id: assistantConversation2.id,
                    matchId: -1,
                    senderId: -1,
                    receiverId: userId,
                    content: kwameResponse2.message,
                    createdAt: assistantConversation2.createdAt?.toISOString() || (/* @__PURE__ */ new Date()).toISOString(),
                    messageType: "text"
                  },
                  for: "recipient",
                  timestamp: (/* @__PURE__ */ new Date()).toISOString()
                })
              );
            } catch {
            }
          }
          return res.json(kwameResponse2);
        } catch (err) {
          console.error("[KWAME-API] Primary photo command failed:", err);
          return res.status(500).json({ error: "Failed to retrieve primary photo" });
        }
      }
      const lower = message.toLowerCase();
      const avatarStyleMatch = message.match(/(create|generate|make|draw|design|turn)[^\n]{0,80}(anime|cartoon|manga|pixar|disney|comic|illustration)[^\n]{0,80}(avatar|image|photo|picture)/i) || message.match(/(anime|cartoon|manga|pixar|disney|comic|illustration)[^\n]{0,80}(avatar|image|photo|picture)[^\n]{0,80}(of me|for me)/i) || message.match(/create.*(anime|cartoon|manga|pixar|disney|comic|illustration).*avatar.*me/i);
      const wantsStylizedAvatar = !!avatarStyleMatch;
      const requestedStyle = avatarStyleMatch ? avatarStyleMatch[2]?.toLowerCase() || avatarStyleMatch[1]?.toLowerCase() : null;
      const wantsImageEdit = /(edit|change|update|transform|improve|enhance|styl(?:e|ize)|turn)[^\n]{0,80}\b(my|the|this)\b[^\n]{0,80}\b(photo|picture|image|avatar|primary\s+photo)\b/i.test(
        lower
      );
      let wantsImageGenerate = /(create|generate|make|draw|design)[^\n]{0,80}\b(image|picture|photo|avatar|logo|banner|poster)\b/i.test(
        lower
      );
      const animeAvatarSignal = /(anime|cartoon|pixar|comic)/.test(lower) && /(avatar|image|photo|picture)/.test(lower);
      const forceImageGenerate = /^\s*(create|generate|make|turn)[^\n]{0,80}(anime|cartoon|pixar|manga)[^\n]{0,80}(avatar|image|photo|picture)/i.test(
        message
      );
      if (animeAvatarSignal) wantsImageGenerate = true;
      const wantsAnyImageAction = /(avatar|image|photo|picture)/.test(lower) && /(create|generate|make|draw|design|turn|transform|styl|style|edit|change|update|improve|enhance)/.test(
        lower
      );
      console.log("[KWAME-API] \u{1F4E5} Incoming message (trimmed):", message.trim());
      if (/(avatar|image|photo|picture)/.test(lower)) {
        console.log("[KWAME-API] \u{1F50E} Image keywords present", { lower });
      }
      if (wantsStylizedAvatar) {
        console.log("[KWAME-API] \u{1F3A8} Stylized avatar request detected:", message, "Style:", requestedStyle);
        try {
          const dbConversationHistory2 = await storage.getRecentKwameContext(
            userId,
            20
          );
          const conversationHistory2 = dbConversationHistory2.map((conv) => ({
            role: conv.role,
            content: conv.content,
            timestamp: conv.createdAt,
            context: conv.context || void 0
          }));
          let sourceImage = null;
          for (let i = conversationHistory2.length - 1; i >= 0; i--) {
            const c = conversationHistory2[i]?.content;
            if (typeof c === "string" && c.startsWith("_!_IMAGE_!_")) {
              sourceImage = c.substring("_!_IMAGE_!_".length);
              break;
            }
          }
          if (!sourceImage) {
            const primary = await storage.getSectionPrimaryPhoto(
              userId,
              (appMode || "MEET").toLowerCase()
            );
            sourceImage = primary?.photoUrl || (await storage.getUser(userId))?.photoUrl || null;
          }
          const dataUrl = await kwameAI.generateStylizedAvatar(sourceImage || void 0, requestedStyle || "anime");
          const photoMessage = `_!_IMAGE_!_${dataUrl}`;
          await storage.createKwameConversation({
            userId,
            role: "user",
            content: message.trim(),
            context: context?.currentScreen ? JSON.stringify(context) : null,
            appMode: appMode || "MEET"
          });
          const assistantConversation2 = await storage.createKwameConversation({
            userId,
            role: "assistant",
            content: photoMessage,
            context: null,
            appMode: appMode || "MEET"
          });
          const userSocket2 = connectedUsers3.get(userId);
          if (userSocket2 && userSocket2.readyState === WebSocket2.OPEN) {
            try {
              userSocket2.send(
                JSON.stringify({
                  type: "new_message",
                  message: {
                    id: assistantConversation2.id,
                    matchId: -1,
                    senderId: -1,
                    receiverId: userId,
                    content: photoMessage,
                    createdAt: assistantConversation2.createdAt?.toISOString() || (/* @__PURE__ */ new Date()).toISOString(),
                    messageType: "text"
                  },
                  for: "recipient",
                  timestamp: (/* @__PURE__ */ new Date()).toISOString()
                })
              );
            } catch {
            }
          }
          return res.json({ message: photoMessage });
        } catch (err) {
          console.error("[KWAME-API] Anime avatar generation failed:", err);
        }
      }
      if (wantsImageEdit || wantsImageGenerate || wantsAnyImageAction || forceImageGenerate) {
        console.log("[KWAME-API] \u{1F5BC}\uFE0F Image intent detected", {
          wantsImageEdit,
          wantsImageGenerate,
          wantsAnyImageAction,
          animeAvatarSignal,
          forceImageGenerate,
          wantsStylizedAvatar,
          requestedStyle,
          message
        });
        try {
          const dbConversationHistory2 = await storage.getRecentKwameContext(
            userId,
            20
          );
          const conversationHistory2 = dbConversationHistory2.map((conv) => ({
            role: conv.role,
            content: conv.content,
            timestamp: conv.createdAt,
            context: conv.context || void 0
          }));
          const styleMatch = message.match(/(?:to|into|in|as)\s+(.+)$/i);
          let styleInstruction = styleMatch ? styleMatch[1].trim() : "tasteful high-quality portrait";
          if (animeAvatarSignal && !/anime|cartoon|manga/i.test(styleInstruction)) {
            styleInstruction = `anime-style portrait, clean line art, soft cel-shading, expressive eyes, preserve identity. ${styleInstruction}`;
          }
          let sourceImage = null;
          for (let i = conversationHistory2.length - 1; i >= 0; i--) {
            const c = conversationHistory2[i]?.content;
            if (typeof c === "string" && c.startsWith("_!_IMAGE_!_")) {
              sourceImage = c.substring("_!_IMAGE_!_".length);
              break;
            }
          }
          if (!sourceImage) {
            const primary = await storage.getSectionPrimaryPhoto(
              userId,
              (appMode || "MEET").toLowerCase()
            );
            sourceImage = primary?.photoUrl || (await storage.getUser(userId))?.photoUrl || null;
          }
          let dataUrl;
          if ((wantsImageEdit || /avatar|photo|picture|image/.test(lower)) && sourceImage) {
            dataUrl = await kwameAI.generatePixarStyleImage(
              sourceImage,
              styleInstruction
            );
          } else {
            const prompt = styleInstruction.includes("photo") ? styleInstruction : `Generate ${styleInstruction}`;
            dataUrl = await kwameAI.generateImageFromPrompt(prompt);
          }
          const photoMessage = `_!_IMAGE_!_${dataUrl}`;
          await storage.createKwameConversation({
            userId,
            role: "user",
            content: message.trim(),
            context: context?.currentScreen ? JSON.stringify(context) : null,
            appMode: appMode || "MEET"
          });
          const assistantConversation2 = await storage.createKwameConversation({
            userId,
            role: "assistant",
            content: photoMessage,
            context: null,
            appMode: appMode || "MEET"
          });
          const userSocket2 = connectedUsers3.get(userId);
          if (userSocket2 && userSocket2.readyState === WebSocket2.OPEN) {
            try {
              userSocket2.send(
                JSON.stringify({
                  type: "new_message",
                  message: {
                    id: assistantConversation2.id,
                    matchId: -1,
                    senderId: -1,
                    receiverId: userId,
                    content: photoMessage,
                    createdAt: assistantConversation2.createdAt?.toISOString() || (/* @__PURE__ */ new Date()).toISOString(),
                    messageType: "text"
                  },
                  for: "recipient",
                  timestamp: (/* @__PURE__ */ new Date()).toISOString()
                })
              );
            } catch {
            }
          }
          return res.json({ message: photoMessage });
        } catch (err) {
          console.error("[KWAME-API] Image intent handling failed:", err);
        }
      }
      const user = await storage.getUser(userId);
      const isPremium = user?.premiumAccess || false;
      if (!rateLimiter.canMakeRequest(userId, isPremium)) {
        const remaining = rateLimiter.getRemainingRequests(userId, isPremium);
        const resetTime = rateLimiter.getResetTime(userId);
        return res.status(429).json({
          error: "Rate limit exceeded. Please try again later.",
          code: "RATE_LIMIT_EXCEEDED",
          remaining,
          resetTime,
          upgradeMessage: isPremium ? null : "Upgrade to Premium for more AI conversations!"
        });
      }
      const culturalContext = await buildCulturalContext(userId);
      console.log(
        `[KWAME-API] \u{1F50D} DEBUG: Cultural context for user ${userId}:`,
        {
          hasUserProfile: !!culturalContext?.userProfile,
          hasUserPreferences: !!culturalContext?.userPreferences,
          hasNetworkingProfile: !!culturalContext?.networkingProfile,
          userProfileKeys: culturalContext?.userProfile ? Object.keys(culturalContext.userProfile) : [],
          networkingProfileKeys: culturalContext?.networkingProfile ? Object.keys(culturalContext.networkingProfile) : [],
          userAge: culturalContext?.userProfile?.dateOfBirth ? Math.floor(
            (Date.now() - culturalContext.userProfile.dateOfBirth.getTime()) / (365.25 * 24 * 60 * 60 * 1e3)
          ) : null,
          userName: culturalContext?.userProfile?.fullName,
          userLocation: culturalContext?.userProfile?.location,
          userProfessionalTagline: culturalContext?.networkingProfile?.professionalTagline,
          userIndustry: culturalContext?.networkingProfile?.industry
        }
      );
      const dbConversationHistory = await storage.getRecentKwameContext(
        userId,
        20
      );
      const conversationHistory = dbConversationHistory.map((conv) => ({
        role: conv.role,
        content: conv.content,
        timestamp: conv.createdAt,
        context: conv.context || void 0
      }));
      const kwameRequest = {
        userId,
        message: message.trim(),
        context: {
          ...context,
          culturalContext: culturalContext ? {
            location: culturalContext.location,
            ethnicity: culturalContext.ethnicity,
            ageGroup: culturalContext.ageGroup
          } : null,
          // Include user profile, preferences, networking and mentorship profiles for personalized responses
          userProfile: culturalContext?.userProfile,
          userPreferences: culturalContext?.userPreferences,
          networkingProfile: culturalContext?.networkingProfile,
          mentorshipProfile: culturalContext?.mentorshipProfile
        },
        conversationHistory,
        appMode: appMode || "MEET"
      };
      console.log(
        `[KWAME-API] \u{1F50D} DEBUG: Final context being sent to KWAME AI:`,
        {
          hasUserProfile: !!kwameRequest.context?.userProfile,
          hasUserPreferences: !!kwameRequest.context?.userPreferences,
          hasNetworkingProfile: !!kwameRequest.context?.networkingProfile,
          hasMentorshipProfile: !!kwameRequest.context?.mentorshipProfile,
          contextKeys: Object.keys(kwameRequest.context || {})
        }
      );
      const normalizedPixar = message.toLowerCase();
      const wantsPixar = /pixar|disney/.test(normalizedPixar) && /(transform|generate|styl(e|ize)|turn)/.test(normalizedPixar);
      const wantsAnime = /anime/.test(normalizedPixar) && /(transform|generate|styl(e|ize)|turn)/.test(normalizedPixar);
      const wantsHyper = /(hyper[- ]?realistic|photoreal(istic)?)/.test(normalizedPixar) && /(transform|generate|turn|styl(e|ize))/.test(normalizedPixar);
      if (wantsPixar) {
        try {
          let sourceImage = null;
          for (let i = conversationHistory.length - 1; i >= 0; i--) {
            const c = conversationHistory[i]?.content;
            if (typeof c === "string" && c.startsWith("_!_IMAGE_!_")) {
              sourceImage = c.substring("_!_IMAGE_!_".length);
              break;
            }
          }
          if (!sourceImage) {
            const primary = await storage.getSectionPrimaryPhoto(
              userId,
              (appMode || "MEET").toLowerCase()
            );
            sourceImage = primary?.photoUrl || (await storage.getUser(userId))?.photoUrl || null;
          }
          if (!sourceImage) {
            return res.status(400).json({ error: "No image available to transform" });
          }
          const generated = await kwameAI.generatePixarStyleImage(sourceImage);
          const photoMessage = `_!_IMAGE_!_${generated}`;
          await storage.createKwameConversation({
            userId,
            role: "user",
            content: message.trim(),
            context: context?.currentScreen ? JSON.stringify(context) : null,
            appMode: appMode || "MEET"
          });
          const assistantConversation2 = await storage.createKwameConversation({
            userId,
            role: "assistant",
            content: photoMessage,
            context: null,
            appMode: appMode || "MEET"
          });
          const userSocket2 = connectedUsers3.get(userId);
          if (userSocket2 && userSocket2.readyState === WebSocket2.OPEN) {
            try {
              userSocket2.send(
                JSON.stringify({
                  type: "new_message",
                  message: {
                    id: assistantConversation2.id,
                    matchId: -1,
                    senderId: -1,
                    receiverId: userId,
                    content: photoMessage,
                    createdAt: assistantConversation2.createdAt?.toISOString() || (/* @__PURE__ */ new Date()).toISOString(),
                    messageType: "text"
                  },
                  for: "recipient",
                  timestamp: (/* @__PURE__ */ new Date()).toISOString()
                })
              );
            } catch {
            }
          }
          return res.json({ message: photoMessage });
        } catch (err) {
          console.error("[KWAME-API] Pixar transform failed:", err);
          return res.status(500).json({ error: "Failed to generate Pixar-style image" });
        }
      }
      if (wantsAnime || wantsHyper) {
        try {
          let sourceImage = null;
          for (let i = conversationHistory.length - 1; i >= 0; i--) {
            const c = conversationHistory[i]?.content;
            if (typeof c === "string" && c.startsWith("_!_IMAGE_!_")) {
              sourceImage = c.substring("_!_IMAGE_!_".length);
              break;
            }
          }
          if (!sourceImage) {
            const primary = await storage.getSectionPrimaryPhoto(
              userId,
              (appMode || "MEET").toLowerCase()
            );
            sourceImage = primary?.photoUrl || (await storage.getUser(userId))?.photoUrl || null;
          }
          if (!sourceImage) {
            return res.status(400).json({ error: "No image available to transform" });
          }
          const stylePrompt = wantsAnime ? "Transform this photo into a high-quality anime illustration while preserving recognizable facial features, hairstyle, and outfit colors. Use clean line art, soft cel-shading, expressive eyes, and a tasteful, softly blurred anime background." : "Transform this photo into a hyper-realistic portrait that preserves facial identity and outfit, with cinematic lighting, detailed textures, and shallow depth-of-field. Keep it tasteful and friendly.";
          const generated = await kwameAI.generatePixarStyleImage(
            sourceImage,
            stylePrompt
          );
          const photoMessage = `_!_IMAGE_!_${generated}`;
          await storage.createKwameConversation({
            userId,
            role: "user",
            content: message.trim(),
            context: context?.currentScreen ? JSON.stringify(context) : null,
            appMode: appMode || "MEET"
          });
          const assistantConversation2 = await storage.createKwameConversation({
            userId,
            role: "assistant",
            content: photoMessage,
            context: null,
            appMode: appMode || "MEET"
          });
          const userSocket2 = connectedUsers3.get(userId);
          if (userSocket2 && userSocket2.readyState === WebSocket2.OPEN) {
            try {
              userSocket2.send(
                JSON.stringify({
                  type: "new_message",
                  message: {
                    id: assistantConversation2.id,
                    matchId: -1,
                    senderId: -1,
                    receiverId: userId,
                    content: photoMessage,
                    createdAt: assistantConversation2.createdAt?.toISOString() || (/* @__PURE__ */ new Date()).toISOString(),
                    messageType: "text"
                  },
                  for: "recipient",
                  timestamp: (/* @__PURE__ */ new Date()).toISOString()
                })
              );
            } catch {
            }
          }
          return res.json({ message: photoMessage });
        } catch (err) {
          console.error("[KWAME-API] Alt style transform failed:", err);
          return res.status(500).json({ error: "Failed to generate stylized image" });
        }
      }
      if (isImageMessage) {
        console.log(`[KWAME-API] \u26A0\uFE0F  IMAGE UPLOAD DETECTED for user ${userId}`);
        console.log(`[KWAME-API] \u26A0\uFE0F  Message length: ${message.length}`);
        console.log(
          `[KWAME-API] \u26A0\uFE0F  Message starts with marker: ${message.startsWith("_!_IMAGE_!_")}`
        );
        const imageMarker = "_!_IMAGE_!_";
        const isPureImageUpload = message.startsWith(imageMarker) && message.length > imageMarker.length;
        if (isPureImageUpload) {
          console.log(
            `[KWAME-API] \u2705 PURE IMAGE UPLOAD - SKIPPING AI ANALYSIS (${message.length} chars)`
          );
          const userConversation2 = await storage.createKwameConversation({
            userId,
            role: "user",
            content: message.trim(),
            context: context?.currentScreen ? JSON.stringify(context) : null,
            appMode: appMode || "MEET"
          });
          console.log(
            `[KWAME-API] Image message stored with ID: ${userConversation2.id}`
          );
          return res.json({
            message: "Image received",
            imageStored: true,
            rateLimitInfo: {
              remaining: rateLimiter.getRemainingRequests(userId, isPremium),
              resetTime: rateLimiter.getResetTime(userId),
              isPremium
            }
          });
        } else {
          console.log(
            `[KWAME-API] Image upload with text/request detected, proceeding with AI analysis`
          );
        }
      }
      console.log(`[KWAME-API] Getting AI response for user ${userId}`);
      const kwameResponse = await kwameAI.chat(kwameRequest);
      console.log(`[KWAME-API] AI response received for user ${userId}`);
      console.log(`[KWAME-API] Storing user message for user ${userId}`);
      const userConversation = await storage.createKwameConversation({
        userId,
        role: "user",
        content: message.trim(),
        context: context?.currentScreen ? JSON.stringify(context) : null,
        appMode: appMode || "MEET"
      });
      console.log(
        `[KWAME-API] User message stored with ID: ${userConversation.id}`
      );
      console.log(`[KWAME-API] Storing assistant message for user ${userId}`);
      const assistantConversation = await storage.createKwameConversation({
        userId,
        role: "assistant",
        content: kwameResponse.message,
        context: null,
        appMode: appMode || "MEET"
      });
      console.log(
        `[KWAME-API] Assistant message stored with ID: ${assistantConversation.id}`
      );
      conversationStore.addMessage(userId, "user", message.trim());
      conversationStore.addMessage(userId, "assistant", kwameResponse.message);
      const userSocket = connectedUsers3.get(userId);
      if (userSocket && userSocket.readyState === WebSocket2.OPEN) {
        try {
          userSocket.send(
            JSON.stringify({
              type: "new_message",
              message: {
                id: assistantConversation.id,
                matchId: -1,
                // Special ID for KWAME AI
                senderId: -1,
                // KWAME AI sender ID
                receiverId: userId,
                content: kwameResponse.message,
                createdAt: assistantConversation.createdAt?.toISOString() || (/* @__PURE__ */ new Date()).toISOString(),
                messageType: "text"
              },
              for: "recipient",
              timestamp: (/* @__PURE__ */ new Date()).toISOString()
            })
          );
          console.log(
            `[KWAME-API] \u2705 Real-time notification sent to user ${userId}`
          );
        } catch (wsError) {
          console.error(
            `[KWAME-API] Failed to send WebSocket notification to user ${userId}:`,
            wsError
          );
        }
      } else {
        console.log(
          `[KWAME-API] \u26A0\uFE0F User ${userId} not connected via WebSocket`
        );
      }
      res.json({
        ...kwameResponse,
        rateLimitInfo: {
          remaining: rateLimiter.getRemainingRequests(userId, isPremium),
          resetTime: rateLimiter.getResetTime(userId),
          isPremium
        }
      });
    } catch (error) {
      console.error("[KWAME-API] Chat error:", error);
      res.status(500).json({
        error: "Internal server error",
        message: "KWAME is having trouble right now. Please try again in a moment.",
        code: "INTERNAL_ERROR"
      });
    }
  });
  app2.post(
    "/api/kwame/generate-avatar",
    async (req, res) => {
      try {
        if (!req.isAuthenticated() || !req.user?.id) {
          return res.status(401).json({ message: "Unauthorized" });
        }
        const userId = req.user.id;
        const section = (req.body?.section || "meet").toString();
        const primary = await storage.getSectionPrimaryPhoto(userId, section);
        let source = primary?.photoUrl || null;
        if (!source) {
          const me = await storage.getUser(userId);
          source = me?.photoUrl || null;
        }
        if (!source) {
          return res.status(400).json({ message: "No primary photo available to generate avatar" });
        }
        const dataUrl = await kwameAI.generatePixarStyleImage(source);
        await db.update(users).set({
          avatarPhoto: dataUrl,
          showAvatar: true,
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq3(users.id, userId));
        res.json({ success: true, avatarPhoto: dataUrl });
      } catch (err) {
        console.error("[KWAME-API][AVATAR]", err);
        res.status(500).json({ message: err?.message || "Failed to generate avatar" });
      }
    }
  );
  app2.delete("/api/user/avatar", async (req, res) => {
    try {
      if (!req.isAuthenticated() || !req.user?.id) {
        console.log("[KWAME-API][AVATAR-DELETE] Unauthorized request");
        return res.status(401).json({ message: "Unauthorized" });
      }
      const userId = req.user.id;
      console.log(
        `[KWAME-API][AVATAR-DELETE] Deleting avatar for user ${userId}`
      );
      const userBefore = await db.select().from(users).where(eq3(users.id, userId)).limit(1);
      console.log(
        `[KWAME-API][AVATAR-DELETE] User before update: avatarPhoto=${userBefore[0]?.avatarPhoto}, showAvatar=${userBefore[0]?.showAvatar}`
      );
      const result = await db.update(users).set({
        avatarPhoto: null,
        showAvatar: false,
        updatedAt: /* @__PURE__ */ new Date()
      }).where(eq3(users.id, userId));
      const userAfter = await db.select().from(users).where(eq3(users.id, userId)).limit(1);
      console.log(
        `[KWAME-API][AVATAR-DELETE] User after update: avatarPhoto=${userAfter[0]?.avatarPhoto}, showAvatar=${userAfter[0]?.showAvatar}`
      );
      console.log(
        `[KWAME-API][AVATAR-DELETE] Successfully deleted avatar for user ${userId}`
      );
      res.json({ success: true });
    } catch (err) {
      console.error("[KWAME-API][AVATAR-DELETE] Error:", err);
      res.status(500).json({ message: err?.message || "Failed to delete avatar" });
    }
  });
  app2.post("/api/kwame/suggestions", async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({
          error: "Authentication required",
          code: "NOT_AUTHENTICATED"
        });
      }
      const userId = req.user?.id;
      const { context, appMode, scenario } = req.body;
      console.log(`[KWAME-API] Suggestions request from user ${userId}`);
      const culturalContext = await buildCulturalContext(userId);
      const kwameRequest = {
        userId,
        message: scenario || "Give me some conversation suggestions",
        context: {
          ...context,
          culturalContext: culturalContext ? {
            location: culturalContext.location,
            ethnicity: culturalContext.ethnicity,
            ageGroup: culturalContext.ageGroup
          } : null,
          // Include user profile and preferences for personalized suggestions
          userProfile: culturalContext?.userProfile,
          userPreferences: culturalContext?.userPreferences
        },
        appMode: appMode || "MEET"
      };
      const suggestions = await kwameAI.getSuggestions(kwameRequest);
      res.json({
        suggestions,
        context: kwameRequest.context
      });
    } catch (error) {
      console.error("[KWAME-API] Suggestions error:", error);
      res.status(500).json({
        error: "Failed to get suggestions",
        suggestions: [
          "Ask about their interests",
          "Share something about yourself",
          "Be genuine and authentic"
        ]
      });
    }
  });
  app2.post(
    "/api/kwame/analyze-profile",
    async (req, res) => {
      try {
        if (!req.isAuthenticated()) {
          return res.status(401).json({
            error: "Authentication required",
            code: "NOT_AUTHENTICATED"
          });
        }
        const userId = req.user?.id;
        console.log(`[KWAME-API] Profile analysis request from user ${userId}`);
        const [user, preferences] = await Promise.all([
          storage.getUser(userId),
          storage.getUserPreferences(userId)
        ]);
        if (!user) {
          return res.status(404).json({
            error: "User not found",
            code: "USER_NOT_FOUND"
          });
        }
        const isPremium = user.premiumAccess || false;
        if (!rateLimiter.canMakeRequest(userId, isPremium)) {
          return res.status(429).json({
            error: "Rate limit exceeded for profile analysis",
            code: "RATE_LIMIT_EXCEEDED"
          });
        }
        const analysis = await kwameAI.analyzeProfile(
          user,
          preferences || void 0
        );
        res.json({
          ...analysis,
          rateLimitInfo: {
            remaining: rateLimiter.getRemainingRequests(userId, isPremium),
            resetTime: rateLimiter.getResetTime(userId),
            isPremium
          }
        });
      } catch (error) {
        console.error("[KWAME-API] Profile analysis error:", error);
        res.status(500).json({
          error: "Failed to analyze profile",
          message: "KWAME cannot analyze your profile right now. Please try again later.",
          code: "ANALYSIS_ERROR"
        });
      }
    }
  );
  app2.get(
    "/api/kwame/conversation-history",
    async (req, res) => {
      try {
        if (!req.isAuthenticated()) {
          return res.status(401).json({
            error: "Authentication required",
            code: "NOT_AUTHENTICATED"
          });
        }
        const userId = req.user?.id;
        const limit = parseInt(req.query.limit) || 20;
        console.log(`[KWAME-API] History request from user ${userId}`);
        const dbHistory = await storage.getRecentKwameContext(userId, limit);
        const messages2 = dbHistory.map((conv) => ({
          role: conv.role,
          content: conv.content,
          timestamp: conv.createdAt?.toISOString() || (/* @__PURE__ */ new Date()).toISOString(),
          context: conv.context
        }));
        res.json({
          messages: messages2,
          total: messages2.length,
          hasMore: false
          // For now, assuming we get all available messages
        });
      } catch (error) {
        console.error("[KWAME-API] History error:", error);
        res.status(500).json({
          error: "Failed to get conversation history",
          messages: []
        });
      }
    }
  );
  app2.delete(
    "/api/kwame/conversation-history",
    async (req, res) => {
      try {
        if (!req.isAuthenticated()) {
          return res.status(401).json({
            error: "Authentication required",
            code: "NOT_AUTHENTICATED"
          });
        }
        const userId = req.user?.id;
        console.log(`[KWAME-API] Clear history request from user ${userId}`);
        conversationStore.clearHistory(userId);
        res.json({
          success: true,
          message: "Conversation history cleared"
        });
      } catch (error) {
        console.error("[KWAME-API] Clear history error:", error);
        res.status(500).json({
          error: "Failed to clear conversation history"
        });
      }
    }
  );
  app2.get("/api/kwame/status", async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({
          error: "Authentication required",
          code: "NOT_AUTHENTICATED"
        });
      }
      const userId = req.user?.id;
      const user = await storage.getUser(userId);
      const isPremium = user?.premiumAccess || false;
      res.json({
        status: "online",
        available: true,
        rateLimitInfo: {
          remaining: rateLimiter.getRemainingRequests(userId, isPremium),
          resetTime: rateLimiter.getResetTime(userId),
          isPremium,
          limits: {
            free: rateLimiter["FREE_TIER_LIMIT"],
            premium: rateLimiter["PREMIUM_TIER_LIMIT"]
          }
        },
        features: {
          chat: true,
          suggestions: true,
          profileAnalysis: true,
          conversationHistory: true,
          culturalContext: true
        }
      });
    } catch (error) {
      console.error("[KWAME-API] Status error:", error);
      res.status(500).json({
        status: "error",
        available: false,
        error: "Service temporarily unavailable"
      });
    }
  });
  app2.post("/api/kwame/feedback", async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({
          error: "Authentication required",
          code: "NOT_AUTHENTICATED"
        });
      }
      const userId = req.user?.id;
      const { messageId, rating, feedback, responseType } = req.body;
      console.log(`[KWAME-API] Feedback from user ${userId}: ${rating}/5`);
      console.log(
        `[KWAME-FEEDBACK] User ${userId} rated response ${messageId}: ${rating}/5`
      );
      if (feedback) {
        console.log(`[KWAME-FEEDBACK] Comments: ${feedback}`);
      }
      res.json({
        success: true,
        message: "Thank you for your feedback! This helps KWAME improve."
      });
    } catch (error) {
      console.error("[KWAME-API] Feedback error:", error);
      res.status(500).json({
        error: "Failed to submit feedback"
      });
    }
  });
  app2.get("/api/kwame/history", async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({
          error: "Authentication required",
          code: "NOT_AUTHENTICATED"
        });
      }
      const userId = req.user?.id;
      const limit = parseInt(req.query.limit) || 500;
      console.log(`[KWAME-API] History request from user ${userId}`);
      const conversations = await storage.getKwameConversationHistory(
        userId,
        limit
      );
      res.json({
        conversations: conversations.map((conv) => ({
          id: conv.id,
          role: conv.role,
          content: conv.content,
          context: conv.context ? JSON.parse(conv.context) : null,
          appMode: conv.appMode,
          timestamp: conv.createdAt
        })),
        total: conversations.length
      });
    } catch (error) {
      console.error("[KWAME-API] History error:", error);
      res.status(500).json({
        error: "Failed to fetch conversation history"
      });
    }
  });
  app2.delete("/api/kwame/history", async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({
          error: "Authentication required",
          code: "NOT_AUTHENTICATED"
        });
      }
      const userId = req.user?.id;
      console.log(`[KWAME-API] Clear history request from user ${userId}`);
      await storage.clearKwameConversationHistory(userId);
      res.json({
        success: true,
        message: "Conversation history cleared successfully"
      });
    } catch (error) {
      console.error("[KWAME-API] Clear history error:", error);
      res.status(500).json({
        error: "Failed to clear conversation history"
      });
    }
  });
  app2.post("/api/kwame/update-country", async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({
          error: "Authentication required",
          code: "NOT_AUTHENTICATED"
        });
      }
      const userId = req.user?.id;
      const { country } = req.body;
      if (!country || typeof country !== "string") {
        return res.status(400).json({
          error: "Country is required and must be a string",
          code: "INVALID_COUNTRY"
        });
      }
      console.log(
        `[KWAME-API] Updating country for user ${userId} to: ${country}`
      );
      const updatedUser = await storage.updateUser(userId, {
        countryOfOrigin: country.trim()
      });
      if (!updatedUser) {
        return res.status(404).json({
          error: "User not found",
          code: "USER_NOT_FOUND"
        });
      }
      console.log(
        `[KWAME-API] \u2705 Successfully updated country for user ${userId}`
      );
      res.json({
        success: true,
        message: "Country updated successfully",
        country: country.trim()
      });
    } catch (error) {
      console.error("[KWAME-API] Update country error:", error);
      res.status(500).json({
        error: "Failed to update country",
        code: "UPDATE_FAILED"
      });
    }
  });
  app2.post(
    "/api/kwame/personalize-statement",
    async (req, res) => {
      try {
        if (!req.isAuthenticated()) {
          return res.status(401).json({
            error: "Authentication required",
            code: "NOT_AUTHENTICATED"
          });
        }
        const userId = req.user?.id;
        const { statement, index, languageCode } = req.body;
        if (!statement || typeof statement !== "string") {
          return res.status(400).json({
            error: "Statement is required",
            code: "INVALID_STATEMENT"
          });
        }
        const targetLanguage = languageCode || "en";
        const cleanStatement = statement.replace(/^["']|["']$/g, "").trim();
        console.log(
          `[KWAME-API] Personalizing statement for user ${userId} in language ${targetLanguage}: "${cleanStatement}"`
        );
        const culturalContext = await buildCulturalContext(userId);
        if (!culturalContext) {
          return res.json({ personalizedStatement: cleanStatement });
        }
        const languageInstructions = {
          en: "- Write the personalized statement in English",
          fr: "- Write the personalized statement in French (fran\xE7ais)",
          es: "- Write the personalized statement in Spanish (espa\xF1ol)",
          tw: "- Write the personalized statement in Twi (Akan language from Ghana)",
          ak: "- Write the personalized statement in Akan (Twi language from Ghana)"
        };
        const languageInstruction = languageInstructions[targetLanguage] || languageInstructions["en"];
        const contextLines = [
          culturalContext.userProfile?.profession && `Profession: ${culturalContext.userProfile.profession}`,
          culturalContext.userProfile?.location && `Location: ${culturalContext.userProfile.location}`,
          culturalContext.nationality && `Culture: ${culturalContext.nationality}`
        ].filter(Boolean).join(", ");
        const personalizationRequest = {
          userId,
          message: `Rephrase this personality statement for a ${culturalContext.nationality || "global"} user: "${cleanStatement}"

Make it:
- Personal using "you"
- Statement (not question) for agree/disagree response
- Natural and conversational
${languageInstruction}
${contextLines ? `Context: ${contextLines}` : ""}

Return only the rephrased statement.`,
          context: {
            currentScreen: "personality-test",
            culturalContext,
            userProfile: culturalContext.userProfile,
            userPreferences: culturalContext.userPreferences,
            networkingProfile: culturalContext.networkingProfile,
            mentorshipProfile: culturalContext.mentorshipProfile
          },
          appMode: "MEET"
        };
        const response = await kwameAI.chat(personalizationRequest);
        res.json({
          personalizedStatement: response.message.trim(),
          originalStatement: cleanStatement
        });
      } catch (error) {
        console.error("[KWAME-API] Statement personalization error:", error);
        res.status(500).json({
          error: "Failed to personalize statement",
          code: "PERSONALIZATION_FAILED",
          // Fallback to original statement
          personalizedStatement: req.body.statement || "",
          originalStatement: req.body.statement || ""
        });
      }
    }
  );
  app2.get(
    "/api/kwame/personality/status",
    async (req, res) => {
      try {
        if (!req.isAuthenticated()) {
          return res.status(401).json({ message: "Unauthorized" });
        }
        const userId = req.user.id;
        const userRecord = await db.select().from(users).where(eq3(users.id, userId)).limit(1);
        if (userRecord.length === 0) {
          return res.status(404).json({ message: "User not found" });
        }
        const user = userRecord[0];
        const personalityRecords = user.personalityRecords ? JSON.parse(user.personalityRecords) : null;
        const big5Profile = user.big5Profile ? JSON.parse(user.big5Profile) : null;
        res.json({
          completed: user.personalityTestCompleted || false,
          progress: personalityRecords ? personalityRecords.length : 0,
          totalQuestions: 100,
          hasBig5Profile: !!big5Profile,
          big5ComputedAt: user.big5ComputedAt,
          personalityModelVersion: user.personalityModelVersion
        });
      } catch (error) {
        console.error("[KWAME-API] Personality status error:", error);
        res.status(500).json({ message: "Internal server error" });
      }
    }
  );
  app2.post(
    "/api/kwame/personality/start",
    async (req, res) => {
      try {
        if (!req.isAuthenticated()) {
          return res.status(401).json({ message: "Unauthorized" });
        }
        const userId = req.user.id;
        const userRecord = await db.select().from(users).where(eq3(users.id, userId)).limit(1);
        if (userRecord.length === 0) {
          return res.status(404).json({ message: "User not found" });
        }
        const user = userRecord[0];
        const personalityRecords = user.personalityRecords ? JSON.parse(user.personalityRecords) : [];
        const statements = big5_scoring_service_default.getStatements();
        res.json({
          currentProgress: personalityRecords.length,
          totalQuestions: statements.length,
          nextQuestion: personalityRecords.length < statements.length ? {
            index: personalityRecords.length,
            statement: statements[personalityRecords.length],
            options: [
              "StronglyDisagree",
              "Disagree",
              "Neutral",
              "Agree",
              "StronglyAgree"
            ]
          } : null,
          completed: personalityRecords.length >= statements.length
        });
      } catch (error) {
        console.error("[KWAME-API] Personality start error:", error);
        res.status(500).json({ message: "Internal server error" });
      }
    }
  );
  app2.post(
    "/api/kwame/personality/answer",
    async (req, res) => {
      try {
        if (!req.isAuthenticated()) {
          return res.status(401).json({ message: "Unauthorized" });
        }
        const { questionIndex, answer } = req.body;
        if (typeof questionIndex !== "number" || !answer || ![
          "StronglyDisagree",
          "Disagree",
          "Neutral",
          "Agree",
          "StronglyAgree"
        ].includes(answer)) {
          return res.status(400).json({ message: "Invalid question index or answer" });
        }
        const userId = req.user.id;
        const userRecord = await db.select().from(users).where(eq3(users.id, userId)).limit(1);
        if (userRecord.length === 0) {
          return res.status(404).json({ message: "User not found" });
        }
        const user = userRecord[0];
        const personalityRecords = user.personalityRecords ? JSON.parse(user.personalityRecords) : [];
        while (personalityRecords.length <= questionIndex) {
          personalityRecords.push(null);
        }
        personalityRecords[questionIndex] = answer;
        await db.update(users).set({
          personalityRecords: JSON.stringify(personalityRecords),
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq3(users.id, userId));
        const statements = big5_scoring_service_default.getStatements();
        const isCompleted = personalityRecords.filter((r) => r !== null).length >= statements.length;
        res.json({
          success: true,
          progress: personalityRecords.filter((r) => r !== null).length,
          totalQuestions: statements.length,
          completed: isCompleted,
          nextQuestion: !isCompleted && personalityRecords.length < statements.length ? {
            index: personalityRecords.length,
            statement: statements[personalityRecords.length],
            options: [
              "StronglyDisagree",
              "Disagree",
              "Neutral",
              "Agree",
              "StronglyAgree"
            ]
          } : null
        });
      } catch (error) {
        console.error("[KWAME-API] Personality answer error:", error);
        res.status(500).json({ message: "Internal server error" });
      }
    }
  );
  app2.post(
    "/api/kwame/personality/complete",
    async (req, res) => {
      try {
        if (!req.isAuthenticated()) {
          return res.status(401).json({ message: "Unauthorized" });
        }
        const userId = req.user.id;
        const userRecord = await db.select().from(users).where(eq3(users.id, userId)).limit(1);
        if (userRecord.length === 0) {
          return res.status(404).json({ message: "User not found" });
        }
        const user = userRecord[0];
        const personalityRecords = user.personalityRecords ? JSON.parse(user.personalityRecords) : [];
        if (personalityRecords.length !== 100 || personalityRecords.some((r) => !r)) {
          return res.status(400).json({
            message: "Incomplete personality assessment",
            progress: personalityRecords.filter((r) => r !== null).length,
            required: 100
          });
        }
        const validation = big5_scoring_service_default.validateResponses(
          personalityRecords
        );
        if (!validation.valid) {
          return res.status(400).json({
            message: "Invalid responses",
            errors: validation.errors
          });
        }
        const big5Profile = big5_scoring_service_default.generateBig5Profile(
          personalityRecords
        );
        await db.update(users).set({
          personalityTestCompleted: true,
          big5Profile: JSON.stringify(big5Profile),
          big5ComputedAt: /* @__PURE__ */ new Date(),
          personalityModelVersion: big5Profile.metadata.modelVersion,
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq3(users.id, userId));
        console.log(`[KWAME-API] Big 5 profile computed for user ${userId}`);
        res.json({
          success: true,
          message: "Personality assessment completed successfully",
          big5Profile
        });
      } catch (error) {
        console.error("[KWAME-API] Personality completion error:", error);
        res.status(500).json({ message: "Internal server error" });
      }
    }
  );
  app2.get(
    "/api/kwame/personality/results",
    async (req, res) => {
      try {
        if (!req.isAuthenticated()) {
          return res.status(401).json({ message: "Unauthorized" });
        }
        const userId = req.user.id;
        const userRecord = await db.select().from(users).where(eq3(users.id, userId)).limit(1);
        if (userRecord.length === 0) {
          return res.status(404).json({ message: "User not found" });
        }
        const user = userRecord[0];
        if (!user.personalityTestCompleted || !user.big5Profile) {
          return res.status(404).json({
            message: "Personality assessment not completed",
            completed: user.personalityTestCompleted || false
          });
        }
        const big5Profile = JSON.parse(user.big5Profile);
        res.json({
          big5Profile,
          computedAt: user.big5ComputedAt,
          modelVersion: user.personalityModelVersion
        });
      } catch (error) {
        console.error("[KWAME-API] Personality results error:", error);
        res.status(500).json({ message: "Internal server error" });
      }
    }
  );
  app2.get(
    "/api/kwame/personality/trait-analysis/:traitName",
    async (req, res) => {
      try {
        if (!req.isAuthenticated()) {
          return res.status(401).json({ message: "Unauthorized" });
        }
        const userId = req.user.id;
        const traitName = req.params.traitName;
        const validTraits = [
          "Openness",
          "Agreeableness",
          "Conscientiousness",
          "Extraversion",
          "Neuroticism"
        ];
        if (!validTraits.includes(traitName)) {
          return res.status(400).json({
            message: "Invalid trait name",
            validTraits
          });
        }
        const userRecord = await db.select().from(users).where(eq3(users.id, userId)).limit(1);
        if (userRecord.length === 0) {
          return res.status(404).json({ message: "User not found" });
        }
        const user = userRecord[0];
        if (!user.personalityTestCompleted || !user.big5Profile) {
          return res.status(404).json({
            message: "Personality assessment not completed",
            completed: user.personalityTestCompleted || false
          });
        }
        const big5Profile = JSON.parse(user.big5Profile);
        const detailedAnalyses = personalityDescriptionsService.generateDetailedAnalysis(
          big5Profile.aspectPercentiles
        );
        const traitAnalysis = detailedAnalyses.find(
          (analysis) => analysis.name === traitName
        );
        if (!traitAnalysis) {
          return res.status(404).json({ message: "Trait analysis not found" });
        }
        res.json({
          traitAnalysis,
          computedAt: user.big5ComputedAt,
          modelVersion: user.personalityModelVersion
        });
      } catch (error) {
        console.error("[KWAME-API] Trait analysis error:", error);
        res.status(500).json({ message: "Internal server error" });
      }
    }
  );
  console.log("[KWAME-API] \u2705 KWAME AI routes registered successfully");
}

// server/payment-confirm.ts
import Stripe from "stripe";
var stripeSecretKey = process.env.STRIPE_LIVE_SECRET_KEY || process.env.STRIPE_SECRET_KEY;
var isLiveMode = !!process.env.STRIPE_LIVE_SECRET_KEY;
var stripe = stripeSecretKey ? new Stripe(stripeSecretKey, {
  apiVersion: "2024-06-20"
}) : null;
if (stripe) {
  console.log(`[STRIPE-PAYMENT] Initialized in ${isLiveMode ? "LIVE" : "TEST"} mode`);
}
async function confirmPayment(req, res, storage2) {
  try {
    const { clientSecret, paymentDetails } = req.body;
    if (!stripe) {
      return res.status(500).json({
        success: false,
        error: "Payment processing not available"
      });
    }
    console.log("[STRIPE-BACKEND] Confirming payment with client secret:", clientSecret.substring(0, 30) + "...");
    const paymentIntentId = clientSecret.split("_secret_")[0];
    let paymentIntent = await stripe.paymentIntents.retrieve(paymentIntentId);
    console.log("[STRIPE-SECURITY] Payment intent current status:", paymentIntent.status);
    if (paymentIntent.status === "requires_confirmation" || paymentIntent.status === "requires_payment_method") {
      if (isLiveMode) {
        console.log("[STRIPE-SECURITY] Cannot confirm payment in live mode without real payment method");
        return res.status(400).json({
          success: false,
          error: "Payment confirmation requires a valid payment method in live mode. Please use the Stripe Elements form instead."
        });
      } else {
        console.log("[STRIPE-SECURITY] Confirming payment intent with test payment method");
        const testPaymentMethodId = "pm_card_visa";
        paymentIntent = await stripe.paymentIntents.confirm(paymentIntentId, {
          payment_method: testPaymentMethodId
        });
      }
    } else if (paymentIntent.status === "succeeded") {
      console.log("[STRIPE-SECURITY] Payment intent already succeeded, skipping confirmation");
    } else {
      console.log("[STRIPE-SECURITY] Payment intent in unexpected state:", paymentIntent.status);
    }
    console.log("[STRIPE-BACKEND] Payment confirmation result:", {
      id: paymentIntent.id,
      status: paymentIntent.status,
      amount: paymentIntent.amount,
      currency: paymentIntent.currency
    });
    if (paymentIntent.status === "succeeded") {
      const userId = req.user.id;
      await storage2.updateUser(userId, { premiumAccess: true });
      console.log("[STRIPE-BACKEND] Payment successful, premium access granted to user:", userId);
      res.json({
        success: true,
        paymentIntent: {
          id: paymentIntent.id,
          status: paymentIntent.status,
          amount: paymentIntent.amount,
          currency: paymentIntent.currency
        },
        error: null
      });
    } else {
      console.log("[STRIPE-BACKEND] Payment not successful, status:", paymentIntent.status);
      res.json({
        success: false,
        error: `Payment ${paymentIntent.status}`,
        paymentIntent: {
          id: paymentIntent.id,
          status: paymentIntent.status
        }
      });
    }
  } catch (error) {
    console.error("[STRIPE-BACKEND] Payment confirmation error:", error);
    res.status(500).json({
      success: false,
      error: error instanceof Error ? error.message : "Payment confirmation failed"
    });
  }
}

// server/routes.ts
init_schema();
init_db();
import { ZodError as ZodError2 } from "zod";
import { fromZodError as fromZodError2 } from "zod-validation-error";
import { randomBytes as randomBytes2 } from "crypto";
import Stripe2 from "stripe";

// server/cache-invalidation.ts
import WebSocket3 from "ws";
function broadcastCacheInvalidation(connectedUsers4, options) {
  const { matchId, userId, messageId, reason } = options;
  console.log(`[CACHE-INVALIDATION] Broadcasting cache clear for match ${matchId}, reason: ${reason}`);
  const cacheInvalidationMessage = {
    type: "cache:invalidate",
    action: "clear_message_cache",
    matchId,
    messageId,
    reason,
    timestamp: (/* @__PURE__ */ new Date()).toISOString(),
    clearTargets: [
      "react_query_cache",
      "local_storage",
      "session_storage",
      "persistent_cache"
    ]
  };
  connectedUsers4.forEach((socket, connectedUserId) => {
    if (socket && socket.readyState === WebSocket3.OPEN) {
      try {
        socket.send(JSON.stringify(cacheInvalidationMessage));
        console.log(`[CACHE-INVALIDATION] Sent cache clear to user ${connectedUserId}`);
      } catch (error) {
        console.error(`[CACHE-INVALIDATION] Failed to send to user ${connectedUserId}:`, error);
      }
    }
  });
}
function invalidateMessageCaches(connectedUsers4, options) {
  const { matchId, reason } = options;
  console.log(`[CACHE-INVALIDATION] Starting complete cache invalidation for match ${matchId}`);
  try {
    broadcastCacheInvalidation(connectedUsers4, options);
    console.log(`[CACHE-INVALIDATION] Complete cache invalidation initiated for match ${matchId}`);
    return {
      success: true,
      matchId,
      reason,
      timestamp: (/* @__PURE__ */ new Date()).toISOString()
    };
  } catch (error) {
    console.error(`[CACHE-INVALIDATION] Error during cache invalidation:`, error);
    return {
      success: false,
      matchId,
      reason,
      error: error instanceof Error ? error.message : "Unknown error",
      timestamp: (/* @__PURE__ */ new Date()).toISOString()
    };
  }
}

// server/routes.ts
init_sendgrid();

// server/services/security-notifications.ts
init_sendgrid();
import crypto from "crypto";
var disputeTokens = /* @__PURE__ */ new Map();
async function sendSecurityChangeNotification(notification) {
  try {
    const disputeToken = crypto.randomBytes(16).toString("hex");
    const disputeInfo = {
      ...notification,
      disputeToken,
      timestamp: /* @__PURE__ */ new Date()
    };
    disputeTokens.set(disputeToken, disputeInfo);
    const disputeUrl = `${process.env.REPLIT_DEV_DOMAIN || "https://your-domain.com"}/dispute?token=${disputeToken}`;
    const changeTypeText = getChangeTypeText(notification.changeType);
    const oldValueDisplay = getValueDisplay(notification.changeType, notification.oldValue);
    const newValueDisplay = getValueDisplay(notification.changeType, notification.newValue);
    const subject = `\u{1F512} Security Alert: Your ${changeTypeText} Has Been Changed`;
    const htmlContent = `
      <!DOCTYPE html>
      <html>
      <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Security Alert</title>
      </head>
      <body style="font-family: Arial, sans-serif; line-height: 1.6; color: #333; max-width: 600px; margin: 0 auto; padding: 20px;">
        <div style="background: #ff4444; color: white; padding: 20px; text-align: center; border-radius: 8px; margin-bottom: 20px;">
          <h1 style="margin: 0; font-size: 24px;">\u{1F512} Security Alert</h1>
          <p style="margin: 10px 0 0 0;">Account Change Detected</p>
        </div>
        
        <p>Hello <strong>${notification.fullName}</strong>,</p>
        
        <div style="background: #fff5f5; border: 1px solid #ffcccb; border-radius: 8px; padding: 15px; margin: 20px 0;">
          <h3 style="color: #e53e3e; margin-top: 0;">\u26A0\uFE0F Your ${changeTypeText.toLowerCase()} has been changed</h3>
          <p><strong>Time:</strong> ${(/* @__PURE__ */ new Date()).toLocaleString()}</p>
          ${notification.userAgent ? `<p><strong>Device:</strong> ${notification.userAgent}</p>` : ""}
          ${notification.ipAddress ? `<p><strong>IP Address:</strong> ${notification.ipAddress}</p>` : ""}
        </div>
        
        <div style="text-align: center; margin: 25px 0;">
          <p><strong>Did you make this change?</strong></p>
          <p>If <strong>NO</strong>, click below to dispute:</p>
          <a href="${disputeUrl}" style="background: #e53e3e; color: white; padding: 12px 24px; text-decoration: none; border-radius: 8px; font-weight: bold; display: inline-block;">
            \u{1F6A8} I Did NOT Make This Change
          </a>
        </div>
        
        <p style="font-size: 14px; color: #666; margin-top: 30px;">
          <strong>CHARLEY Security Team</strong><br>
          If you made this change, you can ignore this email.<br>
          Questions? Contact <a href="mailto:admin@kronogon.com">admin@kronogon.com</a>
        </p>
      </body>
      </html>
    `;
    const textContent = `
SECURITY ALERT - ${changeTypeText} Changed

Hello ${notification.fullName},

Your ${changeTypeText.toLowerCase()} was changed on ${(/* @__PURE__ */ new Date()).toLocaleString()}.

${notification.userAgent ? `Device: ${notification.userAgent}` : ""}
${notification.ipAddress ? `IP: ${notification.ipAddress}` : ""}

If you did NOT make this change, dispute immediately:
${disputeUrl}

Otherwise, ignore this email.

CHARLEY Security Team
admin@kronogon.com
    `;
    const success = await sendEmail(process.env.SENDGRID_API_KEY, {
      to: notification.email,
      from: "admin@kronogon.com",
      subject,
      text: textContent,
      html: htmlContent
    });
    if (success) {
      console.log(`[SECURITY-NOTIFICATION] Sent ${notification.changeType} change notification to ${notification.email}`);
    } else {
      console.error(`[SECURITY-NOTIFICATION] Failed to send ${notification.changeType} change notification to ${notification.email}`);
    }
    return success;
  } catch (error) {
    console.error("[SECURITY-NOTIFICATION] Error sending security notification:", error);
    return false;
  }
}
async function handleSecurityDispute(disputeToken, req) {
  try {
    const disputeInfo = disputeTokens.get(disputeToken);
    if (!disputeInfo) {
      console.log(`[SECURITY-DISPUTE] Invalid or expired dispute token: ${disputeToken}`);
      return false;
    }
    const tokenAge = Date.now() - disputeInfo.timestamp.getTime();
    const sevenDays = 7 * 24 * 60 * 60 * 1e3;
    if (tokenAge > sevenDays) {
      disputeTokens.delete(disputeToken);
      console.log(`[SECURITY-DISPUTE] Expired dispute token: ${disputeToken}`);
      return false;
    }
    const success = await sendDisputeAlertToAdmin(disputeInfo, req);
    if (success) {
      disputeTokens.delete(disputeToken);
      console.log(`[SECURITY-DISPUTE] Successfully processed dispute for user ${disputeInfo.userId}`);
    }
    return success;
  } catch (error) {
    console.error("[SECURITY-DISPUTE] Error handling security dispute:", error);
    return false;
  }
}
async function sendDisputeAlertToAdmin(disputeInfo, req) {
  try {
    const changeTypeText = getChangeTypeText(disputeInfo.changeType);
    const oldValueDisplay = getValueDisplay(disputeInfo.changeType, disputeInfo.oldValue);
    const newValueDisplay = getValueDisplay(disputeInfo.changeType, disputeInfo.newValue);
    const subject = `\u{1F6A8} URGENT: Security Dispute - Unauthorized ${changeTypeText} Change`;
    const htmlContent = `
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Security Dispute Alert</title>
  <style>
    body { 
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; 
      line-height: 1.5; 
      margin: 0; 
      padding: 20px; 
      background: #f7fafc;
      color: #2d3748;
    }
    .container { 
      max-width: 600px; 
      margin: 0 auto; 
      background: white; 
      border-radius: 8px; 
      box-shadow: 0 4px 6px rgba(0,0,0,0.1);
      overflow: hidden;
    }
    .header { 
      background: linear-gradient(135deg, #e53e3e, #c53030); 
      color: white; 
      padding: 20px; 
      text-align: center; 
    }
    .header h1 { 
      margin: 0; 
      font-size: 22px; 
      font-weight: 700; 
    }
    .urgent-banner {
      background: #fed7d7;
      color: #742a2a;
      padding: 12px;
      text-align: center;
      font-weight: 600;
      font-size: 16px;
    }
    .content { 
      padding: 20px; 
    }
    .info-section {
      background: #f7fafc;
      border-radius: 8px;
      padding: 16px;
      margin: 16px 0;
      border-left: 4px solid #e53e3e;
    }
    .info-section h3 {
      margin: 0 0 12px 0;
      font-size: 16px;
      color: #2d3748;
    }
    .info-grid {
      display: grid;
      grid-template-columns: 140px 1fr;
      gap: 8px;
      margin: 0;
    }
    .label {
      font-weight: 600;
      color: #4a5568;
    }
    .value {
      color: #2d3748;
    }
    .action-required {
      background: #fed7d7;
      color: #742a2a;
      border-radius: 8px;
      padding: 16px;
      margin: 16px 0;
      border: 2px solid #f56565;
    }
    .action-required h3 {
      margin: 0 0 12px 0;
      color: #742a2a;
    }
    .footer { 
      background: #edf2f7; 
      padding: 16px; 
      text-align: center; 
      font-size: 12px; 
      color: #718096;
    }
    ol { margin: 8px 0; padding-left: 20px; }
    li { margin: 4px 0; }
  </style>
</head>
<body>
  <div class="container">
    <div class="urgent-banner">
      \u{1F6A8} URGENT SECURITY ALERT - IMMEDIATE ACTION REQUIRED
    </div>
    
    <div class="header">
      <h1>Security Dispute Reported</h1>
      <p style="margin: 8px 0 0 0;">Unauthorized account change disputed by user</p>
    </div>
    
    <div class="content">
      <div class="info-section">
        <h3>\u{1F464} User Information</h3>
        <div class="info-grid">
          <span class="label">User ID:</span>
          <span class="value">#${disputeInfo.userId}</span>
          <span class="label">Name:</span>
          <span class="value">${disputeInfo.fullName}</span>
          <span class="label">Email:</span>
          <span class="value">${disputeInfo.email}</span>
          <span class="label">Phone:</span>
          <span class="value">${disputeInfo.phoneNumber || "Not provided"}</span>
        </div>
      </div>
      
      <div class="info-section">
        <h3>\u{1F4CB} Disputed Change Details</h3>
        <div class="info-grid">
          <span class="label">Change Type:</span>
          <span class="value">${changeTypeText}</span>
          ${disputeInfo.oldValue ? `<span class="label">Previous Value:</span><span class="value">${oldValueDisplay}</span>` : ""}
          ${disputeInfo.newValue ? `<span class="label">New Value:</span><span class="value">${newValueDisplay}</span>` : ""}
          <span class="label">Change Time:</span>
          <span class="value">${disputeInfo.timestamp.toLocaleString()}</span>
          <span class="label">Dispute Time:</span>
          <span class="value">${(/* @__PURE__ */ new Date()).toLocaleString()}</span>
          ${disputeInfo.userAgent ? `<span class="label">Device/Browser:</span><span class="value">${disputeInfo.userAgent}</span>` : ""}
          ${disputeInfo.ipAddress ? `<span class="label">IP Address:</span><span class="value">${disputeInfo.ipAddress}</span>` : ""}
        </div>
      </div>
      
      <div class="action-required">
        <h3>\u{1F3AF} Immediate Actions Required</h3>
        <ol>
          <li><strong>Contact the user within 24 hours</strong> at ${disputeInfo.email}</li>
          <li><strong>Verify the user's identity</strong> through additional security questions</li>
          <li><strong>Review account activity logs</strong> for suspicious behavior</li>
          <li><strong>Consider temporarily suspending the account</strong> if fraud is suspected</li>
          <li><strong>Reverse the unauthorized change</strong> if confirmed as fraudulent</li>
          <li><strong>Implement additional security measures</strong> if needed</li>
        </ol>
      </div>
      
      <p style="font-size: 14px; font-weight: 600; color: #742a2a; text-align: center; margin: 20px 0;">
        This is a high-priority security incident requiring immediate attention.
      </p>
    </div>
    
    <div class="footer">
      <p><strong>CHARLEY Security System</strong></p>
      <p>Automated security dispute notification - Generated at ${(/* @__PURE__ */ new Date()).toLocaleString()}</p>
      <p>For technical issues, contact the development team immediately.</p>
    </div>
  </div>
</body>
</html>
    `;
    const textContent = `
URGENT SECURITY ALERT - UNAUTHORIZED ACCOUNT CHANGE DISPUTED

User Information:
- User ID: #${disputeInfo.userId}
- Name: ${disputeInfo.fullName}
- Email: ${disputeInfo.email}
- Phone: ${disputeInfo.phoneNumber || "Not provided"}

Disputed Change Details:
- Change Type: ${changeTypeText}
${disputeInfo.oldValue ? `- Previous Value: ${oldValueDisplay}` : ""}
${disputeInfo.newValue ? `- New Value: ${newValueDisplay}` : ""}
- Change Timestamp: ${disputeInfo.timestamp.toLocaleString()}
- Dispute Timestamp: ${(/* @__PURE__ */ new Date()).toLocaleString()}
${disputeInfo.userAgent ? `- Device/Browser: ${disputeInfo.userAgent}` : ""}
${disputeInfo.ipAddress ? `- IP Address: ${disputeInfo.ipAddress}` : ""}

IMMEDIATE ACTIONS REQUIRED:
1. Contact the user within 24 hours at ${disputeInfo.email}
2. Verify the user's identity through additional security questions
3. Review account activity logs for suspicious behavior
4. Consider temporarily suspending the account if fraud is suspected
5. Reverse the unauthorized change if confirmed as fraudulent
6. Implement additional security measures if needed

This is a high-priority security incident requiring immediate attention.

CHARLEY Security System
Generated at ${(/* @__PURE__ */ new Date()).toLocaleString()}
    `;
    const success = await sendEmail(process.env.SENDGRID_API_KEY, {
      to: "admin@kronogon.com",
      from: "admin@kronogon.com",
      subject,
      text: textContent,
      html: htmlContent
    });
    if (success) {
      console.log(`[SECURITY-DISPUTE] Sent dispute alert to admin for user ${disputeInfo.userId}`);
    } else {
      console.error(`[SECURITY-DISPUTE] Failed to send dispute alert to admin for user ${disputeInfo.userId}`);
    }
    return success;
  } catch (error) {
    console.error("[SECURITY-DISPUTE] Error sending dispute alert to admin:", error);
    return false;
  }
}
function getChangeTypeText(changeType) {
  switch (changeType) {
    case "password":
      return "Password";
    case "email":
      return "Email Address";
    case "phone":
      return "Phone Number";
    default:
      return "Account Information";
  }
}
function getValueDisplay(changeType, value) {
  if (!value) return "Not specified";
  switch (changeType) {
    case "password":
      return "\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022";
    // Never show actual passwords
    case "email":
      return value;
    case "phone":
      return value;
    default:
      return value;
  }
}
function getDisputeInfo(token) {
  return disputeTokens.get(token);
}
function cleanupExpiredTokens() {
  const now = Date.now();
  const sevenDays = 7 * 24 * 60 * 60 * 1e3;
  for (const [token, info] of disputeTokens) {
    if (now - info.timestamp.getTime() > sevenDays) {
      disputeTokens.delete(token);
    }
  }
}
setInterval(cleanupExpiredTokens, 24 * 60 * 60 * 1e3);

// server/routes/highschool-search.ts
import { Router } from "express";
import fs from "fs";
import path from "path";
var router = Router();
function toTitleCase(str) {
  return str.toLowerCase().replace(/\b\w/g, (char) => char.toUpperCase());
}
var unifiedHighSchools = [];
function loadGhanaHighSchools() {
  try {
    const dataPath = path.join(
      process.cwd(),
      "client/src/data/highschool.json"
    );
    const data = JSON.parse(fs.readFileSync(dataPath, "utf8"));
    const list = Array.isArray(data.ghanaian_high_schools) ? data.ghanaian_high_schools : [];
    return list.map((name) => toTitleCase(name)).map((name) => `${name}, Ghana`);
  } catch (error) {
    console.error("Error loading Ghana high school data:", error);
    return [];
  }
}
function loadUSAHighSchools() {
  const results = [];
  try {
    const dirPath = path.join(process.cwd(), "data", "schools");
    if (!fs.existsSync(dirPath)) {
      return results;
    }
    const files = fs.readdirSync(dirPath).filter((f) => f.endsWith(".json"));
    for (const fileName of files) {
      try {
        const filePath = path.join(dirPath, fileName);
        const content = fs.readFileSync(filePath, "utf8");
        const entries = JSON.parse(content);
        for (const entry of entries) {
          const level = (entry?.level ?? "").toString().toLowerCase();
          if (level === "high" || level.includes("high")) {
            const name = (entry?.name ?? "").toString().trim();
            const stateName = (entry?.location?.state?.name ?? "").toString().trim();
            const stateAbbrRaw = (entry?.location?.state?.abbr ?? "").toString().trim();
            const stateAbbr = stateAbbrRaw.replace(/\s+/g, "");
            if (name) {
              const suffix = stateAbbr || stateName ? `, ${stateAbbr || stateName}` : "";
              results.push(`${name}${suffix}`);
            }
          }
        }
      } catch (innerErr) {
        console.error(
          `Error processing US schools file ${fileName}:`,
          innerErr
        );
      }
    }
  } catch (error) {
    console.error("Error loading USA high school data:", error);
  }
  return results;
}
function buildUnifiedHighSchoolsDataset() {
  const gh = loadGhanaHighSchools();
  const us = loadUSAHighSchools();
  const seen = /* @__PURE__ */ new Set();
  const combined = [];
  for (const name of [...gh, ...us]) {
    const key = name.toLowerCase();
    if (!seen.has(key)) {
      seen.add(key);
      combined.push(name);
    }
  }
  console.log(
    `[HIGH-SCHOOL] GH count: ${gh.length}, US count: ${us.length}, combined: ${combined.length}`
  );
  return combined;
}
try {
  unifiedHighSchools = buildUnifiedHighSchoolsDataset();
  const accraSamples = unifiedHighSchools.filter((n) => n.toLowerCase().includes("accra")).slice(0, 3);
  const youngstownSamples = unifiedHighSchools.filter((n) => n.toLowerCase().includes("youngstown")).slice(0, 3);
  console.log("[HIGH-SCHOOL] Sample Accra entries:", accraSamples);
  console.log("[HIGH-SCHOOL] Sample Youngstown entries:", youngstownSamples);
} catch (e) {
  console.error("Failed to build unified high school dataset:", e);
  unifiedHighSchools = [];
}
router.get("/search", (req, res) => {
  try {
    const { q: query, limit = 10 } = req.query;
    if (!query || typeof query !== "string") {
      return res.json({ schools: [] });
    }
    const searchTerm = query.toLowerCase().trim();
    const filteredSchools = unifiedHighSchools.filter(
      (school) => school.toLowerCase().includes(searchTerm)
    );
    const limitedResults = filteredSchools.slice(0, parseInt(limit));
    res.json({
      schools: limitedResults,
      total: filteredSchools.length
    });
  } catch (error) {
    console.error("Error searching high schools:", error);
    res.status(500).json({ error: "Internal server error" });
  }
});
var highschool_search_default = router;

// server/routes/university-search.ts
import fs2 from "fs";
import path2 from "path";
var universitiesCache = null;
function loadUniversities() {
  if (universitiesCache) {
    return universitiesCache;
  }
  try {
    const filePath = path2.join(
      process.cwd(),
      "client/src/data/universities.json"
    );
    const fileContent = fs2.readFileSync(filePath, "utf-8");
    universitiesCache = JSON.parse(fileContent);
    return universitiesCache || [];
  } catch (error) {
    console.error("Error loading universities data:", error);
    return [];
  }
}
function formatUniversityName(name) {
  return name.toLowerCase().split(" ").map((word) => {
    if (["of", "and", "the", "at", "in", "on", "for", "with", "by"].includes(
      word
    )) {
      return word;
    }
    return word.charAt(0).toUpperCase() + word.slice(1);
  }).join(" ").replace(/^./, (firstChar) => firstChar.toUpperCase());
}
function searchUniversities(req, res) {
  try {
    const query = req.query.q;
    if (!query || query.length < 2) {
      return res.json([]);
    }
    const universities = loadUniversities();
    const searchQuery = query.toLowerCase().trim();
    const matchingUniversities = universities.filter((university) => {
      const universityName = university.name.toLowerCase();
      const country = university.country.toLowerCase();
      const stateProvince = university["state-province"]?.toLowerCase() || "";
      return universityName.includes(searchQuery) || country.includes(searchQuery) || stateProvince.includes(searchQuery) || // Also search by common abbreviations and keywords
      universityName.includes(
        searchQuery.replace(/university|college|institute|school/g, "").trim()
      );
    }).slice(0, 20).map((university) => {
      const name = formatUniversityName(university.name);
      const country = university.country?.trim();
      const state = university["state-province"]?.trim() || null;
      const display = state ? `${name}, ${state}, ${country}` : `${name}, ${country}`;
      return {
        name: display,
        country,
        "state-province": state
      };
    });
    res.json(matchingUniversities);
  } catch (error) {
    console.error("University search error:", error);
    res.status(500).json({ error: "Internal server error" });
  }
}

// server/routes.ts
init_schema();
import { eq as eq6, and as and5, or as or4, sql as sql5, gte } from "drizzle-orm";
var stripe2 = null;
var stripeSecretKey2 = process.env.STRIPE_LIVE_SECRET_KEY || process.env.STRIPE_SECRET_KEY;
var isLiveMode2 = !!process.env.STRIPE_LIVE_SECRET_KEY;
if (stripeSecretKey2) {
  stripe2 = new Stripe2(stripeSecretKey2, {
    apiVersion: "2024-06-20"
  });
  console.log(
    `[STRIPE-ENVIRONMENT-FIX] Backend initialized successfully in ${isLiveMode2 ? "LIVE" : "TEST"} mode`
  );
  console.log(
    `[STRIPE-ENVIRONMENT-FIX] Using ${isLiveMode2 ? "live" : "test"} secret key for payment processing`
  );
} else {
  console.warn(
    "[STRIPE] No Stripe keys found - payment features will be disabled"
  );
}
async function registerRoutes(app2) {
  app2.post("/api/contact/send", async (req, res) => {
    try {
      const { name, email, phoneNumber, message } = req.body;
      if (!name || !email || !message) {
        return res.status(400).json({
          success: false,
          message: "All fields (name, email, message) are required"
        });
      }
      const contactData = {
        name: name.trim(),
        email: email.trim(),
        phoneNumber: phoneNumber || "Not provided",
        message: message.trim()
      };
      const [adminEmailSent, confirmationEmailSent] = await Promise.all([
        sendContactFormEmail(contactData),
        sendContactFormConfirmationEmail(contactData)
      ]);
      if (adminEmailSent && confirmationEmailSent) {
        console.log(
          `[CONTACT-FORM] Both admin and confirmation emails sent successfully from ${email}`
        );
        res.json({
          success: true,
          message: "Message sent successfully! You'll receive a confirmation email shortly, and we'll get back to you soon."
        });
      } else if (adminEmailSent && !confirmationEmailSent) {
        console.log(
          `[CONTACT-FORM] Admin email sent but confirmation email failed from ${email}`
        );
        res.json({
          success: true,
          message: "Message sent successfully! We'll get back to you soon."
        });
      } else if (!adminEmailSent && confirmationEmailSent) {
        console.error(
          `[CONTACT-FORM] Admin email failed but confirmation sent from ${email}`
        );
        res.status(500).json({
          success: false,
          message: "There was an issue processing your message. Please try again later."
        });
      } else {
        console.error(`[CONTACT-FORM] Both emails failed from ${email}`);
        res.status(500).json({
          success: false,
          message: "Failed to send message. Please try again later."
        });
      }
    } catch (error) {
      console.error("Contact form error:", error);
      res.status(500).json({
        success: false,
        message: "Failed to send message. Please try again later."
      });
    }
  });
  function convertDbFieldsToFrontend(dbData) {
    const fieldMapping = {
      // Mentorship fields
      mentorship_looking_for: "mentorshipLookingFor",
      mentorship_experience_level: "mentorshipExperienceLevel",
      mentorship_industries: "mentorshipIndustries",
      mentorship_areas_of_expertise: "mentorshipAreasOfExpertise",
      mentorship_education_level: "mentorshipEducationLevel",
      mentorship_skills: "mentorshipSkills",
      mentorship_topics: "mentorshipTopics",
      mentorship_format: "mentorshipFormat",
      mentorship_time_commitment: "mentorshipTimeCommitment",
      mentorship_location_preference: "mentorshipLocationPreference",
      mentorship_weights: "mentorshipWeights",
      // Networking fields
      networking_purpose: "networkingPurpose",
      networking_company_size: "networkingCompanySize",
      networking_seniority: "networkingSeniority",
      networking_industries: "networkingIndustries",
      networking_areas_of_expertise: "networkingAreasOfExpertise",
      networking_education_level: "networkingEducationLevel",
      networking_skills: "networkingSkills",
      networking_functional_areas: "networkingFunctionalAreas",
      networking_geographic: "networkingGeographic",
      networking_event_preference: "networkingEventPreference",
      networking_weights: "networkingWeights",
      // Jobs fields
      jobs_types: "jobsTypes",
      jobs_salary_range: "jobsSalaryRange",
      jobs_work_arrangement: "jobsWorkArrangement",
      jobs_company_size: "jobsCompanySize",
      jobs_industries: "jobsIndustries",
      jobs_education_level: "jobsEducationLevel",
      jobs_skills: "jobsSkills",
      jobs_experience_level: "jobsExperienceLevel",
      jobs_functional_areas: "jobsFunctionalAreas",
      jobs_work_location: "jobsWorkLocation",
      jobs_weights: "jobsWeights",
      // Global fields
      deal_breakers: "dealBreakers",
      preference_profiles: "preferenceProfiles"
    };
    const mappedData = {};
    Object.entries(dbData).forEach(([key, value]) => {
      const frontendField = fieldMapping[key] || key;
      mappedData[frontendField] = value;
    });
    return mappedData;
  }
  setupAuth(app2);
  const { registerUserBlockingAPI: registerUserBlockingAPI2 } = await Promise.resolve().then(() => (init_user_blocking_api(), user_blocking_api_exports));
  registerUserBlockingAPI2(app2);
  registerMatchAPI(app2);
  registerCompatibilityAPI(app2);
  registerSuiteCompatibilityAPI(app2);
  registerMentorshipCompatibilityAPI(app2);
  registerKwameAPI(app2);
  const { registerJobsCompatibilityAPI: registerJobsCompatibilityAPI2 } = await Promise.resolve().then(() => (init_jobs_compatibility_api(), jobs_compatibility_api_exports));
  registerJobsCompatibilityAPI2(app2);
  const { registerEnhancedDiscoveryAPI: registerEnhancedDiscoveryAPI2 } = await Promise.resolve().then(() => (init_enhanced_discovery_api(), enhanced_discovery_api_exports));
  registerEnhancedDiscoveryAPI2(app2);
  const dataCollectionRoutes = await Promise.resolve().then(() => (init_data_collection_routes(), data_collection_routes_exports));
  app2.use("/api/tracking", dataCollectionRoutes.default);
  app2.post("/api/swipe/undo", async (req, res) => {
    try {
      if (!req.isAuthenticated() || !req.user || !req.user.id) {
        console.log("[UNDO-AUTH-ERROR] Authentication failed:", {
          isAuthenticated: req.isAuthenticated(),
          hasUser: !!req.user,
          userId: req.user?.id
        });
        return res.status(401).json({
          message: "Unauthorized",
          details: "Valid authentication session required"
        });
      }
      const { userId, action } = req.body;
      const currentUser = req.user;
      if (!userId || !action) {
        return res.status(400).json({ message: "Missing required fields" });
      }
      const startTime = Date.now();
      if (action === "like" || action === "dislike") {
        await Promise.all([
          storage.removeLikeOrDislike(currentUser.id, userId),
          storage.removeSwipeFromHistory(currentUser.id, userId)
        ]);
        const sourceUserWs = connectedUsers4.get(currentUser.id);
        let restorationResults = {
          primaryWebSocket: false,
          fallbackRefresh: false,
          connectionStatus: "disconnected"
        };
        if (sourceUserWs) {
          restorationResults.connectionStatus = sourceUserWs.readyState === WebSocket4.OPEN ? "open" : "closed";
        }
        if (sourceUserWs && sourceUserWs.readyState === WebSocket4.OPEN) {
          try {
            const restorationMessage = {
              type: "meet_restore_to_discover",
              userId: parseInt(userId),
              reason: "undo_action",
              timestamp: (/* @__PURE__ */ new Date()).toISOString(),
              sourceUserId: currentUser.id
            };
            sourceUserWs.send(JSON.stringify(restorationMessage));
            restorationResults.primaryWebSocket = true;
            console.log(
              `[RESTORATION-PRIMARY] \u2705 Sent meet_restore_to_discover for user ${userId}`
            );
          } catch (error) {
            console.log(`[RESTORATION-PRIMARY] \u274C Failed:`, error.message);
          }
        }
        if (sourceUserWs && sourceUserWs.readyState === WebSocket4.OPEN) {
          try {
            const refreshMessage = {
              type: "discover:refresh",
              reason: "undo_action",
              userId: parseInt(userId),
              timestamp: (/* @__PURE__ */ new Date()).toISOString(),
              sourceUserId: currentUser.id
            };
            sourceUserWs.send(JSON.stringify(refreshMessage));
            restorationResults.fallbackRefresh = true;
            console.log(
              `[RESTORATION-FALLBACK] \u2705 Sent discover:refresh for user ${userId}`
            );
          } catch (error) {
            console.log(`[RESTORATION-FALLBACK] \u274C Failed:`, error.message);
          }
        }
        const restoredUserData = await storage.getUser(parseInt(userId));
        console.log(
          `[RESTORATION-COMPLETE] User ${userId} restored with results:`,
          {
            primary: restorationResults.primaryWebSocket ? "\u2705" : "\u274C",
            fallback: restorationResults.fallbackRefresh ? "\u2705" : "\u274C",
            connection: restorationResults.connectionStatus,
            hasUserData: !!restoredUserData
          }
        );
        console.log(
          `User ${currentUser.id} undid ${action} for user ${userId} in ${Date.now() - startTime}ms`
        );
        return res.status(200).json({
          message: "Action undone successfully",
          performance: `${Date.now() - startTime}ms`,
          restoration: restorationResults,
          restoredUser: restoredUserData,
          userId: parseInt(userId),
          action
        });
      } else if (action === "message") {
        const [match] = await Promise.all([
          storage.getMatchBetweenUsers(currentUser.id, userId),
          storage.removeLikeOrDislike(currentUser.id, userId)
        ]);
        if (match) {
          const messageCount = await storage.getMessageCountForMatch(match.id);
          if (messageCount === 0) {
            await storage.deleteMatch(match.id);
            console.log(
              `User ${currentUser.id} undid message for user ${userId} and deleted match ${match.id} in ${Date.now() - startTime}ms`
            );
          } else {
            await storage.updateMatchStatus(match.id, false);
            console.log(
              `User ${currentUser.id} undid message for user ${userId} and updated match ${match.id} to unmatched in ${Date.now() - startTime}ms`
            );
          }
        } else {
          console.log(
            `User ${currentUser.id} undid message for user ${userId} (no match found) in ${Date.now() - startTime}ms`
          );
        }
      } else {
        return res.status(400).json({ message: "Invalid action" });
      }
      return res.status(200).json({
        message: "Action undone successfully",
        performance: `${Date.now() - startTime}ms`,
        action
      });
    } catch (error) {
      console.error("Error undoing swipe action:", error);
      return res.status(500).json({ message: "Server error" });
    }
  });
  app2.post(
    "/api/suite/mentorship/undo",
    async (req, res) => {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      try {
        const currentUserId = req.user.id;
        const startTime = Date.now();
        const swipeHistory2 = await storage.getUserSwipeHistory(
          currentUserId,
          "SUITE_MENTORSHIP",
          1
        );
        if (!swipeHistory2 || swipeHistory2.length === 0) {
          return res.status(404).json({ message: "No recent swipes to undo" });
        }
        const lastSwipe = swipeHistory2[0];
        const targetUserId = lastSwipe.targetUserId;
        const targetMentorshipProfile = await storage.getSuiteMentorshipProfile(targetUserId);
        if (!targetMentorshipProfile) {
          return res.status(404).json({ message: "Target mentorship profile not found" });
        }
        const existingConnection = await storage.getSuiteMentorshipConnection(
          currentUserId,
          targetMentorshipProfile.id
        );
        if (existingConnection) {
          if (existingConnection.matched) {
            const currentUserMentorshipProfile = await storage.getSuiteMentorshipProfile(currentUserId);
            if (!currentUserMentorshipProfile) {
              console.log(
                `[SUITE-MENTORSHIP-UNDO] Current user ${currentUserId} has no mentorship profile`
              );
              return res.status(404).json({ message: "Current user mentorship profile not found" });
            }
            const mutualConnection = await storage.getSuiteMentorshipConnection(
              targetUserId,
              currentUserMentorshipProfile.id
            );
            if (mutualConnection) {
              await storage.deleteSuiteMentorshipConnectionById(
                existingConnection.id
              );
              await storage.deleteSuiteMentorshipConnectionById(
                mutualConnection.id
              );
              console.log(
                `[SUITE-MENTORSHIP-UNDO] Removed matched connection between ${currentUserId} and ${targetUserId}`
              );
            }
          } else {
            await storage.deleteSuiteMentorshipConnectionById(
              existingConnection.id
            );
            console.log(
              `[SUITE-MENTORSHIP-UNDO] Removed connection ${existingConnection.id} for user ${currentUserId}`
            );
          }
        }
        await storage.removeSwipeHistory(lastSwipe.id);
        const sourceUserWs = connectedUsers4.get(currentUserId);
        if (sourceUserWs && sourceUserWs.readyState === WebSocket4.OPEN) {
          sourceUserWs.send(
            JSON.stringify({
              type: "suite_restore_to_discover",
              suiteType: "mentorship",
              profileId: targetMentorshipProfile.id,
              userId: targetUserId,
              reason: "undo_action",
              timestamp: (/* @__PURE__ */ new Date()).toISOString()
            })
          );
          console.log(
            `[REAL-TIME] Restored mentorship profile ${targetMentorshipProfile.id} to user ${currentUserId}'s discover deck`
          );
        }
        console.log(
          `\u{1F504} [SUITE-MENTORSHIP-UNDO] User ${currentUserId} undid ${lastSwipe.action} on user ${targetUserId} in ${Date.now() - startTime}ms`
        );
        const completeProfile = await storage.getSuiteMentorshipProfile(targetUserId);
        return res.status(200).json({
          message: "Mentorship action undone successfully",
          undoneAction: lastSwipe.action,
          targetUserId,
          profileId: targetMentorshipProfile.id,
          profile: completeProfile,
          // Include full profile data for instant frontend restoration
          performance: `${Date.now() - startTime}ms`
        });
      } catch (error) {
        console.error("Error undoing mentorship swipe action:", error);
        return res.status(500).json({ message: "Server error" });
      }
    }
  );
  app2.post(
    "/api/suite/networking/undo",
    async (req, res) => {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      try {
        const currentUserId = req.user.id;
        const startTime = Date.now();
        const swipeHistory2 = await storage.getUserSwipeHistory(
          currentUserId,
          "SUITE_NETWORKING",
          1
        );
        if (!swipeHistory2 || swipeHistory2.length === 0) {
          return res.status(404).json({ message: "No recent swipes to undo" });
        }
        const lastSwipe = swipeHistory2[0];
        const targetUserId = lastSwipe.targetUserId;
        const targetNetworkingProfile = await storage.getSuiteNetworkingProfile(targetUserId);
        if (!targetNetworkingProfile) {
          return res.status(404).json({ message: "Target networking profile not found" });
        }
        const existingConnection = await storage.getSuiteNetworkingConnection(
          currentUserId,
          targetNetworkingProfile.id
        );
        if (existingConnection) {
          if (existingConnection.matched) {
            const currentUserNetworkingProfile = await storage.getSuiteNetworkingProfile(currentUserId);
            if (!currentUserNetworkingProfile) {
              console.log(
                `[SUITE-NETWORKING-UNDO] Current user ${currentUserId} has no networking profile`
              );
              return res.status(404).json({ message: "Current user networking profile not found" });
            }
            const mutualConnection = await storage.getSuiteNetworkingConnection(
              targetUserId,
              currentUserNetworkingProfile.id
            );
            if (mutualConnection) {
              await storage.deleteSuiteNetworkingConnectionById(
                existingConnection.id
              );
              await storage.deleteSuiteNetworkingConnectionById(
                mutualConnection.id
              );
              console.log(
                `[SUITE-NETWORKING-UNDO] Removed mutual networking connections: ${existingConnection.id} and ${mutualConnection.id}`
              );
            }
          } else {
            await storage.deleteSuiteNetworkingConnectionById(
              existingConnection.id
            );
            console.log(
              `[SUITE-NETWORKING-UNDO] Removed single networking connection: ${existingConnection.id}`
            );
          }
        } else {
          console.log(
            `[SUITE-NETWORKING-UNDO] No networking connection found between user ${currentUserId} and profile ${targetNetworkingProfile.id}`
          );
        }
        await storage.removeSwipeHistory(lastSwipe.id);
        const sourceUserWs = connectedUsers4.get(currentUserId);
        if (sourceUserWs && sourceUserWs.readyState === WebSocket4.OPEN) {
          sourceUserWs.send(
            JSON.stringify({
              type: "suite_restore_to_discover",
              suiteType: "networking",
              profileId: targetNetworkingProfile.id,
              userId: targetUserId,
              reason: "undo_action",
              timestamp: (/* @__PURE__ */ new Date()).toISOString()
            })
          );
          console.log(
            `[REAL-TIME] Restored networking profile ${targetNetworkingProfile.id} to user ${currentUserId}'s discover deck`
          );
        }
        console.log(
          `\u{1F504} [SUITE-NETWORKING-UNDO] User ${currentUserId} undid ${lastSwipe.action} on user ${targetUserId} in ${Date.now() - startTime}ms`
        );
        const completeProfile = await storage.getSuiteNetworkingProfile(targetUserId);
        return res.status(200).json({
          message: "Networking action undone successfully",
          undoneAction: lastSwipe.action,
          targetUserId,
          profileId: targetNetworkingProfile.id,
          profile: completeProfile,
          // Include full profile data for instant frontend restoration
          performance: `${Date.now() - startTime}ms`
        });
      } catch (error) {
        console.error("Error undoing networking swipe action:", error);
        return res.status(500).json({ message: "Server error" });
      }
    }
  );
  app2.post("/api/suite/jobs/undo", async (req, res) => {
    if (!req.isAuthenticated()) {
      return res.status(401).json({ message: "Unauthorized" });
    }
    try {
      const currentUserId = req.user.id;
      const startTime = Date.now();
      const swipeHistory2 = await storage.getUserSwipeHistory(
        currentUserId,
        "SUITE_JOBS",
        1
      );
      if (!swipeHistory2 || swipeHistory2.length === 0) {
        return res.status(404).json({ message: "No recent job swipes to undo" });
      }
      const lastSwipe = swipeHistory2[0];
      const targetUserId = lastSwipe.targetUserId;
      const targetJobProfile = await storage.getSuiteJobProfile(targetUserId);
      if (!targetJobProfile) {
        return res.status(404).json({ message: "Target job profile not found" });
      }
      const existingApplication = await storage.getSuiteJobApplication(
        currentUserId,
        targetJobProfile.id
      );
      if (existingApplication) {
        if (existingApplication.matched) {
          const reciprocalApplication = await storage.getSuiteJobApplicationByUsers(
            targetUserId,
            // job poster
            currentUserId
            // current user (applicant)
          );
          if (reciprocalApplication) {
            await storage.deleteSuiteJobApplicationById(existingApplication.id);
            await storage.deleteSuiteJobApplicationById(
              reciprocalApplication.id
            );
            console.log(
              `[SUITE-JOBS-UNDO] Removed mutual job applications: ${existingApplication.id} and ${reciprocalApplication.id}`
            );
          }
        } else {
          await storage.deleteSuiteJobApplicationById(existingApplication.id);
          console.log(
            `[SUITE-JOBS-UNDO] Removed single job application: ${existingApplication.id}`
          );
        }
      } else {
        console.log(
          `[SUITE-JOBS-UNDO] No job application found between user ${currentUserId} and profile ${targetJobProfile.id}`
        );
      }
      await storage.removeSwipeHistory(lastSwipe.id);
      const sourceUserWs = connectedUsers4.get(currentUserId);
      if (sourceUserWs && sourceUserWs.readyState === WebSocket4.OPEN) {
        sourceUserWs.send(
          JSON.stringify({
            type: "suite_restore_to_discover",
            suiteType: "jobs",
            profileId: targetJobProfile.id,
            userId: targetUserId,
            reason: "undo_action",
            timestamp: (/* @__PURE__ */ new Date()).toISOString()
          })
        );
        console.log(
          `[REAL-TIME] Restored job profile ${targetJobProfile.id} to user ${currentUserId}'s discover deck`
        );
      }
      console.log(
        `[SUITE-JOBS-UNDO] User ${currentUserId} undid job swipe for profile ${targetJobProfile.id} in ${Date.now() - startTime}ms`
      );
      return res.status(200).json({
        message: "Job swipe undone successfully",
        performance: `${Date.now() - startTime}ms`
      });
    } catch (error) {
      console.error("Error undoing job swipe action:", error);
      return res.status(500).json({ message: "Server error" });
    }
  });
  app2.post("/api/messages/create-chat", async (req, res) => {
    if (!req.isAuthenticated()) {
      return res.status(401).json({ message: "Unauthorized" });
    }
    try {
      const { targetUserId } = req.body;
      if (!targetUserId) {
        return res.status(400).json({ message: "Target user ID is required" });
      }
      const currentUserId = req.user.id;
      if (currentUserId === targetUserId) {
        console.log(
          `User ${currentUserId} attempted to create chat with themselves`
        );
        return res.status(400).json({ message: "Users cannot create chats with themselves" });
      }
      console.log(
        "[CHAT-PERFORMANCE] Starting optimized chat creation process"
      );
      const startTime = Date.now();
      const [userMatches, currentUser, targetUser] = await Promise.all([
        storage.getMatchesByUserId(currentUserId),
        storage.getUser(currentUserId),
        storage.getUser(targetUserId)
      ]);
      console.log(
        `[CHAT-PERFORMANCE] Parallel DB fetch completed in ${Date.now() - startTime}ms`
      );
      const existingMatch = userMatches.find(
        (match2) => match2.userId1 === currentUserId && match2.userId2 === targetUserId || match2.userId1 === targetUserId && match2.userId2 === currentUserId
      );
      let matchId;
      let match;
      if (!targetUser) {
        return res.status(404).json({ message: "Target user not found" });
      }
      if (existingMatch) {
        console.log(
          `\u{1F50D} [MEET-DIRECT-MESSAGE] Found existing match ${existingMatch.id} between users ${currentUserId} and ${targetUserId}`
        );
        console.log(
          `\u{1F50D} [MEET-DIRECT-MESSAGE] Existing match metadata: ${existingMatch.metadata}`
        );
        if (existingMatch.metadata) {
          try {
            const existingMetadata = typeof existingMatch.metadata === "string" ? JSON.parse(existingMatch.metadata) : existingMatch.metadata;
            if (existingMetadata && existingMetadata.origin === "SUITE") {
              console.log(
                `\u{1F517} [MEET-DIRECT-MESSAGE] Found existing SUITE match, checking for MEET in additionalConnections`
              );
              if (!existingMetadata.additionalConnections) {
                existingMetadata.additionalConnections = [];
                console.log(
                  `\u{1F517} [MEET-DIRECT-MESSAGE] Initialized additionalConnections array`
                );
              }
              if (!existingMetadata.additionalConnections.includes("MEET")) {
                existingMetadata.additionalConnections.push("MEET");
                console.log(
                  `\u{1F517} [MEET-DIRECT-MESSAGE] Adding MEET to additionalConnections for existing SUITE match ${existingMatch.id}`
                );
                console.log(
                  `\u{1F517} [MEET-DIRECT-MESSAGE] New additionalConnections: ${JSON.stringify(existingMetadata.additionalConnections)}`
                );
                const updatedMatch = await storage.updateMatch(
                  existingMatch.id,
                  {
                    metadata: JSON.stringify(existingMetadata)
                  }
                );
                console.log(
                  `\u{1F517} [MEET-DIRECT-MESSAGE] Successfully added MEET to additionalConnections for existing SUITE match ${existingMatch.id}`
                );
                console.log(
                  `\u{1F517} [MEET-DIRECT-MESSAGE] Final updated metadata: ${updatedMatch?.metadata}`
                );
                match = updatedMatch || existingMatch;
              } else {
                console.log(
                  `\u{1F517} [MEET-DIRECT-MESSAGE] MEET already exists in additionalConnections`
                );
                match = existingMatch;
              }
            } else {
              console.log(
                `\u{1F517} [MEET-DIRECT-MESSAGE] Existing match is not a SUITE match, using as-is`
              );
              match = existingMatch;
            }
          } catch (error) {
            console.error(
              `\u{1F517} [MEET-DIRECT-MESSAGE] Error parsing/updating existing match metadata:`,
              error
            );
            match = existingMatch;
          }
        } else {
          console.log(
            `\u{1F517} [MEET-DIRECT-MESSAGE] Existing match has no metadata, using as-is`
          );
          match = existingMatch;
        }
        matchId = existingMatch.id;
        console.log(
          `Using existing match ${existingMatch.id} for direct message without changing match status`
        );
        const recipientWs = connectedUsers4.get(targetUserId);
        if (recipientWs && recipientWs.readyState === WebSocket4.OPEN) {
          recipientWs.send(
            JSON.stringify({
              type: "chat_created",
              matchId: existingMatch.id,
              userId: currentUserId,
              isDirectMessage: true,
              // Flag to prevent match dialog
              fromUserInfo: {
                id: currentUserId,
                fullName: currentUser?.fullName || "Unknown User",
                photoUrl: currentUser?.photoUrl
              }
            })
          );
        }
      } else {
        console.log(
          `\u{1F50D} [MEET-DIRECT-MESSAGE] Checking for existing SUITE matches between users ${currentUserId} and ${targetUserId}`
        );
        const existingMatches = await storage.getAllMatchesBetweenUsers(
          currentUserId,
          targetUserId
        );
        console.log(
          `\u{1F50D} [MEET-DIRECT-MESSAGE] Found ${existingMatches.length} existing matches between users`
        );
        if (existingMatches.length > 0) {
          existingMatches.forEach((match2, index) => {
            console.log(
              `\u{1F50D} [MEET-DIRECT-MESSAGE] Match ${index + 1}: ID=${match2.id}, metadata=${match2.metadata}`
            );
          });
        }
        const existingSuiteMatch = existingMatches.find((match2) => {
          if (match2.metadata) {
            try {
              const metadata = typeof match2.metadata === "string" ? JSON.parse(match2.metadata) : match2.metadata;
              return metadata && metadata.origin === "SUITE";
            } catch (e) {
              console.error(
                `\u{1F50D} [MEET-DIRECT-MESSAGE] Failed to parse metadata for match ${match2.id}:`,
                e
              );
              return false;
            }
          }
          return false;
        });
        if (existingSuiteMatch) {
          console.log(
            `\u{1F517} [MEET-DIRECT-MESSAGE] Found existing SUITE match ${existingSuiteMatch.id}, adding MEET as additional connection`
          );
          try {
            const existingMetadata = typeof existingSuiteMatch.metadata === "string" ? JSON.parse(existingSuiteMatch.metadata) : existingSuiteMatch.metadata;
            console.log(
              `\u{1F517} [MEET-DIRECT-MESSAGE] Current metadata: ${JSON.stringify(existingMetadata)}`
            );
            if (!existingMetadata.additionalConnections) {
              existingMetadata.additionalConnections = [];
              console.log(
                `\u{1F517} [MEET-DIRECT-MESSAGE] Initialized additionalConnections array`
              );
            }
            if (!existingMetadata.additionalConnections.includes("MEET")) {
              existingMetadata.additionalConnections.push("MEET");
              console.log(
                `\u{1F517} [MEET-DIRECT-MESSAGE] Adding MEET to additionalConnections for SUITE match ${existingSuiteMatch.id}`
              );
              console.log(
                `\u{1F517} [MEET-DIRECT-MESSAGE] New additionalConnections: ${JSON.stringify(existingMetadata.additionalConnections)}`
              );
              const updatedMatch = await storage.updateMatch(
                existingSuiteMatch.id,
                {
                  metadata: JSON.stringify(existingMetadata)
                }
              );
              console.log(
                `\u{1F517} [MEET-DIRECT-MESSAGE] Successfully added MEET to additionalConnections for existing SUITE match ${existingSuiteMatch.id}`
              );
              console.log(
                `\u{1F517} [MEET-DIRECT-MESSAGE] Final updated metadata: ${updatedMatch?.metadata}`
              );
              matchId = existingSuiteMatch.id;
              match = updatedMatch || existingSuiteMatch;
            } else {
              console.log(
                `\u{1F517} [MEET-DIRECT-MESSAGE] MEET already exists in additionalConnections, using existing match`
              );
              matchId = existingSuiteMatch.id;
              match = existingSuiteMatch;
            }
          } catch (error) {
            console.error(
              `\u{1F517} [MEET-DIRECT-MESSAGE] Error updating existing SUITE match:`,
              error
            );
            const newMatch2 = await storage.createMatch({
              userId1: currentUserId,
              userId2: targetUserId,
              matched: true,
              // Direct messages should create matched connections
              metadata: JSON.stringify({ origin: "MEET" })
            });
            matchId = newMatch2.id;
            match = newMatch2;
          }
        } else {
          const newMatch2 = await storage.createMatch({
            userId1: currentUserId,
            userId2: targetUserId,
            matched: true,
            // CRITICAL FIX: Direct messages should create matched connections
            metadata: JSON.stringify({ origin: "MEET" })
          });
          matchId = newMatch2.id;
          match = newMatch2;
        }
        console.log(
          `Created direct message channel ${newMatch.id} without match notification`
        );
        const recipientWs = connectedUsers4.get(targetUserId);
        if (recipientWs && recipientWs.readyState === WebSocket4.OPEN) {
          recipientWs.send(
            JSON.stringify({
              type: "chat_created",
              matchId: newMatch.id,
              userId: currentUserId,
              isDirectMessage: true,
              // Flag to prevent match dialog
              fromUserInfo: {
                id: currentUserId,
                fullName: currentUser?.fullName || "Unknown User",
                photoUrl: currentUser?.photoUrl
              }
            })
          );
        }
      }
      const enrichedMatch = {
        ...match,
        // Primary user property for chat components (the other user in the match)
        user: {
          id: targetUser.id,
          fullName: targetUser.fullName,
          photoUrl: targetUser.photoUrl,
          bio: targetUser.bio,
          profession: targetUser.profession,
          location: targetUser.location
        },
        // Keep targetUser for backward compatibility
        targetUser: {
          id: targetUser.id,
          fullName: targetUser.fullName,
          photoUrl: targetUser.photoUrl,
          bio: targetUser.bio,
          profession: targetUser.profession,
          location: targetUser.location
        },
        currentUser: {
          id: currentUser?.id,
          fullName: currentUser?.fullName,
          photoUrl: currentUser?.photoUrl
        },
        // Make it clear which user is which
        initiatorId: currentUserId,
        targetUserId
      };
      const totalTime = Date.now() - startTime;
      console.log(
        `[CHAT-PERFORMANCE] Complete chat creation process finished in ${totalTime}ms`
      );
      res.json({
        matchId,
        match: enrichedMatch,
        success: true,
        performance: `${totalTime}ms`
        // Include performance metrics in response
      });
    } catch (error) {
      console.error("Error creating chat:", error);
      res.status(500).json({ message: "Server error creating chat" });
    }
  });
  app2.post("/api/check-email", async (req, res) => {
    try {
      const { email } = req.body;
      if (!email) {
        return res.status(400).json({ error: "Email is required" });
      }
      const normalizedEmail = email.trim().toLowerCase();
      const user = await storage.getUserByEmail(normalizedEmail);
      const exists = !!user;
      if (exists) {
        console.log(
          `[EMAIL-DUPLICATE-PREVENTION] Email ${normalizedEmail} already exists in system - preventing duplicate account creation`
        );
      }
      return res.status(200).json({ exists });
    } catch (error) {
      console.error("Error checking email:", error);
      return res.status(500).json({ error: "Server error" });
    }
  });
  app2.get("/api/admin/users", async (req, res) => {
    try {
      const users2 = await storage.getAllUsers();
      const safeUsers = users2.map((user) => {
        const { password, ...safeUser } = user;
        return safeUser;
      });
      res.status(200).json(safeUsers);
    } catch (error) {
      console.error("Error fetching all users:", error);
      res.status(500).json({ message: "Error fetching users" });
    }
  });
  app2.delete("/api/admin/clean-users", async (req, res) => {
    try {
      await storage.cleanAllUsers();
      res.status(200).json({ message: "All users have been deleted" });
    } catch (error) {
      console.error("Error cleaning users:", error);
      res.status(500).json({ message: "Error cleaning users" });
    }
  });
  app2.get("/api/profile/:id", async (req, res) => {
    const userId = parseInt(req.params.id);
    if (isNaN(userId)) {
      return res.status(400).json({ message: "Invalid user ID" });
    }
    try {
      const user = await storage.getUser(userId);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }
      const { password, ...userWithoutPassword } = user;
      res.json(userWithoutPassword);
    } catch (error) {
      res.status(500).json({ message: "Server error retrieving profile" });
    }
  });
  app2.patch("/api/profile/:id", async (req, res) => {
    if (!req.isAuthenticated()) {
      return res.status(401).json({ message: "Unauthorized" });
    }
    const userId = parseInt(req.params.id);
    if (isNaN(userId) || req.user?.id !== userId) {
      return res.status(403).json({ message: "Not authorized to update this profile" });
    }
    try {
      console.log("Raw profile update request:", req.body);
      if (Object.keys(req.body).length === 1 && "visibilityPreferences" in req.body) {
        console.log("Processing visibility preferences-only update");
        try {
          const visPrefs = JSON.parse(req.body.visibilityPreferences);
          console.log("Parsed visibility preferences:", visPrefs);
        } catch (jsonError) {
          console.error("Invalid JSON in visibilityPreferences:", jsonError);
          return res.status(400).json({
            message: "visibilityPreferences must be a valid JSON string"
          });
        }
      }
      if (req.body.dateOfBirth && typeof req.body.dateOfBirth === "string") {
        req.body.dateOfBirth = new Date(req.body.dateOfBirth);
      }
      let profileData = {};
      if (req.body.profileHidden !== void 0) {
        if (typeof req.body.profileHidden === "boolean") {
          profileData.profileHidden = req.body.profileHidden;
        } else {
          return res.status(400).json({ message: "profileHidden must be a boolean" });
        }
      }
      if (req.body.ghostMode !== void 0) {
        if (typeof req.body.ghostMode === "boolean") {
          profileData.ghostMode = req.body.ghostMode;
        } else {
          return res.status(400).json({ message: "ghostMode must be a boolean" });
        }
      }
      if (req.body.hideAge !== void 0) {
        if (typeof req.body.hideAge === "boolean") {
          profileData.hideAge = req.body.hideAge;
        } else {
          return res.status(400).json({ message: "hideAge must be a boolean" });
        }
      }
      if (req.body.preferredLanguage !== void 0) {
        if (typeof req.body.preferredLanguage === "string") {
          profileData.preferredLanguage = req.body.preferredLanguage;
        } else {
          return res.status(400).json({ message: "preferredLanguage must be a string" });
        }
      }
      const otherFields = { ...req.body };
      delete otherFields.profileHidden;
      delete otherFields.ghostMode;
      delete otherFields.hideAge;
      delete otherFields.preferredLanguage;
      console.log(
        "[PROFILE-UPDATE-DEBUG] Other fields to validate:",
        otherFields
      );
      if (Object.keys(otherFields).length > 0) {
        const partialProfileSchema = userProfileSchema.partial();
        try {
          const validatedOtherFields = partialProfileSchema.parse(otherFields);
          console.log(
            "[PROFILE-UPDATE-DEBUG] Validated fields:",
            validatedOtherFields
          );
          profileData = { ...profileData, ...validatedOtherFields };
        } catch (error) {
          console.log("[PROFILE-UPDATE-DEBUG] Validation error:", error);
          return res.status(400).json({
            message: "Validation failed",
            error: error.message
          });
        }
      }
      if (Object.keys(profileData).length === 0) {
        return res.status(400).json({ message: "No data provided for update" });
      }
      if ("email" in profileData) {
        if (profileData.email === "") {
          return res.status(400).json({ message: "Email cannot be empty" });
        }
        if (profileData.email && typeof profileData.email === "string") {
          if (!profileData.email.includes("@")) {
            return res.status(400).json({ message: "Invalid email format" });
          }
        }
      }
      if ("phoneNumber" in profileData) {
        const phoneNumber = profileData.phoneNumber;
        console.log("Validating phone number:", phoneNumber);
        if (phoneNumber === "") {
          return res.status(400).json({ message: "Phone number cannot be empty" });
        }
        const existingUser = phoneNumber ? await storage.getUserByPhoneNumber(phoneNumber) : void 0;
        if (existingUser && existingUser.id !== userId) {
          return res.status(400).json({
            message: "Phone number already registered to another user"
          });
        }
        if (typeof phoneNumber === "string") {
          if (!phoneNumber.startsWith("+")) {
            return res.status(400).json({
              message: "Phone number must start with country code (e.g., +233)"
            });
          }
          const numericPart = phoneNumber.substring(1);
          if (!/^\d+$/.test(numericPart)) {
            return res.status(400).json({
              message: "Phone number must contain only digits after the country code"
            });
          }
          if (numericPart.length < 7) {
            return res.status(400).json({
              message: "Phone number must have at least 7 digits after country code"
            });
          }
          if (phoneNumber.length > 18) {
            return res.status(400).json({
              message: "Phone number is too long. Maximum length is 18 characters including the country code"
            });
          }
          const countryCodeMatch = phoneNumber.match(/^\+(\d{1,4})/);
          if (!countryCodeMatch || countryCodeMatch[1].length < 1 || countryCodeMatch[1].length > 4) {
            return res.status(400).json({
              message: "Invalid country code format. Country code should be 1-4 digits after the + sign"
            });
          }
        }
      }
      try {
        const originalUser = await storage.getUser(userId);
        if (!originalUser) {
          return res.status(404).json({ message: "User not found" });
        }
        const isVisibilityUpdate = Object.keys(profileData).length === 1 && "visibilityPreferences" in profileData;
        if (isVisibilityUpdate) {
          console.log("Updating visibility preferences only for user", userId);
        } else {
          console.log("Updating profile fields for user", userId, profileData);
        }
        const updatedUser = await storage.updateUserProfile(
          userId,
          profileData
        );
        if (!updatedUser) {
          return res.status(404).json({ message: "User not found" });
        }
        const { password, ...userWithoutPassword } = updatedUser;
        console.log("Profile updated successfully:", userWithoutPassword);
        const userAgent = req.get("User-Agent") || "Unknown";
        const ipAddress = req.ip || req.connection.remoteAddress || "Unknown";
        if ("password" in profileData) {
          console.log(
            `[SECURITY-NOTIFICATION] Sending password change notification for user ${userId}`
          );
          sendSecurityChangeNotification({
            userId,
            email: updatedUser.email,
            fullName: updatedUser.fullName,
            phoneNumber: updatedUser.phoneNumber,
            changeType: "password",
            userAgent,
            ipAddress
          }).catch((error) => {
            console.error(
              "[SECURITY-NOTIFICATION] Error sending password change notification:",
              error
            );
          });
        }
        if ("email" in profileData && originalUser.email !== profileData.email) {
          console.log(
            `[SECURITY-NOTIFICATION] Sending email change notification to PREVIOUS email for user ${userId}`
          );
          sendSecurityChangeNotification({
            userId,
            email: originalUser.email,
            // Send to OLD email (critical security requirement)
            fullName: updatedUser.fullName,
            phoneNumber: updatedUser.phoneNumber,
            changeType: "email",
            oldValue: originalUser.email,
            newValue: profileData.email,
            userAgent,
            ipAddress
          }).catch((error) => {
            console.error(
              "[SECURITY-NOTIFICATION] Error sending email change notification:",
              error
            );
          });
        }
        if ("phoneNumber" in profileData && originalUser.phoneNumber !== profileData.phoneNumber) {
          console.log(
            `[SECURITY-NOTIFICATION] Sending phone number change notification for user ${userId}`
          );
          sendSecurityChangeNotification({
            userId,
            email: updatedUser.email,
            fullName: updatedUser.fullName,
            phoneNumber: originalUser.phoneNumber,
            // Use original phone number for context
            changeType: "phone",
            oldValue: originalUser.phoneNumber || "Not set",
            newValue: profileData.phoneNumber || "Removed",
            userAgent,
            ipAddress
          }).catch((error) => {
            console.error(
              "[SECURITY-NOTIFICATION] Error sending phone number change notification:",
              error
            );
          });
        }
        if ("profileHidden" in profileData) {
          console.log(
            `User ${userId} changed profile visibility to hidden: ${profileData.profileHidden}`
          );
          if (profileVisibilityBroadcaster) {
            profileVisibilityBroadcaster(userId, profileData.profileHidden);
          }
        }
        if ("ghostMode" in profileData) {
          console.log(
            `User ${userId} changed Ghost Mode to: ${profileData.ghostMode}`
          );
          await storage.updateUserOnlineStatus(userId, !profileData.ghostMode);
          if (ghostModeBroadcaster) {
            ghostModeBroadcaster(userId, profileData.ghostMode);
            console.log(
              `Ghost Mode change broadcasted via WebSocket for user ${userId}: ghostMode=${profileData.ghostMode}`
            );
          }
        }
        return res.json(userWithoutPassword);
      } catch (storageError) {
        console.error("Storage error during profile update:", storageError);
        if (storageError instanceof Error) {
          console.error("Storage error details:", storageError.message);
          console.error("Storage error stack:", storageError.stack);
          if (storageError.message.includes("No valid values to set")) {
            return res.status(400).json({ message: "No valid values to update" });
          }
          if (storageError.message.includes("Database error")) {
            return res.status(500).json({
              message: "Database error updating profile",
              details: storageError.message
            });
          }
        }
        throw storageError;
      }
    } catch (error) {
      if (error instanceof ZodError2) {
        return res.status(400).json({ message: fromZodError2(error).message });
      }
      console.error("Profile update error:", error);
      return res.status(500).json({
        message: "Server error updating profile",
        details: error instanceof Error ? error.message : "Unknown error"
      });
    }
  });
  app2.get("/api/preferences/:userId", async (req, res) => {
    if (!req.isAuthenticated()) {
      return res.status(401).json({ message: "Unauthorized" });
    }
    const userId = parseInt(req.params.userId);
    if (isNaN(userId) || req.user?.id !== userId) {
      return res.status(403).json({ message: "Not authorized to view these preferences" });
    }
    try {
      let preferences = await storage.getUserPreferences(userId);
      if (!preferences) {
        try {
          console.log(`Creating default preferences for user ${userId}`);
          const defaultPrefs = {
            userId,
            // Set age, height, and distance preferences to NULL so new users see "Not Specified"
            minAge: null,
            maxAge: null,
            distancePreference: null,
            minHeightPreference: null,
            maxHeightPreference: null,
            religionPreference: JSON.stringify([]),
            ethnicityPreference: JSON.stringify([]),
            educationLevelPreference: JSON.stringify([]),
            highSchoolPreference: JSON.stringify([]),
            hasChildrenPreference: null,
            wantsChildrenPreference: null,
            bodyTypePreference: JSON.stringify([]),
            dealBreakers: JSON.stringify([]),
            interestPreferences: JSON.stringify([]),
            matchingPriorities: JSON.stringify([]),
            relationshipGoalPreference: null
            // Changed from "long-term" to null
          };
          preferences = await storage.createUserPreferences(defaultPrefs);
          console.log(
            `Created default preferences for user ${userId}:`,
            preferences
          );
        } catch (createError) {
          console.error(
            `Error creating default preferences for user ${userId}:`,
            createError
          );
          return res.status(404).json({
            message: "Preferences not found and could not create defaults"
          });
        }
      }
      res.json(preferences);
    } catch (error) {
      console.error("Error fetching/creating preferences:", error);
      res.status(500).json({ message: "Server error retrieving preferences" });
    }
  });
  app2.post("/api/preferences", async (req, res) => {
    if (!req.isAuthenticated()) {
      return res.status(401).json({ message: "Unauthorized" });
    }
    try {
      const preferencesData = userPreferencesSchema.parse(req.body);
      const userId = req.user.id;
      const existingPreferences = await storage.getUserPreferences(userId);
      if (existingPreferences) {
        return res.status(400).json({ message: "Preferences already exist, use PATCH to update" });
      }
      const newPreferences = await storage.createUserPreferences({
        ...preferencesData,
        userId
      });
      res.status(201).json(newPreferences);
    } catch (error) {
      if (error instanceof ZodError2) {
        return res.status(400).json({ message: fromZodError2(error).message });
      }
      res.status(500).json({ message: "Server error creating preferences" });
    }
  });
  app2.patch("/api/preferences/:id", async (req, res) => {
    if (!req.isAuthenticated()) {
      return res.status(401).json({ message: "Unauthorized" });
    }
    let preferenceId = parseInt(req.params.id);
    if (isNaN(preferenceId)) {
      return res.status(400).json({ message: "Invalid preference ID" });
    }
    try {
      let preference = await storage.getUserPreferences(req.user.id);
      if (!preference) {
        try {
          console.log(
            `Creating default preferences for user ${req.user.id} during PATCH operation`
          );
          const defaultPrefs = {
            userId: req.user.id,
            // Set age, height, and distance preferences to NULL so new users see "Not Specified"
            minAge: null,
            maxAge: null,
            distancePreference: null,
            minHeightPreference: null,
            maxHeightPreference: null,
            religionPreference: JSON.stringify([]),
            ethnicityPreference: JSON.stringify([]),
            educationLevelPreference: JSON.stringify([]),
            highSchoolPreference: JSON.stringify([]),
            hasChildrenPreference: null,
            wantsChildrenPreference: null,
            bodyTypePreference: JSON.stringify([]),
            dealBreakers: JSON.stringify([]),
            interestPreferences: JSON.stringify([]),
            matchingPriorities: JSON.stringify([]),
            relationshipGoalPreference: null
            // Changed from "long-term" to null
          };
          preference = await storage.createUserPreferences(defaultPrefs);
          console.log(
            `Created default preferences during PATCH for user ${req.user.id}:`,
            preference
          );
          preferenceId = preference.id;
        } catch (createError) {
          console.error(
            `Error creating default preferences for user ${req.user.id}:`,
            createError
          );
          return res.status(500).json({ message: "Failed to create preferences before update" });
        }
      } else if (preference.id !== preferenceId) {
        return res.status(403).json({ message: "Not authorized to update these preferences" });
      }
      const preferencesData = userPreferencesSchema.partial().parse(req.body);
      const updatedPreferences = await storage.updateUserPreferences(
        preferenceId,
        preferencesData
      );
      if (!updatedPreferences) {
        return res.status(404).json({ message: "Preferences not found" });
      }
      res.json(updatedPreferences);
    } catch (error) {
      if (error instanceof ZodError2) {
        return res.status(400).json({ message: fromZodError2(error).message });
      }
      res.status(500).json({ message: "Server error updating preferences" });
    }
  });
  app2.put(
    "/api/user/nationality",
    requireAuth,
    async (req, res) => {
      try {
        const { nationality } = req.body;
        if (!nationality || typeof nationality !== "string") {
          return res.status(400).json({ message: "Nationality is required and must be a string" });
        }
        const userId = req.user?.id;
        if (!userId) {
          return res.status(401).json({ message: "User not authenticated" });
        }
        const updatedUser = await storage.updateUserProfile(userId, {
          countryOfOrigin: nationality
        });
        if (!updatedUser) {
          return res.status(404).json({ message: "User not found" });
        }
        try {
          await storage.updateUserLocationPreference(userId, nationality);
          console.log(
            `[NATIONALITY] Updated user ${userId} location preference to: ${nationality}`
          );
        } catch (prefError) {
          console.warn(
            `[NATIONALITY] Failed to update location preference for user ${userId}:`,
            prefError
          );
        }
        console.log(
          `[NATIONALITY] Updated user ${userId} nationality to: ${nationality}`
        );
        res.status(200).json({
          message: "Nationality updated successfully",
          nationality: updatedUser.countryOfOrigin
        });
      } catch (error) {
        console.error("Error updating user nationality:", error);
        res.status(500).json({ message: "Error updating nationality" });
      }
    }
  );
  app2.put(
    "/api/user/pool-country",
    requireAuth,
    async (req, res) => {
      try {
        const { poolCountry, appMode } = req.body;
        if (!poolCountry || typeof poolCountry !== "string") {
          return res.status(400).json({ message: "Pool country is required and must be a string" });
        }
        if (!appMode || !["MEET", "SUITE"].includes(appMode)) {
          return res.status(400).json({
            message: "App mode is required and must be 'MEET' or 'SUITE'"
          });
        }
        const userId = req.user?.id;
        if (!userId) {
          return res.status(401).json({ message: "User not authenticated" });
        }
        const updatedPreference = await storage.updateUserAppSpecificPoolCountry(
          userId,
          poolCountry,
          appMode
        );
        if (!updatedPreference) {
          return res.status(404).json({ message: "Failed to update pool country preference" });
        }
        const fieldName = appMode === "MEET" ? "meetPoolCountry" : "suitePoolCountry";
        const updatedValue = appMode === "MEET" ? updatedPreference.meetPoolCountry : updatedPreference.suitePoolCountry;
        console.log(
          `[POOL-COUNTRY] Updated user ${userId} ${appMode} pool country to: ${poolCountry}`
        );
        res.status(200).json({
          message: "Pool country updated successfully",
          appMode,
          poolCountry: updatedValue,
          [fieldName]: updatedValue
        });
      } catch (error) {
        console.error("Error updating user pool country:", error);
        res.status(500).json({ message: "Error updating pool country" });
      }
    }
  );
  app2.get(
    "/api/user/pool-country",
    requireAuth,
    async (req, res) => {
      try {
        const userId = req.user?.id;
        if (!userId) {
          return res.status(401).json({ message: "User not authenticated" });
        }
        const preferences = await storage.getUserPreferences(userId);
        if (!preferences) {
          return res.status(404).json({ message: "User preferences not found" });
        }
        console.log(
          `[POOL-COUNTRY] Retrieved pool countries for user ${userId}`
        );
        res.status(200).json({
          meetPoolCountry: preferences.meetPoolCountry || "ANYWHERE",
          suitePoolCountry: preferences.suitePoolCountry || "ANYWHERE",
          // Legacy field for backward compatibility
          poolCountry: preferences.poolCountry || "ANYWHERE"
        });
      } catch (error) {
        console.error("Error getting user pool country:", error);
        res.status(500).json({ message: "Error getting pool country" });
      }
    }
  );
  app2.get("/api/discover-users", async (req, res) => {
    if (!req.isAuthenticated()) {
      return res.status(401).json({ message: "Unauthorized", status: "login_required" });
    }
    try {
      const currentUserId = req.user?.id;
      if (!currentUserId) {
        return res.status(400).json({ message: "Invalid user ID" });
      }
      const discoverUsers = await storage.getDiscoverUsers(currentUserId);
      res.status(200).json(discoverUsers);
    } catch (error) {
      console.error("Error fetching discover users:", error);
      res.status(500).json({ message: "Error fetching users for discover page" });
    }
  });
  app2.get("/api/liked-by/:userId", async (req, res) => {
    if (!req.isAuthenticated()) {
      return res.status(401).json({ message: "Unauthorized" });
    }
    try {
      const userId = parseInt(req.params.userId);
      if (userId !== req.user.id) {
        return res.status(403).json({ message: "Not authorized to view these likes" });
      }
      const matches2 = await storage.getMatchesByUserId(userId);
      const likedByMatches = matches2.filter(
        (match) => match.userId2 === userId && !match.matched
      );
      const likedByUsers = await Promise.all(
        likedByMatches.map(async (match) => {
          const otherUserId = match.userId1;
          const otherUser = await storage.getUser(otherUserId);
          if (!otherUser) return null;
          const { password, ...userWithoutPassword } = otherUser;
          if (userWithoutPassword.ghostMode) {
            userWithoutPassword.isOnline = false;
          }
          let age = void 0;
          if (userWithoutPassword.dateOfBirth) {
            const birthDate = new Date(userWithoutPassword.dateOfBirth);
            const today = /* @__PURE__ */ new Date();
            age = today.getFullYear() - birthDate.getFullYear();
            const m = today.getMonth() - birthDate.getMonth();
            if (m < 0 || m === 0 && today.getDate() < birthDate.getDate()) {
              age--;
            }
          }
          return {
            id: match.id,
            // Using match id as a unique identifier
            matchId: match.id,
            userId: otherUserId,
            fullName: userWithoutPassword.fullName,
            photoUrl: userWithoutPassword.photoUrl,
            age,
            location: userWithoutPassword.location,
            bio: userWithoutPassword.bio,
            compatibility: Math.random() * 0.4 + 0.6
            // Just for demo - this should be calculated properly
          };
        })
      );
      const validLikedByUsers = likedByUsers.filter((user) => user !== null);
      res.json(validLikedByUsers);
    } catch (error) {
      console.error(
        "Error retrieving users who liked the current user:",
        error
      );
      res.status(500).json({ message: "Server error retrieving users who liked you" });
    }
  });
  app2.get("/api/match/:matchId", async (req, res) => {
    if (!req.isAuthenticated()) {
      return res.status(401).json({ message: "Unauthorized" });
    }
    const matchId = parseInt(req.params.matchId);
    const userId = req.user.id;
    if (isNaN(matchId)) {
      return res.status(400).json({ message: "Invalid match ID" });
    }
    try {
      const match = await storage.getMatchById(matchId);
      if (!match) {
        return res.status(404).json({ message: "Match not found" });
      }
      if (match.userId1 !== userId && match.userId2 !== userId) {
        return res.status(403).json({ message: "Not authorized to access this match" });
      }
      const otherUserId = match.userId1 === userId ? match.userId2 : match.userId1;
      const otherUser = await storage.getUser(otherUserId);
      const enrichedMatch = {
        ...match,
        otherUser: otherUser ? {
          id: otherUser.id,
          fullName: otherUser.fullName,
          photoUrl: otherUser.photoUrl,
          bio: otherUser.bio,
          profession: otherUser.profession,
          location: otherUser.location
        } : null
      };
      res.json(enrichedMatch);
    } catch (error) {
      console.error("Error retrieving match:", error);
      res.status(500).json({ message: "Server error retrieving match" });
    }
  });
  app2.get(
    "/api/matches/between/:userId",
    async (req, res) => {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      try {
        const currentUserId = req.user.id;
        const otherUserId = parseInt(req.params.userId);
        if (isNaN(otherUserId)) {
          return res.status(400).json({ message: "Invalid user ID" });
        }
        console.log(
          `Fetching all matches between users ${currentUserId} and ${otherUserId}`
        );
        const allMatches = await storage.getAllMatchesBetweenUsers(
          currentUserId,
          otherUserId
        );
        console.log(
          `Found ${allMatches.length} matches between users ${currentUserId} and ${otherUserId}`
        );
        res.json(allMatches);
      } catch (error) {
        console.error("Error fetching matches between users:", error);
        res.status(500).json({ message: "Server error retrieving matches" });
      }
    }
  );
  app2.get("/api/matches", async (req, res) => {
    if (!req.isAuthenticated()) {
      return res.status(401).json({ message: "Unauthorized" });
    }
    const startTime = Date.now();
    try {
      const userId = req.user.id;
      console.log(
        `[MATCH-PERFORMANCE] Starting optimized matches fetch for user ${userId}`
      );
      const optimizedMatches = await storage.getMatches(userId);
      if (optimizedMatches.length === 0) {
        console.log(`[MATCH-PERFORMANCE] No matches found for user ${userId}`);
        return res.json([]);
      }
      const enrichedMatches = await Promise.all(
        optimizedMatches.map(async (match) => {
          const otherUserId = match.userId1 === userId ? match.userId2 : match.userId1;
          const otherUser = await storage.getUser(otherUserId);
          return {
            ...match,
            user: otherUser ? {
              id: otherUser.id,
              fullName: otherUser.fullName,
              photoUrl: otherUser.photoUrl,
              bio: otherUser.bio,
              profession: otherUser.profession,
              location: otherUser.location
            } : null
          };
        })
      );
      const confirmedMatches = enrichedMatches.filter((match) => match.matched);
      const pendingLikes = enrichedMatches.filter((match) => {
        if (match.matched || match.isDislike) return false;
        if (match.metadata) {
          try {
            const metadata = typeof match.metadata === "string" ? JSON.parse(match.metadata) : match.metadata;
            if (metadata && metadata.suiteType) {
              console.log(
                `[SUITE-MATCH-DEBUG] Found SUITE match ${match.id} for user ${userId}, showing bidirectionally`
              );
              return true;
            }
          } catch (e) {
            console.error(
              `[SUITE-MATCH-DEBUG] Failed to parse metadata for match ${match.id}:`,
              e
            );
          }
        }
        return match.userId1 !== userId && match.userId2 === userId;
      }).sort((a, b) => {
        if (a.createdAt && b.createdAt) {
          return new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime();
        }
        return b.id - a.id;
      });
      const confirmedMatchesWithType = confirmedMatches.filter((match) => match.user).map((match) => ({
        ...match,
        matchType: "confirmed"
      }));
      const pendingLikesWithType = pendingLikes.filter((match) => match.user).map((match) => ({
        ...match,
        matchType: "pending"
      }));
      const allMatches = [...confirmedMatchesWithType, ...pendingLikesWithType];
      const endTime = Date.now();
      const executionTime = endTime - startTime;
      console.log(
        `[MATCH-PERFORMANCE] \u26A1 Optimized matches fetch completed in ${executionTime}ms for user ${userId}`
      );
      console.log(
        `[MATCH-PERFORMANCE] \u2705 Returning ${allMatches.length} matches (${confirmedMatchesWithType.length} confirmed, ${pendingLikesWithType.length} pending)`
      );
      res.json(allMatches);
    } catch (error) {
      const endTime = Date.now();
      const executionTime = endTime - startTime;
      console.error(
        `[MATCH-PERFORMANCE] \u274C Error in optimized matches fetch after ${executionTime}ms:`,
        error
      );
      res.status(500).json({ message: "Server error retrieving matches" });
    }
  });
  app2.delete("/api/matches/:id", async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ message: "Unauthorized", success: false });
      }
      const matchId = parseInt(req.params.id);
      if (isNaN(matchId)) {
        return res.status(400).json({ message: "Invalid match ID", success: false });
      }
      const match = await storage.getMatchById(matchId);
      if (!match) {
        return res.status(404).json({ message: "Match not found", success: false });
      }
      if (match.userId1 !== req.user.id && match.userId2 !== req.user.id) {
        return res.status(403).json({
          message: "Not authorized to delete this match",
          success: false
        });
      }
      const currentUserId = req.user.id;
      const otherUserId = match.userId1 === currentUserId ? match.userId2 : match.userId1;
      console.log(
        `[SWIPE] User ${currentUserId} disliked user ${otherUserId} via Matches page`
      );
      await storage.deleteMatch(matchId);
      try {
        await storage.createMatch({
          userId1: currentUserId,
          userId2: otherUserId,
          matched: false,
          isDislike: true,
          metadata: JSON.stringify({ origin: "MEET" })
        });
        console.log(
          `[SWIPE] Created dislike record: ${currentUserId} -> ${otherUserId}`
        );
      } catch (error) {
        if (error instanceof Error && error.message.includes("duplicate")) {
          console.log(
            `[SWIPE] Dislike record ${currentUserId} -> ${otherUserId} already exists`
          );
        } else {
          throw error;
        }
      }
      try {
        await storage.createMatch({
          userId1: otherUserId,
          userId2: currentUserId,
          matched: false,
          isDislike: true,
          metadata: JSON.stringify({ origin: "MEET" })
        });
        console.log(
          `[SWIPE] Created bidirectional dislike record: ${otherUserId} -> ${currentUserId}`
        );
      } catch (error) {
        if (error instanceof Error && error.message.includes("duplicate")) {
          console.log(
            `[SWIPE] Bidirectional dislike record ${otherUserId} -> ${currentUserId} already exists`
          );
        } else {
          throw error;
        }
      }
      if (connectedUsers4) {
        const otherUserSocket = connectedUsers4.get(otherUserId);
        if (otherUserSocket && otherUserSocket.readyState === WebSocket4.OPEN) {
          otherUserSocket.send(
            JSON.stringify({
              type: "swipe_action",
              action: "dislike",
              targetUserId: currentUserId,
              fromUserId: currentUserId
            })
          );
          console.log(
            `[SWIPE] Notified user ${otherUserId} about dislike action from user ${currentUserId}`
          );
        }
        const currentUserSocket = connectedUsers4.get(currentUserId);
        if (currentUserSocket && currentUserSocket.readyState === WebSocket4.OPEN) {
          currentUserSocket.send(
            JSON.stringify({
              type: "discover:refresh",
              reason: "dislike_action",
              timestamp: (/* @__PURE__ */ new Date()).toISOString()
            })
          );
        }
      }
      return res.status(200).json({ message: "Match deleted successfully", success: true });
    } catch (error) {
      console.error("Error deleting match:", error);
      const errorMessage = error instanceof Error ? error.message : "Unknown error";
      return res.status(500).json({
        message: "Server error deleting match",
        error: errorMessage,
        success: false
      });
    }
  });
  app2.post("/api/matches/:id/unmatch", async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ message: "Unauthorized", success: false });
      }
      const matchId = parseInt(req.params.id);
      if (isNaN(matchId)) {
        return res.status(400).json({ message: "Invalid match ID", success: false });
      }
      const match = await storage.getMatchById(matchId);
      if (!match) {
        return res.status(404).json({ message: "Match not found", success: false });
      }
      if (match.userId1 !== req.user.id && match.userId2 !== req.user.id) {
        return res.status(403).json({ message: "Not authorized to unmatch", success: false });
      }
      const currentUserId = req.user.id;
      const otherUserId = match.userId1 === currentUserId ? match.userId2 : match.userId1;
      const { sendUnmatchNotification: sendUnmatchNotification2 } = await Promise.resolve().then(() => (init_match_api(), match_api_exports));
      console.log(
        `[UNMATCH] Starting comprehensive archival for match ${matchId}`
      );
      let archivedMatchId = null;
      let messageCount = 0;
      try {
        const { ArchivingService: ArchivingService2 } = await Promise.resolve().then(() => (init_archiving_service(), archiving_service_exports));
        const archiveResult = await ArchivingService2.archiveMatchWithMessages(
          matchId,
          currentUserId,
          "unmatch"
        );
        archivedMatchId = archiveResult.archivedMatchId;
        messageCount = archiveResult.messageCount;
        console.log(
          `[UNMATCH] Successfully archived match ${matchId} as archive ${archivedMatchId} with ${messageCount} messages`
        );
      } catch (archiveError) {
        console.error(
          `[UNMATCH] Failed to archive match ${matchId}:`,
          archiveError
        );
      }
      await db.delete(typingStatus).where(eq6(typingStatus.matchId, matchId));
      await db.delete(videoCalls).where(eq6(videoCalls.matchId, matchId));
      const messages2 = await storage.getMessagesByMatchId(matchId);
      if (messages2 && messages2.length > 0) {
        for (const message of messages2) {
          await db.delete(messages).where(eq6(messages.id, message.id));
        }
      }
      await storage.deleteMatch(matchId);
      console.log(
        `[UNMATCH] Creating bidirectional dislike records for users ${currentUserId} and ${otherUserId}`
      );
      try {
        await db.insert(matches).values({
          userId1: currentUserId,
          userId2: otherUserId,
          matched: false,
          isDislike: true,
          createdAt: /* @__PURE__ */ new Date()
        });
        await db.insert(matches).values({
          userId1: otherUserId,
          userId2: currentUserId,
          matched: false,
          isDislike: true,
          createdAt: /* @__PURE__ */ new Date()
        });
        console.log(
          `[UNMATCH] \u2705 Bidirectional dislike records created successfully - users ${currentUserId} and ${otherUserId} will never appear in each other's discovery again`
        );
      } catch (dislikeError) {
        console.error(
          `[UNMATCH] \u274C Failed to create dislike records:`,
          dislikeError
        );
      }
      console.log(
        `Sending unmatch notification to user ${otherUserId} about match ${matchId}`
      );
      await sendUnmatchNotification2(otherUserId, matchId, currentUserId);
      const responseData = {
        message: "Unmatched successfully",
        success: true
      };
      if (archivedMatchId) {
        responseData.archived = {
          matchId: archivedMatchId,
          messageCount,
          timestamp: (/* @__PURE__ */ new Date()).toISOString()
        };
      }
      return res.status(200).json(responseData);
    } catch (error) {
      console.error("Error unmatching:", error);
      const errorMessage = error instanceof Error ? error.message : "Unknown error";
      return res.status(500).json({
        message: "Server error unmatching",
        error: errorMessage,
        success: false
      });
    }
  });
  app2.post(
    "/api/report-user",
    requireAuth,
    async (req, res) => {
      try {
        const reportingUserId = req.user.id;
        const dataWithReporter = {
          ...req.body,
          reporterUserId: reportingUserId
        };
        const validatedData = insertUserReportStrikeSchema.parse(dataWithReporter);
        if (reportingUserId === validatedData.reportedUserId) {
          return res.status(400).json({
            message: "Cannot report yourself",
            success: false
          });
        }
        const reportedUser = await storage.getUser(
          validatedData.reportedUserId
        );
        if (!reportedUser) {
          return res.status(404).json({
            message: "Reported user not found",
            success: false
          });
        }
        let matchId = void 0;
        if (validatedData.matchId) {
          const match = await storage.getMatchById(validatedData.matchId);
          if (match && (match.userId1 === reportingUserId && match.userId2 === validatedData.reportedUserId || match.userId2 === reportingUserId && match.userId1 === validatedData.reportedUserId)) {
            matchId = validatedData.matchId;
          }
        }
        console.log(
          `[REPORT-USER] User ${reportingUserId} reporting user ${validatedData.reportedUserId} for: ${validatedData.reason}`
        );
        const reportStrike = await storage.createUserReportStrike({
          reporterUserId: validatedData.reporterUserId,
          reportedUserId: validatedData.reportedUserId,
          reason: validatedData.reason,
          description: validatedData.description,
          matchId
        });
        const totalStrikes = await storage.getUserReportStrikeCount(
          validatedData.reportedUserId
        );
        console.log(
          `[REPORT-USER] Report created successfully. User ${validatedData.reportedUserId} now has ${totalStrikes} total strikes`
        );
        if (matchId) {
          try {
            console.log(
              `[REPORT-USER] Unmatching users ${reportingUserId} and ${validatedData.reportedUserId} due to report`
            );
            const { ArchivingService: ArchivingService2 } = await Promise.resolve().then(() => (init_archiving_service(), archiving_service_exports));
            await ArchivingService2.archiveMatchWithMessages(
              matchId,
              reportingUserId,
              "user_deletion"
            );
            await storage.deleteMatch(matchId);
            await db.insert(matches).values([
              {
                userId1: reportingUserId,
                userId2: validatedData.reportedUserId,
                matched: false,
                isDislike: true,
                createdAt: /* @__PURE__ */ new Date()
              },
              {
                userId1: validatedData.reportedUserId,
                userId2: reportingUserId,
                matched: false,
                isDislike: true,
                createdAt: /* @__PURE__ */ new Date()
              }
            ]);
            console.log(
              `[REPORT-USER] Successfully unmatched and created dislike records`
            );
          } catch (unmatchError) {
            console.error(
              `[REPORT-USER] Error during unmatch process:`,
              unmatchError
            );
          }
        }
        if (totalStrikes >= 3) {
          console.log(
            `[REPORT-USER] User ${validatedData.reportedUserId} reached suspension threshold with ${totalStrikes} strikes`
          );
          try {
            const suspensionExpiresAt = /* @__PURE__ */ new Date();
            suspensionExpiresAt.setDate(suspensionExpiresAt.getDate() + 3);
            await storage.updateUserProfile(validatedData.reportedUserId, {
              isSuspended: true,
              suspendedAt: /* @__PURE__ */ new Date(),
              suspensionExpiresAt
            });
            console.log(
              `[REPORT-USER] User ${validatedData.reportedUserId} suspended until ${suspensionExpiresAt.toISOString()}`
            );
            const { sendEmail: sendEmail2 } = await Promise.resolve().then(() => (init_sendgrid(), sendgrid_exports));
            const emailContent = `
            <div style="font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; max-width: 600px; margin: 0 auto; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); border-radius: 20px; overflow: hidden; box-shadow: 0 20px 40px rgba(0,0,0,0.1);">
              <div style="background: linear-gradient(90deg, #ff6b6b, #4ecdc4, #45b7d1, #96ceb4, #ffeaa7, #dda0dd, #98d8c8); height: 6px;"></div>
              
              <div style="padding: 40px; text-align: center; background: white;">
                <h1 style="color: #333; margin: 0 0 20px 0; font-size: 28px; font-weight: 700;">
                  \u{1F6A8} Account Suspension Notice
                </h1>
                
                <div style="background: linear-gradient(135deg, #ff6b6b, #ee5a52); padding: 20px; border-radius: 12px; margin: 20px 0;">
                  <h2 style="color: white; margin: 0; font-size: 18px;">
                    Your CHARLEY account has been suspended
                  </h2>
                </div>

                <p style="color: #555; font-size: 16px; line-height: 1.6; margin: 20px 0;">
                  Dear ${reportedUser.fullName},
                </p>

                <p style="color: #555; font-size: 16px; line-height: 1.6; margin: 20px 0;">
                  Your account has been suspended due to multiple reports received regarding your behavior on the platform. 
                  You have accumulated <strong>${totalStrikes} reports</strong>, which violates our community guidelines.
                </p>

                <div style="background: #f8f9fa; padding: 20px; border-radius: 8px; margin: 20px 0;">
                  <h3 style="color: #333; margin: 0 0 10px 0;">Suspension Details:</h3>
                  <p style="color: #666; margin: 5px 0;"><strong>Duration:</strong> 3 days</p>
                  <p style="color: #666; margin: 5px 0;"><strong>Reason:</strong> Multiple user reports</p>
                  <p style="color: #666; margin: 5px 0;"><strong>Total Reports:</strong> ${totalStrikes}</p>
                </div>

                <p style="color: #555; font-size: 16px; line-height: 1.6; margin: 20px 0;">
                  If you believe this suspension is incorrect, you can appeal by contacting our support team at 
                  <a href="mailto:admin@kronogon.com" style="color: #667eea;">admin@kronogon.com</a>
                </p>

                <div style="margin: 30px 0;">
                  <p style="color: #999; font-size: 14px; margin: 0;">
                    BTechnos Team<br>
                    CHARLEY Dating Platform
                  </p>
                </div>
              </div>
            </div>
          `;
            await sendEmail2(process.env.SENDGRID_API_KEY, {
              to: reportedUser.email,
              from: "admin@kronogon.com",
              subject: "\u{1F6A8} CHARLEY Account Suspension Notice",
              html: emailContent,
              text: `Your CHARLEY account has been suspended due to multiple reports. You have ${totalStrikes} total reports. Contact admin@kronogon.com to appeal.`
            });
            console.log(
              `[REPORT-USER] Suspension email sent to ${reportedUser.email}`
            );
          } catch (emailError) {
            console.error(
              `[REPORT-USER] Failed to send suspension email:`,
              emailError
            );
          }
        }
        return res.status(201).json({
          message: "Report submitted successfully",
          success: true,
          reportId: reportStrike.id,
          totalStrikes,
          suspended: totalStrikes >= 3
        });
      } catch (error) {
        console.error("Error creating report:", error);
        if (error instanceof ZodError2) {
          return res.status(400).json({
            message: "Validation failed",
            errors: fromZodError2(error).details,
            success: false
          });
        }
        const errorMessage = error instanceof Error ? error.message : "Unknown error";
        return res.status(500).json({
          message: "Server error creating report",
          error: errorMessage,
          success: false
        });
      }
    }
  );
  app2.post("/api/suspension/appeal", async (req, res) => {
    if (!req.isAuthenticated()) {
      return res.status(401).json({ message: "Unauthorized" });
    }
    try {
      const { message } = req.body;
      const userId = req.user.id;
      if (!message || typeof message !== "string" || message.trim().length === 0) {
        return res.status(400).json({
          message: "Appeal message is required",
          success: false
        });
      }
      const user = await storage.getUser(userId);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }
      try {
        const { sendEmail: sendEmail2 } = await Promise.resolve().then(() => (init_sendgrid(), sendgrid_exports));
        const emailContent = `
          <div style="font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; max-width: 600px; margin: 0 auto; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); border-radius: 20px; overflow: hidden; box-shadow: 0 20px 40px rgba(0,0,0,0.1);">
            <div style="background: linear-gradient(90deg, #ff6b6b, #4ecdc4, #45b7d1, #96ceb4, #ffeaa7, #dda0dd, #98d8c8); height: 6px;"></div>
            
            <div style="padding: 40px; text-align: center; background: white;">
              <h1 style="color: #333; margin: 0 0 20px 0; font-size: 28px; font-weight: 700;">
                \u{1F4DD} Suspension Appeal Request
              </h1>
              
              <div style="background: linear-gradient(135deg, #4ecdc4, #45b7d1); padding: 20px; border-radius: 12px; margin: 20px 0;">
                <h2 style="color: white; margin: 0; font-size: 18px;">
                  Appeal from suspended user
                </h2>
              </div>

              <div style="background: #f8f9fa; padding: 20px; border-radius: 8px; margin: 20px 0; text-align: left;">
                <h3 style="color: #333; margin: 0 0 10px 0;">User Details:</h3>
                <p style="color: #666; margin: 5px 0;"><strong>User ID:</strong> ${userId}</p>
                <p style="color: #666; margin: 5px 0;"><strong>Name:</strong> ${user.fullName}</p>
                <p style="color: #666; margin: 5px 0;"><strong>Email:</strong> ${user.email}</p>
                <p style="color: #666; margin: 5px 0;"><strong>Phone:</strong> ${user.phoneNumber || "Not provided"}</p>
              </div>

              <div style="background: #fff3cd; padding: 20px; border-radius: 8px; margin: 20px 0; text-align: left;">
                <h3 style="color: #333; margin: 0 0 10px 0;">Appeal Message:</h3>
                <p style="color: #856404; line-height: 1.6; white-space: pre-wrap;">${message.trim()}</p>
              </div>

              <div style="margin: 30px 0;">
                <p style="color: #999; font-size: 14px; margin: 0;">
                  BTechnos Admin Team<br>
                  CHARLEY Dating Platform
                </p>
              </div>
            </div>
          </div>
        `;
        await sendEmail2(process.env.SENDGRID_API_KEY, {
          to: "admin@kronogon.com",
          from: "admin@kronogon.com",
          subject: `\u{1F6A8} Suspension Appeal - ${user.fullName} (ID: ${userId})`,
          html: emailContent,
          text: `Suspension Appeal Request

User: ${user.fullName} (ID: ${userId})
Email: ${user.email}
Phone: ${user.phoneNumber || "Not provided"}

Message:
${message.trim()}`
        });
        console.log(
          `[SUSPENSION-APPEAL] Appeal submitted by user ${userId} sent to admin`
        );
        return res.status(200).json({
          message: "Appeal submitted successfully",
          success: true
        });
      } catch (emailError) {
        console.error(
          `[SUSPENSION-APPEAL] Failed to send appeal email:`,
          emailError
        );
        return res.status(500).json({
          message: "Failed to send appeal. Please try again later.",
          success: false
        });
      }
    } catch (error) {
      console.error("Error processing suspension appeal:", error);
      const errorMessage = error instanceof Error ? error.message : "Unknown error";
      return res.status(500).json({
        message: "Server error processing appeal",
        error: errorMessage,
        success: false
      });
    }
  });
  app2.get(
    "/api/match-dashboard/:matchId",
    async (req, res) => {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      try {
        const matchId = parseInt(req.params.matchId);
        const userId = req.user.id;
        if (isNaN(matchId)) {
          return res.status(400).json({ message: "Invalid match ID" });
        }
        const match = await storage.getMatchById(matchId);
        if (!match) {
          return res.status(404).json({ message: "Match not found" });
        }
        if (match.userId1 !== userId && match.userId2 !== userId) {
          return res.status(403).json({ message: "Not authorized to view this match dashboard" });
        }
        const otherUserId = match.userId1 === userId ? match.userId2 : match.userId1;
        const otherUser = await storage.getUser(otherUserId);
        if (!otherUser) {
          return res.status(404).json({ message: "Match user not found" });
        }
        const { password, ...otherUserWithoutPassword } = otherUser;
        const dashboardData = {
          matchId,
          matchUser: {
            id: otherUserWithoutPassword.id,
            fullName: otherUserWithoutPassword.fullName,
            photoUrl: otherUserWithoutPassword.photoUrl || "https://via.placeholder.com/150"
          },
          overallScore: 71,
          // This will come from GPT model
          // All other data will be populated by GPT model integration
          coreCompatibility: [],
          loveLanguages: [],
          personalityTraits: [],
          culturalFactors: [],
          lifestyleActivities: [],
          interactionMetrics: [],
          idealDateSuggestion: "Data will be provided by AI analysis system"
        };
        res.json(dashboardData);
      } catch (error) {
        console.error("Error retrieving match dashboard data:", error);
        res.status(500).json({ message: "Server error retrieving match dashboard data" });
      }
    }
  );
  app2.get("/api/potential-matches", async (req, res) => {
    if (!req.isAuthenticated()) {
      return res.status(401).json({ message: "Unauthorized" });
    }
    try {
      const userId = req.user.id;
      const potentialMatches = await storage.getPotentialMatches(userId);
      const sanitizedMatches = potentialMatches.map((user) => {
        const { password, ...userWithoutPassword } = user;
        return userWithoutPassword;
      });
      res.json(sanitizedMatches);
    } catch (error) {
      res.status(500).json({ message: "Server error retrieving potential matches" });
    }
  });
  app2.get("/api/messages/:matchId", async (req, res) => {
    if (!req.isAuthenticated()) {
      return res.status(401).json({ message: "Unauthorized" });
    }
    const matchId = parseInt(req.params.matchId);
    const userId = req.user.id;
    if (isNaN(matchId)) {
      return res.status(400).json({ message: "Invalid match ID" });
    }
    try {
      const match = await storage.getMatchById(matchId);
      if (!match) {
        return res.status(404).json({ message: "Match not found" });
      }
      if (match.userId1 !== userId && match.userId2 !== userId) {
        return res.status(403).json({ message: "Not authorized to view these messages" });
      }
      const messages2 = await storage.getMessagesByMatchId(matchId, userId);
      for (const message of messages2) {
        if (message.receiverId === userId && !message.read) {
          await storage.markMessageAsReadWithTimestamp(message.id);
        }
      }
      await storage.markMatchRead(matchId, userId);
      res.json(messages2);
    } catch (error) {
      console.error("Error retrieving messages:", error);
      res.status(500).json({ message: "Server error retrieving messages" });
    }
  });
  app2.get("/api/messages", async (req, res) => {
    if (!req.isAuthenticated()) {
      return res.status(401).json({ message: "Unauthorized" });
    }
    try {
      const userId = req.user.id;
      const matches2 = await storage.getMatchesByUserId(userId);
      const confirmedMatches = matches2.filter((match) => match.matched);
      const allMessages = await Promise.all(
        confirmedMatches.map(async (match) => {
          const messages2 = await storage.getMessagesByMatchId(match.id, userId);
          const hasUnreadMessages = match.userId1 === userId ? match.hasUnreadMessages1 : match.hasUnreadMessages2;
          return {
            matchId: match.id,
            messages: messages2,
            hasUnreadMessages,
            lastMessageAt: match.lastMessageAt
          };
        })
      );
      console.log(
        `User ${userId} fetched messages for ${confirmedMatches.length} matches`
      );
      res.json(allMessages);
    } catch (error) {
      console.error("Error fetching all messages:", error);
      res.status(500).json({ message: "Server error retrieving messages" });
    }
  });
  app2.get("/api/messages/unread/count", async (req, res) => {
    if (!req.isAuthenticated()) {
      return res.status(401).json({ message: "Unauthorized" });
    }
    try {
      const userId = req.user.id;
      const mode = req.query.mode || "MEET";
      console.log(
        `Fetching unread message count for user ${userId} in mode ${mode}`
      );
      const conversationsWithUnread = await storage.getUnreadConversationsCount(userId);
      console.log(
        `[API] Returning unread count for ${mode} mode: ${conversationsWithUnread}`
      );
      res.json({ count: conversationsWithUnread });
    } catch (error) {
      console.error("Error fetching unread message count:", error);
      res.status(500).json({ message: "Server error retrieving unread count" });
    }
  });
  app2.post("/api/messages", async (req, res) => {
    if (!req.isAuthenticated()) {
      return res.status(401).json({ message: "Unauthorized" });
    }
    try {
      const messageData = insertMessageSchema.parse(req.body);
      if (messageData.senderId !== req.user.id) {
        return res.status(403).json({ message: "Not authorized to send message as this user" });
      }
      const match = await storage.getMatchById(messageData.matchId);
      if (!match) {
        return res.status(404).json({ message: "Match not found" });
      }
      if (match.userId1 !== req.user.id && match.userId2 !== req.user.id) {
        return res.status(403).json({ message: "Not authorized to send message in this match" });
      }
      const validReceiver = match.userId1 === messageData.receiverId || match.userId2 === messageData.receiverId;
      if (!validReceiver) {
        return res.status(400).json({ message: "Receiver is not part of this match" });
      }
      const newMessage = await storage.createMessage(messageData);
      res.status(201).json(newMessage);
    } catch (error) {
      if (error instanceof ZodError2) {
        return res.status(400).json({ message: fromZodError2(error).message });
      }
      res.status(500).json({ message: "Server error creating message" });
    }
  });
  app2.post("/api/messages/:matchId", async (req, res) => {
    if (!req.isAuthenticated()) {
      return res.status(401).json({ message: "Unauthorized" });
    }
    try {
      const matchId = parseInt(req.params.matchId);
      if (isNaN(matchId)) {
        return res.status(400).json({ message: "Invalid match ID" });
      }
      const {
        content,
        receiverId,
        messageType,
        audioUrl,
        audioDuration,
        replyToMessageId,
        replyToMessage
      } = req.body;
      console.log("Message content received:", {
        contentType: typeof content,
        content: typeof content === "string" ? content.length > 30 ? content.substring(0, 30) + "..." : content : content,
        receiverId,
        messageType
      });
      if (!content || typeof content !== "string" || content.trim().length === 0) {
        console.error("Message content is null or empty:", {
          content,
          contentType: typeof content
        });
        return res.status(400).json({
          message: "Message content is required and must be a non-empty string"
        });
      }
      const match = await storage.getMatchById(matchId);
      if (!match) {
        return res.status(404).json({ message: "Match not found" });
      }
      if (match.userId1 !== req.user.id && match.userId2 !== req.user.id) {
        return res.status(403).json({ message: "Not authorized to send message in this match" });
      }
      const validReceiver = match.userId1 === receiverId || match.userId2 === receiverId;
      if (!validReceiver) {
        return res.status(400).json({ message: "Receiver is not part of this match" });
      }
      const trimmedContent = content.trim();
      try {
        console.log(
          `[DUPLICATE-PREVENTION] Checking for duplicates, content: "${trimmedContent.substring(0, 20)}..."`
        );
        const longWindow = /* @__PURE__ */ new Date();
        longWindow.setMinutes(longWindow.getMinutes() - 5);
        const longWindowStr = longWindow.toISOString();
        const exactDuplicates = await storage.findRecentDuplicateMessages({
          matchId,
          senderId: req.user.id,
          content: trimmedContent,
          messageType: messageType || "text",
          since: longWindowStr
        });
        if (exactDuplicates && exactDuplicates.length > 0) {
          const duplicateMessage = exactDuplicates[0];
          console.log(
            `[DUPLICATE-PREVENTION] BLOCKED: Found exact duplicate message ${duplicateMessage.id} from ${duplicateMessage.createdAt}`
          );
          res.setHeader("X-Duplicate-Message", "true");
          res.setHeader("X-Duplicate-Strategy", "exact-match");
          return res.status(200).json(duplicateMessage);
        }
        if (trimmedContent.length <= 5) {
          const veryLongWindow = /* @__PURE__ */ new Date();
          veryLongWindow.setMinutes(veryLongWindow.getMinutes() - 10);
          const caseInsensitiveDuplicates = await storage.findRecentDuplicateMessages({
            matchId,
            senderId: req.user.id,
            content: trimmedContent,
            messageType: messageType || "text",
            since: veryLongWindow.toISOString(),
            caseInsensitive: true
            // Enable case-insensitive matching for short messages
          });
          if (caseInsensitiveDuplicates && caseInsensitiveDuplicates.length > 0) {
            const duplicateMessage = caseInsensitiveDuplicates[0];
            console.log(
              `[DUPLICATE-PREVENTION] BLOCKED: Found case-insensitive match for short message "${trimmedContent}" (ID: ${duplicateMessage.id})`
            );
            res.setHeader("X-Duplicate-Message", "true");
            res.setHeader("X-Duplicate-Strategy", "case-insensitive-short");
            return res.status(200).json(duplicateMessage);
          }
        }
        const veryRecentWindow = /* @__PURE__ */ new Date();
        veryRecentWindow.setSeconds(veryRecentWindow.getSeconds() - 30);
        const recentDuplicates = await storage.findRecentDuplicateMessages({
          matchId,
          senderId: req.user.id,
          content: trimmedContent,
          messageType: messageType || "text",
          since: veryRecentWindow.toISOString(),
          caseInsensitive: false
          // Case-sensitive for exact matching
        });
        if (recentDuplicates && recentDuplicates.length > 0) {
          const duplicateMessage = recentDuplicates[0];
          console.log(
            `[DUPLICATE-PREVENTION] BLOCKED: Message throttled, same content sent ${recentDuplicates.length} times in the last 30 seconds`
          );
          res.setHeader("X-Duplicate-Message", "true");
          res.setHeader("X-Duplicate-Strategy", "throttle");
          return res.status(200).json(duplicateMessage);
        }
        console.log(
          `[DUPLICATE-PREVENTION] No duplicates found, proceeding with message creation`
        );
      } catch (duplicateError) {
        console.error(
          "[DUPLICATE-PREVENTION] Error checking for duplicates:",
          duplicateError
        );
      }
      let calculatedReplyToIsCurrentUser = null;
      if (replyToMessageId && replyToMessage) {
        const originalMessage = await storage.getMessageById(replyToMessageId);
        if (originalMessage) {
          calculatedReplyToIsCurrentUser = originalMessage.senderId === req.user.id;
        }
      }
      const messageData = {
        matchId,
        senderId: req.user.id,
        receiverId,
        content: trimmedContent,
        messageType: messageType || "text",
        audioUrl: audioUrl || null,
        audioDuration: audioDuration || null,
        encryptedContent: null,
        iv: null,
        // Encryption removed as per requirements
        // Reply fields - don't calculate isCurrentUser here, it will be done dynamically when fetching
        replyToMessageId: replyToMessageId || null,
        replyToContent: replyToMessage?.content || null,
        replyToSenderName: replyToMessage?.senderName || null,
        replyToIsCurrentUser: null
        // Will be calculated dynamically when fetching messages
      };
      console.log("Creating message with data:", {
        matchId,
        senderId: req.user.id,
        receiverId,
        contentLength: trimmedContent.length,
        messageType: messageType || "text",
        replyToMessageId: replyToMessageId || null,
        replyToContent: replyToMessage?.content?.substring(0, 20) || null
      });
      const newMessage = await storage.createMessage(messageData);
      let transformedMessage = newMessage;
      if (newMessage.replyToMessageId && newMessage.replyToContent && newMessage.replyToSenderName) {
        let isCurrentUser = false;
        if (replyToMessageId) {
          const originalMessage = await storage.getMessageById(replyToMessageId);
          if (originalMessage) {
            isCurrentUser = originalMessage.senderId === req.user.id;
            console.log(
              `\u{1F504} [REPLY-TRANSFORM-CREATE] Message ${newMessage.id} "${newMessage.content}"`
            );
            console.log(
              `   \u{1F4E7} Replying to message ${replyToMessageId} "${newMessage.replyToContent}"`
            );
            console.log(
              `   \u{1F464} Original message sender: ${originalMessage.senderId}, Current user: ${req.user.id}`
            );
            console.log(
              `   \u{1F3AF} isCurrentUser = ${isCurrentUser} (should show "${isCurrentUser ? "You" : newMessage.replyToSenderName}")`
            );
          }
        }
        transformedMessage = {
          ...newMessage,
          replyToMessage: {
            id: newMessage.replyToMessageId,
            content: newMessage.replyToContent,
            senderName: newMessage.replyToSenderName,
            isCurrentUser
          }
        };
      }
      try {
        const senderSettings = await storage.getUserMatchSettings(
          req.user.id,
          matchId
        );
        if (senderSettings && senderSettings.autoDeleteMode !== "never") {
          let deleteAt;
          if (senderSettings.autoDeleteMode === "always") {
            await storage.scheduleMessageDeletion(
              newMessage.id,
              /* @__PURE__ */ new Date(),
              "always"
            );
          } else if (senderSettings.autoDeleteMode === "custom") {
            deleteAt = /* @__PURE__ */ new Date();
            const value = senderSettings.autoDeleteValue || 5;
            switch (senderSettings.autoDeleteUnit) {
              case "minutes":
                deleteAt.setMinutes(deleteAt.getMinutes() + value);
                break;
              case "hours":
                deleteAt.setHours(deleteAt.getHours() + value);
                break;
              case "days":
                deleteAt.setDate(deleteAt.getDate() + value);
                break;
              case "weeks":
                deleteAt.setDate(deleteAt.getDate() + value * 7);
                break;
              case "months":
                deleteAt.setMonth(deleteAt.getMonth() + value);
                break;
            }
            await storage.scheduleMessageDeletion(
              newMessage.id,
              deleteAt,
              "custom"
            );
          }
        }
      } catch (autoDeleteError) {
        console.error(
          "Error scheduling auto-delete for message:",
          autoDeleteError
        );
      }
      const recipientWs = connectedUsers4.get(receiverId);
      if (recipientWs && recipientWs.readyState === WebSocket4.OPEN) {
        try {
          recipientWs.send(
            JSON.stringify({
              type: "new_message",
              message: transformedMessage,
              for: "recipient",
              timestamp: (/* @__PURE__ */ new Date()).toISOString()
            })
          );
          console.log(
            `\u2705 Message ${newMessage.id} delivered to recipient ${receiverId} via WebSocket`
          );
        } catch (wsError) {
          console.error(
            `Failed to send message to recipient ${receiverId}:`,
            wsError
          );
        }
      } else {
        console.log(`\u26A0\uFE0F Recipient ${receiverId} not connected via WebSocket`);
      }
      const senderWs = connectedUsers4.get(req.user.id);
      if (senderWs && senderWs.readyState === WebSocket4.OPEN) {
        try {
          senderWs.send(
            JSON.stringify({
              type: "message_sent",
              messageId: newMessage.id,
              matchId: match.id,
              message: transformedMessage,
              for: "sender",
              timestamp: (/* @__PURE__ */ new Date()).toISOString()
            })
          );
          console.log(
            `\u2705 Message ${newMessage.id} delivery confirmed to sender ${req.user.id} via WebSocket`
          );
        } catch (wsError) {
          console.error(
            `Failed to send delivery confirmation to sender ${req.user.id}:`,
            wsError
          );
        }
      } else {
        console.log(`\u26A0\uFE0F Sender ${req.user.id} not connected via WebSocket`);
      }
      res.status(201).json(transformedMessage);
    } catch (error) {
      console.error("Error sending message:", error);
      res.status(500).json({ message: "Server error creating message" });
    }
  });
  app2.patch("/api/messages/:id/read", async (req, res) => {
    if (!req.isAuthenticated()) {
      return res.status(401).json({ message: "Unauthorized" });
    }
    const messageId = parseInt(req.params.id);
    if (isNaN(messageId)) {
      return res.status(400).json({ message: "Invalid message ID" });
    }
    try {
      const updatedMessage = await storage.markMessageAsRead(messageId);
      if (!updatedMessage) {
        return res.status(404).json({ message: "Message not found" });
      }
      res.json(updatedMessage);
    } catch (error) {
      res.status(500).json({ message: "Server error updating message" });
    }
  });
  app2.get("/api/interests/:userId", async (req, res) => {
    const userId = parseInt(req.params.userId);
    if (isNaN(userId)) {
      return res.status(400).json({ message: "Invalid user ID" });
    }
    try {
      if (req.isAuthenticated() && req.user?.id === userId) {
        if (req.session) {
          req.session.touch();
        }
      }
      const interests = await storage.getUserInterests(userId);
      res.json(interests);
    } catch (error) {
      console.error("Error retrieving user interests:", error);
      res.status(500).json({ message: "Server error retrieving interests" });
    }
  });
  app2.delete("/api/interests/:userId", async (req, res) => {
    if (!req.isAuthenticated()) {
      return res.status(401).json({ message: "Unauthorized" });
    }
    const userId = parseInt(req.params.userId);
    if (isNaN(userId)) {
      return res.status(400).json({ message: "Invalid user ID" });
    }
    if (req.user?.id !== userId) {
      return res.status(403).json({ message: "Not authorized to delete these interests" });
    }
    try {
      await storage.deleteAllUserInterests(userId);
      res.status(200).json({ message: "All interests deleted successfully" });
    } catch (error) {
      console.error("Error deleting user interests:", error);
      res.status(500).json({ message: "Server error deleting interests" });
    }
  });
  app2.patch(
    "/api/interests/:userId/visibility",
    async (req, res) => {
      if (!req.isAuthenticated()) {
        console.log("User not authenticated for visibility update");
        return res.status(401).json({ message: "Unauthorized" });
      }
      if (req.session) {
        req.session.touch();
      }
      const userId = parseInt(req.params.userId);
      if (isNaN(userId)) {
        return res.status(400).json({ message: "Invalid user ID" });
      }
      console.log(
        `Requesting user ID: ${req.user.id}, Target user ID: ${userId}`
      );
      if (req.user?.id !== userId) {
        console.log(
          `User ${req.user.id} not authorized to update interests for user ${userId}`
        );
        return res.status(403).json({ message: "Not authorized to update these interests" });
      }
      const { showOnProfile } = req.body;
      if (typeof showOnProfile !== "boolean") {
        return res.status(400).json({ message: "showOnProfile boolean value is required" });
      }
      try {
        console.log(
          `Updating interests visibility for user ${userId} to ${showOnProfile}`
        );
        await storage.updateUserInterestsVisibility(userId, showOnProfile);
        res.status(200).json({ message: "Interests visibility updated successfully" });
      } catch (error) {
        console.error("Error updating interests visibility:", error);
        res.status(500).json({ message: "Server error updating interests visibility" });
      }
    }
  );
  app2.post("/api/interests", async (req, res) => {
    if (!req.isAuthenticated()) {
      console.log("User not authenticated when adding interest");
      return res.status(401).json({ message: "Unauthorized" });
    }
    if (req.session) {
      req.session.touch();
    }
    try {
      console.log("Adding interest request body:", req.body);
      const { interest, userId } = req.body;
      if (!interest) {
        return res.status(400).json({ message: "Interest is required" });
      }
      if (userId && parseInt(userId) !== req.user.id) {
        console.warn(
          `User ${req.user.id} attempted to add interest for a different user ID: ${userId}`
        );
        return res.status(403).json({ message: "Not authorized to add interests for other users" });
      }
      console.log(`Adding interest "${interest}" for user ${req.user.id}`);
      try {
        const globalInterest = await storage.getGlobalInterestByName(interest);
        if (!globalInterest) {
          console.log(`Adding "${interest}" to global interests database`);
          await storage.addGlobalInterest({
            interest,
            category: "user-added",
            createdBy: req.user.id
          });
        }
        const newInterest = await storage.addUserInterest({
          userId: req.user.id,
          interest,
          showOnProfile: true
          // Explicitly set interest visibility to true
        });
        console.log(
          `Interest added successfully: ${JSON.stringify(newInterest)}`
        );
        return res.status(201).json(newInterest);
      } catch (storageError) {
        console.error("Storage error adding interest:", storageError);
        return res.status(500).json({
          message: "Server error adding interest",
          details: storageError instanceof Error ? storageError.message : "Unknown error"
        });
      }
    } catch (error) {
      console.error("Error processing interest request:", error);
      res.status(500).json({
        message: "Server error processing interest request",
        details: error instanceof Error ? error.message : "Unknown error"
      });
    }
  });
  app2.get("/api/global-interests", async (req, res) => {
    try {
      const interests = await storage.getAllGlobalInterests();
      res.json(interests);
    } catch (error) {
      console.error("Error fetching global interests:", error);
      res.status(500).json({ message: "Server error retrieving global interests" });
    }
  });
  app2.post("/api/global-interests", async (req, res) => {
    if (!req.isAuthenticated()) {
      console.log("User not authenticated when adding global interest");
      return res.status(401).json({ message: "Unauthorized" });
    }
    if (req.session) {
      req.session.touch();
    }
    try {
      console.log("Adding global interest request body:", req.body);
      let globalInterestData;
      try {
        globalInterestData = insertGlobalInterestSchema.parse(req.body);
      } catch (zodError) {
        if (zodError instanceof ZodError2) {
          const errorMessage = fromZodError2(zodError).message;
          console.error(
            "Validation error adding global interest:",
            errorMessage
          );
          return res.status(400).json({ message: errorMessage });
        }
        throw zodError;
      }
      try {
        const existingInterest = await storage.getGlobalInterestByName(
          globalInterestData.interest
        );
        if (existingInterest) {
          console.log(
            `Interest "${globalInterestData.interest}" already exists in global database, returning existing interest`
          );
          return res.status(200).json(existingInterest);
        }
      } catch (lookupError) {
        console.error("Error checking for existing interest:", lookupError);
      }
      if (!globalInterestData.createdBy) {
        globalInterestData.createdBy = req.user.id;
      }
      try {
        const newGlobalInterest = await storage.addGlobalInterest(globalInterestData);
        console.log(
          `Added new global interest: ${JSON.stringify(newGlobalInterest)}`
        );
        return res.status(201).json(newGlobalInterest);
      } catch (storageError) {
        console.error("Storage error adding global interest:", storageError);
        return res.status(500).json({
          message: "Database error adding global interest",
          details: storageError instanceof Error ? storageError.message : "Unknown error"
        });
      }
    } catch (error) {
      console.error("Unexpected error adding global interest:", error);
      res.status(500).json({
        message: "Server error adding global interest",
        details: error instanceof Error ? error.message : "Unknown error"
      });
    }
  });
  app2.get("/api/global-deal-breakers", async (req, res) => {
    try {
      const dealBreakers = await storage.getAllGlobalDealBreakers();
      res.json(dealBreakers);
    } catch (error) {
      console.error("Error fetching global deal breakers:", error);
      res.status(500).json({ message: "Server error retrieving global deal breakers" });
    }
  });
  app2.post("/api/global-deal-breakers", async (req, res) => {
    if (!req.isAuthenticated()) {
      console.log("User not authenticated when adding global deal breaker");
      return res.status(401).json({ message: "Unauthorized" });
    }
    if (req.session) {
      req.session.touch();
    }
    try {
      console.log("Adding global deal breaker request body:", req.body);
      let globalDealBreakerData;
      try {
        globalDealBreakerData = insertGlobalDealBreakerSchema.parse(req.body);
      } catch (zodError) {
        if (zodError instanceof ZodError2) {
          const errorMessage = fromZodError2(zodError).message;
          console.error(
            "Validation error adding global deal breaker:",
            errorMessage
          );
          return res.status(400).json({ message: errorMessage });
        }
        throw zodError;
      }
      try {
        const existingDealBreaker = await storage.getGlobalDealBreakerByName(
          globalDealBreakerData.dealBreaker
        );
        if (existingDealBreaker) {
          console.log(
            `Deal breaker "${globalDealBreakerData.dealBreaker}" already exists in global database, returning existing deal breaker`
          );
          return res.status(200).json(existingDealBreaker);
        }
      } catch (lookupError) {
        console.error("Error checking for existing deal breaker:", lookupError);
      }
      if (!globalDealBreakerData.createdBy) {
        globalDealBreakerData.createdBy = req.user.id;
      }
      try {
        const newGlobalDealBreaker = await storage.addGlobalDealBreaker(
          globalDealBreakerData
        );
        console.log(
          `Added new global deal breaker: ${JSON.stringify(newGlobalDealBreaker)}`
        );
        return res.status(201).json(newGlobalDealBreaker);
      } catch (storageError) {
        console.error(
          "Storage error adding global deal breaker:",
          storageError
        );
        return res.status(500).json({
          message: "Database error adding global deal breaker",
          details: storageError instanceof Error ? storageError.message : "Unknown error"
        });
      }
    } catch (error) {
      console.error("Unexpected error adding global deal breaker:", error);
      res.status(500).json({
        message: "Server error adding global deal breaker",
        details: error instanceof Error ? error.message : "Unknown error"
      });
    }
  });
  app2.get("/api/global-tribes", async (req, res) => {
    try {
      const tribes = await storage.getAllGlobalTribes();
      res.json(tribes);
    } catch (error) {
      console.error("Error fetching global tribes:", error);
      res.status(500).json({ message: "Server error retrieving global tribes" });
    }
  });
  app2.post("/api/global-tribes", async (req, res) => {
    if (!req.isAuthenticated()) {
      console.log("User not authenticated when adding global tribe");
      return res.status(401).json({ message: "Unauthorized" });
    }
    if (req.session) {
      req.session.touch();
    }
    try {
      console.log("Adding global tribe request body:", req.body);
      let globalTribeData;
      try {
        globalTribeData = insertGlobalTribeSchema.parse(req.body);
      } catch (zodError) {
        if (zodError instanceof ZodError2) {
          const errorMessage = fromZodError2(zodError).message;
          console.error("Validation error adding global tribe:", errorMessage);
          return res.status(400).json({ message: errorMessage });
        }
        throw zodError;
      }
      try {
        const existingTribe = await storage.getGlobalTribeByName(
          globalTribeData.tribe
        );
        if (existingTribe) {
          console.log(
            `Tribe "${globalTribeData.tribe}" already exists in global database, returning existing tribe`
          );
          return res.status(200).json(existingTribe);
        }
      } catch (lookupError) {
        console.error("Error checking for existing tribe:", lookupError);
      }
      if (!globalTribeData.createdBy) {
        globalTribeData.createdBy = req.user.id;
      }
      try {
        const newGlobalTribe = await storage.addGlobalTribe(globalTribeData);
        console.log(
          `Added new global tribe: ${JSON.stringify(newGlobalTribe)}`
        );
        return res.status(201).json(newGlobalTribe);
      } catch (storageError) {
        console.error("Storage error adding global tribe:", storageError);
        return res.status(500).json({
          message: "Database error adding global tribe",
          details: storageError instanceof Error ? storageError.message : "Unknown error"
        });
      }
    } catch (error) {
      console.error("Unexpected error adding global tribe:", error);
      res.status(500).json({
        message: "Server error adding global tribe",
        details: error instanceof Error ? error.message : "Unknown error"
      });
    }
  });
  app2.get("/api/global-religions", async (req, res) => {
    try {
      const religions = await storage.getAllGlobalReligions();
      res.json(religions);
    } catch (error) {
      console.error("Error fetching global religions:", error);
      res.status(500).json({ message: "Server error retrieving global religions" });
    }
  });
  app2.post("/api/global-religions", async (req, res) => {
    if (!req.isAuthenticated()) {
      console.log("User not authenticated when adding global religion");
      return res.status(401).json({ message: "Unauthorized" });
    }
    if (req.session) {
      req.session.touch();
    }
    try {
      console.log("Adding global religion request body:", req.body);
      let globalReligionData;
      try {
        globalReligionData = insertGlobalReligionSchema.parse(req.body);
      } catch (zodError) {
        if (zodError instanceof ZodError2) {
          const errorMessage = fromZodError2(zodError).message;
          console.error(
            "Validation error adding global religion:",
            errorMessage
          );
          return res.status(400).json({ message: errorMessage });
        }
        throw zodError;
      }
      try {
        const existingReligion = await storage.getGlobalReligionByName(
          globalReligionData.religion
        );
        if (existingReligion) {
          console.log(
            `Religion "${globalReligionData.religion}" already exists in global database, returning existing religion`
          );
          return res.status(200).json(existingReligion);
        }
      } catch (lookupError) {
        console.error("Error checking for existing religion:", lookupError);
      }
      if (!globalReligionData.createdBy) {
        globalReligionData.createdBy = req.user.id;
      }
      try {
        const newGlobalReligion = await storage.addGlobalReligion(globalReligionData);
        console.log(
          `Added new global religion: ${JSON.stringify(newGlobalReligion)}`
        );
        return res.status(201).json(newGlobalReligion);
      } catch (storageError) {
        console.error("Storage error adding global religion:", storageError);
        return res.status(500).json({
          message: "Database error adding global religion",
          details: storageError instanceof Error ? storageError.message : "Unknown error"
        });
      }
    } catch (error) {
      console.error("Unexpected error adding global religion:", error);
      res.status(500).json({
        message: "Server error adding global religion",
        details: error instanceof Error ? error.message : "Unknown error"
      });
    }
  });
  app2.post("/api/swipe", async (req, res) => {
    if (!req.isAuthenticated()) {
      return res.status(401).json({ message: "Unauthorized" });
    }
    try {
      const { targetUserId, action } = req.body;
      const currentUserId = req.user.id;
      if (!targetUserId || !action || !["like", "dislike"].includes(action)) {
        return res.status(400).json({ message: "Invalid swipe data" });
      }
      console.log(
        `[SWIPE] User ${currentUserId} ${action}d user ${targetUserId}`
      );
      if (action === "dislike") {
        try {
          await storage.createMatch({
            userId1: currentUserId,
            userId2: targetUserId,
            matched: false,
            isDislike: true,
            metadata: JSON.stringify({ origin: "MEET" })
          });
          console.log(
            `[SWIPE] Created dislike record: ${currentUserId} -> ${targetUserId}`
          );
        } catch (error) {
          if (error instanceof Error && error.message.includes("duplicate")) {
            console.log(
              `[SWIPE] Dislike record ${currentUserId} -> ${targetUserId} already exists`
            );
          } else {
            throw error;
          }
        }
      } else if (action === "like") {
        console.log(
          `\u{1F50D} [MEET-SWIPE] Checking for existing SUITE matches between users ${currentUserId} and ${targetUserId}`
        );
        const existingMatches = await storage.getAllMatchesBetweenUsers(
          currentUserId,
          targetUserId
        );
        console.log(
          `\u{1F50D} [MEET-SWIPE] Found ${existingMatches.length} existing matches between users`
        );
        if (existingMatches.length > 0) {
          existingMatches.forEach((match, index) => {
            console.log(
              `\u{1F50D} [MEET-SWIPE] Match ${index + 1}: ID=${match.id}, metadata=${match.metadata}`
            );
          });
        }
        const existingSuiteMatch = existingMatches.find((match) => {
          if (match.metadata) {
            try {
              const metadata = typeof match.metadata === "string" ? JSON.parse(match.metadata) : match.metadata;
              return metadata && metadata.origin === "SUITE";
            } catch (e) {
              console.error(
                `\u{1F50D} [MEET-SWIPE] Failed to parse metadata for match ${match.id}:`,
                e
              );
              return false;
            }
          }
          return false;
        });
        if (existingSuiteMatch) {
          console.log(
            `\u{1F517} [MEET-SWIPE] Found existing SUITE match ${existingSuiteMatch.id}, adding MEET as additional connection`
          );
          try {
            const existingMetadata = typeof existingSuiteMatch.metadata === "string" ? JSON.parse(existingSuiteMatch.metadata) : existingSuiteMatch.metadata;
            console.log(
              `\u{1F517} [MEET-SWIPE] Current metadata: ${JSON.stringify(existingMetadata)}`
            );
            if (!existingMetadata.additionalConnections) {
              existingMetadata.additionalConnections = [];
              console.log(
                `\u{1F517} [MEET-SWIPE] Initialized additionalConnections array`
              );
            }
            if (!existingMetadata.additionalConnections.includes("MEET")) {
              existingMetadata.additionalConnections.push("MEET");
              console.log(
                `\u{1F517} [MEET-SWIPE] Adding MEET to additionalConnections for SUITE match ${existingSuiteMatch.id}`
              );
              console.log(
                `\u{1F517} [MEET-SWIPE] New additionalConnections: ${JSON.stringify(existingMetadata.additionalConnections)}`
              );
              const updatedMatch = await storage.updateMatch(
                existingSuiteMatch.id,
                {
                  metadata: JSON.stringify(existingMetadata)
                }
              );
              console.log(
                `\u{1F517} [MEET-SWIPE] Successfully added MEET to additionalConnections for existing SUITE match ${existingSuiteMatch.id}`
              );
              console.log(
                `\u{1F517} [MEET-SWIPE] Final updated metadata: ${updatedMatch?.metadata}`
              );
              return res.json({
                success: true,
                action,
                isMatch: true,
                message: "MEET added as additional connection to existing SUITE match"
              });
            } else {
              console.log(
                `\u{1F517} [MEET-SWIPE] MEET already exists in additionalConnections, no update needed`
              );
              return res.json({
                success: true,
                action,
                isMatch: true,
                message: "MEET connection already exists"
              });
            }
          } catch (error) {
            console.error(
              `\u{1F517} [MEET-SWIPE] Error updating existing SUITE match:`,
              error
            );
          }
        }
        try {
          await storage.createMatch({
            userId1: currentUserId,
            userId2: targetUserId,
            matched: false,
            isDislike: false,
            metadata: JSON.stringify({ origin: "MEET" })
          });
          console.log(
            `[SWIPE] Created like record: ${currentUserId} -> ${targetUserId}`
          );
          const mutualLike = await db.select().from(matches).where(
            and5(
              eq6(matches.userId1, targetUserId),
              eq6(matches.userId2, currentUserId),
              eq6(matches.matched, false),
              eq6(matches.isDislike, false)
            )
          ).limit(1);
          if (mutualLike.length > 0) {
            console.log(
              `\u{1F50D} [MEET-MUTUAL-MATCH] Checking for existing SUITE matches before creating mutual match`
            );
            const allExistingMatches = await storage.getAllMatchesBetweenUsers(
              currentUserId,
              targetUserId
            );
            const existingSuiteMatchForMutual = allExistingMatches.find(
              (match) => {
                if (match.metadata) {
                  try {
                    const metadata = typeof match.metadata === "string" ? JSON.parse(match.metadata) : match.metadata;
                    return metadata && metadata.origin === "SUITE";
                  } catch (e) {
                    return false;
                  }
                }
                return false;
              }
            );
            let finalMetadata = { origin: "MEET" };
            if (existingSuiteMatchForMutual) {
              console.log(
                `\u{1F517} [MEET-MUTUAL-MATCH] Found existing SUITE match ${existingSuiteMatchForMutual.id}, preserving SUITE metadata and adding MEET`
              );
              try {
                const existingMetadata = typeof existingSuiteMatchForMutual.metadata === "string" ? JSON.parse(existingSuiteMatchForMutual.metadata) : existingSuiteMatchForMutual.metadata;
                finalMetadata = { ...existingMetadata };
                if (!finalMetadata.additionalConnections) {
                  finalMetadata.additionalConnections = [];
                }
                if (!finalMetadata.additionalConnections.includes("MEET")) {
                  finalMetadata.additionalConnections.push("MEET");
                }
                console.log(
                  `\u{1F517} [MEET-MUTUAL-MATCH] Final metadata: ${JSON.stringify(finalMetadata)}`
                );
              } catch (error) {
                console.error(
                  `\u{1F517} [MEET-MUTUAL-MATCH] Error parsing existing SUITE metadata:`,
                  error
                );
              }
            }
            await db.update(matches).set({
              matched: true,
              metadata: JSON.stringify(finalMetadata)
            }).where(
              or4(
                and5(
                  eq6(matches.userId1, currentUserId),
                  eq6(matches.userId2, targetUserId)
                ),
                and5(
                  eq6(matches.userId1, targetUserId),
                  eq6(matches.userId2, currentUserId)
                )
              )
            );
            console.log(
              `[SWIPE] Match created: ${currentUserId} \u2194 ${targetUserId}`
            );
            console.log(
              `[SWIPE-CLEANUP] About to clean up swipe history for users ${currentUserId} \u2194 ${targetUserId}`
            );
            try {
              await storage.removeMatchedUsersFromSwipeHistory(
                currentUserId,
                targetUserId
              );
              console.log(
                `[SWIPE-CLEANUP] Successfully cleaned up swipe history for users ${currentUserId} \u2194 ${targetUserId}`
              );
            } catch (historyError) {
              console.error(
                "Error cleaning up swipe history for matched users:",
                historyError
              );
            }
            if (connectedUsers4) {
              [currentUserId, targetUserId].forEach((userId) => {
                const userSocket = connectedUsers4.get(userId);
                if (userSocket && userSocket.readyState === WebSocket4.OPEN) {
                  userSocket.send(
                    JSON.stringify({
                      type: "match_notification",
                      matchedUserId: userId === currentUserId ? targetUserId : currentUserId,
                      timestamp: (/* @__PURE__ */ new Date()).toISOString()
                    })
                  );
                  userSocket.send(
                    JSON.stringify({
                      type: "card_removal",
                      removeUserId: userId === currentUserId ? targetUserId : currentUserId,
                      reason: "mutual_match",
                      timestamp: (/* @__PURE__ */ new Date()).toISOString()
                    })
                  );
                  console.log(
                    `\u{1F5D1}\uFE0F [CARD-REMOVAL] Sent card removal to user ${userId} for user ${userId === currentUserId ? targetUserId : currentUserId}`
                  );
                }
              });
            }
            return res.json({ success: true, action, isMatch: true });
          }
        } catch (error) {
          if (error instanceof Error && error.message.includes("duplicate")) {
            console.log(
              `[SWIPE] Like record ${currentUserId} -> ${targetUserId} already exists`
            );
          } else {
            throw error;
          }
        }
      }
      res.json({ success: true, action, isMatch: false });
    } catch (error) {
      console.error("Error processing swipe action:", error);
      res.status(500).json({ message: "Failed to process swipe action" });
    }
  });
  app2.get(
    "/api/photos/single/:photoId",
    async (req, res) => {
      try {
        const { photoId } = req.params;
        const photo = await storage.getUserPhotoById(parseInt(photoId));
        if (!photo) {
          return res.status(404).json({ error: "Photo not found" });
        }
        if (req.isAuthenticated() && req.user.id !== photo.userId) {
          console.log(
            `User ${req.user.id} accessed photo ${photoId} of user ${photo.userId}`
          );
        }
        res.json(photo);
      } catch (err) {
        console.error(err);
        res.status(500).json({ error: "An error occurred while fetching the photo" });
      }
    }
  );
  app2.get("/api/photos/:userId", async (req, res) => {
    try {
      const { userId } = req.params;
      const photos = await storage.getUserPhotos(parseInt(userId));
      res.json(photos);
    } catch (err) {
      console.error(err);
      res.status(500).json({ error: "An error occurred while fetching user photos" });
    }
  });
  app2.post("/api/photos", async (req, res) => {
    if (!req.isAuthenticated()) {
      return res.status(401).json({ message: "Unauthorized" });
    }
    try {
      const { photoUrl, isPrimary = false } = req.body;
      if (!photoUrl) {
        return res.status(400).json({ message: "Photo URL is required" });
      }
      const photo = await storage.addUserPhoto({
        userId: req.user.id,
        photoUrl,
        isPrimary
      });
      res.status(201).json(photo);
    } catch (err) {
      console.error(err);
      res.status(500).json({ error: "An error occurred while adding a photo" });
    }
  });
  app2.delete("/api/photos/:id", async (req, res) => {
    if (!req.isAuthenticated()) {
      return res.status(401).json({ message: "Unauthorized" });
    }
    try {
      const { id } = req.params;
      const photoId = parseInt(id);
      if (photoId > 2147483647 || isNaN(photoId)) {
        return res.status(400).json({
          error: "Invalid photo ID. Temporary photos cannot be deleted via server."
        });
      }
      await storage.deleteUserPhoto(photoId);
      res.status(204).send();
    } catch (err) {
      console.error(err);
      res.status(500).json({ error: "An error occurred while deleting the photo" });
    }
  });
  app2.patch("/api/photos/:id/primary", async (req, res) => {
    if (!req.isAuthenticated()) {
      return res.status(401).json({ message: "Unauthorized" });
    }
    try {
      const { id } = req.params;
      const photoId = parseInt(id);
      if (photoId > 2147483647 || isNaN(photoId)) {
        return res.status(400).json({
          error: "Invalid photo ID. Temporary photos cannot be set as primary via server."
        });
      }
      const photo = await storage.setPrimaryPhoto(photoId, req.user.id);
      res.json(photo);
    } catch (err) {
      console.error(err);
      res.status(500).json({ error: "An error occurred while setting primary photo" });
    }
  });
  app2.post("/api/profile/photo", async (req, res) => {
    if (!req.isAuthenticated()) {
      return res.status(401).json({ message: "Unauthorized" });
    }
    try {
      const { photoData, photoId } = req.body;
      if (!photoData || !photoData.startsWith("data:image/")) {
        return res.status(400).json({ message: "Valid image data is required" });
      }
      if (photoId) {
        const existingPhoto = await storage.getUserPhotoById(photoId);
        if (!existingPhoto) {
          return res.status(404).json({ message: "Photo not found" });
        }
        if (existingPhoto.userId !== req.user.id) {
          return res.status(403).json({ message: "Not authorized to update this photo" });
        }
        const updatedPhoto = await storage.updateUserPhoto(photoId, {
          photoUrl: photoData
        });
        if (existingPhoto.isPrimary) {
          await storage.updateUserProfile(req.user.id, { photoUrl: photoData });
        }
        return res.status(200).json(updatedPhoto);
      }
      const existingPhotos = await storage.getUserPhotos(req.user.id);
      const isPrimary = existingPhotos.length === 0;
      const photo = await storage.addUserPhoto({
        userId: req.user.id,
        photoUrl: photoData,
        isPrimary
      });
      if (isPrimary) {
        await storage.updateUserProfile(req.user.id, { photoUrl: photoData });
      }
      res.status(201).json(photo);
    } catch (err) {
      console.error("Error uploading profile photo:", err);
      res.status(500).json({
        error: "An error occurred while uploading your profile photo"
      });
    }
  });
  app2.patch(
    "/api/profile/photo/:photoId/primary/:section",
    async (req, res) => {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      try {
        const photoId = parseInt(req.params.photoId);
        const section = req.params.section;
        if (isNaN(photoId)) {
          return res.status(400).json({ message: "Invalid photo ID" });
        }
        const validSections = ["meet", "job", "mentorship", "networking"];
        if (!validSections.includes(section)) {
          return res.status(400).json({
            message: "Invalid section. Must be one of: meet, job, mentorship, networking"
          });
        }
        const existingPhoto = await storage.getUserPhotoById(photoId);
        if (!existingPhoto) {
          return res.status(404).json({ message: "Photo not found" });
        }
        if (existingPhoto.userId !== req.user.id) {
          return res.status(403).json({
            message: "Not authorized to update this photo"
          });
        }
        const result = await storage.updateSectionPrimaryPhoto(
          req.user.id,
          photoId,
          section
        );
        if (!result.success) {
          return res.status(500).json({ message: result.error });
        }
        const updatedPhotos = await storage.getUserPhotos(req.user.id);
        res.status(200).json({
          message: `Primary photo updated for ${section} section`,
          photos: updatedPhotos,
          updatedPhotoId: photoId,
          section
        });
      } catch (err) {
        console.error("Error updating section primary photo:", err);
        res.status(500).json({
          error: "An error occurred while updating the primary photo"
        });
      }
    }
  );
  app2.get(
    "/api/profile/photos/section/:section",
    async (req, res) => {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      try {
        const section = req.params.section;
        const validSections = ["meet", "job", "mentorship", "networking"];
        if (!validSections.includes(section)) {
          return res.status(400).json({
            message: "Invalid section. Must be one of: meet, job, mentorship, networking"
          });
        }
        const photos = await storage.getUserPhotosWithSectionPrimary(
          req.user.id,
          section
        );
        res.status(200).json({
          photos,
          section
        });
      } catch (err) {
        console.error("Error fetching section photos:", err);
        res.status(500).json({
          error: "An error occurred while fetching photos"
        });
      }
    }
  );
  app2.get(
    "/api/profile/photo/primary/:section",
    async (req, res) => {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      try {
        const section = req.params.section;
        const validSections = ["meet", "job", "mentorship", "networking"];
        if (!validSections.includes(section)) {
          return res.status(400).json({
            message: "Invalid section. Must be one of: meet, job, mentorship, networking"
          });
        }
        const primaryPhoto = await storage.getSectionPrimaryPhoto(
          req.user.id,
          section
        );
        if (!primaryPhoto) {
          return res.status(404).json({
            message: `No primary photo found for ${section} section`,
            section
          });
        }
        res.status(200).json({
          photo: primaryPhoto,
          section
        });
      } catch (err) {
        console.error("Error fetching section primary photo:", err);
        res.status(500).json({
          error: "An error occurred while fetching the primary photo"
        });
      }
    }
  );
  app2.get("/api/ice", async (req, res) => {
    if (!req.isAuthenticated()) {
      return res.status(401).json({ message: "Unauthorized" });
    }
    try {
      const iceServers = [
        // Free STUN servers for basic connectivity
        { urls: ["stun:stun.l.google.com:19302"] },
        { urls: ["stun:stun1.l.google.com:19302"] },
        // Public TURN servers for testing (rate limited)
        {
          urls: ["turn:openrelay.metered.ca:80"],
          username: "openrelayproject",
          credential: "openrelayproject"
        },
        {
          urls: ["turn:openrelay.metered.ca:443"],
          username: "openrelayproject",
          credential: "openrelayproject"
        },
        {
          urls: ["turn:openrelay.metered.ca:443?transport=tcp"],
          username: "openrelayproject",
          credential: "openrelayproject"
        }
      ];
      res.json({ ice_servers: iceServers });
    } catch (error) {
      console.error("Error generating ICE servers:", error);
      res.status(500).json({ message: "Server error generating ICE servers" });
    }
  });
  app2.post("/api/video-calls", async (req, res) => {
    if (!req.isAuthenticated()) {
      return res.status(401).json({ message: "Unauthorized" });
    }
    try {
      const videoCallData = insertVideoCallSchema.parse(req.body);
      if (videoCallData.initiatorId !== req.user.id) {
        return res.status(403).json({ message: "Not authorized to initiate call as this user" });
      }
      const match = await storage.getMatchById(videoCallData.matchId);
      if (!match) {
        return res.status(404).json({ message: "Match not found" });
      }
      if (match.userId1 !== req.user.id && match.userId2 !== req.user.id) {
        return res.status(403).json({ message: "Not authorized to start call in this match" });
      }
      if (!videoCallData.roomName) {
        videoCallData.roomName = `charley-${randomBytes2(10).toString("hex")}`;
      }
      const newVideoCall = await storage.createVideoCall(videoCallData);
      try {
        const targetWs = connectedUsers4.get(videoCallData.receiverId);
        console.log("\u{1F4E1} [WebSocket] Server-side call_initiate relay check:", {
          receiverId: videoCallData.receiverId,
          targetWsExists: !!targetWs,
          targetWsReady: targetWs?.readyState === WebSocket4.OPEN,
          connectedUsersCount: connectedUsers4.size,
          connectedUserIds: Array.from(connectedUsers4.keys())
        });
        if (targetWs && targetWs.readyState === WebSocket4.OPEN) {
          const initiatePayload = {
            type: "call_initiate",
            matchId: newVideoCall.matchId,
            callerId: newVideoCall.initiatorId,
            receiverId: newVideoCall.receiverId,
            toUserId: newVideoCall.receiverId,
            callId: newVideoCall.id,
            roomName: newVideoCall.roomName,
            timestamp: (/* @__PURE__ */ new Date()).toISOString()
          };
          console.log(
            "\u{1F4E1} [WebSocket] Server-side initiating call signal:",
            initiatePayload
          );
          targetWs.send(JSON.stringify(initiatePayload));
        } else {
          console.log(
            "\u{1F4E1} [WebSocket] Receiver not connected for server-side call_initiate",
            videoCallData.receiverId
          );
        }
      } catch (e) {
        console.error("Error sending server-side call_initiate:", e);
      }
      res.status(201).json({
        videoCall: newVideoCall,
        twilioToken: "DEMO_TOKEN"
        // This would be a real token in production
      });
    } catch (error) {
      if (error instanceof ZodError2) {
        return res.status(400).json({ message: fromZodError2(error).message });
      }
      res.status(500).json({ message: "Server error creating video call" });
    }
  });
  app2.get("/api/video-calls/:id", async (req, res) => {
    if (!req.isAuthenticated()) {
      return res.status(401).json({ message: "Unauthorized" });
    }
    const callId = parseInt(req.params.id);
    if (isNaN(callId)) {
      return res.status(400).json({ message: "Invalid call ID" });
    }
    try {
      const videoCall = await storage.getVideoCallById(callId);
      if (!videoCall) {
        return res.status(404).json({ message: "Video call not found" });
      }
      if (videoCall.initiatorId !== req.user.id && videoCall.receiverId !== req.user.id) {
        return res.status(403).json({ message: "Not authorized to access this call" });
      }
      res.json({
        videoCall,
        twilioToken: "DEMO_TOKEN"
        // This would be a real token in production
      });
    } catch (error) {
      res.status(500).json({ message: "Server error retrieving video call" });
    }
  });
  app2.patch(
    "/api/video-calls/:id/status",
    async (req, res) => {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      const callId = parseInt(req.params.id);
      if (isNaN(callId)) {
        return res.status(400).json({ message: "Invalid call ID" });
      }
      try {
        const { status } = req.body;
        if (!status || !["active", "completed", "declined"].includes(status)) {
          return res.status(400).json({
            message: "Valid status required (active, completed, or declined)"
          });
        }
        const videoCall = await storage.getVideoCallById(callId);
        if (!videoCall) {
          return res.status(404).json({ message: "Video call not found" });
        }
        if (videoCall.initiatorId !== req.user.id && videoCall.receiverId !== req.user.id) {
          return res.status(403).json({ message: "Not authorized to update this call" });
        }
        const updateData = { status };
        if (status === "active" && !videoCall.startedAt) {
          updateData.startedAt = /* @__PURE__ */ new Date();
        } else if (status === "completed" && !videoCall.endedAt) {
          updateData.endedAt = /* @__PURE__ */ new Date();
        }
        const updatedCall = await storage.updateVideoCallStatus(
          callId,
          updateData
        );
        try {
          const isDeclined = status === "declined";
          const isCompletedBeforeStart = status === "completed" && !videoCall.startedAt;
          if (isDeclined || isCompletedBeforeStart) {
            const callerId = videoCall.initiatorId;
            const receiverId = videoCall.receiverId;
            const matchIdForCall = videoCall.matchId;
            console.log(
              `\u{1F4DE} [CALL-SYSTEM][HTTP] Creating no-answer message for match=${matchIdForCall} caller=${callerId} receiver=${receiverId} (status=${status})`
            );
            const callSystemMessage = await storage.createMessage({
              matchId: matchIdForCall,
              senderId: callerId,
              receiverId,
              content: "_CALL:NO_ANSWER",
              messageType: "call",
              audioUrl: null,
              audioDuration: null
            });
            try {
              await storage.markMatchUnread(matchIdForCall, receiverId);
            } catch (e) {
              console.error(
                "[CALL-SYSTEM][HTTP] Failed to mark match unread:",
                e
              );
            }
            const rxWs = connectedUsers4.get(receiverId);
            if (rxWs && rxWs.readyState === WebSocket4.OPEN) {
              rxWs.send(
                JSON.stringify({
                  type: "new_message",
                  message: callSystemMessage,
                  for: "recipient",
                  receiptId: `call_no_answer_${callSystemMessage?.id}_rx_http`,
                  timestamp: (/* @__PURE__ */ new Date()).toISOString()
                })
              );
            }
            const txWs = connectedUsers4.get(callerId);
            if (txWs && txWs.readyState === WebSocket4.OPEN) {
              txWs.send(
                JSON.stringify({
                  type: "new_message",
                  message: callSystemMessage,
                  for: "sender",
                  receiptId: `call_no_answer_${callSystemMessage?.id}_tx_http`,
                  timestamp: (/* @__PURE__ */ new Date()).toISOString()
                })
              );
            }
          }
        } catch (e) {
          console.error(
            "[CALL-SYSTEM][HTTP] Error creating/broadcasting no-answer:",
            e
          );
        }
        res.json(updatedCall);
      } catch (error) {
        res.status(500).json({ message: "Server error updating video call" });
      }
    }
  );
  const phoneVerificationCache = /* @__PURE__ */ new Map();
  const PHONE_RATE_LIMIT = 3e3;
  app2.post("/api/verify/phone/send", async (req, res) => {
    try {
      const { phoneNumber } = req.body;
      if (!phoneNumber) {
        return res.status(400).json({ message: "Phone number is required" });
      }
      console.log(
        `[AGE-COMPLIANCE] Checking if phone number ${phoneNumber} is blocked`
      );
      const isBlocked = await storage.isPhoneNumberBlocked(phoneNumber);
      if (isBlocked) {
        console.log(
          `[AGE-COMPLIANCE] Blocked phone number attempted registration: ${phoneNumber}`
        );
        const blockedRecord = await storage.getBlockedPhoneNumber(phoneNumber);
        return res.status(403).json({
          message: "This phone number cannot be used for registration. Please contact admin@kronogon.com or call Customer Service on +1 (469) 496-5620 for assistance.",
          blocked: true,
          reason: blockedRecord?.reason || "Compliance violation"
        });
      }
      const lastVerificationAttempt = phoneVerificationCache.get(phoneNumber);
      const now = Date.now();
      if (lastVerificationAttempt && now - lastVerificationAttempt < PHONE_RATE_LIMIT) {
        return res.status(200).json({
          message: `Verification code sent to ${phoneNumber} (throttled)`,
          phoneNumber,
          codeLength: 7,
          expiresAt: new Date(now + 10 * 60 * 1e3),
          skipVerification: false
        });
      }
      phoneVerificationCache.set(phoneNumber, now);
      const existingUser = await storage.getUserByPhoneNumber(phoneNumber);
      if (existingUser && existingUser.twoFactorEnabled === false) {
        return res.status(200).json({
          message: "User found with two-factor authentication disabled",
          skipVerification: true,
          user: {
            id: existingUser.id,
            username: existingUser.username
          }
        });
      }
      const code = Math.floor(1e6 + Math.random() * 9e6).toString();
      const expiresAt = new Date(now + 10 * 60 * 1e3);
      await storage.createVerificationCode({
        phoneNumber,
        code,
        expiresAt
      });
      if (Math.random() < 0.01) {
        storage.deleteExpiredVerificationCodes().catch((err) => console.error("Background cleanup error:", err));
      }
      res.status(200).json({
        message: "Verification code sent successfully",
        code
        // Remove this line in production
      });
    } catch (error) {
      console.error("Phone verification error:", error);
      console.error("Full error details:", {
        message: error.message,
        code: error.code,
        stack: error.stack
      });
      if (error.message?.includes("relation") || error.code === "42P01") {
        console.error("\u274C Database table 'verification_codes' does not exist!");
        console.error("\u{1F4A1} Run: npx drizzle-kit push to create missing tables");
        res.status(500).json({
          message: "Database configuration error - verification_codes table missing"
        });
      } else {
        res.status(500).json({
          message: "Server error sending verification code"
        });
      }
    }
  });
  app2.post("/api/phone/block", async (req, res) => {
    try {
      const { phoneNumber, fullName, email, reason, metadata } = req.body;
      if (!phoneNumber) {
        return res.status(400).json({ message: "Phone number is required" });
      }
      if (!reason) {
        return res.status(400).json({ message: "Reason is required" });
      }
      console.log(
        `[AGE-COMPLIANCE] Blocking phone number ${phoneNumber} for ${fullName || "Unknown User"} (${email || "No Email"}) - Reason: ${reason}`
      );
      const alreadyBlocked = await storage.isPhoneNumberBlocked(phoneNumber);
      if (alreadyBlocked) {
        console.log(
          `[AGE-COMPLIANCE] Phone number ${phoneNumber} already blocked`
        );
        return res.status(200).json({
          message: "Phone number is already blocked",
          alreadyBlocked: true
        });
      }
      const blockedRecord = await storage.addBlockedPhoneNumber(
        phoneNumber,
        reason,
        fullName,
        email,
        metadata
      );
      console.log(
        `[AGE-COMPLIANCE] Successfully blocked phone number ${phoneNumber} with ID ${blockedRecord.id}`
      );
      if (email && fullName && reason.includes("under 14")) {
        console.log(
          `[AGE-COMPLIANCE] Sending apology email to blocked user: ${email}`
        );
        try {
          const { sendUnderAgeApologyEmail: sendUnderAgeApologyEmail2 } = await Promise.resolve().then(() => (init_sendgrid(), sendgrid_exports));
          let dateOfBirth = null;
          if (metadata) {
            try {
              const parsedMetadata = JSON.parse(metadata);
              dateOfBirth = parsedMetadata.dateOfBirth;
            } catch (parseError) {
              console.warn(
                `[AGE-COMPLIANCE] Could not parse metadata for email: ${parseError}`
              );
            }
          }
          const emailSent = await sendUnderAgeApologyEmail2({
            name: fullName,
            email,
            dateOfBirth
          });
          if (emailSent) {
            console.log(
              `[AGE-COMPLIANCE] Apology email sent successfully to blocked user: ${email}`
            );
          } else {
            console.error(
              `[AGE-COMPLIANCE] Failed to send apology email to blocked user: ${email}`
            );
          }
        } catch (emailError) {
          console.error(
            `[AGE-COMPLIANCE] Error sending apology email to ${email}:`,
            emailError
          );
        }
      }
      res.status(200).json({
        message: "Phone number has been successfully blocked",
        blocked: true,
        id: blockedRecord.id
      });
    } catch (error) {
      console.error("[AGE-COMPLIANCE] Error blocking phone number:", error);
      res.status(500).json({
        message: "Server error blocking phone number",
        error: error instanceof Error ? error.message : "Unknown error"
      });
    }
  });
  app2.post(
    "/api/password/send-reset-code",
    async (req, res) => {
      try {
        const { email } = req.body;
        if (!email) {
          return res.status(400).json({ message: "Email is required" });
        }
        const user = await storage.getUserByEmail(email);
        if (!user) {
          return res.status(404).json({ message: "No user found with this email address" });
        }
        const resetCode = Math.floor(
          1e6 + Math.random() * 9e6
        ).toString();
        const expiresAt = /* @__PURE__ */ new Date();
        expiresAt.setMinutes(expiresAt.getMinutes() + 10);
        await db.insert(passwordResetCodes).values({
          email,
          resetCode,
          isUsed: false,
          expiresAt
        });
        const emailSent = await sendEmail(process.env.SENDGRID_API_KEY, {
          to: email,
          from: "admin@kronogon.com",
          subject: "CHARLEY - Password Reset Code",
          html: `
          <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto; padding: 20px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); border-radius: 20px;">
            <div style="background: rgba(255, 255, 255, 0.95); border-radius: 16px; padding: 30px; text-align: center;">
              <h1 style="color: #4f46e5; margin-bottom: 20px; font-size: 28px;">Password Reset Code</h1>
              
              <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); border-radius: 12px; padding: 20px; margin: 20px 0;">
                <h2 style="color: white; font-size: 36px; margin: 0; letter-spacing: 8px; font-family: 'Courier New', monospace;">${resetCode}</h2>
              </div>
              
              <p style="color: #374151; font-size: 16px; margin: 20px 0;">
                Use this 7-digit code to reset your CHARLEY password. This code expires in 10 minutes.
              </p>
              
              <p style="color: #6b7280; font-size: 14px; margin-top: 30px;">
                If you didn't request this password reset, please ignore this email.
              </p>
              
              <div style="margin-top: 30px; padding-top: 20px; border-top: 1px solid #e5e7eb;">
                <p style="color: #9ca3af; font-size: 12px; margin: 0;">
                  From the BTechnos Team<br>
                  CHARLEY - Connecting Communities Worldwide
                </p>
              </div>
            </div>
          </div>
        `,
          text: `Your CHARLEY password reset code is: ${resetCode}. This code expires in 10 minutes. If you didn't request this, please ignore this email.`
        });
        if (emailSent) {
          res.status(200).json({
            message: "Reset code sent to your email",
            success: true
          });
        } else {
          res.status(500).json({ message: "Failed to send reset code" });
        }
      } catch (error) {
        console.error("Password reset code error:", error);
        res.status(500).json({ message: "Server error during password reset request" });
      }
    }
  );
  app2.post(
    "/api/password/verify-reset-code",
    async (req, res) => {
      try {
        const { email, resetCode } = req.body;
        if (!email || !resetCode) {
          return res.status(400).json({ message: "Email and reset code are required" });
        }
        const validCode = await db.select().from(passwordResetCodes).where(
          and5(
            eq6(passwordResetCodes.email, email),
            eq6(passwordResetCodes.resetCode, resetCode),
            eq6(passwordResetCodes.isUsed, false),
            gte(passwordResetCodes.expiresAt, /* @__PURE__ */ new Date())
          )
        ).limit(1);
        if (validCode.length === 0) {
          return res.status(400).json({ message: "Invalid or expired reset code" });
        }
        res.status(200).json({
          message: "Reset code verified successfully",
          success: true
        });
      } catch (error) {
        console.error("Reset code verification error:", error);
        res.status(500).json({ message: "Server error during code verification" });
      }
    }
  );
  app2.post(
    "/api/password/reset-with-code",
    async (req, res) => {
      try {
        const { email, resetCode, newPassword } = req.body;
        if (!email || !resetCode || !newPassword) {
          return res.status(400).json({
            message: "Email, reset code, and new password are required"
          });
        }
        const validCode = await db.select().from(passwordResetCodes).where(
          and5(
            eq6(passwordResetCodes.email, email),
            eq6(passwordResetCodes.resetCode, resetCode),
            eq6(passwordResetCodes.isUsed, false),
            gte(passwordResetCodes.expiresAt, /* @__PURE__ */ new Date())
          )
        ).limit(1);
        if (validCode.length === 0) {
          return res.status(400).json({ message: "Invalid or expired reset code" });
        }
        const user = await storage.getUserByEmail(email);
        if (!user) {
          return res.status(404).json({ message: "User not found" });
        }
        const hashedPassword = await hashPassword(newPassword);
        await storage.updateUserPassword(user.id, hashedPassword);
        await db.update(passwordResetCodes).set({ isUsed: true }).where(eq6(passwordResetCodes.id, validCode[0].id));
        res.status(200).json({
          message: "Password reset successfully",
          success: true
        });
      } catch (error) {
        console.error("Password reset error:", error);
        res.status(500).json({ message: "Server error during password reset" });
      }
    }
  );
  app2.post("/api/password/change", async (req, res) => {
    if (!req.isAuthenticated()) {
      return res.status(401).json({ message: "Unauthorized" });
    }
    try {
      const { currentPassword, newPassword } = req.body;
      if (!currentPassword || !newPassword) {
        return res.status(400).json({ message: "Current password and new password are required" });
      }
      if (newPassword.length < 6) {
        return res.status(400).json({ message: "New password must be at least 6 characters long" });
      }
      const user = await storage.getUser(req.user.id);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }
      const isPasswordValid = await comparePasswords(
        currentPassword,
        user.password
      );
      if (!isPasswordValid) {
        return res.status(400).json({ message: "Current password is incorrect" });
      }
      const hashedPassword = await hashPassword(newPassword);
      await storage.updateUserPassword(user.id, hashedPassword);
      const userAgent = req.get("User-Agent") || "Unknown";
      const ipAddress = req.ip || req.connection.remoteAddress || "Unknown";
      console.log(
        `[SECURITY-NOTIFICATION] Sending password change notification for user ${user.id}`
      );
      sendSecurityChangeNotification({
        userId: user.id,
        email: user.email,
        fullName: user.fullName,
        phoneNumber: user.phoneNumber,
        changeType: "password",
        userAgent,
        ipAddress
      }).catch((error) => {
        console.error(
          "[SECURITY-NOTIFICATION] Error sending password change notification:",
          error
        );
      });
      req.logout((err) => {
        if (err) {
          console.error("Error logging out user after password change:", err);
          return res.status(500).json({ message: "Password changed but logout failed" });
        }
        req.session.destroy((sessionErr) => {
          if (sessionErr) {
            console.error(
              "Error destroying session after password change:",
              sessionErr
            );
            return res.status(500).json({ message: "Password changed but session cleanup failed" });
          }
          res.clearCookie("connect.sid");
          return res.status(200).json({
            success: true,
            message: "Password successfully changed. Please log in again with your new password.",
            requiresRelogin: true
          });
        });
      });
    } catch (error) {
      console.error("Error changing password:", error);
      console.error(
        "Error stack:",
        error instanceof Error ? error.stack : "No stack trace"
      );
      console.error("Error details:", JSON.stringify(error));
      res.status(500).json({ message: "Server error during password change" });
    }
  });
  app2.get("/api/premium/status", async (req, res) => {
    if (!req.isAuthenticated()) {
      return res.status(401).json({ message: "Unauthorized" });
    }
    try {
      const userId = req.user.id;
      const user = await storage.getUser(userId);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }
      if (user.stripeSubscriptionId && stripe2) {
        try {
          console.log(
            `[STRIPE-SYNC] Checking real-time subscription status for user ${userId}, subscription: ${user.stripeSubscriptionId}`
          );
          const stripeSubscription = await stripe2.subscriptions.retrieve(
            user.stripeSubscriptionId
          );
          console.log(`[STRIPE-SYNC] Stripe subscription details:`);
          console.log(`[STRIPE-SYNC] - Status: ${stripeSubscription.status}`);
          console.log(
            `[STRIPE-SYNC] - Cancel at period end: ${stripeSubscription.cancel_at_period_end}`
          );
          console.log(
            `[STRIPE-SYNC] - Current period end: ${new Date(stripeSubscription.current_period_end * 1e3)}`
          );
          console.log(
            `[STRIPE-SYNC] - Current database status: ${user.subscriptionStatus}`
          );
          let localSubscriptionStatus = user.subscriptionStatus;
          let localPremiumAccess = user.premiumAccess;
          let localSubscriptionExpiresAt = user.subscriptionExpiresAt;
          if (stripeSubscription.status === "active") {
            console.log(`[STRIPE-SYNC] User ${userId} has active subscription`);
            if (stripeSubscription.cancel_at_period_end) {
              console.log(
                `[STRIPE-SYNC] - Subscription scheduled for cancellation at period end (grace period)`
              );
              localSubscriptionStatus = "canceled";
              localPremiumAccess = true;
              localSubscriptionExpiresAt = new Date(
                stripeSubscription.current_period_end * 1e3
              );
            } else {
              console.log(
                `[STRIPE-SYNC] - Subscription is truly active (not scheduled for cancellation)`
              );
              localSubscriptionStatus = "active";
              localPremiumAccess = true;
              localSubscriptionExpiresAt = new Date(
                stripeSubscription.current_period_end * 1e3
              );
            }
          } else if (stripeSubscription.status === "canceled" || stripeSubscription.status === "unpaid") {
            const currentPeriodEnd = new Date(
              stripeSubscription.current_period_end * 1e3
            );
            const now = /* @__PURE__ */ new Date();
            if (now < currentPeriodEnd) {
              localSubscriptionStatus = "canceled";
              localPremiumAccess = true;
              localSubscriptionExpiresAt = currentPeriodEnd;
            } else {
              localSubscriptionStatus = "expired";
              localPremiumAccess = false;
              localSubscriptionExpiresAt = currentPeriodEnd;
            }
          }
          if (localSubscriptionStatus !== user.subscriptionStatus || localPremiumAccess !== user.premiumAccess) {
            console.log(
              `[STRIPE-SYNC] Updating user ${userId} status from Stripe: ${stripeSubscription.status}, premium: ${localPremiumAccess}`
            );
            await storage.updateUserProfile(userId, {
              subscriptionStatus: localSubscriptionStatus,
              premiumAccess: localPremiumAccess,
              subscriptionExpiresAt: localSubscriptionExpiresAt
            });
          }
          return res.json({
            premiumAccess: localPremiumAccess,
            subscriptionStatus: localSubscriptionStatus,
            subscriptionExpiresAt: localSubscriptionExpiresAt,
            gracePeriodActive: localSubscriptionStatus === "canceled" && localPremiumAccess,
            stripeStatus: stripeSubscription.status,
            stripeCancelAtPeriodEnd: stripeSubscription.cancel_at_period_end
          });
        } catch (stripeError) {
          console.error(
            `[STRIPE-SYNC] Error checking Stripe subscription for user ${userId}:`,
            stripeError
          );
        }
      }
      if (user.subscriptionExpiresAt && user.subscriptionStatus === "canceled") {
        const now = /* @__PURE__ */ new Date();
        const expiresAt = new Date(user.subscriptionExpiresAt);
        if (now > expiresAt && user.premiumAccess) {
          console.log(
            `[SUBSCRIPTION-EXPIRY] User ${userId} subscription expired at ${expiresAt}, removing premium access`
          );
          await storage.updateUserProfile(userId, {
            premiumAccess: false,
            subscriptionStatus: "expired"
          });
          return res.json({
            premiumAccess: false,
            subscriptionExpired: true,
            expiredAt: expiresAt
          });
        }
      }
      res.json({
        premiumAccess: user.premiumAccess || false,
        subscriptionStatus: user.subscriptionStatus,
        subscriptionExpiresAt: user.subscriptionExpiresAt,
        gracePeriodActive: user.subscriptionStatus === "canceled" && user.premiumAccess
      });
    } catch (error) {
      console.error("Error getting premium status:", error);
      res.status(500).json({ message: "Server error getting premium status" });
    }
  });
  app2.post("/api/premium/toggle", async (req, res) => {
    if (!req.isAuthenticated()) {
      return res.status(401).json({ message: "Unauthorized" });
    }
    try {
      const { premiumAccess } = req.body;
      if (typeof premiumAccess !== "boolean") {
        return res.status(400).json({ message: "premiumAccess must be a boolean" });
      }
      const userId = req.user.id;
      console.log(
        `[PREMIUM-TOGGLE] User ${userId} toggling premium access to: ${premiumAccess}`
      );
      await storage.updateUserProfile(userId, {
        premiumAccess
      });
      const updatedUser = await storage.getUser(userId);
      res.json({
        message: "Premium access updated successfully",
        premiumAccess: updatedUser?.premiumAccess || false
      });
    } catch (error) {
      console.error("[PREMIUM-TOGGLE] Error:", error);
      res.status(500).json({
        message: "Server error updating premium access",
        error: error.message
      });
    }
  });
  app2.post("/api/subscription/cancel", async (req, res) => {
    if (!req.isAuthenticated()) {
      return res.status(401).json({ message: "Unauthorized" });
    }
    try {
      const userId = req.user.id;
      const user = await storage.getUser(userId);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }
      console.log(
        `[SUBSCRIPTION-CANCEL] User ${userId} requesting subscription cancellation`
      );
      if (!user.stripeSubscriptionId) {
        console.log(
          `[SUBSCRIPTION-CANCEL] User ${userId} has no Stripe subscription, just removing premium access`
        );
        await storage.updateUserProfile(userId, {
          premiumAccess: false
        });
        return res.json({
          message: "Premium access cancelled successfully",
          gracePeriod: false,
          premiumAccess: false
        });
      }
      if (stripe2) {
        try {
          console.log(
            `[SUBSCRIPTION-CANCEL] Canceling Stripe subscription: ${user.stripeSubscriptionId}`
          );
          const canceledSubscription = await stripe2.subscriptions.update(
            user.stripeSubscriptionId,
            {
              cancel_at_period_end: true
            }
          );
          console.log(
            `[SUBSCRIPTION-CANCEL] Stripe subscription canceled with grace period until: ${new Date(canceledSubscription.current_period_end * 1e3)}`
          );
          await storage.updateUserProfile(userId, {
            subscriptionStatus: "canceled",
            subscriptionCanceledAt: /* @__PURE__ */ new Date()
            // Keep premiumAccess: true during grace period
            // subscriptionExpiresAt stays the same for grace period end
          });
          try {
            const subscription = await storage.getSubscriptionByStripeId(
              user.stripeSubscriptionId
            );
            if (subscription) {
              await storage.createSubscriptionEvent({
                subscriptionId: subscription.id,
                userId,
                eventType: "subscription_canceled",
                provider: "stripe",
                providerEventId: canceledSubscription.id,
                oldStatus: "active",
                newStatus: "canceled",
                metadata: JSON.stringify({
                  canceledAt: (/* @__PURE__ */ new Date()).toISOString(),
                  gracePeriodEnd: new Date(
                    canceledSubscription.current_period_end * 1e3
                  ).toISOString(),
                  cancelAtPeriodEnd: true
                })
              });
              console.log(
                `[SUBSCRIPTION-CANCEL] Created cancellation event for subscription: ${subscription.id}`
              );
            }
          } catch (eventError) {
            console.error(
              `[SUBSCRIPTION-CANCEL] Failed to create cancellation event:`,
              eventError
            );
          }
          const gracePeriodEnd = new Date(
            canceledSubscription.current_period_end * 1e3
          );
          res.json({
            message: "Subscription cancelled successfully. You'll retain premium access until your billing period ends.",
            gracePeriod: true,
            gracePeriodEnd,
            premiumAccess: true,
            subscriptionStatus: "canceled"
          });
        } catch (stripeError) {
          console.error(
            `[SUBSCRIPTION-CANCEL] Stripe cancellation failed:`,
            stripeError
          );
          if (stripeError.code === "resource_missing") {
            console.log(
              `[SUBSCRIPTION-CANCEL] Subscription not found in Stripe, updating local status only`
            );
            await storage.updateUserProfile(userId, {
              premiumAccess: false,
              subscriptionStatus: "expired",
              stripeSubscriptionId: null
            });
            return res.json({
              message: "Premium access cancelled successfully",
              gracePeriod: false,
              premiumAccess: false
            });
          }
          throw stripeError;
        }
      } else {
        console.log(
          `[SUBSCRIPTION-CANCEL] Stripe not configured, removing premium access locally`
        );
        await storage.updateUserProfile(userId, {
          premiumAccess: false
        });
        res.json({
          message: "Premium access cancelled successfully",
          gracePeriod: false,
          premiumAccess: false
        });
      }
    } catch (error) {
      console.error("[SUBSCRIPTION-CANCEL] Error:", error);
      res.status(500).json({
        message: "Server error cancelling subscription",
        error: error.message
      });
    }
  });
  app2.post(
    "/api/subscriptions/check-expiry",
    async (req, res) => {
      try {
        console.log(
          `[SUBSCRIPTION-EXPIRY] Checking for expired subscriptions...`
        );
        const expiredUsers = await db.select().from(users).where(
          sql5`subscription_status = 'canceled' 
              AND premium_access = true 
              AND subscription_expires_at < NOW()`
        );
        let expiredCount = 0;
        for (const user of expiredUsers) {
          console.log(
            `[SUBSCRIPTION-EXPIRY] Expiring subscription for user ${user.id}`
          );
          await storage.updateUserProfile(user.id, {
            premiumAccess: false,
            subscriptionStatus: "expired"
          });
          expiredCount++;
        }
        console.log(
          `[SUBSCRIPTION-EXPIRY] Expired ${expiredCount} subscriptions`
        );
        res.json({
          success: true,
          expiredCount,
          message: `Expired ${expiredCount} subscriptions`
        });
      } catch (error) {
        console.error("[SUBSCRIPTION-EXPIRY] Error checking expiry:", error);
        res.status(500).json({
          success: false,
          error: "Failed to check subscription expiry"
        });
      }
    }
  );
  app2.post("/api/verify/phone/check", async (req, res) => {
    try {
      const { phoneNumber, code } = req.body;
      if (!phoneNumber || !code) {
        return res.status(400).json({ message: "Phone number and verification code are required" });
      }
      const verification = await storage.getVerificationCode(phoneNumber, code);
      if (!verification) {
        return res.status(400).json({ message: "Invalid verification code" });
      }
      if (verification.expiresAt < /* @__PURE__ */ new Date()) {
        await storage.deleteVerificationCode(verification.id);
        return res.status(400).json({ message: "Verification code has expired" });
      }
      await storage.deleteVerificationCode(verification.id);
      const existingUser = await storage.getUserByPhoneNumber(phoneNumber);
      if (existingUser) {
        await storage.updateUserProfile(existingUser.id, {
          verifiedByPhone: true
        });
        req.login(existingUser, (err) => {
          if (err) {
            console.error(
              "Error logging in existing user after phone verification:",
              err
            );
            return res.status(500).json({ message: "Error logging in after verification" });
          }
          const { password, ...userWithoutPassword } = existingUser;
          res.status(200).json({
            message: "Phone number verified. User logged in successfully.",
            user: userWithoutPassword
          });
        });
      } else {
        res.status(200).json({
          message: "Phone number verified. Please complete your profile.",
          phoneNumber
        });
      }
    } catch (error) {
      console.error("Phone verification check error:", error);
      res.status(500).json({ message: "Server error verifying code" });
    }
  });
  app2.post("/api/user/delete", async (req, res) => {
    if (!req.isAuthenticated()) {
      return res.status(401).json({ message: "Unauthorized" });
    }
    try {
      const { password } = req.body;
      const userId = req.user.id;
      const user = await storage.getUser(userId);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }
      const passwordValid = await comparePasswords(password, user.password);
      if (!passwordValid) {
        return res.status(400).json({
          message: "Password verification failed. Please enter your correct password."
        });
      }
      console.log(
        `User ${userId} requested account deletion with valid password`
      );
      let subscriptionCanceled = false;
      if (stripe2 && user.stripeSubscriptionId) {
        try {
          console.log(
            `[STRIPE-CANCELLATION] Canceling subscription ${user.stripeSubscriptionId} for user ${userId}`
          );
          const canceledSubscription = await stripe2.subscriptions.cancel(
            user.stripeSubscriptionId
          );
          console.log(
            `[STRIPE-CANCELLATION] Successfully canceled subscription: ${canceledSubscription.id}, status: ${canceledSubscription.status}`
          );
          subscriptionCanceled = true;
          await storage.updateUser(userId, {
            subscriptionStatus: "canceled",
            subscriptionCanceledAt: /* @__PURE__ */ new Date(),
            premiumAccess: false
          });
        } catch (error) {
          console.error(
            `[STRIPE-CANCELLATION] Error canceling subscription for user ${userId}:`,
            error
          );
        }
      } else if (user.stripeSubscriptionId && !stripe2) {
        console.warn(
          `[STRIPE-CANCELLATION] User ${userId} has subscription ${user.stripeSubscriptionId} but Stripe is not initialized`
        );
      }
      req.logout((err) => {
        if (err) {
          console.error(
            `Error logging out user ${userId} during account deletion:`,
            err
          );
          return res.status(500).json({ message: "Error during logout process" });
        }
        storage.deleteUser(userId).then(() => {
          console.log(`User ${userId} successfully deleted`);
          const responseMessage = subscriptionCanceled ? "Account and subscription successfully canceled and deleted" : "Account successfully deleted";
          res.status(200).json({
            message: responseMessage,
            redirectUrl: "/auth"
          });
        }).catch((error) => {
          console.error(`Error deleting user ${userId}:`, error);
          res.status(500).json({
            message: "Server error deleting account. Please try again later."
          });
        });
      });
    } catch (error) {
      console.error("Account deletion error:", error);
      res.status(500).json({
        message: "Server error processing account deletion request"
      });
    }
  });
  app2.post(
    "/api/user/deactivate-profile",
    async (req, res) => {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      try {
        const userId = req.user.id;
        await storage.updateUser(userId, {
          hasActivatedProfile: false,
          profileHidden: true,
          // Also hide the profile
          // Reset all MY INFO fields to null (Not specified)
          bio: null,
          location: null,
          countryOfOrigin: null,
          profession: null,
          religion: null,
          ethnicity: null,
          secondaryTribe: null,
          relationshipStatus: null,
          relationshipGoal: null,
          highSchool: null,
          collegeUniversity: null,
          interests: null,
          educationLevel: null,
          // Reset optional profile fields
          hasChildren: null,
          wantsChildren: null,
          smoking: null,
          drinking: null,
          // Reset OTHER section fields - Body Type and Height
          bodyType: null,
          height: null,
          // Reset photo visibility toggle
          showProfilePhoto: false,
          // Reset visibility preferences to disable MY INFO toggles only
          visibilityPreferences: JSON.stringify({
            bio: false,
            location: false,
            countryOfOrigin: false,
            profession: false,
            religion: false,
            ethnicity: false,
            relationshipStatus: false,
            relationshipGoal: false,
            highSchool: false,
            collegeUniversity: false,
            interests: false
          })
        });
        try {
          const preferences = await storage.getUserPreferences(userId);
          if (preferences) {
            await storage.updateUserPreferences(preferences.id, {
              // Reset children preferences
              hasChildrenPreference: null,
              wantsChildrenPreference: null,
              // Reset age range preferences to NULL
              minAge: null,
              maxAge: null,
              // Reset height range preferences to NULL
              minHeightPreference: null,
              maxHeightPreference: null,
              // Reset distance preference to NULL
              distancePreference: null,
              // Reset the 10 additional dating preference fields to NULL
              bodyTypePreference: null,
              // 1. Body Type
              religionPreference: null,
              // 3. Religion
              ethnicityPreference: null,
              // 4. Ghanaian Tribes
              educationLevelPreference: null,
              // 5. Education Level
              highSchoolPreference: null,
              // 6. High School Preferences (under-18 only)
              interestPreferences: null,
              // 7. Interests
              matchingPriorities: null,
              // 7. Matching Priorities
              dealBreakers: null,
              // 8. Deal Breakers
              relationshipGoalPreference: null
              // 9. Relationship Goals
            });
            console.log(
              `CRITICAL BUG FIXED: Reset ALL Dating Preferences (age, height, distance + 9 additional fields) to NULL for user ${userId} using preferences record ID ${preferences.id}`
            );
          } else {
            console.log(
              `No preferences record found for user ${userId} - skipping preferences reset`
            );
          }
        } catch (preferencesError) {
          console.error(
            `Error resetting preferences for user ${userId}:`,
            preferencesError
          );
        }
        try {
          await storage.deleteAllUserInterests(userId);
          console.log(`Cleared all interests for user ${userId}`);
        } catch (interestError) {
          console.error(
            `Error clearing interests for user ${userId}:`,
            interestError
          );
        }
        try {
          await storage.updateUserInterestsVisibility(userId, false);
          console.log(
            `Set all interests visibility to hidden for user ${userId}`
          );
        } catch (visibilityError) {
          console.error(
            `Error setting interests visibility for user ${userId}:`,
            visibilityError
          );
        }
        console.log(
          `User ${userId} deactivated their profile and reset all MY INFO fields`
        );
        res.status(200).json({
          message: "Profile deactivated successfully",
          success: true
        });
      } catch (error) {
        console.error("Profile deactivation error:", error);
        res.status(500).json({
          message: "Server error deactivating profile"
        });
      }
    }
  );
  app2.post(
    "/api/test/reset-networking",
    async (req, res) => {
      try {
        await storage.clearAllNetworkingConnections();
        res.json({ success: true, message: "Networking connections reset" });
      } catch (error) {
        console.error("Error resetting networking connections:", error);
        res.status(500).json({ message: "Failed to reset connections" });
      }
    }
  );
  const httpServer = createServer(app2);
  let wss;
  try {
    wss = new WebSocketServer({
      noServer: true
    });
    httpServer.on("upgrade", (request, socket, head) => {
      if (request.url === "/ws") {
        wss.handleUpgrade(request, socket, head, (ws2) => {
          wss.emit("connection", ws2, request);
        });
      }
    });
    console.log("WebSocket server created successfully on path /ws");
  } catch (error) {
    console.error(
      `Failed to create WebSocket server: ${error instanceof Error ? error.message : String(error)}`
    );
    wss = new WebSocketServer({ noServer: true });
  }
  const connectedUsers4 = /* @__PURE__ */ new Map();
  const typingTimeouts = /* @__PURE__ */ new Map();
  let profileVisibilityBroadcaster = null;
  let ghostModeBroadcaster = null;
  let verificationStatusBroadcaster = null;
  function broadcastNetworkingProfileUpdate(userId, updatedProfile) {
    const updateMessage = JSON.stringify({
      type: "networking_profile_updated",
      userId,
      profile: updatedProfile,
      timestamp: (/* @__PURE__ */ new Date()).toISOString()
    });
    console.log(
      `Broadcasting networking profile update for user ${userId} to ${connectedUsers4.size} connected users`
    );
    connectedUsers4.forEach((ws2, connectedUserId) => {
      if (connectedUserId !== userId && ws2.readyState === WebSocket4.OPEN) {
        try {
          ws2.send(updateMessage);
          console.log(
            `Sent networking profile update to user ${connectedUserId}`
          );
        } catch (error) {
          console.error(
            `Failed to send networking profile update to user ${connectedUserId}:`,
            error
          );
          connectedUsers4.delete(connectedUserId);
        }
      }
    });
  }
  function getConnectedUsers() {
    return connectedUsers4;
  }
  setWebSocketConnections(connectedUsers4);
  registerSuiteConnectionAPI(app2);
  setSuiteWebSocketConnections(connectedUsers4);
  setKwameWebSocketConnections(connectedUsers4);
  const activeChats = /* @__PURE__ */ new Map();
  const rateLimits = /* @__PURE__ */ new Map();
  wss.on("connection", (ws2, req) => {
    console.log("WebSocket connection established");
    let userId = null;
    ws2.on("message", async (message) => {
      try {
        const data = JSON.parse(message);
        console.log("\u{1F4E1} [WebSocket] Received message:", {
          type: data.type,
          userId,
          timestamp: (/* @__PURE__ */ new Date()).toISOString()
        });
        if (data.type && data.type.includes("call")) {
          console.log("\u{1F4E1} [WebSocket] Received call signaling message:", {
            type: data.type,
            userId,
            matchId: data.matchId,
            callId: data.callId,
            fromUserId: data.fromUserId || data.callerId,
            toUserId: data.toUserId || data.receiverId
          });
        }
        if (data.type === "auth") {
          userId = data.userId;
          if (userId) {
            try {
              const user = await storage.getUser(userId);
              if (!user) {
                ws2.send(
                  JSON.stringify({
                    type: "auth_error",
                    message: "User not found"
                  })
                );
                return;
              }
              connectedUsers4.set(userId, ws2);
              await storage.updateUserOnlineStatus(userId, true);
              const connectTime = /* @__PURE__ */ new Date();
              const timestampISO = connectTime.toISOString();
              console.log(
                `[PRESENCE] User ${userId} authenticated and is now online at ${timestampISO}`
              );
              ws2.send(
                JSON.stringify({
                  type: "auth_success",
                  userId,
                  timestamp: timestampISO
                })
              );
              const onlineCount = connectedUsers4.size;
              ws2.send(
                JSON.stringify({
                  type: "online_count_update",
                  count: onlineCount,
                  timestamp: timestampISO
                })
              );
              const userLastActive = await storage.getUserLastActive(userId);
              broadcastToAllUsers({
                type: "user_status",
                userId,
                status: "online",
                lastSeen: userLastActive ? userLastActive.toISOString() : null,
                timestamp: timestampISO,
                priority: "high"
                // Mark as high priority
              });
              broadcastToAllUsers({
                type: "online_count_update",
                count: onlineCount,
                timestamp: timestampISO
              });
            } catch (error) {
              console.error(
                `WebSocket authentication error for user ${userId}:`,
                error
              );
              ws2.send(
                JSON.stringify({
                  type: "auth_error",
                  message: "Authentication failed"
                })
              );
            }
          } else {
            ws2.send(
              JSON.stringify({
                type: "auth_error",
                message: "Invalid user ID"
              })
            );
          }
        } else if (data.type === "message" && userId) {
          try {
            if (!data.matchId) {
              console.error(
                `[PRIVACY VIOLATION] User ${userId} sent message without matchId`
              );
              ws2.send(
                JSON.stringify({
                  type: "error",
                  message: "Missing match ID for message",
                  code: "MISSING_MATCH_ID"
                })
              );
              return;
            }
            if (!data.receiverId) {
              console.error(
                `[PRIVACY VIOLATION] User ${userId} sent message without receiverId`
              );
              ws2.send(
                JSON.stringify({
                  type: "error",
                  message: "Missing recipient ID for message",
                  code: "MISSING_RECIPIENT_ID"
                })
              );
              return;
            }
            if (!data.content) {
              console.error(
                `[PRIVACY VIOLATION] User ${userId} attempted to send empty message content`
              );
              ws2.send(
                JSON.stringify({
                  type: "error",
                  message: "Message content cannot be empty",
                  code: "EMPTY_CONTENT"
                })
              );
              return;
            }
            if (typeof data.content !== "string") {
              console.error(
                `[PRIVACY VIOLATION] User ${userId} attempted to send invalid message content type: ${typeof data.content}`
              );
              ws2.send(
                JSON.stringify({
                  type: "error",
                  message: "Message content must be a string",
                  code: "INVALID_CONTENT_TYPE"
                })
              );
              return;
            }
            if (data.content.trim().length === 0) {
              console.error(
                `[PRIVACY VIOLATION] User ${userId} attempted to send whitespace-only message`
              );
              ws2.send(
                JSON.stringify({
                  type: "error",
                  message: "Message content cannot be empty",
                  code: "EMPTY_CONTENT"
                })
              );
              return;
            }
            const match = await storage.getMatchById(data.matchId);
            if (!match) {
              console.error(
                `[PRIVACY VIOLATION] User ${userId} attempted to send message for non-existent match ${data.matchId}`
              );
              ws2.send(
                JSON.stringify({
                  type: "error",
                  message: "Match not found",
                  code: "MATCH_NOT_FOUND"
                })
              );
              return;
            }
            if (match.userId1 !== userId && match.userId2 !== userId) {
              console.error(
                `[PRIVACY VIOLATION] User ${userId} attempted to send message for match ${data.matchId} they're not part of. Match participants: ${match.userId1}, ${match.userId2}`
              );
              ws2.send(
                JSON.stringify({
                  type: "error",
                  message: "Not authorized to send messages in this match",
                  code: "UNAUTHORIZED_MATCH"
                })
              );
              return;
            }
            const otherUserId = match.userId1 === userId ? match.userId2 : match.userId1;
            if (data.receiverId !== otherUserId) {
              console.error(
                `[PRIVACY VIOLATION] User ${userId} attempted to send message to unauthorized recipient ${data.receiverId} in match ${data.matchId}. Authorized recipient: ${otherUserId}`
              );
              ws2.send(
                JSON.stringify({
                  type: "error",
                  message: "Invalid recipient for this match",
                  code: "INVALID_RECIPIENT"
                })
              );
              return;
            }
            if (match.id !== data.matchId) {
              console.error(
                `[PRIVACY VIOLATION] Match ID mismatch: requested ${data.matchId}, found ${match.id}`
              );
              ws2.send(
                JSON.stringify({
                  type: "error",
                  message: "Match ID validation failed",
                  code: "MATCH_ID_MISMATCH"
                })
              );
              return;
            }
            console.log(
              `[PRIVACY] User ${userId} sending message to ${data.receiverId} in match ${data.matchId} (Verified: User is authorized participant)`
            );
            const messageData = {
              matchId: data.matchId,
              senderId: userId,
              receiverId: data.receiverId,
              content: data.content,
              encryptedContent: null,
              iv: null
              // Encryption removed as per requirements
            };
            const newMessage = await storage.createMessage(messageData);
            await storage.markMatchUnread(data.matchId, data.receiverId);
            console.log(
              `[PRIVACY] Created secure message ${newMessage.id} for match ${data.matchId}`
            );
            const messageReceiptId = `${newMessage.id}_${Date.now()}`;
            const recipientWs = connectedUsers4.get(data.receiverId);
            if (recipientWs && recipientWs.readyState === WebSocket4.OPEN) {
              recipientWs.send(
                JSON.stringify({
                  type: "new_message",
                  message: newMessage,
                  receiptId: messageReceiptId,
                  timestamp: (/* @__PURE__ */ new Date()).toISOString(),
                  for: "recipient"
                  // Explicitly mark this message for the recipient
                })
              );
            }
            ws2.send(
              JSON.stringify({
                type: "message_sent",
                messageId: newMessage.id,
                matchId: data.matchId,
                receiptId: messageReceiptId,
                // Same receipt ID to help client detect duplicates
                timestamp: (/* @__PURE__ */ new Date()).toISOString(),
                for: "sender"
                // Explicitly mark this message for the sender
              })
            );
          } catch (error) {
            console.error("Error processing message:", error);
            ws2.send(
              JSON.stringify({
                type: "error",
                message: "Failed to process message"
              })
            );
          }
        } else if (data.type === "typing_status" && userId) {
          try {
            if (!data.matchId) {
              console.error(
                `[PRIVACY VIOLATION] User ${userId} sent typing status without matchId`
              );
              ws2.send(
                JSON.stringify({
                  type: "error",
                  message: "Missing match ID for typing status",
                  code: "MISSING_MATCH_ID"
                })
              );
              return;
            }
            const match = await storage.getMatchById(data.matchId);
            if (!match) {
              console.error(
                `[PRIVACY VIOLATION] User ${userId} attempted to update typing status for non-existent match ${data.matchId}`
              );
              ws2.send(
                JSON.stringify({
                  type: "error",
                  message: "Match not found for typing status update",
                  code: "MATCH_NOT_FOUND"
                })
              );
              return;
            }
            if (match.userId1 !== userId && match.userId2 !== userId) {
              console.error(
                `[PRIVACY VIOLATION] User ${userId} attempted to update typing status for match ${data.matchId} they're not part of. Match participants: ${match.userId1}, ${match.userId2}`
              );
              ws2.send(
                JSON.stringify({
                  type: "error",
                  message: "Not authorized to update typing status in this match",
                  code: "UNAUTHORIZED_MATCH"
                })
              );
              return;
            }
            console.log(
              `[PRIVACY] User ${userId} updated typing status to ${data.isTyping} in match ${data.matchId} (Verified: User is authorized participant)`
            );
            await storage.updateTypingStatus(
              userId,
              data.matchId,
              data.isTyping
            );
            const otherUserId = match.userId1 === userId ? match.userId2 : match.userId1;
            const otherUserWs = connectedUsers4.get(otherUserId);
            if (otherUserWs && otherUserWs.readyState === WebSocket4.OPEN) {
              otherUserWs.send(
                JSON.stringify({
                  type: "typing_status",
                  userId,
                  matchId: data.matchId,
                  isTyping: data.isTyping,
                  timestamp: (/* @__PURE__ */ new Date()).toISOString()
                })
              );
            }
            if (data.isTyping) {
              const timeoutKey = `typing_${userId}_${data.matchId}`;
              if (typingTimeouts.has(timeoutKey)) {
                clearTimeout(typingTimeouts.get(timeoutKey));
              }
              const timeout = setTimeout(async () => {
                try {
                  console.log(
                    `[AUTO-CLEAR] Clearing stuck typing status for user ${userId} in match ${data.matchId}`
                  );
                  await storage.updateTypingStatus(
                    userId,
                    data.matchId,
                    false
                  );
                  const currentOtherUserWs = connectedUsers4.get(otherUserId);
                  if (currentOtherUserWs && currentOtherUserWs.readyState === WebSocket4.OPEN) {
                    currentOtherUserWs.send(
                      JSON.stringify({
                        type: "typing_status",
                        userId,
                        matchId: data.matchId,
                        isTyping: false,
                        timestamp: (/* @__PURE__ */ new Date()).toISOString(),
                        autoCleared: true
                      })
                    );
                  }
                  typingTimeouts.delete(timeoutKey);
                } catch (clearError) {
                  console.error(
                    "Error auto-clearing typing status:",
                    clearError
                  );
                }
              }, 1e4);
              typingTimeouts.set(timeoutKey, timeout);
            } else {
              const timeoutKey = `typing_${userId}_${data.matchId}`;
              if (typingTimeouts.has(timeoutKey)) {
                clearTimeout(typingTimeouts.get(timeoutKey));
                typingTimeouts.delete(timeoutKey);
              }
            }
          } catch (error) {
            console.error("Error updating typing status:", error);
          }
        } else if (data.type === "message_read" && userId) {
          try {
            if (!data.messageId) {
              console.error(
                `[PRIVACY VIOLATION] User ${userId} sent message_read without messageId`
              );
              ws2.send(
                JSON.stringify({
                  type: "error",
                  message: "Missing message ID for read status update",
                  code: "MISSING_MESSAGE_ID"
                })
              );
              return;
            }
            const message2 = await storage.getMessageById(data.messageId);
            if (!message2) {
              console.error(
                `[PRIVACY VIOLATION] User ${userId} attempted to mark non-existent message ${data.messageId} as read`
              );
              ws2.send(
                JSON.stringify({
                  type: "error",
                  message: "Message not found",
                  code: "MESSAGE_NOT_FOUND"
                })
              );
              return;
            }
            const match = await storage.getMatchById(message2.matchId);
            if (!match) {
              console.error(
                `[PRIVACY VIOLATION] Message ${data.messageId} belongs to non-existent match ${message2.matchId}`
              );
              ws2.send(
                JSON.stringify({
                  type: "error",
                  message: "Match not found for this message",
                  code: "MATCH_NOT_FOUND"
                })
              );
              return;
            }
            if (match.userId1 !== userId && match.userId2 !== userId) {
              console.error(
                `[PRIVACY VIOLATION] User ${userId} attempted to mark message as read for match ${message2.matchId} they're not part of. Match participants: ${match.userId1}, ${match.userId2}`
              );
              ws2.send(
                JSON.stringify({
                  type: "error",
                  message: "Not authorized to access messages in this match",
                  code: "UNAUTHORIZED_MATCH"
                })
              );
              return;
            }
            if (message2.receiverId !== userId) {
              console.error(
                `[PRIVACY VIOLATION] User ${userId} attempted to mark message ${data.messageId} as read but is not the recipient. Actual recipient: ${message2.receiverId}`
              );
              ws2.send(
                JSON.stringify({
                  type: "error",
                  message: "Not authorized to mark this message as read",
                  code: "UNAUTHORIZED_RECIPIENT"
                })
              );
              return;
            }
            if (message2.id !== data.messageId) {
              console.error(
                `[PRIVACY VIOLATION] Message ID mismatch: requested ${data.messageId}, found ${message2.id}`
              );
              ws2.send(
                JSON.stringify({
                  type: "error",
                  message: "Message ID validation failed",
                  code: "MESSAGE_ID_MISMATCH"
                })
              );
              return;
            }
            console.log(
              `[PRIVACY] User ${userId} marking message ${data.messageId} as read (Verified: User is authorized recipient)`
            );
            const updatedMessage = await storage.markMessageAsReadWithTimestamp(
              data.messageId
            );
            if (updatedMessage) {
              const senderWs = connectedUsers4.get(updatedMessage.senderId);
              if (senderWs && senderWs.readyState === WebSocket4.OPEN) {
                senderWs.send(
                  JSON.stringify({
                    type: "read_receipt",
                    messageId: updatedMessage.id,
                    matchId: updatedMessage.matchId,
                    readAt: updatedMessage.readAt,
                    timestamp: (/* @__PURE__ */ new Date()).toISOString()
                  })
                );
              }
            }
          } catch (error) {
            console.error("Error marking message as read:", error);
          }
        } else if (data.type === "active_chat" && userId) {
          try {
            const { matchId, active } = data;
            if (!matchId) {
              console.error(
                `[PRIVACY VIOLATION] User ${userId} sent active chat status without matchId`
              );
              ws2.send(
                JSON.stringify({
                  type: "error",
                  message: "Missing match ID for active chat status",
                  code: "MISSING_MATCH_ID"
                })
              );
              return;
            }
            const match = await storage.getMatchById(matchId);
            if (!match) {
              console.error(
                `[PRIVACY VIOLATION] User ${userId} attempted to update active status for non-existent match ${matchId}`
              );
              ws2.send(
                JSON.stringify({
                  type: "error",
                  message: "Match not found for active chat status update",
                  code: "MATCH_NOT_FOUND"
                })
              );
              return;
            }
            if (match.userId1 !== userId && match.userId2 !== userId) {
              console.error(
                `[PRIVACY VIOLATION] User ${userId} attempted to update active status for match ${matchId} they're not part of. Match participants: ${match.userId1}, ${match.userId2}`
              );
              ws2.send(
                JSON.stringify({
                  type: "error",
                  message: "Not authorized to update active chat status in this match",
                  code: "UNAUTHORIZED_MATCH"
                })
              );
              return;
            }
            if (match.id !== matchId) {
              console.error(
                `[PRIVACY VIOLATION] Match ID mismatch: requested ${matchId}, found ${match.id}`
              );
              ws2.send(
                JSON.stringify({
                  type: "error",
                  message: "Match ID validation failed",
                  code: "MATCH_ID_MISMATCH"
                })
              );
              return;
            }
            console.log(
              `[PRIVACY] User ${userId} updated active chat status to ${active} in match ${matchId} (Verified: User is authorized participant)`
            );
            const otherUserId = match.userId1 === userId ? match.userId2 : match.userId1;
            if (active) {
              if (!activeChats.has(userId)) {
                activeChats.set(userId, /* @__PURE__ */ new Set());
              }
              activeChats.get(userId).add(matchId);
              await storage.updateActiveChatStatus(userId, matchId, true);
              console.log(
                `[PRIVACY] User ${userId} set active status for match ${matchId} to true`
              );
              const activeUsers = await storage.getUsersInActiveChat(matchId);
              const bothUsersActive = activeUsers.includes(userId) && activeUsers.includes(otherUserId);
              const otherUserWs = connectedUsers4.get(otherUserId);
              if (otherUserWs && otherUserWs.readyState === WebSocket4.OPEN) {
                const currentTime = /* @__PURE__ */ new Date();
                const timestampISO = currentTime.toISOString();
                otherUserWs.send(
                  JSON.stringify({
                    type: "chat_partner_active",
                    userId,
                    matchId,
                    active: true,
                    inChat: bothUsersActive,
                    // Both users are in the chat
                    timestamp: timestampISO
                  })
                );
                otherUserWs.send(
                  JSON.stringify({
                    type: "user_status",
                    userId,
                    status: "online",
                    inChatMatch: matchId,
                    // This user is in this specific chat
                    timestamp: timestampISO,
                    priority: "high"
                    // Override any previous status
                  })
                );
                if (ws2.readyState === WebSocket4.OPEN) {
                  ws2.send(
                    JSON.stringify({
                      type: "user_status",
                      userId: otherUserId,
                      status: "online",
                      inChatMatch: activeUsers.includes(otherUserId) ? matchId : null,
                      timestamp: timestampISO,
                      priority: "high"
                      // Override any previous status
                    })
                  );
                }
              }
            } else {
              if (activeChats.has(userId)) {
                activeChats.get(userId).delete(matchId);
              }
              await storage.updateActiveChatStatus(userId, matchId, false);
              console.log(
                `[PRIVACY] User ${userId} set active status for match ${matchId} to false`
              );
              const otherUserWs = connectedUsers4.get(otherUserId);
              if (otherUserWs && otherUserWs.readyState === WebSocket4.OPEN) {
                otherUserWs.send(
                  JSON.stringify({
                    type: "chat_partner_active",
                    userId,
                    matchId,
                    active: false,
                    inChat: false,
                    // User has left the chat
                    timestamp: (/* @__PURE__ */ new Date()).toISOString()
                  })
                );
              }
            }
          } catch (error) {
            console.error("Error updating active chat status:", error);
          }
        } else if (data.type === "match_popup_closed" && userId) {
          try {
            const { matchId, sendMessage } = data;
            if (!matchId) {
              console.error(
                `[MATCH] User ${userId} sent match_popup_closed without matchId`
              );
              return;
            }
            const match = await storage.getMatchById(matchId);
            if (!match) {
              console.error(
                `[MATCH] User ${userId} attempted to close match popup for non-existent match ${matchId}`
              );
              return;
            }
            if (match.userId1 !== userId && match.userId2 !== userId) {
              console.error(
                `[MATCH] User ${userId} attempted to close match popup for match ${matchId} they're not part of`
              );
              return;
            }
            const otherUserId = match.userId1 === userId ? match.userId2 : match.userId1;
            const otherUserWs = connectedUsers4.get(otherUserId);
            if (otherUserWs && otherUserWs.readyState === WebSocket4.OPEN) {
              otherUserWs.send(
                JSON.stringify({
                  type: "match_popup_closed",
                  matchId,
                  closedBy: userId,
                  sendMessage: sendMessage || false,
                  timestamp: (/* @__PURE__ */ new Date()).toISOString()
                })
              );
              console.log(
                `[MATCH] Notified user ${otherUserId} that match popup for match ${matchId} was closed by user ${userId}`
              );
            } else {
              console.log(
                `[MATCH] Other user ${otherUserId} not connected via WebSocket, could not notify about match popup closed`
              );
            }
          } catch (error) {
            console.error("Error handling match popup closed event:", error);
          }
        } else if (data.type === "swipe_action" && userId) {
          try {
            const { targetUserId, action, isMatch } = data;
            if (!targetUserId || !action) {
              console.error(
                `[SWIPE] User ${userId} sent swipe_action without targetUserId or action`
              );
              return;
            }
            const targetUser = await storage.getUser(targetUserId);
            if (!targetUser) {
              console.error(
                `[SWIPE] User ${userId} attempted to swipe on non-existent user ${targetUserId}`
              );
              return;
            }
            console.log(
              `[SWIPE] User ${userId} ${action}d user ${targetUserId}`
            );
            if (action === "message") {
              try {
                let match = await storage.getMatchBetweenUsers(
                  userId,
                  targetUserId
                );
                let matchId;
                if (!match) {
                  const newMatch2 = await storage.createMatch({
                    userId1: userId,
                    userId2: targetUserId,
                    matched: true,
                    metadata: JSON.stringify({ origin: "MEET" })
                  });
                  matchId = newMatch2.id;
                  console.log(
                    `[SWIPE-MESSAGE] Created new match ${matchId} between users ${userId} and ${targetUserId}`
                  );
                } else if (!match.matched) {
                  const updatedMatch = await storage.updateMatchStatus(
                    match.id,
                    true
                  );
                  if (!updatedMatch) {
                    console.error(
                      `[SWIPE-MESSAGE] Failed to update match ${match.id} to matched=true`
                    );
                    return;
                  }
                  matchId = updatedMatch.id;
                  console.log(
                    `[SWIPE-MESSAGE] Updated match ${matchId} to matched=true`
                  );
                } else {
                  matchId = match.id;
                }
                const targetUserWs = connectedUsers4.get(targetUserId);
                if (targetUserWs && targetUserWs.readyState === WebSocket4.OPEN) {
                  const sourceUser = await storage.getUser(userId);
                  const safeUserInfo = sourceUser ? (({ password, ...rest }) => rest)(sourceUser) : { id: userId, fullName: "Unknown User" };
                  targetUserWs.send(
                    JSON.stringify({
                      type: "message_request",
                      fromUserId: userId,
                      fromUserInfo: safeUserInfo,
                      matchId,
                      timestamp: (/* @__PURE__ */ new Date()).toISOString()
                    })
                  );
                  console.log(
                    `[SWIPE-MESSAGE] Notified user ${targetUserId} about message request from user ${userId}`
                  );
                }
              } catch (error) {
                console.error(
                  `[SWIPE-MESSAGE] Error in message action handling: ${error}`
                );
              }
            } else {
              const sourceUserWs = connectedUsers4.get(userId);
              const targetUserWs = connectedUsers4.get(targetUserId);
              if (sourceUserWs && sourceUserWs.readyState === WebSocket4.OPEN) {
                sourceUserWs.send(
                  JSON.stringify({
                    type: "remove_from_discover",
                    removeUserId: targetUserId,
                    reason: `${action}_action`,
                    timestamp: (/* @__PURE__ */ new Date()).toISOString()
                  })
                );
                console.log(
                  `[REAL-TIME] Instantly removed user ${targetUserId}'s card from user ${userId}'s discover deck`
                );
              }
              if (targetUserWs && targetUserWs.readyState === WebSocket4.OPEN) {
                targetUserWs.send(
                  JSON.stringify({
                    type: "remove_from_discover",
                    removeUserId: userId,
                    reason: `received_${action}`,
                    timestamp: (/* @__PURE__ */ new Date()).toISOString()
                  })
                );
                if (action === "like") {
                  const sourceUser = await storage.getUser(userId);
                  const safeUserInfo = sourceUser ? (({ password, ...rest }) => rest)(sourceUser) : { id: userId, fullName: "Unknown User" };
                  targetUserWs.send(
                    JSON.stringify({
                      type: "new_like_received",
                      fromUserId: userId,
                      fromUserInfo: safeUserInfo,
                      isMatch: isMatch || false,
                      timestamp: (/* @__PURE__ */ new Date()).toISOString()
                    })
                  );
                }
                console.log(
                  `[REAL-TIME] Instantly removed user ${userId}'s card from user ${targetUserId}'s discover deck`
                );
              }
            }
            for (const [
              connectedUserId,
              connectedWs
            ] of connectedUsers4.entries()) {
              if (connectedWs.readyState === WebSocket4.OPEN) {
                if (connectedUserId === targetUserId || connectedUserId === userId) {
                  connectedWs.send(
                    JSON.stringify({
                      type: "discover:refresh",
                      timestamp: (/* @__PURE__ */ new Date()).toISOString()
                    })
                  );
                  if (action === "like" || action === "message") {
                    connectedWs.send(
                      JSON.stringify({
                        type: "matches:refresh",
                        timestamp: (/* @__PURE__ */ new Date()).toISOString()
                      })
                    );
                  }
                }
              }
            }
          } catch (error) {
            console.error("Error handling swipe action event:", error);
          }
        } else if (data.type === "ping") {
          ws2.send(
            JSON.stringify({
              type: "pong",
              timestamp: (/* @__PURE__ */ new Date()).toISOString()
            })
          );
        } else if (data.type === "get_online_count") {
          const onlineCount = connectedUsers4.size;
          ws2.send(
            JSON.stringify({
              type: "online_count_update",
              count: onlineCount,
              timestamp: (/* @__PURE__ */ new Date()).toISOString()
            })
          );
        } else if (data.type === "call_initiate" || data.type === "call_ringing" || data.type === "call_cancel" || data.type === "call_accept" || data.type === "call_decline" || data.type === "call_end" || data.type === "webrtc_offer" || data.type === "webrtc_answer" || data.type === "webrtc_ice") {
          if (!userId) return;
          const now = Date.now();
          const rateLimitKey = `call_signaling_${userId}`;
          if (!rateLimits.has(rateLimitKey)) {
            rateLimits.set(rateLimitKey, { count: 0, resetTime: now + 6e4 });
          }
          const userRateLimit = rateLimits.get(rateLimitKey);
          if (now > userRateLimit.resetTime) {
            userRateLimit.count = 0;
            userRateLimit.resetTime = now + 6e4;
          }
          userRateLimit.count++;
          if (userRateLimit.count > 50) {
            console.warn(
              `Rate limit exceeded for call signaling by user ${userId}`
            );
            return;
          }
          const { matchId, callId } = data;
          if (!matchId || data.type !== "webrtc_ice" && !callId) {
            console.warn(
              `Invalid call signaling message from user ${userId}:`,
              data.type
            );
            return;
          }
          const toUserId = data.toUserId ?? data.receiverId ?? (typeof data.callerId === "number" && data.callerId !== userId ? data.callerId : void 0) ?? (typeof data.fromUserId === "number" && data.fromUserId !== userId ? data.fromUserId : void 0);
          if (!toUserId) return;
          try {
            if (storage.getMatchById) {
              const match = await storage.getMatchById(matchId);
              if (!match) {
                console.warn(
                  `Match ${matchId} not found for call signaling from user ${userId}`
                );
                return;
              }
              const participants = /* @__PURE__ */ new Set([match.userId1, match.userId2]);
              if (!participants.has(userId) || !participants.has(toUserId)) {
                console.warn(
                  `User ${userId} not authorized for match ${matchId} call signaling`
                );
                return;
              }
            }
          } catch (error) {
            console.error(
              `Error validating match ${matchId} for call signaling:`,
              error
            );
            return;
          }
          if (callId && storage.getVideoCallById) {
            try {
              const call = await storage.getVideoCallById(callId);
              if (call && call.initiatorId !== userId && call.receiverId !== userId) {
                console.warn(
                  `User ${userId} not authorized for call ${callId}`
                );
                return;
              }
            } catch (error) {
              console.error(`Error validating call ${callId}:`, error);
            }
          }
          const targetWs = connectedUsers4.get(toUserId);
          console.log("\u{1F4E1} [WebSocket] Attempting to relay call signal:", {
            toUserId,
            targetWsExists: !!targetWs,
            targetWsReady: targetWs?.readyState === WebSocket4.OPEN,
            connectedUsersCount: connectedUsers4.size,
            connectedUserIds: Array.from(connectedUsers4.keys())
          });
          if (targetWs && targetWs.readyState === WebSocket4.OPEN) {
            console.log(
              "\u{1F4E1} [WebSocket] \u2705 Relaying call signal to user",
              toUserId
            );
            targetWs.send(
              JSON.stringify({
                ...data,
                timestamp: (/* @__PURE__ */ new Date()).toISOString()
              })
            );
          } else {
            console.log(
              "\u{1F4E1} [WebSocket] \u274C Cannot relay - target user not connected",
              toUserId
            );
          }
          try {
            if (data.type === "call_initiate" && data.callId) {
              await storage.updateVideoCallStatus?.(data.callId, {
                status: "pending"
              });
            } else if (data.type === "call_accept" && data.callId) {
              await storage.updateVideoCallStatus?.(data.callId, {
                status: "active",
                startedAt: /* @__PURE__ */ new Date()
              });
            } else if ((data.type === "call_decline" || data.type === "call_cancel") && data.callId) {
              await storage.updateVideoCallStatus?.(data.callId, {
                status: "declined",
                endedAt: /* @__PURE__ */ new Date()
              });
              try {
                const call = await storage.getVideoCallById?.(data.callId);
                if (call && !call.startedAt) {
                  const callerId = call.initiatorId;
                  const receiverId = call.receiverId;
                  const matchIdForCall = call.matchId;
                  console.log(
                    `\u{1F4DE} [CALL-SYSTEM] Creating no-answer message for match=${matchIdForCall} caller=${callerId} receiver=${receiverId}`
                  );
                  const callSystemMessage = await storage.createMessage({
                    matchId: matchIdForCall,
                    senderId: callerId,
                    receiverId,
                    content: "_CALL:NO_ANSWER",
                    // Caller sees: No answer; Receiver renders: Missed call
                    messageType: "call",
                    audioUrl: null,
                    audioDuration: null
                  });
                  try {
                    await storage.markMatchUnread(matchIdForCall, receiverId);
                  } catch (e) {
                    console.error(
                      "[CALL-SYSTEM] Failed to mark match unread:",
                      e
                    );
                  }
                  console.log(
                    `\u{1F4DE} [CALL-SYSTEM] Inserted call system message id=${callSystemMessage?.id} for match=${matchIdForCall}`
                  );
                  const rxWs = connectedUsers4.get(receiverId);
                  if (rxWs && rxWs.readyState === WebSocket4.OPEN) {
                    rxWs.send(
                      JSON.stringify({
                        type: "new_message",
                        message: callSystemMessage,
                        for: "recipient",
                        receiptId: `call_no_answer_${callSystemMessage?.id}_rx`,
                        timestamp: (/* @__PURE__ */ new Date()).toISOString()
                      })
                    );
                  }
                  const txWs = connectedUsers4.get(callerId);
                  if (txWs && txWs.readyState === WebSocket4.OPEN) {
                    txWs.send(
                      JSON.stringify({
                        type: "new_message",
                        message: callSystemMessage,
                        for: "sender",
                        receiptId: `call_no_answer_${callSystemMessage?.id}_tx`,
                        timestamp: (/* @__PURE__ */ new Date()).toISOString()
                      })
                    );
                  }
                }
              } catch (e) {
                console.error(
                  "Failed to create no-answer/missed call message:",
                  e
                );
              }
            } else if (data.type === "call_end" && data.callId) {
              let callRecord = null;
              try {
                if (storage.getVideoCallById) {
                  callRecord = await storage.getVideoCallById(data.callId);
                }
              } catch (e) {
                console.error(
                  "[CALL-SYSTEM] Error fetching call record on call_end:",
                  e
                );
              }
              if (callRecord && !callRecord.startedAt) {
                await storage.updateVideoCallStatus?.(data.callId, {
                  status: "declined",
                  endedAt: /* @__PURE__ */ new Date()
                });
                try {
                  const callerId = callRecord.initiatorId;
                  const receiverId = callRecord.receiverId;
                  const matchIdForCall = callRecord.matchId;
                  console.log(
                    `\u{1F4DE} [CALL-SYSTEM] call_end before start \u2192 creating no-answer message for match=${matchIdForCall} caller=${callerId} receiver=${receiverId}`
                  );
                  const callSystemMessage = await storage.createMessage({
                    matchId: matchIdForCall,
                    senderId: callerId,
                    receiverId,
                    content: "_CALL:NO_ANSWER",
                    messageType: "call",
                    audioUrl: null,
                    audioDuration: null
                  });
                  try {
                    await storage.markMatchUnread(matchIdForCall, receiverId);
                  } catch (e) {
                    console.error(
                      "[CALL-SYSTEM] Failed to mark match unread:",
                      e
                    );
                  }
                  const rxWs = connectedUsers4.get(receiverId);
                  if (rxWs && rxWs.readyState === WebSocket4.OPEN) {
                    rxWs.send(
                      JSON.stringify({
                        type: "new_message",
                        message: callSystemMessage,
                        for: "recipient",
                        receiptId: `call_no_answer_${callSystemMessage?.id}_rx`,
                        timestamp: (/* @__PURE__ */ new Date()).toISOString()
                      })
                    );
                  }
                  const txWs = connectedUsers4.get(callerId);
                  if (txWs && txWs.readyState === WebSocket4.OPEN) {
                    txWs.send(
                      JSON.stringify({
                        type: "new_message",
                        message: callSystemMessage,
                        for: "sender",
                        receiptId: `call_no_answer_${callSystemMessage?.id}_tx`,
                        timestamp: (/* @__PURE__ */ new Date()).toISOString()
                      })
                    );
                  }
                } catch (e) {
                  console.error(
                    "[CALL-SYSTEM] Failed to create/broadcast no-answer on call_end:",
                    e
                  );
                }
              } else {
                await storage.updateVideoCallStatus?.(data.callId, {
                  status: "completed",
                  endedAt: /* @__PURE__ */ new Date()
                });
              }
            }
          } catch (e) {
            console.error("Call status update error:", e);
          }
        }
      } catch (error) {
        console.error("Error processing WebSocket message:", error);
      }
    });
    ws2.on("close", async () => {
      if (userId) {
        console.log(`User ${userId} disconnected`);
        await storage.updateUserOnlineStatus(userId, false);
        if (activeChats.has(userId)) {
          const userActiveChats = Array.from(activeChats.get(userId) || []);
          for (const matchId of userActiveChats) {
            try {
              const match = await storage.getMatchById(matchId);
              if (match) {
                await storage.updateActiveChatStatus(userId, matchId, false);
                const otherUserId = match.userId1 === userId ? match.userId2 : match.userId1;
                const otherUserWs = connectedUsers4.get(otherUserId);
                if (otherUserWs && otherUserWs.readyState === WebSocket4.OPEN) {
                  otherUserWs.send(
                    JSON.stringify({
                      type: "chat_partner_active",
                      userId,
                      matchId,
                      active: false,
                      inChat: false,
                      timestamp: (/* @__PURE__ */ new Date()).toISOString()
                    })
                  );
                }
              }
            } catch (error) {
              console.error(
                `Error handling disconnection for match ${matchId}:`,
                error
              );
            }
          }
          activeChats.delete(userId);
        }
        connectedUsers4.delete(userId);
        const disconnectTime = /* @__PURE__ */ new Date();
        const timestampISO = disconnectTime.toISOString();
        const onlineCount = connectedUsers4.size;
        broadcastToAllUsers({
          type: "online_count_update",
          count: onlineCount,
          timestamp: timestampISO
        });
        broadcastToAllUsers({
          type: "user_profile_update",
          userId,
          isOnline: false,
          lastSeen: timestampISO,
          timestamp: timestampISO
        });
        const activeMatchIds = activeChats.get(userId) || /* @__PURE__ */ new Set();
        Array.from(activeMatchIds).forEach((matchId) => {
          broadcastToAllUsers({
            type: "chat_partner_active",
            userId,
            matchId,
            active: false,
            inChat: false,
            timestamp: timestampISO,
            priority: "high"
          });
        });
        broadcastToAllUsers({
          type: "user_disconnected",
          userId,
          timestamp: timestampISO
        });
        setTimeout(() => {
          const offlineStatus = {
            type: "user_status",
            userId,
            status: "offline",
            lastSeen: timestampISO,
            inChatMatch: null,
            // Clear any chat match on disconnect
            timestamp: timestampISO,
            priority: "high"
            // Mark as high priority to prevent race conditions
          };
          broadcastToAllUsers(offlineStatus);
          console.log(
            `[PRESENCE] User ${userId} is now offline. Last seen: ${timestampISO}`
          );
          Array.from(connectedUsers4.values()).forEach((clientWs) => {
            if (clientWs.readyState === WebSocket4.OPEN) {
              clientWs.send(
                JSON.stringify({
                  type: "chat_clear_user",
                  userId,
                  timestamp: timestampISO,
                  priority: "high"
                })
              );
            }
          });
        }, 50);
      }
    });
  });
  function broadcastToAllUsers(data) {
    connectedUsers4.forEach((ws2) => {
      if (ws2.readyState === WebSocket4.OPEN) {
        ws2.send(JSON.stringify(data));
      }
    });
  }
  function broadcastToUsers(userIds, data) {
    for (const userId of userIds) {
      const userSocket = connectedUsers4.get(userId);
      if (userSocket && userSocket.readyState === WebSocket4.OPEN) {
        userSocket.send(JSON.stringify(data));
      }
    }
  }
  function broadcastProfileVisibilityChange(userId, isHidden) {
    const visibilityChangeMessage = {
      type: "profileVisibilityChanged",
      userId,
      isHidden,
      timestamp: (/* @__PURE__ */ new Date()).toISOString()
    };
    let notifiedCount = 0;
    connectedUsers4.forEach((ws2, connectedUserId) => {
      if (connectedUserId !== userId && ws2.readyState === WebSocket4.OPEN) {
        try {
          ws2.send(JSON.stringify(visibilityChangeMessage));
          notifiedCount++;
        } catch (wsError) {
          console.error(
            `Failed to notify user ${connectedUserId} of profile visibility change:`,
            wsError
          );
        }
      }
    });
    console.log(
      `Broadcasted profile visibility change for user ${userId} to ${notifiedCount} other users`
    );
  }
  function broadcastGhostModeChange(userId, isEnabled) {
    const ghostModeChangeMessage = {
      type: "ghostModeChanged",
      userId,
      isEnabled,
      timestamp: (/* @__PURE__ */ new Date()).toISOString()
    };
    let notifiedCount = 0;
    connectedUsers4.forEach((ws2, connectedUserId) => {
      if (connectedUserId !== userId && ws2.readyState === WebSocket4.OPEN) {
        try {
          ws2.send(JSON.stringify(ghostModeChangeMessage));
          notifiedCount++;
        } catch (wsError) {
          console.error(
            `Failed to notify user ${connectedUserId} of Ghost Mode change:`,
            wsError
          );
        }
      }
    });
    console.log(
      `Broadcasted Ghost Mode change for user ${userId} to ${notifiedCount} other users`
    );
  }
  function broadcastVerificationStatusChange(userId, isVerified) {
    const verificationChangeMessage = {
      type: "verificationStatusChanged",
      userId,
      isVerified,
      timestamp: (/* @__PURE__ */ new Date()).toISOString()
    };
    let notifiedCount = 0;
    connectedUsers4.forEach((ws2, connectedUserId) => {
      if (ws2.readyState === WebSocket4.OPEN) {
        try {
          ws2.send(JSON.stringify(verificationChangeMessage));
          notifiedCount++;
        } catch (wsError) {
          console.error(
            `Failed to notify user ${connectedUserId} about verification status change:`,
            wsError
          );
        }
      }
    });
    console.log(
      `Broadcasted verification status change for user ${userId} (isVerified: ${isVerified}) to ${notifiedCount} connected users`
    );
  }
  app2.get(
    "/api/messages/check-chat/:matchId",
    async (req, res) => {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      try {
        const matchId = parseInt(req.params.matchId);
        if (isNaN(matchId)) {
          return res.status(400).json({ message: "Invalid match ID" });
        }
        const match = await storage.getMatchById(matchId);
        if (!match) {
          return res.status(404).json({ message: "Match not found" });
        }
        if (match.userId1 !== req.user.id && match.userId2 !== req.user.id) {
          return res.status(403).json({ message: "Not authorized to access this match" });
        }
        const messages2 = await storage.getMessagesByMatchId(matchId);
        const chatExists = messages2.length > 0;
        if (chatExists && !match.matched) {
          await storage.updateMatchStatus(matchId, true);
          console.log(
            `Auto-repaired match status for match ${matchId} - marked as matched since chat exists`
          );
        }
        return res.status(200).json({
          chatExists,
          messageCount: messages2.length,
          matchStatus: match.matched ? "confirmed" : "pending"
        });
      } catch (error) {
        console.error(`Error checking chat existence for match: ${error}`);
        return res.status(500).json({
          message: "Failed to check chat existence",
          error: error instanceof Error ? error.message : "Unknown error"
        });
      }
    }
  );
  app2.delete(
    "/api/messages/:messageId",
    async (req, res) => {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      try {
        const messageId = parseInt(req.params.messageId);
        if (isNaN(messageId)) {
          return res.status(400).json({ message: "Invalid message ID" });
        }
        const userId = req.user.id;
        const message = await storage.getMessageById(messageId);
        if (!message) {
          console.log(
            `Message ${messageId} not found - likely already deleted by user ${userId} or auto-delete`
          );
          return res.status(200).json({
            success: true,
            message: "Message already deleted",
            messageId,
            alreadyDeleted: true
          });
        }
        if (message.senderId !== userId) {
          return res.status(403).json({ message: "Not authorized to delete this message" });
        }
        const match = await storage.getMatchById(message.matchId);
        if (!match) {
          console.error(
            `\u26A0\uFE0F CRITICAL: Match ${message.matchId} not found during message deletion by user ${userId}. This suggests a data consistency issue.`
          );
          try {
            await new Promise((resolve) => setTimeout(resolve, 100));
            const retryMatch = await storage.getMatchById(message.matchId);
            if (retryMatch) {
              console.log(
                `\u2705 RECOVERY: Match ${message.matchId} found on retry. Continuing with deletion.`
              );
            } else {
              console.error(
                `\u274C CRITICAL: Match ${message.matchId} still not found after retry. Data consistency issue detected.`
              );
              return res.status(200).json({
                success: true,
                message: "Message deletion completed (match verification skipped due to temporary issue)",
                messageId,
                warning: "temporary_match_lookup_issue",
                userFriendlyMessage: "Your message was removed. If you experience any issues, please refresh the page."
              });
            }
          } catch (retryError) {
            console.error(`Failed to retry match lookup:`, retryError);
            console.log(
              `\u26A0\uFE0F FALLBACK: Proceeding with message deletion despite match lookup failure`
            );
            return res.status(200).json({
              success: true,
              message: "Message deletion completed (match verification bypassed)",
              messageId,
              warning: "match_lookup_failed",
              userFriendlyMessage: "Your message was removed. Your match is still active."
            });
          }
        }
        const actualMatch = match || await storage.getMatchById(message.matchId);
        if (actualMatch && actualMatch.userId1 !== userId && actualMatch.userId2 !== userId) {
          return res.status(403).json({ message: "Not authorized to access this match" });
        }
        if (message.messageType === "audio" && message.audioUrl) {
          try {
            console.log(`Would delete audio file: ${message.audioUrl}`);
          } catch (mediaError) {
            console.error("Error deleting media file:", mediaError);
          }
        }
        if (message.messageType === "image" && message.content?.startsWith("_!_IMAGE_!_")) {
          try {
            const imageUrl = message.content.replace("_!_IMAGE_!_", "");
            console.log(`Would delete image file: ${imageUrl}`);
          } catch (mediaError) {
            console.error("Error deleting image file:", mediaError);
          }
        }
        const deleteResult = await db.delete(messages).where(eq6(messages.id, messageId));
        const verificationMessage = await storage.getMessageById(messageId);
        if (verificationMessage) {
          console.warn(
            `Message ${messageId} deletion verification failed, but delete command executed`
          );
        }
        try {
          invalidateMessageCaches(connectedUsers4, {
            matchId: message.matchId,
            userId,
            messageId,
            reason: "message_delete"
          });
        } catch (cacheError) {
          console.error(
            `Failed to invalidate caches for match ${message.matchId}:`,
            cacheError
          );
        }
        const otherUserId = actualMatch ? actualMatch.userId1 === userId ? actualMatch.userId2 : actualMatch.userId1 : null;
        if (otherUserId) {
          const deletionMessage = {
            type: "messageDeleted",
            messageId,
            matchId: message.matchId,
            deletedBy: userId,
            timestamp: (/* @__PURE__ */ new Date()).toISOString()
          };
          const senderWs = connectedUsers4.get(userId);
          if (senderWs && senderWs.readyState === WebSocket4.OPEN) {
            try {
              senderWs.send(JSON.stringify(deletionMessage));
            } catch (wsError) {
              console.error(
                `Failed to notify sender ${userId} of message deletion:`,
                wsError
              );
            }
          }
          const receiverWs = connectedUsers4.get(otherUserId);
          if (receiverWs && receiverWs.readyState === WebSocket4.OPEN) {
            try {
              receiverWs.send(JSON.stringify(deletionMessage));
            } catch (wsError) {
              console.error(
                `Failed to notify receiver ${otherUserId} of message deletion:`,
                wsError
              );
            }
          }
        } else {
          console.warn(
            `\u26A0\uFE0F Skipping WebSocket broadcast for message ${messageId} - other user ID could not be determined`
          );
        }
        console.log(
          `Message ${messageId} successfully deleted by user ${userId} from match ${message.matchId}`
        );
        res.status(200).json({
          success: true,
          message: "Message deleted successfully",
          messageId,
          matchId: message.matchId
        });
      } catch (error) {
        console.error("Error deleting message:", error);
        const errorMessage = error instanceof Error ? error.message : "Unknown error";
        const requestedMessageId = parseInt(req.params.messageId);
        if (errorMessage.includes("not found") || errorMessage.includes("does not exist")) {
          return res.status(200).json({
            success: true,
            message: "Message already deleted",
            messageId: requestedMessageId,
            alreadyDeleted: true
          });
        }
        res.status(500).json({
          message: "Server error deleting message",
          error: errorMessage,
          success: false
        });
      }
    }
  );
  app2.delete(
    "/api/messages/:messageId/recipient",
    async (req, res) => {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      try {
        const messageId = parseInt(req.params.messageId);
        if (isNaN(messageId)) {
          return res.status(400).json({ message: "Invalid message ID" });
        }
        const userId = req.user.id;
        const message = await storage.getMessageById(messageId);
        if (!message) {
          return res.status(404).json({ message: "Message not found" });
        }
        const match = await storage.getMatchById(message.matchId);
        if (!match) {
          return res.status(404).json({ message: "Match not found" });
        }
        if (match.userId1 !== userId && match.userId2 !== userId) {
          return res.status(403).json({ message: "Not authorized to access this match" });
        }
        await storage.markMessageAsDeletedForUser(messageId, userId);
        try {
          invalidateMessageCaches(connectedUsers4, {
            matchId: message.matchId,
            userId,
            messageId,
            reason: "message_delete"
          });
        } catch (cacheError) {
          console.error(
            `Failed to invalidate caches for user ${userId} in match ${message.matchId}:`,
            cacheError
          );
        }
        console.log(
          `Message ${messageId} marked as deleted for user ${userId} (recipient deletion)`
        );
        res.status(200).json({
          success: true,
          message: "Message deleted from your view",
          messageId,
          matchId: message.matchId
        });
      } catch (error) {
        console.error("Error deleting message for recipient:", error);
        const errorMessage = error instanceof Error ? error.message : "Unknown error";
        res.status(500).json({
          message: "Server error deleting message",
          error: errorMessage,
          success: false
        });
      }
    }
  );
  app2.post(
    "/api/messages/:messageId/reactions",
    async (req, res) => {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      try {
        const messageId = parseInt(req.params.messageId);
        const { emoji } = req.body;
        const userId = req.user.id;
        if (isNaN(messageId) || !emoji) {
          return res.status(400).json({ message: "Invalid message ID or emoji" });
        }
        const message = await storage.getMessageById(messageId);
        if (!message) {
          return res.status(404).json({ message: "Message not found" });
        }
        const match = await storage.getMatchById(message.matchId);
        if (!match || match.userId1 !== userId && match.userId2 !== userId) {
          return res.status(403).json({ message: "Access denied" });
        }
        const reaction = await storage.addMessageReaction({
          messageId,
          userId,
          emoji
        });
        const reactingUser = await storage.getUser(userId);
        const userName = reactingUser?.fullName || reactingUser?.username || "Someone";
        const otherUserId = match.userId1 === userId ? match.userId2 : match.userId1;
        const otherUserSocket = connectedUsers4.get(otherUserId);
        if (otherUserSocket && otherUserSocket.readyState === WebSocket4.OPEN) {
          otherUserSocket.send(
            JSON.stringify({
              type: "reactionReplaced",
              // Changed from "reactionAdded" to be more accurate
              messageId,
              userId,
              emoji,
              matchId: message.matchId,
              reaction: {
                ...reaction,
                userName
              },
              isReplacement: true
              // Flag to indicate this replaces the user's previous reaction
            })
          );
        }
        res.json({ success: true, reaction });
      } catch (error) {
        console.error("Error adding message reaction:", error);
        res.status(500).json({ message: "Failed to add reaction" });
      }
    }
  );
  app2.delete(
    "/api/messages/:messageId/reactions",
    async (req, res) => {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      try {
        const messageId = parseInt(req.params.messageId);
        const { emoji } = req.body;
        const userId = req.user.id;
        if (isNaN(messageId) || !emoji) {
          return res.status(400).json({ message: "Invalid message ID or emoji" });
        }
        const message = await storage.getMessageById(messageId);
        if (!message) {
          return res.status(404).json({ message: "Message not found" });
        }
        const match = await storage.getMatchById(message.matchId);
        if (!match || match.userId1 !== userId && match.userId2 !== userId) {
          return res.status(403).json({ message: "Access denied" });
        }
        await storage.removeMessageReaction(messageId, userId, emoji);
        const removingUser = await storage.getUser(userId);
        const userName = removingUser?.fullName || removingUser?.username || "Someone";
        const otherUserId = match.userId1 === userId ? match.userId2 : match.userId1;
        const otherUserSocket = connectedUsers4.get(otherUserId);
        if (otherUserSocket && otherUserSocket.readyState === WebSocket4.OPEN) {
          otherUserSocket.send(
            JSON.stringify({
              type: "reactionRemoved",
              messageId,
              userId,
              emoji,
              matchId: message.matchId,
              userName
            })
          );
        }
        res.json({ success: true });
      } catch (error) {
        console.error("Error removing message reaction:", error);
        res.status(500).json({ message: "Failed to remove reaction" });
      }
    }
  );
  app2.get(
    "/api/messages/:messageId/reactions",
    async (req, res) => {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      try {
        const messageId = parseInt(req.params.messageId);
        const userId = req.user.id;
        if (isNaN(messageId)) {
          return res.status(400).json({ message: "Invalid message ID" });
        }
        const message = await storage.getMessageById(messageId);
        if (!message) {
          return res.status(404).json({ message: "Message not found" });
        }
        const match = await storage.getMatchById(message.matchId);
        if (!match || match.userId1 !== userId && match.userId2 !== userId) {
          return res.status(403).json({ message: "Access denied" });
        }
        const reactions = await storage.getMessageReactions(messageId);
        res.json({ reactions });
      } catch (error) {
        console.error("Error getting message reactions:", error);
        res.status(500).json({ message: "Failed to get reactions" });
      }
    }
  );
  app2.get(
    "/api/matches/:matchId/reactions",
    async (req, res) => {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      try {
        const matchId = parseInt(req.params.matchId);
        const userId = req.user.id;
        if (isNaN(matchId)) {
          return res.status(400).json({ message: "Invalid match ID" });
        }
        const match = await storage.getMatchById(matchId);
        if (!match || match.userId1 !== userId && match.userId2 !== userId) {
          return res.status(403).json({ message: "Access denied" });
        }
        const reactions = await storage.getMessageReactionsByMatch(matchId);
        res.json({ reactions });
      } catch (error) {
        console.error("Error getting match reactions:", error);
        res.status(500).json({ message: "Failed to get reactions" });
      }
    }
  );
  app2.get(
    "/api/matches/:matchId/auto-delete-settings",
    async (req, res) => {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      try {
        const matchId = parseInt(req.params.matchId);
        const userId = req.user.id;
        if (isNaN(matchId)) {
          return res.status(400).json({ message: "Invalid match ID" });
        }
        const match = await storage.getMatchById(matchId);
        if (!match || match.userId1 !== userId && match.userId2 !== userId) {
          return res.status(403).json({ message: "Access denied" });
        }
        const settings = await storage.getUserMatchSettings(userId, matchId);
        res.json({
          settings: settings || {
            autoDeleteMode: "never",
            autoDeleteValue: 5,
            autoDeleteUnit: "minutes"
          }
        });
      } catch (error) {
        console.error("Error getting auto-delete settings:", error);
        res.status(500).json({ message: "Failed to get auto-delete settings" });
      }
    }
  );
  app2.post(
    "/api/matches/:matchId/auto-delete-settings",
    async (req, res) => {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      try {
        const matchId = parseInt(req.params.matchId);
        const userId = req.user.id;
        const { autoDeleteMode, autoDeleteValue, autoDeleteUnit } = req.body;
        if (isNaN(matchId)) {
          return res.status(400).json({ message: "Invalid match ID" });
        }
        if (!["never", "always", "custom"].includes(autoDeleteMode)) {
          return res.status(400).json({ message: "Invalid auto-delete mode" });
        }
        if (autoDeleteMode === "custom") {
          if (!["minutes", "hours", "days", "weeks", "months"].includes(
            autoDeleteUnit
          )) {
            return res.status(400).json({ message: "Invalid auto-delete unit" });
          }
          if (!autoDeleteValue || autoDeleteValue < 1) {
            return res.status(400).json({ message: "Invalid auto-delete value" });
          }
        }
        const match = await storage.getMatchById(matchId);
        if (!match || match.userId1 !== userId && match.userId2 !== userId) {
          return res.status(403).json({ message: "Access denied" });
        }
        const currentSettings = await storage.getUserMatchSettings(
          userId,
          matchId
        );
        const isChangingToAlways = autoDeleteMode === "always" && (!currentSettings || currentSettings.autoDeleteMode !== "always");
        const settingsData = {
          autoDeleteMode,
          autoDeleteValue: autoDeleteValue || 5,
          autoDeleteUnit: autoDeleteUnit || "minutes"
        };
        if (isChangingToAlways) {
          settingsData.alwaysModeActivatedAt = /* @__PURE__ */ new Date();
          console.log(
            `User ${userId} activated "always" mode for match ${matchId} at ${settingsData.alwaysModeActivatedAt}`
          );
        }
        const settings = await storage.updateUserMatchSettings(
          userId,
          matchId,
          settingsData
        );
        res.json({ success: true, settings });
      } catch (error) {
        console.error("Error updating auto-delete settings:", error);
        res.status(500).json({ message: "Failed to update auto-delete settings" });
      }
    }
  );
  app2.post(
    "/api/admin/process-auto-delete",
    async (req, res) => {
      try {
        await storage.processAutoDeleteMessages();
        res.json({
          success: true,
          message: "Auto-delete processing completed"
        });
      } catch (error) {
        console.error("Error processing auto-delete messages:", error);
        res.status(500).json({ message: "Failed to process auto-delete messages" });
      }
    }
  );
  app2.post(
    "/api/matches/:matchId/trigger-auto-delete",
    async (req, res) => {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      try {
        const matchId = parseInt(req.params.matchId);
        const userId = req.user.id;
        if (isNaN(matchId)) {
          return res.status(400).json({ message: "Invalid match ID" });
        }
        const match = await storage.getMatchById(matchId);
        if (!match || match.userId1 !== userId && match.userId2 !== userId) {
          return res.status(403).json({ message: "Access denied" });
        }
        const settings = await storage.getUserMatchSettings(userId, matchId);
        if (settings && settings.autoDeleteMode === "always") {
          console.log(
            `Triggering auto-delete for user ${userId} in match ${matchId} (always mode)`
          );
          await storage.deleteMessagesForUser(userId, matchId);
          const remainingMessagesForUser = await storage.getMessagesByMatchId(
            matchId,
            userId
          );
          const remainingMessagesForOther = await storage.getMessagesByMatchId(
            matchId,
            match.userId1 === userId ? match.userId2 : match.userId1
          );
          const newLastMessageForUser = remainingMessagesForUser.length > 0 ? remainingMessagesForUser[remainingMessagesForUser.length - 1] : null;
          const newLastMessageForOther = remainingMessagesForOther.length > 0 ? remainingMessagesForOther[remainingMessagesForOther.length - 1] : null;
          const otherUserId = match.userId1 === userId ? match.userId2 : match.userId1;
          const currentUserSocket = connectedUsers4.get(userId);
          if (currentUserSocket && currentUserSocket.readyState === WebSocket4.OPEN) {
            currentUserSocket.send(
              JSON.stringify({
                type: "messagesDeletedForUser",
                matchId,
                deletedForUserId: userId,
                reason: "always_mode_exit",
                isCurrentUser: true,
                newLastMessage: newLastMessageForUser ? {
                  content: newLastMessageForUser.content,
                  createdAt: newLastMessageForUser.createdAt,
                  senderId: newLastMessageForUser.senderId
                } : null
              })
            );
          }
          const otherUserSocket = connectedUsers4.get(otherUserId);
          if (otherUserSocket && otherUserSocket.readyState === WebSocket4.OPEN) {
            otherUserSocket.send(
              JSON.stringify({
                type: "messagesDeletedForUser",
                matchId,
                deletedForUserId: userId,
                reason: "always_mode_exit",
                isCurrentUser: false,
                newLastMessage: newLastMessageForOther ? {
                  content: newLastMessageForOther.content,
                  createdAt: newLastMessageForOther.createdAt,
                  senderId: newLastMessageForOther.senderId
                } : null
              })
            );
          }
          const matchRefreshData = {
            type: "matches:refresh",
            matchId,
            reason: "auto_delete_lastMessage_update",
            timestamp: (/* @__PURE__ */ new Date()).toISOString()
          };
          if (currentUserSocket && currentUserSocket.readyState === WebSocket4.OPEN) {
            currentUserSocket.send(JSON.stringify(matchRefreshData));
          }
          if (otherUserSocket && otherUserSocket.readyState === WebSocket4.OPEN) {
            otherUserSocket.send(JSON.stringify(matchRefreshData));
          }
          res.json({
            success: true,
            message: "Auto-delete triggered successfully"
          });
        } else {
          res.json({ success: true, message: "No auto-delete needed" });
        }
      } catch (error) {
        console.error("Error triggering auto-delete:", error);
        res.status(500).json({ message: "Failed to trigger auto-delete" });
      }
    }
  );
  profileVisibilityBroadcaster = broadcastProfileVisibilityChange;
  ghostModeBroadcaster = broadcastGhostModeChange;
  verificationStatusBroadcaster = broadcastVerificationStatusChange;
  app2.get(
    "/api/suite/profile-settings",
    async (req, res) => {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      try {
        const userId = req.user.id;
        const settings = await storage.getSuiteProfileSettings(userId);
        res.json(
          settings || {
            jobProfileActive: false,
            mentorshipProfileActive: false,
            networkingProfileActive: false,
            hiddenInJobDiscovery: false,
            hiddenInMentorshipDiscovery: false,
            hiddenInNetworkingDiscovery: false,
            primaryProfileType: null
          }
        );
      } catch (error) {
        console.error("Error fetching SUITE profile settings:", error);
        res.status(500).json({ message: "Failed to fetch profile settings" });
      }
    }
  );
  app2.put(
    "/api/suite/profile-settings",
    async (req, res) => {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      try {
        const userId = req.user.id;
        const settings = req.body;
        const updatedSettings = await storage.updateSuiteProfileSettings(
          userId,
          settings
        );
        res.json(updatedSettings);
      } catch (error) {
        console.error("Error updating SUITE profile settings:", error);
        res.status(500).json({ message: "Failed to update profile settings" });
      }
    }
  );
  app2.get(
    "/api/suite/job-profile/:userId",
    async (req, res) => {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      try {
        const targetUserId = parseInt(req.params.userId);
        console.log(
          `[JOB-PROFILE-API] Request from user ${req.user.id} for job profile of target user ${targetUserId}`
        );
        const profile = await storage.getSuiteJobProfile(targetUserId);
        if (!profile) {
          console.log(
            `[JOB-PROFILE-API] No job profile found for target user ${targetUserId}`
          );
          return res.status(404).json({ message: "Job profile not found" });
        }
        console.log(
          `[JOB-PROFILE-API] Found job profile for target user ${targetUserId}:`,
          {
            profileId: profile.id,
            profileUserId: profile.userId,
            jobTitle: profile.jobTitle,
            description: profile.description,
            whoShouldApply: profile.whoShouldApply,
            applicationUrl: profile.applicationUrl,
            applicationEmail: profile.applicationEmail
          }
        );
        if (profile.userId !== targetUserId) {
          console.error(
            `[JOB-PROFILE-API] CRITICAL ERROR: Profile user ID ${profile.userId} does not match target user ID ${targetUserId}`
          );
          return res.status(500).json({ message: "Data integrity error" });
        }
        res.json(profile);
      } catch (error) {
        console.error("Error fetching job profile by user ID:", error);
        res.status(500).json({ message: "Failed to fetch job profile" });
      }
    }
  );
  app2.get("/api/suite/job-profile", async (req, res) => {
    if (!req.isAuthenticated()) {
      return res.status(401).json({ message: "Unauthorized" });
    }
    try {
      const userId = req.user.id;
      const jobProfile = await storage.getSuiteJobProfile(userId);
      res.json(jobProfile);
    } catch (error) {
      console.error("Error fetching job profile:", error);
      res.status(500).json({ message: "Failed to fetch job profile" });
    }
  });
  app2.post("/api/suite/job-profile", async (req, res) => {
    if (!req.isAuthenticated()) {
      return res.status(401).json({ message: "Unauthorized" });
    }
    try {
      const userId = req.user.id;
      const jobProfileData = { ...req.body, userId };
      const jobProfile = await storage.createOrUpdateSuiteJobProfile(
        userId,
        jobProfileData
      );
      await storage.updateSuiteProfileSettings(userId, {
        jobProfileActive: true,
        hiddenInJobDiscovery: false
        // Automatically make profile visible in discovery
      });
      res.json(jobProfile);
    } catch (error) {
      console.error("Error creating/updating job profile:", error);
      res.status(500).json({ message: "Failed to save job profile" });
    }
  });
  app2.patch("/api/suite/job-profile", async (req, res) => {
    if (!req.isAuthenticated()) {
      return res.status(401).json({ message: "Unauthorized" });
    }
    try {
      const userId = req.user.id;
      const { visibilityPreferences } = req.body;
      if (!visibilityPreferences) {
        return res.status(400).json({ message: "Visibility preferences required" });
      }
      const updatedProfile = await storage.updateSuiteJobProfileVisibility(
        userId,
        visibilityPreferences
      );
      res.json(updatedProfile);
    } catch (error) {
      console.error("Error updating job profile visibility:", error);
      res.status(500).json({ message: "Failed to update visibility preferences" });
    }
  });
  app2.delete("/api/suite/job-profile", async (req, res) => {
    if (!req.isAuthenticated()) {
      return res.status(401).json({ message: "Unauthorized" });
    }
    try {
      const userId = req.user.id;
      console.log("Deleting job profile for user:", userId);
      await storage.deleteSuiteJobProfile(userId);
      broadcastToAllUsers({
        type: "suite_profile_deleted",
        profileType: "job",
        userId,
        timestamp: (/* @__PURE__ */ new Date()).toISOString()
      });
      console.log("Job profile deleted successfully for user:", userId);
      res.json({
        success: true,
        message: "Job profile deleted successfully"
      });
    } catch (error) {
      console.error("Error deleting job profile:", error);
      res.status(500).json({
        message: "Failed to delete job profile",
        error: error instanceof Error ? error.message : "Unknown error"
      });
    }
  });
  app2.get(
    "/api/suite/mentorship-profile/:userId",
    async (req, res) => {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      try {
        const userId = parseInt(req.params.userId);
        const profiles = await storage.getSuiteMentorshipProfiles(userId);
        const profile = profiles && profiles.length > 0 ? profiles[0] : null;
        if (!profile) {
          return res.status(404).json({ message: "Mentorship profile not found" });
        }
        res.json(profile);
      } catch (error) {
        console.error("Error fetching mentorship profile by user ID:", error);
        res.status(500).json({ message: "Failed to fetch mentorship profile" });
      }
    }
  );
  app2.get(
    "/api/suite/mentorship-profile",
    async (req, res) => {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      try {
        const userId = req.user.id;
        const role = req.query.role;
        if (role) {
          const mentorshipProfile = await storage.getSuiteMentorshipProfile(
            userId,
            role
          );
          res.json(mentorshipProfile);
        } else {
          const mentorshipProfiles = await storage.getSuiteMentorshipProfiles(userId);
          res.json(mentorshipProfiles);
        }
      } catch (error) {
        console.error("Error fetching mentorship profile:", error);
        res.status(500).json({ message: "Failed to fetch mentorship profile" });
      }
    }
  );
  app2.get(
    "/api/suite/mentorship-profiles",
    async (req, res) => {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      try {
        const userId = req.user.id;
        const mentorshipProfiles = await storage.getSuiteMentorshipProfiles(userId);
        res.json(mentorshipProfiles);
      } catch (error) {
        console.error("Error fetching mentorship profiles:", error);
        res.status(500).json({ message: "Failed to fetch mentorship profiles" });
      }
    }
  );
  app2.post(
    "/api/suite/mentorship-profile",
    async (req, res) => {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      try {
        const userId = req.user.id;
        console.log("Received mentorship profile data:", req.body);
        const { userId: bodyUserId, ...mentorshipProfileData } = req.body;
        console.log("Cleaned mentorship profile data:", mentorshipProfileData);
        if (!mentorshipProfileData.role) {
          return res.status(400).json({ message: "Role (mentor/mentee) is required" });
        }
        const role = mentorshipProfileData.role;
        console.log("Creating/updating mentorship profile for role:", role);
        const existingProfile = await storage.getSuiteMentorshipProfileByRole(
          userId,
          role
        );
        if (existingProfile?.visibilityPreferences) {
          mentorshipProfileData.visibilityPreferences = existingProfile.visibilityPreferences;
          console.log(
            "POST: Preserving existing mentorship visibilityPreferences:",
            existingProfile.visibilityPreferences
          );
        }
        const mentorshipProfile = await storage.createOrUpdateSuiteMentorshipProfile(
          userId,
          mentorshipProfileData
        );
        await storage.updateSuiteProfileSettings(userId, {
          mentorshipProfileActive: true,
          hiddenInMentorshipDiscovery: false
          // Automatically make profile visible in discovery
        });
        console.log(
          "Successfully saved mentorship profile:",
          mentorshipProfile
        );
        res.json(mentorshipProfile);
      } catch (error) {
        console.error("Error creating/updating mentorship profile:", error);
        console.error("Error stack:", error?.stack);
        res.status(500).json({
          message: "Failed to save mentorship profile",
          error: error?.message
        });
      }
    }
  );
  app2.delete(
    "/api/suite/mentorship-profile",
    async (req, res) => {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      try {
        const userId = req.user.id;
        const { role } = req.query;
        console.log(
          "Deleting mentorship profile for user:",
          userId,
          "role:",
          role
        );
        if (role) {
          await storage.deleteSuiteMentorshipProfile(userId, role);
        } else {
          await storage.deleteSuiteMentorshipProfile(userId);
        }
        broadcastToAllUsers({
          type: "suite_profile_deleted",
          profileType: "mentorship",
          userId,
          role: role || "all",
          timestamp: (/* @__PURE__ */ new Date()).toISOString()
        });
        console.log(
          "Mentorship profile deleted successfully for user:",
          userId
        );
        res.json({
          success: true,
          message: "Mentorship profile deleted successfully"
        });
      } catch (error) {
        console.error("Error deleting mentorship profile:", error);
        res.status(500).json({
          message: "Failed to delete mentorship profile",
          error: error instanceof Error ? error.message : "Unknown error"
        });
      }
    }
  );
  app2.patch(
    "/api/suite/mentorship-profile",
    async (req, res) => {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      try {
        const userId = req.user.id;
        console.log("PATCH Mentorship profile request body:", req.body);
        console.log("User ID:", userId);
        const updateData = req.body;
        console.log("Mentorship profile PATCH data:", updateData);
        console.log(
          "visibilityPreferences in PATCH data:",
          updateData.visibilityPreferences
        );
        console.log(
          "Type of visibilityPreferences:",
          typeof updateData.visibilityPreferences
        );
        if (updateData.visibilityPreferences) {
          try {
            const parsed = JSON.parse(updateData.visibilityPreferences);
            console.log(
              "Successfully parsed visibilityPreferences:",
              Object.keys(parsed)
            );
          } catch (jsonError) {
            console.error("Invalid JSON in visibilityPreferences:", jsonError);
            return res.status(400).json({
              message: "visibilityPreferences must be a valid JSON string"
            });
          }
        }
        if (updateData.role) {
          const role = updateData.role;
          console.log("PATCH: Updating profile for role:", role);
          const existingProfile = await storage.getSuiteMentorshipProfileByRole(
            userId,
            role
          );
          if (!existingProfile) {
            console.log(
              "No existing mentorship profile found for role - PATCH requires existing profile"
            );
            return res.status(404).json({
              message: "No mentorship profile found. Create a profile first before updating preferences."
            });
          }
        } else {
          const existingProfile = await storage.getSuiteMentorshipProfile(userId);
          if (!existingProfile) {
            console.log(
              "No existing mentorship profile found - PATCH requires existing profile"
            );
            return res.status(404).json({
              message: "No mentorship profile found. Create a profile first before updating preferences."
            });
          }
        }
        console.log(
          "PATCH: About to call createOrUpdateSuiteMentorshipProfile with:",
          {
            userId,
            updateDataKeys: Object.keys(updateData),
            hasVisibilityPreferences: !!updateData.visibilityPreferences,
            visibilityPreferencesType: typeof updateData.visibilityPreferences
          }
        );
        const mentorshipProfile = await storage.createOrUpdateSuiteMentorshipProfile(
          userId,
          updateData
        );
        console.log(
          "Successfully updated mentorship profile via PATCH:",
          mentorshipProfile
        );
        res.json(mentorshipProfile);
      } catch (error) {
        console.error("Error updating mentorship profile via PATCH:", error);
        console.error("Error stack:", error?.stack);
        console.error("Error message:", error?.message);
        res.status(500).json({
          message: "Failed to update mentorship profile",
          error: error?.message
        });
      }
    }
  );
  app2.get(
    "/api/suite/networking-profile/:userId",
    async (req, res) => {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      try {
        const userId = parseInt(req.params.userId);
        const profile = await storage.getSuiteNetworkingProfile(userId);
        if (!profile) {
          return res.status(404).json({ message: "Networking profile not found" });
        }
        res.json(profile);
      } catch (error) {
        console.error("Error fetching networking profile by user ID:", error);
        res.status(500).json({ message: "Failed to fetch networking profile" });
      }
    }
  );
  app2.get(
    "/api/suite/networking-profile",
    async (req, res) => {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      try {
        const userId = req.user.id;
        console.log("Fetching networking profile for user:", userId);
        const networkingProfile = await storage.getSuiteNetworkingProfile(userId);
        console.log("Retrieved networking profile:", networkingProfile);
        console.log(
          "visibilityPreferences field:",
          networkingProfile?.visibilityPreferences
        );
        res.json(networkingProfile);
      } catch (error) {
        console.error("Error fetching networking profile:", error);
        res.status(500).json({ message: "Failed to fetch networking profile" });
      }
    }
  );
  app2.post(
    "/api/suite/networking-profile",
    async (req, res) => {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      try {
        const userId = req.user.id;
        console.log("Networking profile request body:", req.body);
        console.log("User ID:", userId);
        const { userId: bodyUserId, ...networkingProfileData } = req.body;
        console.log("Cleaned networking profile data:", networkingProfileData);
        const existingProfile = await storage.getSuiteNetworkingProfile(userId);
        if (existingProfile?.visibilityPreferences) {
          networkingProfileData.visibilityPreferences = existingProfile.visibilityPreferences;
          console.log(
            "POST: Preserving existing visibilityPreferences:",
            existingProfile.visibilityPreferences
          );
        }
        const networkingProfile = await storage.createOrUpdateSuiteNetworkingProfile(
          userId,
          networkingProfileData
        );
        await storage.updateSuiteProfileSettings(userId, {
          networkingProfileActive: true,
          hiddenInNetworkingDiscovery: false
          // Automatically make profile visible in discovery
        });
        broadcastNetworkingProfileUpdate(userId, networkingProfile);
        console.log(
          "Successfully saved networking profile:",
          networkingProfile
        );
        res.json(networkingProfile);
      } catch (error) {
        console.error("Error creating/updating networking profile:", error);
        console.error("Error stack:", error.stack);
        console.error("Error message:", error.message);
        res.status(500).json({
          message: "Failed to save networking profile",
          error: error.message
        });
      }
    }
  );
  app2.put(
    "/api/suite/networking-profile",
    async (req, res) => {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      try {
        const userId = req.user.id;
        console.log("PUT Networking profile request body:", req.body);
        console.log("User ID:", userId);
        const { userId: bodyUserId, ...networkingProfileData } = req.body;
        console.log("Cleaned networking profile data:", networkingProfileData);
        const existingProfile = await storage.getSuiteNetworkingProfile(userId);
        if (existingProfile?.visibilityPreferences) {
          networkingProfileData.visibilityPreferences = existingProfile.visibilityPreferences;
          console.log(
            "PUT: Preserving existing visibilityPreferences:",
            existingProfile.visibilityPreferences
          );
        }
        const networkingProfile = await storage.createOrUpdateSuiteNetworkingProfile(
          userId,
          networkingProfileData
        );
        broadcastNetworkingProfileUpdate(userId, networkingProfile);
        console.log(
          "Successfully updated networking profile via PUT:",
          networkingProfile
        );
        res.json(networkingProfile);
      } catch (error) {
        console.error("Error updating networking profile via PUT:", error);
        console.error("Error stack:", error.stack);
        console.error("Error message:", error.message);
        res.status(500).json({
          message: "Failed to update networking profile",
          error: error.message
        });
      }
    }
  );
  app2.delete(
    "/api/suite/networking-profile",
    async (req, res) => {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      try {
        const userId = req.user.id;
        console.log("Deleting networking profile for user:", userId);
        await storage.deleteSuiteNetworkingProfile(userId);
        broadcastToAllUsers({
          type: "suite_profile_deleted",
          profileType: "networking",
          userId,
          timestamp: (/* @__PURE__ */ new Date()).toISOString()
        });
        console.log(
          "Networking profile deleted successfully for user:",
          userId
        );
        res.json({
          success: true,
          message: "Networking profile deleted successfully"
        });
      } catch (error) {
        console.error("Error deleting networking profile:", error);
        res.status(500).json({
          message: "Failed to delete networking profile",
          error: error instanceof Error ? error.message : "Unknown error"
        });
      }
    }
  );
  app2.patch(
    "/api/suite/networking-profile",
    async (req, res) => {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      try {
        const userId = req.user.id;
        console.log("PATCH Networking profile request body:", req.body);
        console.log("User ID:", userId);
        const updateData = req.body;
        console.log("Networking profile PATCH data:", updateData);
        console.log(
          "visibilityPreferences in PATCH data:",
          updateData.visibilityPreferences
        );
        console.log(
          "Type of visibilityPreferences:",
          typeof updateData.visibilityPreferences
        );
        const existingProfile = await storage.getSuiteNetworkingProfile(userId);
        if (!existingProfile) {
          console.log(
            "No existing networking profile found - PATCH requires existing profile"
          );
          return res.status(404).json({
            message: "No networking profile found. Create a profile first before updating preferences."
          });
        }
        const networkingProfile = await storage.createOrUpdateSuiteNetworkingProfile(
          userId,
          updateData
        );
        broadcastNetworkingProfileUpdate(userId, networkingProfile);
        console.log(
          "Successfully updated networking profile via PATCH:",
          networkingProfile
        );
        res.json(networkingProfile);
      } catch (error) {
        console.error("Error updating networking profile via PATCH:", error);
        console.error("Error stack:", error.stack);
        console.error("Error message:", error.message);
        res.status(500).json({
          message: "Failed to update networking profile",
          error: error.message
        });
      }
    }
  );
  app2.patch(
    "/api/suite/networking-profile/activate",
    async (req, res) => {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      try {
        const userId = req.user.id;
        const { active } = req.body;
        if (typeof active !== "boolean") {
          return res.status(400).json({ message: "Active status must be a boolean" });
        }
        await storage.updateSuiteProfileSettings(userId, {
          networkingProfileActive: active
        });
        res.json({ success: true, networkingProfileActive: active });
      } catch (error) {
        console.error("Error updating networking profile activation:", error);
        res.status(500).json({ message: "Failed to update profile activation" });
      }
    }
  );
  app2.get(
    "/api/suite/field-visibility/:profileType",
    async (req, res) => {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      try {
        const userId = req.user.id;
        const profileType = req.params.profileType;
        if (!["job", "mentorship", "networking"].includes(profileType)) {
          return res.status(400).json({ message: "Invalid profile type" });
        }
        const visibilitySettings = await storage.getFieldVisibility(
          userId,
          profileType
        );
        const visibilityObject = visibilitySettings.reduce(
          (acc, setting) => {
            acc[setting.fieldName] = setting.isVisible;
            return acc;
          },
          {}
        );
        res.json(visibilityObject);
      } catch (error) {
        console.error("Error fetching field visibility:", error);
        res.status(500).json({ message: "Failed to fetch field visibility" });
      }
    }
  );
  app2.post(
    "/api/suite/field-visibility/:profileType",
    async (req, res) => {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      try {
        const userId = req.user.id;
        const profileType = req.params.profileType;
        const visibilityData = req.body;
        if (!["job", "mentorship", "networking"].includes(profileType)) {
          return res.status(400).json({ message: "Invalid profile type" });
        }
        if (!visibilityData || typeof visibilityData !== "object") {
          return res.status(400).json({ message: "Invalid visibility data" });
        }
        await storage.updateMultipleFieldVisibility(
          userId,
          profileType,
          visibilityData
        );
        res.json({ message: "Field visibility updated successfully" });
      } catch (error) {
        console.error("Error updating field visibility:", error);
        res.status(500).json({ message: "Failed to update field visibility" });
      }
    }
  );
  app2.put(
    "/api/suite/field-visibility/:profileType",
    async (req, res) => {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      try {
        const userId = req.user.id;
        const profileType = req.params.profileType;
        const visibilityData = req.body;
        if (!["job", "mentorship", "networking"].includes(profileType)) {
          return res.status(400).json({ message: "Invalid profile type" });
        }
        if (!visibilityData || typeof visibilityData !== "object") {
          return res.status(400).json({ message: "Invalid visibility data" });
        }
        await storage.updateMultipleFieldVisibility(
          userId,
          profileType,
          visibilityData
        );
        res.json({ message: "Field visibility updated successfully" });
      } catch (error) {
        console.error("Error updating field visibility:", error);
        res.status(500).json({ message: "Failed to update field visibility" });
      }
    }
  );
  app2.get("/api/suite/discovery/jobs", async (req, res) => {
    if (!req.isAuthenticated()) {
      return res.status(401).json({ message: "Unauthorized" });
    }
    try {
      const userId = req.user.id;
      const jobProfiles = await storage.getDiscoveryJobProfiles(
        userId,
        1e3,
        // High limit to get all available profiles
        0
      );
      console.log(`Loaded ${jobProfiles.length} job profiles for discovery`);
      const { suiteMatchingEngine: suiteMatchingEngine2 } = await Promise.resolve().then(() => (init_suite_matching_engine(), suite_matching_engine_exports));
      const ranked = await suiteMatchingEngine2.rankJobs(userId, jobProfiles);
      res.json(ranked);
    } catch (error) {
      console.error("Error fetching job discovery profiles:", error);
      res.status(500).json({ message: "Failed to fetch job profiles" });
    }
  });
  app2.post("/api/suite/jobs/apply", async (req, res) => {
    if (!req.isAuthenticated()) {
      return res.status(401).json({ message: "Unauthorized" });
    }
    try {
      const { profileId, action } = req.body;
      const userId = req.user.id;
      if (!profileId || !action) {
        return res.status(400).json({ message: "Missing required fields" });
      }
      if (!["like", "pass"].includes(action)) {
        return res.status(400).json({ message: "Invalid action" });
      }
      const jobProfile = await storage.getSuiteJobProfileById(profileId);
      if (!jobProfile) {
        return res.status(404).json({ message: "Job profile not found" });
      }
      const existingApplication = await storage.getSuiteJobApplication(
        userId,
        profileId
      );
      if (existingApplication) {
        return res.status(409).json({ message: "Already applied to this job" });
      }
      const applicationData = {
        userId,
        targetProfileId: profileId,
        targetUserId: jobProfile.userId,
        action,
        matched: false,
        applicationStatus: action === "like" ? "pending" : "rejected"
      };
      const application = await storage.createSuiteJobApplication(applicationData);
      await storage.addSwipeHistory({
        userId,
        targetUserId: jobProfile.userId,
        action: action === "like" ? "like" : "dislike",
        appMode: "SUITE_JOBS"
      });
      console.log(
        `\u{1F4DD} [SUITE-JOBS-HISTORY] Recorded swipe history for user ${userId} -> ${jobProfile.userId} (${action})`
      );
      let isMatch = false;
      if (action === "like") {
        const reciprocalApplication = await storage.getSuiteJobApplicationByUsers(
          jobProfile.userId,
          // job poster
          userId
          // current user (applicant)
        );
        if (reciprocalApplication && reciprocalApplication.action === "like") {
          await storage.updateSuiteJobApplication(application.id, {
            matched: true,
            applicationStatus: "matched"
          });
          await storage.updateSuiteJobApplication(reciprocalApplication.id, {
            matched: true,
            applicationStatus: "matched"
          });
          isMatch = true;
          const matchData = {
            userId1: Math.min(userId, jobProfile.userId),
            userId2: Math.max(userId, jobProfile.userId),
            matched: true,
            isDislike: false,
            metadata: JSON.stringify({
              origin: "SUITE",
              suiteType: "jobs",
              context: "professional"
            })
          };
          await storage.createMatch(matchData);
          console.log(
            `\u{1F4BC} [SUITE-JOBS] Instant match created: ${userId} \u2194 ${jobProfile.userId}`
          );
          try {
            await storage.removeMatchedUsersFromSwipeHistory(
              userId,
              jobProfile.userId
            );
            console.log(
              `[JOBS-MATCH] Cleaned up swipe history for matched users: ${userId} \u2194 ${jobProfile.userId}`
            );
          } catch (historyError) {
            console.error(
              "Error cleaning up jobs swipe history for matched users:",
              historyError
            );
          }
        }
      }
      const removalMessage = {
        type: "suite_remove_from_discover",
        suiteType: "jobs",
        // Backend sends plural "jobs"
        removeProfileId: profileId,
        removeUserId: jobProfile.userId,
        reason: `jobs_${action}_action`,
        timestamp: (/* @__PURE__ */ new Date()).toISOString()
      };
      const currentUserWs = connectedUsers4.get(userId);
      if (currentUserWs && currentUserWs.readyState === 1) {
        currentUserWs.send(JSON.stringify(removalMessage));
        console.log(
          `\u{1F5D1}\uFE0F [JOBS-REMOVAL] Sent card removal to user ${userId} for profile ${profileId}`
        );
      }
      const targetUserWs = connectedUsers4.get(jobProfile.userId);
      if (targetUserWs && targetUserWs.readyState === 1) {
        try {
          const currentUserJobProfile = await storage.getSuiteJobProfileByUserId(userId);
          if (currentUserJobProfile) {
            const targetRemovalMessage = {
              type: "suite_remove_from_discover",
              suiteType: "jobs",
              removeProfileId: currentUserJobProfile.id,
              // Use profile ID, not user ID
              removeUserId: userId,
              reason: `jobs_bidirectional_${action}`,
              timestamp: (/* @__PURE__ */ new Date()).toISOString()
            };
            targetUserWs.send(JSON.stringify(targetRemovalMessage));
            console.log(
              `\u{1F5D1}\uFE0F [JOBS-REMOVAL] Sent bidirectional card removal to user ${jobProfile.userId} for profile ${currentUserJobProfile.id} (user ${userId})`
            );
          }
        } catch (profileError) {
          console.error(
            "Error getting current user's job profile for bidirectional removal:",
            profileError
          );
        }
      }
      if (action === "like") {
        if (targetUserWs && targetUserWs.readyState === 1) {
          const notificationData = {
            type: isMatch ? "job_match" : "job_application",
            application,
            fromUserId: userId,
            isMatch,
            timestamp: (/* @__PURE__ */ new Date()).toISOString()
          };
          targetUserWs.send(JSON.stringify(notificationData));
          console.log(
            `WebSocket notification sent to user ${jobProfile.userId} for job application`
          );
        }
      }
      res.json({
        success: true,
        action,
        profileId,
        isMatch,
        message: isMatch ? "It's a job match!" : action === "like" ? "Application submitted" : "Job passed"
      });
    } catch (error) {
      console.error("Error processing job application:", error);
      res.status(500).json({ message: "Failed to process job application" });
    }
  });
  app2.post(
    "/api/suite/connections/jobs/:applicationId/respond",
    async (req, res) => {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      try {
        const { action } = req.body;
        const applicationId = parseInt(req.params.applicationId);
        const currentUserId = req.user.id;
        if (!["accept", "decline"].includes(action)) {
          return res.status(400).json({ message: "Invalid action" });
        }
        const existingApplication = await storage.getSuiteJobApplicationById(applicationId);
        if (!existingApplication) {
          return res.status(404).json({ message: "Job application not found" });
        }
        if (existingApplication.targetUserId !== currentUserId) {
          return res.status(403).json({ message: "Not authorized to respond to this application" });
        }
        let isMatch = false;
        if (action === "accept") {
          await storage.updateSuiteJobApplication(existingApplication.id, {
            applicationStatus: "accepted",
            matched: true
          });
          isMatch = true;
          const existingMatch = await storage.getMatchBetweenUsers(
            currentUserId,
            existingApplication.userId
          );
          console.log(
            `\u{1F50D} [JOBS-ACCEPT-DEBUG] Existing match found: ${existingMatch ? `ID ${existingMatch.id}` : "none"}`
          );
          const currentUserNetworkingProfile = await storage.getSuiteNetworkingProfile(currentUserId);
          const targetUserNetworkingProfile = await storage.getSuiteNetworkingProfile(existingApplication.userId);
          console.log(
            `\u{1F50D} [JOBS-ACCEPT-DEBUG] Networking profiles - Current user ${currentUserId}: ${currentUserNetworkingProfile ? "exists" : "none"}, Target user ${existingApplication.userId}: ${targetUserNetworkingProfile ? "exists" : "none"}`
          );
          let existingNetworkingConnection = null;
          if (currentUserNetworkingProfile && targetUserNetworkingProfile) {
            const connection1 = await storage.getSuiteNetworkingConnection(
              currentUserId,
              targetUserNetworkingProfile.id
            );
            const connection2 = await storage.getSuiteNetworkingConnection(
              existingApplication.userId,
              currentUserNetworkingProfile.id
            );
            console.log(
              `\u{1F50D} [JOBS-ACCEPT-DEBUG] Connection1 (${currentUserId} -> ${targetUserNetworkingProfile.id}): ${connection1 ? `matched=${connection1.matched}, action=${connection1.action}` : "none"}`
            );
            console.log(
              `\u{1F50D} [JOBS-ACCEPT-DEBUG] Connection2 (${existingApplication.userId} -> ${currentUserNetworkingProfile.id}): ${connection2 ? `matched=${connection2.matched}, action=${connection2.action}` : "none"}`
            );
            existingNetworkingConnection = connection1?.matched || connection2?.matched ? connection1?.matched ? connection1 : connection2 : connection1?.action === "like" && connection2?.action === "like" ? connection1 : null;
          }
          console.log(
            `\u{1F50D} [JOBS-ACCEPT-DEBUG] Final networking connection selected: ${existingNetworkingConnection ? `matched=${existingNetworkingConnection.matched}` : "none"}`
          );
          let finalMatch;
          if (existingMatch) {
            try {
              let existingMetadata;
              if (existingMatch.metadata) {
                existingMetadata = typeof existingMatch.metadata === "string" ? JSON.parse(existingMatch.metadata) : existingMatch.metadata;
              }
              console.log(
                `\u{1F50D} [JOBS-ACCEPT-DEBUG] Existing match metadata:`,
                existingMetadata
              );
              if (existingMetadata) {
                if (!existingMetadata.additionalConnections) {
                  existingMetadata.additionalConnections = [];
                }
                if (existingNetworkingConnection && existingNetworkingConnection.matched && !existingMetadata.additionalConnections.includes("networking")) {
                  existingMetadata.additionalConnections.push("networking");
                  console.log(
                    `\u{1F517} [JOBS-ACCEPT] Adding networking to additionalConnections for existing match ${existingMatch.id}`
                  );
                }
                if (existingMetadata.origin === "SUITE" && existingMetadata.suiteType !== "jobs" || existingMetadata.origin === "MEET") {
                  if (!existingMetadata.additionalConnections.includes("jobs")) {
                    existingMetadata.additionalConnections.push("jobs");
                    console.log(
                      `\u{1F517} [JOBS-ACCEPT] Adding jobs to additionalConnections for existing match ${existingMatch.id} between users ${currentUserId} and ${existingApplication.userId}`
                    );
                  }
                  finalMatch = await storage.updateMatch(existingMatch.id, {
                    matched: true,
                    metadata: JSON.stringify(existingMetadata)
                  });
                } else {
                  if (existingNetworkingConnection && existingNetworkingConnection.matched && !existingMetadata.additionalConnections.includes(
                    "networking"
                  )) {
                    existingMetadata.additionalConnections.push("networking");
                    console.log(
                      `\u{1F517} [JOBS-ACCEPT] Adding networking to additionalConnections for jobs match ${existingMatch.id}`
                    );
                    finalMatch = await storage.updateMatch(existingMatch.id, {
                      matched: true,
                      metadata: JSON.stringify(existingMetadata)
                    });
                  } else {
                    finalMatch = await storage.updateMatch(existingMatch.id, {
                      matched: true,
                      metadata: JSON.stringify(existingMetadata)
                    });
                    console.log(
                      `\u{1F517} [JOBS-ACCEPT] Updated existing match ${existingMatch.id} with jobs metadata`
                    );
                  }
                }
              } else {
                const newMetadata = {
                  origin: "SUITE",
                  suiteType: "jobs",
                  context: "professional",
                  additionalConnections: []
                };
                if (existingNetworkingConnection && existingNetworkingConnection.matched) {
                  newMetadata.additionalConnections.push("networking");
                  console.log(
                    `\u{1F517} [JOBS-ACCEPT] Adding networking to new metadata for match ${existingMatch.id}`
                  );
                }
                finalMatch = await storage.updateMatch(existingMatch.id, {
                  matched: true,
                  metadata: JSON.stringify(newMetadata)
                });
                console.log(
                  `\u{1F517} [JOBS-ACCEPT] Added jobs metadata with networking additional connection to existing match ${existingMatch.id}`
                );
              }
            } catch (parseError) {
              console.error("Failed to parse existing metadata:", parseError);
              finalMatch = await storage.updateMatch(existingMatch.id, {
                matched: true,
                metadata: JSON.stringify({
                  origin: "SUITE",
                  suiteType: "jobs",
                  context: "professional"
                })
              });
            }
          } else if (existingNetworkingConnection && (existingNetworkingConnection.matched || existingNetworkingConnection.action === "like")) {
            console.log(
              `\u{1F517} [JOBS-ACCEPT] Found existing networking connection between users ${currentUserId} and ${existingApplication.userId}, creating match with jobs as additional connection`
            );
            const matchData = {
              userId1: Math.min(currentUserId, existingApplication.userId),
              userId2: Math.max(currentUserId, existingApplication.userId),
              matched: true,
              isDislike: false,
              metadata: JSON.stringify({
                origin: "SUITE",
                suiteType: "networking",
                context: "professional",
                additionalConnections: ["jobs"]
              })
            };
            finalMatch = await storage.createMatch(matchData);
            console.log(
              `\u{1F517} [JOBS-ACCEPT] Created new match ${finalMatch.id} with networking as primary and jobs as additional connection`
            );
          } else {
            const matchData = {
              userId1: Math.min(currentUserId, existingApplication.userId),
              userId2: Math.max(currentUserId, existingApplication.userId),
              matched: true,
              isDislike: false,
              metadata: JSON.stringify({
                origin: "SUITE",
                suiteType: "jobs",
                context: "professional"
              })
            };
            finalMatch = await storage.createMatch(matchData);
            console.log(
              `\u{1F517} [JOBS-ACCEPT] Created new jobs match between users ${currentUserId} and ${existingApplication.userId}`
            );
          }
          try {
            await storage.removeMatchedUsersFromSwipeHistory(
              currentUserId,
              existingApplication.userId
            );
            console.log(
              `[JOBS-ACCEPT-MATCH] Cleaned up swipe history for matched users: ${currentUserId} \u2194 ${existingApplication.userId}`
            );
          } catch (historyError) {
            console.error(
              "Error cleaning up jobs accept swipe history for matched users:",
              historyError
            );
          }
          const acceptedByUser = await storage.getUser(currentUserId);
          const applicantUser = await storage.getUser(
            existingApplication.userId
          );
          const applicantWs = connectedUsers4.get(existingApplication.userId);
          console.log(
            `[SUITE-JOBS-DEBUG] Applicant WebSocket for user ${existingApplication.userId}: ${applicantWs ? `found, readyState=${applicantWs.readyState}` : "NOT FOUND"}`
          );
          if (applicantWs && applicantWs.readyState === 1) {
            const notificationData = {
              type: "job_match",
              application: {
                id: existingApplication.id,
                userId: existingApplication.userId,
                targetUserId: existingApplication.targetUserId
              },
              acceptedBy: currentUserId,
              isMatch: true,
              timestamp: (/* @__PURE__ */ new Date()).toISOString(),
              matchedUserName: acceptedByUser?.fullName,
              matchedUserPhoto: acceptedByUser?.photoUrl,
              matchedUserProfession: acceptedByUser?.profession,
              matchedUserLocation: acceptedByUser?.location
            };
            applicantWs.send(JSON.stringify(notificationData));
            console.log(
              `[SUITE-JOBS] Sent job match notification to applicant (User ${existingApplication.userId})`
            );
          } else {
            console.log(
              `[SUITE-JOBS-ERROR] Cannot send notification to applicant (User ${existingApplication.userId}) - WebSocket ${applicantWs ? "not ready" : "not found"}`
            );
          }
          const accepterWs = connectedUsers4.get(currentUserId);
          console.log(
            `[SUITE-JOBS-DEBUG] Accepter WebSocket for user ${currentUserId}: ${accepterWs ? `found, readyState=${accepterWs.readyState}` : "NOT FOUND"}`
          );
          if (accepterWs && accepterWs.readyState === 1) {
            const notificationData = {
              type: "job_match",
              application: {
                id: existingApplication.id,
                userId: existingApplication.userId,
                targetUserId: existingApplication.targetUserId
              },
              acceptedBy: currentUserId,
              isMatch: true,
              timestamp: (/* @__PURE__ */ new Date()).toISOString(),
              matchedUserName: applicantUser?.fullName,
              matchedUserPhoto: applicantUser?.photoUrl,
              matchedUserProfession: applicantUser?.profession,
              matchedUserLocation: applicantUser?.location
            };
            accepterWs.send(JSON.stringify(notificationData));
            console.log(
              `[SUITE-JOBS] Sent job match notification to accepter (User ${currentUserId})`
            );
          } else {
            console.log(
              `[SUITE-JOBS-ERROR] Cannot send notification to accepter (User ${currentUserId}) - WebSocket ${accepterWs ? "not ready" : "not found"}`
            );
          }
        } else {
          await storage.updateSuiteJobApplication(existingApplication.id, {
            applicationStatus: "rejected",
            matched: false
          });
        }
        res.json({
          success: true,
          isMatch,
          action,
          message: action === "accept" ? "Application accepted" : "Application declined"
        });
      } catch (error) {
        console.error("Error responding to job application:", error);
        res.status(500).json({ message: "Failed to respond to job application" });
      }
    }
  );
  app2.get(
    "/api/suite/discovery/mentorship",
    async (req, res) => {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      try {
        const userId = req.user.id;
        const mentorshipProfiles = await storage.getDiscoveryMentorshipProfiles(
          userId,
          1e3,
          // High limit to get all available profiles
          0
        );
        console.log(
          `Loaded ${mentorshipProfiles.length} mentorship profiles for discovery`
        );
        const { suiteMatchingEngine: suiteMatchingEngine2 } = await Promise.resolve().then(() => (init_suite_matching_engine(), suite_matching_engine_exports));
        const ranked = await suiteMatchingEngine2.rankMentorship(
          userId,
          mentorshipProfiles
        );
        res.json(ranked);
      } catch (error) {
        console.error("Error fetching mentorship discovery profiles:", error);
        res.status(500).json({ message: "Failed to fetch mentorship profiles" });
      }
    }
  );
  app2.get(
    "/api/suite/discovery/networking",
    async (req, res) => {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      try {
        const userId = req.user.id;
        const networkingProfiles = await storage.getDiscoveryNetworkingProfiles(
          userId,
          1e3,
          // High limit to get all available profiles
          0
        );
        console.log(
          `Loaded ${networkingProfiles.length} networking profiles for discovery`
        );
        const { suiteMatchingEngine: suiteMatchingEngine2 } = await Promise.resolve().then(() => (init_suite_matching_engine(), suite_matching_engine_exports));
        const ranked = await suiteMatchingEngine2.rankNetworking(
          userId,
          networkingProfiles
        );
        res.json(ranked);
      } catch (error) {
        console.error("Error fetching networking discovery profiles:", error);
        res.status(500).json({ message: "Failed to fetch networking profiles" });
      }
    }
  );
  app2.post(
    "/api/suite/networking/swipe",
    async (req, res) => {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      try {
        const { profileId, action } = req.body;
        const currentUserId = req.user.id;
        if (!profileId || !action || !["like", "pass"].includes(action)) {
          return res.status(400).json({ message: "Invalid swipe data" });
        }
        const currentUserNetworkingProfile = await storage.getSuiteNetworkingProfile(currentUserId);
        if (!currentUserNetworkingProfile) {
          return res.status(403).json({
            message: "Profile required",
            action: "create_profile",
            profileType: "networking"
          });
        }
        const targetProfile = await storage.getSuiteNetworkingProfileById(profileId);
        if (!targetProfile) {
          return res.status(404).json({ message: "Profile not found" });
        }
        const connectionData = {
          userId: currentUserId,
          targetProfileId: profileId,
          targetUserId: targetProfile.userId,
          action,
          matched: false
        };
        const existingConnection = await storage.getSuiteNetworkingConnection(
          currentUserId,
          profileId
        );
        if (existingConnection) {
          return res.status(409).json({ message: "Already acted on this profile" });
        }
        const connection = await storage.createSuiteNetworkingConnection(connectionData);
        if (action === "pass") {
          try {
            const existingScore = await storage.getSuiteCompatibilityScore(
              currentUserId,
              profileId
            );
            if (existingScore) {
              await storage.deleteSuiteCompatibilityScore(existingScore.id);
              console.log(
                `\u{1F5D1}\uFE0F [COMPATIBILITY-CLEANUP] Deleted networking compatibility score ${existingScore.id} after user ${currentUserId} passed on profile ${profileId}`
              );
            }
          } catch (cleanupError) {
            console.error(
              "Error cleaning up compatibility score after dislike:",
              cleanupError
            );
          }
        }
        await storage.addSwipeHistory({
          userId: currentUserId,
          targetUserId: targetProfile.userId,
          action: action === "like" ? "like" : "dislike",
          appMode: "SUITE_NETWORKING"
        });
        console.log(
          `\u{1F4DD} [SUITE-NETWORKING-HISTORY] Recorded swipe history for user ${currentUserId} -> ${targetProfile.userId} (${action})`
        );
        const sourceNetworkingProfile = await storage.getSuiteNetworkingProfile(currentUserId);
        let isMatch = false;
        if (action === "like" && sourceNetworkingProfile) {
          const mutualConnection = await storage.getSuiteNetworkingConnection(
            targetProfile.userId,
            sourceNetworkingProfile.id
          );
          if (mutualConnection && mutualConnection.action === "like") {
            await storage.updateSuiteNetworkingConnection(connection.id, {
              matched: true
            });
            await storage.updateSuiteNetworkingConnection(mutualConnection.id, {
              matched: true
            });
            isMatch = true;
            const existingMatch = await storage.getMatchBetweenUsers(
              currentUserId,
              targetProfile.userId
            );
            let finalMatch;
            if (existingMatch) {
              let metadata;
              if (!existingMatch.metadata) {
                metadata = {
                  origin: "SUITE",
                  suiteType: "networking",
                  context: "professional"
                };
              } else {
                try {
                  metadata = typeof existingMatch.metadata === "string" ? JSON.parse(existingMatch.metadata) : existingMatch.metadata;
                  if (metadata.suiteType !== "networking") {
                    if (!metadata.additionalConnections) {
                      metadata.additionalConnections = [];
                    }
                    if (!metadata.additionalConnections.includes("networking")) {
                      metadata.additionalConnections.push("networking");
                      console.log(
                        `\u{1F517} Adding networking to additionalConnections for existing match ${existingMatch.id}`
                      );
                    }
                  }
                } catch (parseError) {
                  console.error(
                    "Failed to parse existing metadata:",
                    parseError
                  );
                  metadata = {
                    origin: "SUITE",
                    suiteType: "networking",
                    context: "professional"
                  };
                }
              }
              finalMatch = await storage.updateMatch(existingMatch.id, {
                matched: true,
                metadata: JSON.stringify(metadata)
              });
            } else {
              const matchData = {
                userId1: Math.min(currentUserId, targetProfile.userId),
                userId2: Math.max(currentUserId, targetProfile.userId),
                matched: true,
                isDislike: false,
                metadata: JSON.stringify({
                  origin: "SUITE",
                  suiteType: "networking",
                  context: "professional"
                })
              };
              finalMatch = await storage.createMatch(matchData);
            }
            console.log(
              `\u{1F49D} [SUITE-NETWORKING] Match created: ${currentUserId} \u2194 ${targetProfile.userId}`
            );
          }
        }
        console.log(
          `\u{1F680} [SUITE-NETWORKING] User ${currentUserId} ${action}d networking profile ${profileId}`
        );
        const sourceUserWs = connectedUsers4.get(currentUserId);
        const targetUserWs = connectedUsers4.get(targetProfile.userId);
        console.log(`[DEBUG-NETWORKING] WebSocket connections check:`);
        console.log(
          `  - Source user ${currentUserId}: ${sourceUserWs ? "CONNECTED" : "NOT FOUND"} (readyState: ${sourceUserWs?.readyState})`
        );
        console.log(
          `  - Target user ${targetProfile.userId}: ${targetUserWs ? "CONNECTED" : "NOT FOUND"} (readyState: ${targetUserWs?.readyState})`
        );
        console.log(`  - Total connected users: ${connectedUsers4.size}`);
        console.log(
          `  - Connected user IDs: [${Array.from(connectedUsers4.keys()).join(", ")}]`
        );
        let sourceRemovalSent = false;
        let targetRemovalSent = false;
        if (sourceUserWs && sourceUserWs.readyState === WebSocket4.OPEN) {
          sourceUserWs.send(
            JSON.stringify({
              type: "suite_remove_from_discover",
              suiteType: "networking",
              removeProfileId: profileId,
              removeUserId: targetProfile.userId,
              reason: `networking_${action}_action`,
              timestamp: (/* @__PURE__ */ new Date()).toISOString()
            })
          );
          console.log(
            `[REAL-TIME] Instantly removed networking profile ${profileId} from user ${currentUserId}'s discover deck`
          );
          sourceRemovalSent = true;
        } else {
          console.log(
            `[FALLBACK] Source user ${currentUserId} WebSocket not found, broadcasting removal to all users`
          );
          connectedUsers4.forEach((ws2, userId) => {
            if (userId === currentUserId && ws2.readyState === WebSocket4.OPEN) {
              ws2.send(
                JSON.stringify({
                  type: "suite_remove_from_discover",
                  suiteType: "networking",
                  removeProfileId: profileId,
                  removeUserId: targetProfile.userId,
                  reason: `networking_${action}_action_fallback`,
                  timestamp: (/* @__PURE__ */ new Date()).toISOString()
                })
              );
              sourceRemovalSent = true;
              console.log(
                `[FALLBACK] Successfully sent removal to source user ${currentUserId}`
              );
            }
          });
        }
        if (sourceNetworkingProfile && targetUserWs && targetUserWs.readyState === WebSocket4.OPEN) {
          targetUserWs.send(
            JSON.stringify({
              type: "suite_remove_from_discover",
              suiteType: "networking",
              removeProfileId: sourceNetworkingProfile.id,
              removeUserId: currentUserId,
              reason: `received_networking_${action}`,
              timestamp: (/* @__PURE__ */ new Date()).toISOString()
            })
          );
          console.log(
            `[REAL-TIME] Instantly removed networking profile ${sourceNetworkingProfile.id} from user ${targetProfile.userId}'s discover deck`
          );
          targetRemovalSent = true;
        } else if (sourceNetworkingProfile) {
          console.log(
            `[FALLBACK] Target user ${targetProfile.userId} WebSocket not found, broadcasting removal to all users`
          );
          connectedUsers4.forEach((ws2, userId) => {
            if (userId === targetProfile.userId && ws2.readyState === WebSocket4.OPEN) {
              ws2.send(
                JSON.stringify({
                  type: "suite_remove_from_discover",
                  suiteType: "networking",
                  removeProfileId: sourceNetworkingProfile.id,
                  removeUserId: currentUserId,
                  reason: `received_networking_${action}_fallback`,
                  timestamp: (/* @__PURE__ */ new Date()).toISOString()
                })
              );
              targetRemovalSent = true;
              console.log(
                `[FALLBACK] Successfully sent removal to target user ${targetProfile.userId}`
              );
            }
          });
        }
        console.log(
          `[REMOVAL-STATUS] Source: ${sourceRemovalSent ? "\u2705 SENT" : "\u274C FAILED"}, Target: ${targetRemovalSent ? "\u2705 SENT" : "\u274C FAILED"}`
        );
        if (action === "like") {
          try {
            if (targetUserWs && targetUserWs.readyState === WebSocket4.OPEN) {
              const sourceUser = await storage.getUser(currentUserId);
              const safeUserInfo = sourceUser ? (({ password, ...rest }) => rest)(sourceUser) : { id: currentUserId, fullName: "Unknown User" };
              const userNetworkingConnections = await storage.getUserNetworkingConnections(
                targetProfile.userId
              );
              const pendingConnections = userNetworkingConnections.filter(
                (conn) => !conn.matched && conn.action === "like"
              );
              const confirmedConnections = userNetworkingConnections.filter(
                (conn) => conn.matched
              );
              targetUserWs.send(
                JSON.stringify({
                  type: isMatch ? "networking_match" : "networking_like",
                  connection,
                  fromUserId: currentUserId,
                  fromUserInfo: safeUserInfo,
                  targetProfileId: profileId,
                  counts: {
                    pending: pendingConnections.length,
                    confirmed: confirmedConnections.length
                  },
                  isMatch,
                  timestamp: (/* @__PURE__ */ new Date()).toISOString()
                })
              );
              console.log(
                `\u{1F514} [SUITE-NETWORKING] Sent ${isMatch ? "match" : "like"} notification to user ${targetProfile.userId} from user ${currentUserId}`
              );
            }
          } catch (error) {
            console.error("Error sending networking notification:", error);
          }
        }
        console.log(
          `[DISCOVERY-REFRESH] Broadcasting discovery refresh to all connected users`
        );
        connectedUsers4.forEach((ws2, userId) => {
          if (ws2.readyState === WebSocket4.OPEN) {
            ws2.send(
              JSON.stringify({
                type: "discover:refresh",
                suiteType: "networking",
                reason: `networking_${action}_completed`,
                affectedUsers: [currentUserId, targetProfile.userId],
                timestamp: (/* @__PURE__ */ new Date()).toISOString()
              })
            );
          }
        });
        if (isMatch) {
          connectedUsers4.forEach((ws2, userId) => {
            if ((userId === currentUserId || userId === targetProfile.userId) && ws2.readyState === WebSocket4.OPEN) {
              ws2.send(
                JSON.stringify({
                  type: "connections:refresh",
                  suiteType: "networking",
                  reason: "networking_match_created",
                  timestamp: (/* @__PURE__ */ new Date()).toISOString()
                })
              );
            }
          });
          console.log(
            `[CONNECTIONS-REFRESH] Sent connections refresh for new match`
          );
        }
        res.json({
          success: true,
          action,
          profileId,
          isMatch,
          message: action === "like" ? isMatch ? "It's a match!" : "Connection request sent" : "Profile passed"
        });
      } catch (error) {
        console.error("Error processing networking swipe:", error);
        res.status(500).json({ message: "Failed to process swipe action" });
      }
    }
  );
  app2.post(
    "/api/suite/mentorship/swipe",
    async (req, res) => {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      try {
        const { profileId, action } = req.body;
        const currentUserId = req.user.id;
        if (!profileId || !action || !["like", "pass"].includes(action)) {
          return res.status(400).json({ message: "Invalid swipe data" });
        }
        const currentUserMentorshipProfile = await storage.getSuiteMentorshipProfile(currentUserId);
        if (!currentUserMentorshipProfile) {
          return res.status(403).json({
            message: "Profile required",
            action: "create_profile",
            profileType: "mentorship"
          });
        }
        const targetProfile = await storage.getSuiteMentorshipProfileById(profileId);
        if (!targetProfile) {
          return res.status(404).json({ message: "Profile not found" });
        }
        const connectionData = {
          userId: currentUserId,
          targetProfileId: profileId,
          targetUserId: targetProfile.userId,
          action,
          matched: false
        };
        const existingConnection = await storage.getSuiteMentorshipConnection(
          currentUserId,
          profileId
        );
        if (existingConnection) {
          return res.status(409).json({ message: "Already acted on this profile" });
        }
        const connection = await storage.createSuiteMentorshipConnection(connectionData);
        if (action === "pass") {
          try {
            const existingScore = await storage.getSuiteMentorshipCompatibilityScore(
              currentUserId,
              profileId
            );
            if (existingScore) {
              await storage.deleteSuiteMentorshipCompatibilityScore(
                existingScore.id
              );
              console.log(
                `\u{1F5D1}\uFE0F [COMPATIBILITY-CLEANUP] Deleted mentorship compatibility score ${existingScore.id} after user ${currentUserId} passed on profile ${profileId}`
              );
            }
          } catch (cleanupError) {
            console.error(
              "Error cleaning up compatibility score after dislike:",
              cleanupError
            );
          }
        }
        let isMatch = false;
        if (action === "like") {
          const currentUserProfile = await storage.getSuiteMentorshipProfile(currentUserId);
          if (!currentUserProfile) {
            console.log(
              `[SUITE-MENTORSHIP] Current user ${currentUserId} has no mentorship profile`
            );
            return res.status(404).json({ message: "Current user mentorship profile not found" });
          }
          const mutualConnection = await storage.getSuiteMentorshipConnection(
            targetProfile.userId,
            currentUserProfile.id
          );
          if (mutualConnection && mutualConnection.action === "like") {
            await storage.updateSuiteMentorshipConnection(connection.id, {
              matched: true
            });
            await storage.updateSuiteMentorshipConnection(mutualConnection.id, {
              matched: true
            });
            isMatch = true;
            const existingMatch = await storage.getMatchBetweenUsers(
              currentUserId,
              targetProfile.userId
            );
            let finalMatch;
            if (existingMatch) {
              let metadata;
              if (!existingMatch.metadata) {
                metadata = {
                  origin: "SUITE",
                  suiteType: "mentorship",
                  context: "professional"
                };
              } else {
                try {
                  metadata = typeof existingMatch.metadata === "string" ? JSON.parse(existingMatch.metadata) : existingMatch.metadata;
                  if (metadata.suiteType !== "mentorship") {
                    if (!metadata.additionalConnections) {
                      metadata.additionalConnections = [];
                    }
                    if (!metadata.additionalConnections.includes("mentorship")) {
                      metadata.additionalConnections.push("mentorship");
                      console.log(
                        `\u{1F517} Adding mentorship to additionalConnections for existing match ${existingMatch.id}`
                      );
                    }
                  }
                } catch (parseError) {
                  console.error(
                    "Failed to parse existing metadata:",
                    parseError
                  );
                  metadata = {
                    origin: "SUITE",
                    suiteType: "mentorship",
                    context: "professional"
                  };
                }
              }
              finalMatch = await storage.updateMatch(existingMatch.id, {
                matched: true,
                metadata: JSON.stringify(metadata)
              });
            } else {
              const matchData = {
                userId1: Math.min(currentUserId, targetProfile.userId),
                userId2: Math.max(currentUserId, targetProfile.userId),
                matched: true,
                isDislike: false,
                metadata: JSON.stringify({
                  origin: "SUITE",
                  suiteType: "mentorship",
                  context: "professional"
                })
              };
              finalMatch = await storage.createMatch(matchData);
            }
            console.log(
              `\u{1F49D} [SUITE-MENTORSHIP] Match created: ${currentUserId} \u2194 ${targetProfile.userId}`
            );
          }
        }
        try {
          const historyData = {
            userId: currentUserId,
            targetUserId: targetProfile.userId,
            action: action === "pass" ? "dislike" : action,
            // Normalize "pass" to "dislike" for history consistency
            appMode: "SUITE_MENTORSHIP"
            // Specific app mode for mentorship
          };
          await storage.addSwipeHistory(historyData);
          const userHistory = await storage.getUserSwipeHistory(
            currentUserId,
            "SUITE_MENTORSHIP",
            20
          );
          if (userHistory.length > 9) {
            const entriesToDelete = userHistory.slice(9);
            for (const entry of entriesToDelete) {
              await storage.removeSwipeHistory(entry.id);
            }
          }
          console.log(
            `\u{1F4DD} [SUITE-MENTORSHIP-HISTORY] Recorded swipe history for user ${currentUserId} -> ${targetProfile.userId} (${historyData.action})`
          );
        } catch (historyError) {
          console.error("Error recording swipe history:", historyError);
        }
        console.log(
          `\u{1F680} [SUITE-MENTORSHIP] User ${currentUserId} ${action}d mentorship profile ${profileId}`
        );
        const sourceUserWs = connectedUsers4.get(currentUserId);
        const targetUserWs = connectedUsers4.get(targetProfile.userId);
        if (sourceUserWs && sourceUserWs.readyState === WebSocket4.OPEN) {
          sourceUserWs.send(
            JSON.stringify({
              type: "suite_remove_from_discover",
              suiteType: "mentorship",
              removeProfileId: profileId,
              removeUserId: targetProfile.userId,
              reason: `mentorship_${action}_action`,
              timestamp: (/* @__PURE__ */ new Date()).toISOString()
            })
          );
          console.log(
            `[REAL-TIME] Instantly removed mentorship profile ${profileId} from user ${currentUserId}'s discover deck`
          );
        }
        const sourceMentorshipProfile = await storage.getSuiteMentorshipProfile(currentUserId);
        if (sourceMentorshipProfile && targetUserWs && targetUserWs.readyState === WebSocket4.OPEN) {
          targetUserWs.send(
            JSON.stringify({
              type: "suite_remove_from_discover",
              suiteType: "mentorship",
              removeProfileId: sourceMentorshipProfile.id,
              removeUserId: currentUserId,
              reason: `received_mentorship_${action}`,
              timestamp: (/* @__PURE__ */ new Date()).toISOString()
            })
          );
          console.log(
            `[REAL-TIME] Instantly removed mentorship profile ${sourceMentorshipProfile.id} from user ${targetProfile.userId}'s discover deck`
          );
        }
        if (action === "like" && targetUserWs && targetUserWs.readyState === WebSocket4.OPEN) {
          try {
            const sourceUser = await storage.getUser(currentUserId);
            const safeUserInfo = sourceUser ? (({ password, ...rest }) => rest)(sourceUser) : { id: currentUserId, fullName: "Unknown User" };
            const userMentorshipConnections = await storage.getUserMentorshipConnections(targetProfile.userId);
            const pendingConnections = userMentorshipConnections.filter(
              (conn) => !conn.matched && conn.action === "like"
            );
            const confirmedConnections = userMentorshipConnections.filter(
              (conn) => conn.matched
            );
            targetUserWs.send(
              JSON.stringify({
                type: isMatch ? "mentorship_match" : "mentorship_like",
                connection,
                fromUserId: currentUserId,
                fromUserInfo: safeUserInfo,
                targetProfileId: profileId,
                counts: {
                  pending: pendingConnections.length,
                  confirmed: confirmedConnections.length
                },
                isMatch,
                timestamp: (/* @__PURE__ */ new Date()).toISOString()
              })
            );
            console.log(
              `\u{1F514} [SUITE-MENTORSHIP] Sent ${isMatch ? "match" : "like"} notification to user ${targetProfile.userId} from user ${currentUserId}`
            );
          } catch (error) {
            console.error("Error sending mentorship notification:", error);
          }
        }
        res.json({
          success: true,
          action,
          profileId,
          isMatch,
          message: action === "like" ? isMatch ? "It's a match!" : "Interest expressed" : "Profile passed"
        });
      } catch (error) {
        console.error("Error processing mentorship swipe:", error);
        res.status(500).json({ message: "Failed to process swipe action" });
      }
    }
  );
  app2.get(
    "/api/debug/messages/:matchId",
    async (req, res) => {
      try {
        const matchId = parseInt(req.params.matchId);
        const userId = parseInt(req.query.userId) || 6;
        console.log(
          `\u{1F50D} [DEBUG-ENDPOINT] Testing reply transformation for match ${matchId}, user ${userId}`
        );
        const messages2 = await storage.getMessagesByMatchId(matchId, userId);
        console.log(
          `\u{1F50D} [DEBUG-ENDPOINT] Retrieved ${messages2.length} messages`
        );
        messages2.forEach((msg) => {
          console.log(`  Message ${msg.id}: "${msg.content}"`);
          if (msg.replyToMessageId) {
            console.log(
              `    Has reply: Reply to message ${msg.replyToMessageId}`
            );
          } else {
            console.log(`    No reply context`);
          }
        });
        res.json(messages2);
      } catch (error) {
        console.error("Debug endpoint error:", error);
        res.status(500).json({ error: error.message });
      }
    }
  );
  app2.post("/api/swipe/history", async (req, res) => {
    if (!req.isAuthenticated()) {
      return res.status(401).json({ message: "Unauthorized" });
    }
    try {
      const { targetUserId, action, appMode } = req.body;
      if (!targetUserId || !action || !appMode) {
        return res.status(400).json({ message: "Missing required fields" });
      }
      const swipeData = {
        userId: req.user.id,
        targetUserId: parseInt(targetUserId),
        action,
        appMode
      };
      const history = await storage.addSwipeHistory(swipeData);
      res.json(history);
    } catch (error) {
      console.error("Error adding swipe history:", error);
      res.status(500).json({ message: "Failed to add swipe history" });
    }
  });
  app2.get("/api/swipe/history", async (req, res) => {
    if (!req.isAuthenticated()) {
      return res.status(401).json({ message: "Unauthorized" });
    }
    try {
      const { appMode, limit } = req.query;
      if (!appMode) {
        return res.status(400).json({ message: "appMode parameter required" });
      }
      const history = await storage.getUserSwipeHistory(
        req.user.id,
        appMode,
        limit ? parseInt(limit) : 10
      );
      res.json(history);
    } catch (error) {
      console.error("Error getting swipe history:", error);
      res.status(500).json({ message: "Failed to get swipe history" });
    }
  });
  app2.delete("/api/swipe/history/:id", async (req, res) => {
    if (!req.isAuthenticated()) {
      return res.status(401).json({ message: "Unauthorized" });
    }
    try {
      const historyId = parseInt(req.params.id);
      if (isNaN(historyId)) {
        return res.status(400).json({ message: "Invalid history ID" });
      }
      await storage.removeSwipeHistory(historyId);
      res.json({ success: true });
    } catch (error) {
      console.error("Error removing swipe history:", error);
      res.status(500).json({ message: "Failed to remove swipe history" });
    }
  });
  app2.delete(
    "/api/swipe/history/clear",
    async (req, res) => {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      try {
        const { appMode } = req.query;
        if (!appMode) {
          return res.status(400).json({ message: "appMode parameter required" });
        }
        await storage.clearUserSwipeHistory(req.user.id, appMode);
        res.json({ success: true });
      } catch (error) {
        console.error("Error clearing swipe history:", error);
        res.status(500).json({ message: "Failed to clear swipe history" });
      }
    }
  );
  app2.get(
    "/api/connections/preferences",
    async (req, res) => {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      try {
        const preferences = await storage.getConnectionsPreferences(
          req.user.id
        );
        if (preferences) {
          const mappedPreferences = convertDbFieldsToFrontend(preferences);
          res.json(mappedPreferences);
        } else {
          res.json(preferences);
        }
      } catch (error) {
        console.error("Error getting connections preferences:", error);
        res.status(500).json({ message: "Failed to get preferences" });
      }
    }
  );
  app2.post(
    "/api/connections/preferences",
    async (req, res) => {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      try {
        const preferences = await storage.saveConnectionsPreferences(
          req.user.id,
          req.body
        );
        const mappedPreferences = convertDbFieldsToFrontend(preferences);
        res.json(mappedPreferences);
      } catch (error) {
        console.error("Error saving connections preferences:", error);
        res.status(500).json({ message: "Failed to save preferences" });
      }
    }
  );
  app2.post(
    "/api/user/verification-status",
    async (req, res) => {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      try {
        const { userId, isVerified } = req.body;
        if (typeof userId !== "number" || typeof isVerified !== "boolean") {
          return res.status(400).json({
            message: "Invalid parameters. userId (number) and isVerified (boolean) are required."
          });
        }
        const updatedUser = await storage.updateUserProfile(userId, {
          isVerified
        });
        if (verificationStatusBroadcaster) {
          verificationStatusBroadcaster(userId, isVerified);
          console.log(
            `Verification status update broadcasted via WebSocket for user ${userId}: isVerified=${isVerified}`
          );
        }
        res.json({
          success: true,
          message: `User ${userId} verification status updated to ${isVerified}`,
          isVerified: updatedUser.isVerified
        });
      } catch (error) {
        console.error("Error updating verification status:", error);
        res.status(500).json({ message: "Failed to update verification status" });
      }
    }
  );
  app2.patch("/api/user/verify-id", async (req, res) => {
    if (!req.isAuthenticated()) {
      return res.status(401).json({ message: "Unauthorized" });
    }
    try {
      const { idVerificationPhoto, liveVerificationPhoto } = req.body;
      if (!idVerificationPhoto || !liveVerificationPhoto) {
        return res.status(400).json({
          message: "Both ID verification photo and live verification photo are required"
        });
      }
      const updatedUser = await storage.updateUserProfile(req.user.id, {
        idVerificationPhoto,
        liveVerificationPhoto
      });
      console.log(
        `[ID-VERIFICATION] User ${req.user.id} submitted new verification photos`
      );
      res.json({
        success: true,
        message: "Verification photos submitted successfully",
        user: {
          id: updatedUser.id,
          idVerificationPhoto: updatedUser.idVerificationPhoto,
          liveVerificationPhoto: updatedUser.liveVerificationPhoto
        }
      });
    } catch (error) {
      console.error("Error updating verification photos:", error);
      res.status(500).json({ message: "Failed to update verification photos" });
    }
  });
  app2.post("/api/email/verify", async (req, res) => {
    try {
      const { email } = req.body;
      if (!email || typeof email !== "string") {
        return res.status(400).json({
          success: false,
          message: "Valid email address is required"
        });
      }
      console.log(`[EMAIL-VERIFICATION] Starting verification for: ${email}`);
      const { EmailVerificationService: EmailVerificationService2 } = await Promise.resolve().then(() => (init_email_verification(), email_verification_exports));
      const result = await EmailVerificationService2.verifyEmail(
        email.trim().toLowerCase()
      );
      console.log(`[EMAIL-VERIFICATION] Result for ${email}:`, result);
      res.json({
        success: true,
        email: email.trim().toLowerCase(),
        isValid: result.isValid,
        reason: result.reason,
        confidence: result.confidence
      });
    } catch (error) {
      console.error("[EMAIL-VERIFICATION] API error:", error);
      res.status(500).json({
        success: false,
        message: "Email verification service temporarily unavailable",
        isValid: false,
        confidence: "low"
      });
    }
  });
  registerSuiteCompatibilityAPI(app2);
  app2.get("/api/test/sendgrid", requireAuth, async (req, res) => {
    try {
      const { testSendGridConfig: testSendGridConfig2 } = await Promise.resolve().then(() => (init_sendgrid(), sendgrid_exports));
      const result = await testSendGridConfig2();
      res.json(result);
    } catch (error) {
      console.error("SendGrid test error:", error);
      res.status(500).json({
        success: false,
        message: "SendGrid test failed"
      });
    }
  });
  app2.post("/api/welcome/send", async (req, res) => {
    try {
      const { name, email, dateOfBirth } = req.body;
      if (!name || !email) {
        return res.status(400).json({
          success: false,
          message: "Name and email are required"
        });
      }
      const calculateAge2 = (dateOfBirth2) => {
        const today = /* @__PURE__ */ new Date();
        const birthDate = new Date(dateOfBirth2);
        let age = today.getFullYear() - birthDate.getFullYear();
        const monthDiff = today.getMonth() - birthDate.getMonth();
        if (monthDiff < 0 || monthDiff === 0 && today.getDate() < birthDate.getDate()) {
          age--;
        }
        return age;
      };
      const userAge = dateOfBirth ? calculateAge2(dateOfBirth) : null;
      const isUnder14 = userAge !== null && userAge < 14;
      const isTeenage = userAge !== null && userAge >= 14 && userAge < 18;
      const isAdult = userAge !== null && userAge >= 18;
      console.log(
        `[WELCOME-EMAIL] User ${name} (${email}) is ${userAge} years old - Under 14: ${isUnder14}, Teenage (14-17): ${isTeenage}, Adult (18+): ${isAdult}`
      );
      const {
        sendWelcomeEmail: sendWelcomeEmail2,
        sendTeenageWelcomeEmail: sendTeenageWelcomeEmail2,
        sendUnderAgeApologyEmail: sendUnderAgeApologyEmail2
      } = await Promise.resolve().then(() => (init_sendgrid(), sendgrid_exports));
      let success = false;
      if (isUnder14) {
        console.log(
          `[WELCOME-EMAIL] Sending under-age apology email to ${email} for ${name} (age: ${userAge})`
        );
        success = await sendUnderAgeApologyEmail2({
          name: name.trim(),
          email: email.trim(),
          dateOfBirth
        });
        if (success) {
          console.log(
            `[WELCOME-EMAIL] Successfully sent under-age apology email to ${email}`
          );
          res.json({
            success: true,
            message: "Under-age apology email sent successfully",
            emailType: "apology"
          });
        } else {
          console.error(
            `[WELCOME-EMAIL] Failed to send under-age apology email to ${email}`
          );
          res.status(500).json({
            success: false,
            message: "Failed to send under-age apology email"
          });
        }
      } else if (isTeenage) {
        console.log(
          `[WELCOME-EMAIL] Sending teenage welcome email to ${email} for ${name} (age: ${userAge})`
        );
        success = await sendTeenageWelcomeEmail2({
          name: name.trim(),
          email: email.trim(),
          dateOfBirth
        });
        if (success) {
          console.log(
            `[WELCOME-EMAIL] Successfully sent teenage welcome email to ${email}`
          );
          res.json({
            success: true,
            message: "Teenage welcome email sent successfully",
            emailType: "teenage_welcome"
          });
        } else {
          console.error(
            `[WELCOME-EMAIL] Failed to send teenage welcome email to ${email}`
          );
          res.status(500).json({
            success: false,
            message: "Failed to send teenage welcome email"
          });
        }
      } else if (isAdult) {
        console.log(
          `[WELCOME-EMAIL] Sending adult welcome email to ${email} for ${name} (age: ${userAge})`
        );
        success = await sendWelcomeEmail2({
          name: name.trim(),
          email: email.trim(),
          dateOfBirth
        });
        if (success) {
          console.log(
            `[WELCOME-EMAIL] Successfully sent adult welcome email to ${email}`
          );
          res.json({
            success: true,
            message: "Adult welcome email sent successfully",
            emailType: "adult_welcome"
          });
        } else {
          console.error(
            `[WELCOME-EMAIL] Failed to send adult welcome email to ${email}`
          );
          res.status(500).json({
            success: false,
            message: "Failed to send adult welcome email"
          });
        }
      } else {
        console.error(
          `[WELCOME-EMAIL] Invalid age data for user ${name} (${email}): age = ${userAge}`
        );
        res.status(400).json({
          success: false,
          message: "Invalid age data - cannot determine appropriate email type"
        });
      }
    } catch (error) {
      console.error("[WELCOME-EMAIL] API error:", error);
      res.status(500).json({
        success: false,
        message: "Server error sending welcome email"
      });
    }
  });
  app2.get("/dispute", async (req, res) => {
    try {
      const token = req.query.token;
      if (!token) {
        return res.status(400).send(`
          <!DOCTYPE html>
          <html>
          <head>
            <title>Invalid Dispute Link</title>
            <style>body { font-family: Arial, sans-serif; text-align: center; padding: 50px; }</style>
          </head>
          <body>
            <h1>\u274C Invalid Dispute Link</h1>
            <p>This dispute link is invalid or malformed.</p>
            <p>If you received this link in a security email, please contact admin@kronogon.com</p>
          </body>
          </html>
        `);
      }
      const disputeInfo = getDisputeInfo(token);
      if (!disputeInfo) {
        return res.status(404).send(`
          <!DOCTYPE html>
          <html>
          <head>
            <title>Dispute Link Expired</title>
            <style>body { font-family: Arial, sans-serif; text-align: center; padding: 50px; }</style>
          </head>
          <body>
            <h1>\u23F0 Dispute Link Expired</h1>
            <p>This dispute link has expired or has already been used.</p>
            <p>Dispute links are valid for 7 days after the security change.</p>
            <p>If you still need assistance, please contact admin@kronogon.com directly.</p>
          </body>
          </html>
        `);
      }
      const success = await handleSecurityDispute(token, req);
      if (success) {
        return res.send(`
          <!DOCTYPE html>
          <html>
          <head>
            <title>Dispute Submitted Successfully</title>
            <style>
              body { 
                font-family: Arial, sans-serif; 
                text-align: center; 
                padding: 50px;
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                margin: 0;
              }
              .container {
                background: white;
                color: #333;
                border-radius: 16px;
                padding: 40px;
                max-width: 600px;
                margin: 0 auto;
                box-shadow: 0 20px 40px rgba(0,0,0,0.1);
              }
              .success-icon { font-size: 64px; margin-bottom: 20px; }
              h1 { color: #22c55e; margin-bottom: 20px; }
              .info-box {
                background: #f0f9ff;
                border: 2px solid #0ea5e9;
                border-radius: 12px;
                padding: 20px;
                margin: 20px 0;
                text-align: left;
              }
            </style>
          </head>
          <body>
            <div class="container">
              <div class="success-icon">\u{1F6A8}</div>
              <h1>Dispute Submitted Successfully</h1>
              <p><strong>Your security dispute has been received and processed.</strong></p>
              
              <div class="info-box">
                <h3>What happens next:</h3>
                <ul>
                  <li>Our security team has been immediately notified</li>
                  <li>We will contact you within 24 hours at <strong>${disputeInfo.email}</strong></li>
                  <li>We may temporarily secure your account during investigation</li>
                  <li>The unauthorized change will be reviewed and may be reversed</li>
                </ul>
              </div>
              
              <p><strong>Important:</strong> This dispute link has now been used and cannot be accessed again.</p>
              
              <p>If you have immediate concerns, contact us at:</p>
              <p><strong>admin@kronogon.com</strong></p>
              
              <hr style="margin: 30px 0;">
              <p style="font-size: 14px; color: #666;">
                CHARLEY Security System<br>
                Dispute processed at ${(/* @__PURE__ */ new Date()).toLocaleString()}
              </p>
            </div>
          </body>
          </html>
        `);
      } else {
        return res.status(500).send(`
          <!DOCTYPE html>
          <html>
          <head>
            <title>Dispute Processing Error</title>
            <style>body { font-family: Arial, sans-serif; text-align: center; padding: 50px; }</style>
          </head>
          <body>
            <h1>\u274C Error Processing Dispute</h1>
            <p>There was an error processing your security dispute.</p>
            <p>Please contact admin@kronogon.com directly with the following information:</p>
            <ul style="text-align: left; display: inline-block;">
              <li>Dispute Token: ${token}</li>
              <li>Your Email: ${disputeInfo.email}</li>
              <li>Change Type: ${disputeInfo.changeType}</li>
              <li>Timestamp: ${(/* @__PURE__ */ new Date()).toLocaleString()}</li>
            </ul>
          </body>
          </html>
        `);
      }
    } catch (error) {
      console.error("[SECURITY-DISPUTE] Error handling dispute route:", error);
      return res.status(500).send(`
        <!DOCTYPE html>
        <html>
        <head>
          <title>System Error</title>
          <style>body { font-family: Arial, sans-serif; text-align: center; padding: 50px; }</style>
        </head>
        <body>
          <h1>\u274C System Error</h1>
          <p>A system error occurred while processing your dispute.</p>
          <p>Please contact admin@kronogon.com immediately.</p>
        </body>
        </html>
      `);
    }
  });
  app2.get("/api/pricing", async (req, res) => {
    try {
      const region = req.query.region || "global";
      const pricing = await storage.getRegionalPricing(region);
      res.json(pricing);
    } catch (error) {
      console.error("Error fetching pricing:", error);
      res.status(500).json({ message: "Failed to fetch pricing" });
    }
  });
  app2.post("/api/promo/validate", async (req, res) => {
    try {
      const { code, region } = req.body;
      const userId = req.user?.id;
      if (!code || !region) {
        return res.status(400).json({
          valid: false,
          error: "Missing required fields"
        });
      }
      if (!userId) {
        return res.status(401).json({
          valid: false,
          error: "Authentication required"
        });
      }
      const validation = await storage.validatePromotionalCode(
        code,
        userId,
        region
      );
      res.json(validation);
    } catch (error) {
      console.error("Error validating promo code:", error);
      res.status(500).json({
        valid: false,
        error: "Server error validating promotional code"
      });
    }
  });
  app2.post(
    "/api/subscription/create",
    requireAuth,
    async (req, res) => {
      try {
        if (!stripe2) {
          return res.status(503).json({
            success: false,
            error: "Payment processing is currently unavailable. Please contact support.",
            code: "STRIPE_NOT_CONFIGURED"
          });
        }
        console.log(
          `[STRIPE-ENVIRONMENT-FIX] Creating subscription in ${isLiveMode2 ? "LIVE" : "TEST"} mode for user ${req.user.id}`
        );
        const {
          planType,
          region,
          promoCode,
          paymentMethod = "card",
          billingName,
          billingEmail,
          billingPhone,
          billingAddress,
          billingCity,
          billingState,
          billingPostalCode,
          billingCountry,
          nickname
        } = req.body;
        const userId = req.user.id;
        if (!planType || !region) {
          return res.status(400).json({
            success: false,
            error: "Missing required fields"
          });
        }
        const pricingList = await storage.getRegionalPricing(region, planType);
        const pricing = pricingList[0];
        if (!pricing) {
          return res.status(400).json({
            success: false,
            error: "Invalid plan or region"
          });
        }
        const existingSubscription = await storage.getSubscriptionByUser(userId);
        if (existingSubscription && existingSubscription.status === "active") {
          return res.status(400).json({
            success: false,
            error: "User already has an active subscription"
          });
        }
        const user = await storage.getUser(userId);
        if (!user) {
          return res.status(404).json({ error: "User not found" });
        }
        let stripeCustomerId = user.stripeCustomerId;
        let needsNewCustomer = !stripeCustomerId;
        if (stripeCustomerId && stripe2) {
          try {
            await stripe2.customers.retrieve(stripeCustomerId);
            console.log(
              `[STRIPE] Using existing customer: ${stripeCustomerId}`
            );
          } catch (error) {
            if (error.code === "resource_missing") {
              console.log(
                `[STRIPE] Customer ${stripeCustomerId} not found in current mode, creating new customer`
              );
              needsNewCustomer = true;
            } else {
              throw error;
            }
          }
        }
        if (needsNewCustomer && stripe2) {
          const customer = await stripe2.customers.create({
            email: user.email,
            name: user.fullName,
            metadata: {
              userId: userId.toString(),
              region,
              mode: isLiveMode2 ? "live" : "test"
            }
          });
          stripeCustomerId = customer.id;
          console.log(
            `[STRIPE] Created new customer: ${stripeCustomerId} in ${isLiveMode2 ? "LIVE" : "TEST"} mode`
          );
          await storage.updateUser(userId, { stripeCustomerId });
        }
        console.log(
          `[STRIPE] Creating subscription for user ${userId}, plan: ${planType}, region: ${region}, amount: ${pricing.amount} ${pricing.currency}`
        );
        const supportedCurrencies = ["usd", "eur", "gbp", "cad", "aud", "jpy"];
        const requestedCurrency = pricing.currency.toLowerCase();
        const isUnsupportedCurrency = !supportedCurrencies.includes(requestedCurrency);
        let stripeCurrency = requestedCurrency;
        let stripeAmount = pricing.amount;
        if (isUnsupportedCurrency) {
          stripeCurrency = "usd";
          const conversionRates = {
            ghs: 10.44,
            // 10.44 GHS = 1 USD (current rate)
            ngn: 1600,
            // 1600 NGN = 1 USD (example for future)
            kes: 130
            // 130 KES = 1 USD (example for future)
          };
          const conversionRate = conversionRates[requestedCurrency];
          if (conversionRate) {
            stripeAmount = Math.round(pricing.amount / conversionRate);
          } else {
            stripeAmount = pricing.amount;
          }
          console.log(
            `[STRIPE-CURRENCY-FALLBACK] Converting ${pricing.amount} ${pricing.currency} to ${stripeAmount} ${stripeCurrency.toUpperCase()} (rate: ${conversionRate || "default"})`
          );
        }
        let productId;
        if (stripe2) {
          try {
            const product = await stripe2.products.create({
              name: `CHARLEY Premium - ${planType.replace("_", " ").toUpperCase()}`,
              description: `Premium subscription for ${region} region`,
              metadata: {
                app: "charley",
                plan_type: planType,
                region,
                original_currency: pricing.currency,
                stripe_currency: stripeCurrency
              }
            });
            productId = product.id;
            console.log(`[STRIPE] Created product: ${productId}`);
          } catch (productError) {
            console.error(
              `[STRIPE] Error creating product:`,
              productError.message
            );
            throw new Error(
              `Failed to create product: ${productError.message}`
            );
          }
        }
        const subscriptionParams = {
          customer: stripeCustomerId,
          items: [
            {
              price_data: {
                currency: stripeCurrency,
                unit_amount: stripeAmount,
                recurring: {
                  interval: planType.includes("yearly") ? "year" : "month",
                  interval_count: planType.includes("quarterly") ? 3 : 1
                },
                product: productId
              }
            }
          ],
          payment_behavior: "default_incomplete",
          payment_settings: {
            payment_method_types: ["card"],
            save_default_payment_method: "on_subscription"
          },
          expand: ["latest_invoice.payment_intent"],
          metadata: {
            userId: userId.toString(),
            region,
            planType,
            paymentMethod: paymentMethod || "card",
            original_currency: pricing.currency,
            original_amount: pricing.amount.toString(),
            stripe_currency: stripeCurrency,
            stripe_amount: stripeAmount.toString(),
            // Billing Address Information
            billing_name: billingName || "",
            billing_email: billingEmail || "",
            billing_phone: billingPhone || "",
            billing_address: billingAddress || "",
            billing_city: billingCity || "",
            billing_state: billingState || "",
            billing_postal_code: billingPostalCode || "",
            billing_country: billingCountry || "",
            nickname: nickname || ""
          }
        };
        console.log(
          `[STRIPE] Subscription params:`,
          JSON.stringify(subscriptionParams, null, 2)
        );
        if (isUnsupportedCurrency) {
          console.log(`[STRIPE-CURRENCY-CONVERSION] SUCCESSFUL FALLBACK:`);
          console.log(
            `[STRIPE-CURRENCY-CONVERSION] Original: ${pricing.amount} ${pricing.currency}`
          );
          console.log(
            `[STRIPE-CURRENCY-CONVERSION] Stripe Processing: ${stripeAmount} ${stripeCurrency.toUpperCase()}`
          );
          console.log(
            `[STRIPE-CURRENCY-CONVERSION] User sees: ${pricing.currency} pricing, Stripe charges: USD equivalent`
          );
        }
        if (promoCode && stripe2) {
          const validation = await storage.validatePromotionalCode(
            promoCode,
            userId,
            region
          );
          if (validation.valid && validation.discount) {
            const coupon = await stripe2.coupons.create({
              percent_off: validation.discount,
              duration: "once",
              metadata: {
                promoCode,
                userId: userId.toString()
              }
            });
            subscriptionParams.coupon = coupon.id;
          }
        }
        let stripeSubscription = null;
        try {
          if (stripe2) {
            console.log(
              `[STRIPE] Calling stripe.subscriptions.create with customer: ${stripeCustomerId}`
            );
            stripeSubscription = await stripe2.subscriptions.create(subscriptionParams);
            console.log(
              `[STRIPE] Successfully created subscription: ${stripeSubscription.id}`
            );
          }
        } catch (stripeError) {
          console.error(`[STRIPE] Error creating subscription:`, stripeError);
          console.error(`[STRIPE] Error type:`, stripeError.type);
          console.error(`[STRIPE] Error code:`, stripeError.code);
          console.error(`[STRIPE] Error message:`, stripeError.message);
          console.error(`[STRIPE] Error details:`, stripeError.detail);
          throw new Error(
            `Stripe subscription creation failed: ${stripeError.message}`
          );
        }
        if (!stripeSubscription) {
          return res.status(503).json({
            success: false,
            error: "Payment processing is currently unavailable. Please contact support.",
            code: "STRIPE_NOT_CONFIGURED"
          });
        }
        const subscription = await storage.createSubscription({
          userId,
          provider: "stripe",
          subscriptionId: stripeSubscription.id,
          planType,
          status: stripeSubscription.status,
          currentPeriodStart: new Date(
            stripeSubscription.current_period_start * 1e3
          ),
          currentPeriodEnd: new Date(
            stripeSubscription.current_period_end * 1e3
          ),
          cancelAtPeriodEnd: stripeSubscription.cancel_at_period_end,
          currency: pricing.currency,
          // Keep original currency for user display
          amount: pricing.amount,
          // Keep original amount for user display
          region,
          paymentMethod: paymentMethod || "card"
        });
        try {
          const subscriptionEvent = await storage.createSubscriptionEvent({
            subscriptionId: subscription.id,
            userId,
            eventType: "created",
            provider: "stripe",
            providerEventId: stripeSubscription.id,
            oldStatus: null,
            newStatus: stripeSubscription.status,
            metadata: JSON.stringify({
              subscriptionId: stripeSubscription.id,
              planType,
              amount: pricing.amount,
              currency: pricing.currency,
              region,
              stripe_currency: stripeCurrency,
              stripe_amount: stripeAmount,
              currency_converted: isUnsupportedCurrency,
              currentPeriodStart: stripeSubscription.current_period_start,
              currentPeriodEnd: stripeSubscription.current_period_end
            })
          });
          console.log(
            `[SUBSCRIPTION-CREATION] Created subscription event: ${subscriptionEvent.id}`
          );
        } catch (eventError) {
          console.error(
            `[SUBSCRIPTION-CREATION] Failed to create subscription event:`,
            eventError
          );
        }
        const clientSecret = stripeSubscription.latest_invoice?.payment_intent?.client_secret;
        const paymentIntentId = stripeSubscription.latest_invoice?.payment_intent?.id;
        console.log(`[STRIPE] Payment intent ID: ${paymentIntentId}`);
        console.log(`[STRIPE] Client secret: ${clientSecret}`);
        console.log(
          `[STRIPE] Latest invoice:`,
          JSON.stringify(stripeSubscription.latest_invoice, null, 2)
        );
        if (!clientSecret) {
          console.error("[STRIPE] No client secret found in payment intent!");
          console.error(
            "[STRIPE] Subscription object:",
            JSON.stringify(stripeSubscription, null, 2)
          );
          throw new Error("Failed to get payment intent client secret");
        }
        res.json({
          success: true,
          subscription: {
            id: subscription.id,
            stripeSubscriptionId: stripeSubscription.id,
            planType: subscription.planType,
            status: subscription.status,
            currentPeriodEnd: subscription.currentPeriodEnd
          },
          clientSecret,
          paymentMethod
        });
      } catch (error) {
        console.error("Error creating subscription:", error);
        res.status(500).json({
          success: false,
          error: "Failed to create subscription"
        });
      }
    }
  );
  app2.post(
    "/api/subscription/payment-success",
    requireAuth,
    async (req, res) => {
      try {
        const { paymentIntentId } = req.body;
        const userId = req.user.id;
        console.log(`[PAYMENT-SUCCESS] Request received for user ${userId}`);
        console.log(
          `[PAYMENT-SUCCESS] Request body:`,
          JSON.stringify(req.body, null, 2)
        );
        console.log(`[PAYMENT-SUCCESS] Payment intent ID:`, paymentIntentId);
        if (!stripe2) {
          console.log(`[PAYMENT-SUCCESS] Stripe not configured`);
          return res.status(503).json({
            success: false,
            error: "Payment processing is currently unavailable. Please contact support.",
            code: "STRIPE_NOT_CONFIGURED"
          });
        }
        if (!paymentIntentId) {
          console.log(`[PAYMENT-SUCCESS] Missing payment intent ID in request`);
          return res.status(400).json({
            success: false,
            error: "Missing payment intent ID"
          });
        }
        console.log(
          `[STRIPE] Verifying payment success for user ${userId}, payment intent: ${paymentIntentId}`
        );
        let paymentIntent;
        let retryCount = 0;
        const maxRetries = 3;
        while (retryCount < maxRetries) {
          try {
            paymentIntent = await stripe2.paymentIntents.retrieve(paymentIntentId);
            break;
          } catch (retrieveError) {
            retryCount++;
            console.log(
              `[STRIPE] Attempt ${retryCount}/${maxRetries} failed to retrieve payment intent:`,
              retrieveError.message
            );
            if (retryCount >= maxRetries) {
              throw retrieveError;
            }
            await new Promise((resolve) => setTimeout(resolve, 1e3));
          }
        }
        if (!paymentIntent) {
          throw new Error(
            "Failed to retrieve payment intent after multiple attempts"
          );
        }
        console.log(
          `[PAYMENT-SUCCESS] Payment intent status: ${paymentIntent.status}`
        );
        console.log(`[PAYMENT-SUCCESS] Payment intent details:`, {
          id: paymentIntent.id,
          status: paymentIntent.status,
          amount: paymentIntent.amount,
          currency: paymentIntent.currency
        });
        if (paymentIntent.status === "succeeded") {
          let currentSubscriptionId = null;
          let subscriptionExpiresAt = null;
          if (paymentIntent.invoice) {
            try {
              const invoice = await stripe2.invoices.retrieve(
                paymentIntent.invoice
              );
              if (invoice.subscription) {
                currentSubscriptionId = invoice.subscription;
                console.log(
                  `[PAYMENT-SUCCESS] Found subscription ID from invoice: ${currentSubscriptionId}`
                );
              }
            } catch (invoiceError) {
              console.warn(
                `[PAYMENT-SUCCESS] Could not retrieve invoice:`,
                invoiceError
              );
            }
          }
          if (currentSubscriptionId && stripe2) {
            try {
              const stripeSubscription = await stripe2.subscriptions.retrieve(
                currentSubscriptionId
              );
              subscriptionExpiresAt = new Date(
                stripeSubscription.current_period_end * 1e3
              );
              console.log(
                `[PAYMENT-SUCCESS] Retrieved subscription expiry from Stripe: ${subscriptionExpiresAt}`
              );
              console.log(
                `[PAYMENT-SUCCESS] Stripe subscription status: ${stripeSubscription.status}`
              );
            } catch (stripeError) {
              console.warn(
                `[PAYMENT-SUCCESS] Could not fetch subscription from Stripe:`,
                stripeError
              );
            }
          }
          const subscription = await storage.getSubscriptionByUser(userId);
          if (subscription || currentSubscriptionId) {
            try {
              if (paymentIntent.payment_method && typeof paymentIntent.payment_method === "string") {
                const stripePaymentMethod = await stripe2.paymentMethods.retrieve(
                  paymentIntent.payment_method
                );
                const existingPaymentMethods = await storage.getPaymentMethodsByUser(userId);
                const paymentMethodExists = existingPaymentMethods.some(
                  (pm) => pm.externalId === paymentIntent.payment_method
                );
                if (!paymentMethodExists) {
                  let billingInfo = {};
                  if (currentSubscriptionId) {
                    try {
                      const stripeSubscription = await stripe2.subscriptions.retrieve(
                        currentSubscriptionId
                      );
                      const metadata = stripeSubscription.metadata || {};
                      billingInfo = {
                        billingName: metadata.billing_name || null,
                        billingEmail: metadata.billing_email || null,
                        billingPhone: metadata.billing_phone || null,
                        billingAddress: metadata.billing_address || null,
                        billingCity: metadata.billing_city || null,
                        billingState: metadata.billing_state || null,
                        billingPostalCode: metadata.billing_postal_code || null,
                        billingCountry: metadata.billing_country || null,
                        nickname: metadata.nickname || null
                      };
                    } catch (error) {
                      console.warn(
                        `[PAYMENT-SUCCESS] Could not retrieve subscription metadata for billing info:`,
                        error
                      );
                    }
                  }
                  const paymentMethodRecord = await storage.createPaymentMethod(
                    {
                      userId,
                      provider: "stripe",
                      externalId: paymentIntent.payment_method,
                      type: "card",
                      isDefault: existingPaymentMethods.length === 0,
                      // First payment method becomes default
                      metadata: JSON.stringify({
                        last4: stripePaymentMethod.card?.last4,
                        brand: stripePaymentMethod.card?.brand,
                        expMonth: stripePaymentMethod.card?.exp_month,
                        expYear: stripePaymentMethod.card?.exp_year,
                        fingerprint: stripePaymentMethod.card?.fingerprint,
                        country: stripePaymentMethod.card?.country
                      }),
                      // Include billing address information from subscription metadata
                      ...billingInfo
                    }
                  );
                  console.log(
                    `[PAYMENT-SUCCESS] Created payment method record: ${paymentMethodRecord.id} with billing info`
                  );
                }
              }
            } catch (paymentMethodError) {
              console.error(
                `[PAYMENT-SUCCESS] Failed to create payment method:`,
                paymentMethodError
              );
            }
            try {
              const paymentHistoryRecord = await storage.createPaymentHistory({
                subscriptionId: subscription.id,
                userId,
                provider: "stripe",
                providerTransactionId: paymentIntent.id,
                amount: paymentIntent.amount,
                currency: paymentIntent.currency.toUpperCase(),
                status: "succeeded",
                paymentMethod: "card",
                metadata: JSON.stringify({
                  paymentIntentId: paymentIntent.id,
                  customerEmail: paymentIntent.metadata?.customer_email,
                  planType: subscription.planType,
                  region: subscription.region,
                  stripePaymentMethodId: paymentIntent.payment_method
                })
              });
              console.log(
                `[PAYMENT-SUCCESS] Created payment history record: ${paymentHistoryRecord.id}`
              );
            } catch (paymentHistoryError) {
              console.error(
                `[PAYMENT-SUCCESS] Failed to create payment history:`,
                paymentHistoryError
              );
            }
            try {
              const subscriptionEvent = await storage.createSubscriptionEvent({
                subscriptionId: subscription.id,
                userId,
                eventType: "payment_succeeded",
                provider: "stripe",
                providerEventId: paymentIntent.id,
                oldStatus: subscription.status,
                newStatus: "active",
                metadata: JSON.stringify({
                  paymentIntentId: paymentIntent.id,
                  amount: paymentIntent.amount,
                  currency: paymentIntent.currency,
                  timestamp: (/* @__PURE__ */ new Date()).toISOString()
                })
              });
              console.log(
                `[PAYMENT-SUCCESS] Created subscription event: ${subscriptionEvent.id}`
              );
            } catch (eventError) {
              console.error(
                `[PAYMENT-SUCCESS] Failed to create subscription event:`,
                eventError
              );
            }
            await storage.updateUserProfile(userId, {
              premiumAccess: true,
              stripeSubscriptionId: currentSubscriptionId || (subscription ? subscription.subscriptionId : null),
              subscriptionStatus: "active",
              subscriptionExpiresAt,
              subscriptionCanceledAt: null
              // Clear any previous cancellation
            });
            console.log(
              `[PAYMENT-SUCCESS] Updated user ${userId} with premium access and subscription data`
            );
            try {
              const user = await storage.getUser(userId);
              if (user && user.email) {
                const { sendPremiumSubscriptionEmail: sendPremiumSubscriptionEmail2 } = await Promise.resolve().then(() => (init_sendgrid(), sendgrid_exports));
                const emailSuccess = await sendPremiumSubscriptionEmail2({
                  name: user.fullName || user.username || "CHARLEY User",
                  email: user.email,
                  planType: subscription.planType,
                  subscriptionId: subscription.subscriptionId,
                  subscriptionExpiresAt: subscriptionExpiresAt || void 0
                });
                if (emailSuccess) {
                  console.log(
                    `[PAYMENT-SUCCESS] Premium welcome email sent to ${user.email}`
                  );
                } else {
                  console.warn(
                    `[PAYMENT-SUCCESS] Failed to send premium welcome email to ${user.email}`
                  );
                }
              } else {
                console.warn(
                  `[PAYMENT-SUCCESS] Cannot send premium email - user not found or no email`
                );
              }
            } catch (emailError) {
              console.error(
                `[PAYMENT-SUCCESS] Error sending premium welcome email:`,
                emailError
              );
            }
            if (subscription.status === "incomplete") {
              await storage.updateSubscription(subscription.id, {
                status: "active"
              });
              console.log(
                `[PAYMENT-SUCCESS] Updated subscription ${subscription.id} status to active`
              );
            }
          } else {
            await storage.updateUserProfile(userId, { premiumAccess: true });
            console.log(
              `[PAYMENT-SUCCESS] Updated user ${userId} premium access to true (no subscription record)`
            );
            try {
              const user = await storage.getUser(userId);
              if (user && user.email) {
                const { sendPremiumSubscriptionEmail: sendPremiumSubscriptionEmail2 } = await Promise.resolve().then(() => (init_sendgrid(), sendgrid_exports));
                const emailSuccess = await sendPremiumSubscriptionEmail2({
                  name: user.fullName || user.username || "CHARLEY User",
                  email: user.email,
                  planType: "premium",
                  // Generic plan type for fallback
                  subscriptionId: paymentIntentId,
                  // Use payment intent as subscription reference
                  subscriptionExpiresAt: void 0
                  // No expiration for fallback case
                });
                if (emailSuccess) {
                  console.log(
                    `[PAYMENT-SUCCESS] Premium welcome email sent to ${user.email} (fallback case)`
                  );
                } else {
                  console.warn(
                    `[PAYMENT-SUCCESS] Failed to send premium welcome email to ${user.email} (fallback case)`
                  );
                }
              } else {
                console.warn(
                  `[PAYMENT-SUCCESS] Cannot send premium email - user not found or no email (fallback case)`
                );
              }
            } catch (emailError) {
              console.error(
                `[PAYMENT-SUCCESS] Error sending premium welcome email (fallback case):`,
                emailError
              );
            }
          }
          res.json({
            success: true,
            paymentIntent
          });
        } else {
          console.log(
            `[PAYMENT-SUCCESS] Payment intent not in succeeded status: ${paymentIntent.status}`
          );
          res.status(400).json({
            success: false,
            error: `Payment verification failed: status is ${paymentIntent.status}`,
            details: {
              paymentIntentId: paymentIntent.id,
              status: paymentIntent.status,
              amount: paymentIntent.amount,
              currency: paymentIntent.currency
            }
          });
        }
      } catch (error) {
        console.error("[STRIPE] Error verifying payment success:", error);
        res.status(500).json({
          success: false,
          error: error.message || "Payment verification failed"
        });
      }
    }
  );
  app2.post(
    "/api/subscription/mobile-money",
    requireAuth,
    async (req, res) => {
      try {
        const { planType, region, phoneNumber, provider } = req.body;
        const userId = req.user.id;
        if (region !== "ghana") {
          return res.status(400).json({
            success: false,
            error: "Mobile money is only available for Ghana region"
          });
        }
        if (!planType || !phoneNumber || !provider) {
          return res.status(400).json({
            success: false,
            error: "Missing required fields for mobile money payment"
          });
        }
        const pricingList = await storage.getRegionalPricing(region, planType);
        const pricing = pricingList[0];
        if (!pricing) {
          return res.status(400).json({
            success: false,
            error: "Invalid plan or region"
          });
        }
        const user = await storage.getUser(userId);
        if (!user) {
          return res.status(404).json({ error: "User not found" });
        }
        const subscription = await storage.createSubscription({
          userId,
          provider: "mobile_money",
          subscriptionId: `mm_${Date.now()}_${userId}`,
          planType,
          status: "pending",
          currentPeriodStart: /* @__PURE__ */ new Date(),
          currentPeriodEnd: new Date(Date.now() + 30 * 24 * 60 * 60 * 1e3),
          cancelAtPeriodEnd: false,
          currency: pricing.currency,
          amount: pricing.amount,
          region,
          paymentMethod: "mobile_money"
        });
        res.json({
          success: true,
          subscription: {
            id: subscription.id,
            planType: subscription.planType,
            status: subscription.status,
            currentPeriodEnd: subscription.currentPeriodEnd
          },
          paymentInstructions: {
            message: `Please dial *170# and follow prompts to pay GHS ${(pricing.amount / 100).toFixed(2)} to complete your CHARLEY Premium subscription.`,
            amount: pricing.amount / 100,
            currency: pricing.currency,
            provider,
            reference: subscription.subscriptionId
          }
        });
      } catch (error) {
        console.error("Error initiating mobile money payment:", error);
        res.status(500).json({
          success: false,
          error: "Failed to initiate mobile money payment"
        });
      }
    }
  );
  app2.get(
    "/api/subscription/status",
    requireAuth,
    async (req, res) => {
      try {
        const userId = req.user.id;
        const subscription = await storage.getSubscriptionByUser(userId);
        if (!subscription) {
          return res.json({
            hasSubscription: false,
            subscription: null
          });
        }
        res.json({
          hasSubscription: true,
          subscription: {
            id: subscription.id,
            planType: subscription.planType,
            status: subscription.status,
            provider: subscription.provider,
            paymentMethod: subscription.paymentMethod,
            currency: subscription.currency,
            amount: subscription.amount,
            region: subscription.region,
            currentPeriodStart: subscription.currentPeriodStart,
            currentPeriodEnd: subscription.currentPeriodEnd,
            cancelAtPeriodEnd: subscription.cancelAtPeriodEnd,
            cancelledAt: subscription.cancelledAt
          }
        });
      } catch (error) {
        console.error("Error fetching subscription status:", error);
        res.status(500).json({
          hasSubscription: false,
          error: "Failed to fetch subscription status"
        });
      }
    }
  );
  app2.post(
    "/api/payment/confirm",
    requireAuth,
    async (req, res) => {
      await confirmPayment(req, res, storage);
    }
  );
  app2.post(
    "/api/subscription/cancel",
    requireAuth,
    async (req, res) => {
      try {
        const userId = req.user.id;
        const subscription = await storage.getSubscriptionByUser(userId);
        if (!subscription) {
          return res.status(404).json({
            success: false,
            error: "No active subscription found"
          });
        }
        if (subscription.provider === "stripe" && stripe2) {
          await stripe2.subscriptions.update(subscription.subscriptionId, {
            cancel_at_period_end: true
          });
        }
        const updatedSubscription = await storage.updateSubscription(
          subscription.id,
          {
            cancelAtPeriodEnd: true,
            cancelledAt: /* @__PURE__ */ new Date()
          }
        );
        res.json({
          success: true,
          subscription: {
            id: updatedSubscription.id,
            status: updatedSubscription.status,
            cancelAtPeriodEnd: updatedSubscription.cancelAtPeriodEnd,
            cancelledAt: updatedSubscription.cancelledAt
          }
        });
      } catch (error) {
        console.error("Error cancelling subscription:", error);
        res.status(500).json({
          success: false,
          error: "Failed to cancel subscription"
        });
      }
    }
  );
  app2.get(
    "/api/subscription/status",
    requireAuth,
    async (req, res) => {
      try {
        const userId = req.user.id;
        const subscription = await storage.getSubscriptionByUser(userId);
        if (!subscription) {
          return res.json({
            hasActiveSubscription: false,
            planType: null,
            currentPeriodEnd: null,
            status: "inactive"
          });
        }
        res.json({
          hasActiveSubscription: subscription.status === "active",
          planType: subscription.planType,
          currentPeriodEnd: subscription.currentPeriodEnd,
          status: subscription.status,
          cancelAtPeriodEnd: subscription.cancelAtPeriodEnd
        });
      } catch (error) {
        console.error("Error getting subscription status:", error);
        res.status(500).json({ message: "Failed to get subscription status" });
      }
    }
  );
  app2.post(
    "/api/subscription/cancel",
    requireAuth,
    async (req, res) => {
      try {
        const userId = req.user.id;
        const subscription = await storage.getSubscriptionByUser(userId);
        if (!subscription) {
          return res.status(404).json({ message: "No active subscription found" });
        }
        if (stripe2) {
          await stripe2.subscriptions.update(subscription.subscriptionId, {
            cancel_at_period_end: true
          });
        }
        await storage.updateSubscription(subscription.id, {
          cancelAtPeriodEnd: true,
          cancelledAt: /* @__PURE__ */ new Date()
        });
        res.json({
          success: true,
          message: "Subscription will be cancelled at the end of the current period"
        });
      } catch (error) {
        console.error("Error cancelling subscription:", error);
        res.status(500).json({ message: "Failed to cancel subscription" });
      }
    }
  );
  app2.post(
    "/api/payment/methods",
    requireAuth,
    async (req, res) => {
      try {
        const userId = req.user.id;
        const {
          paymentMethodId,
          isDefault = false,
          billingName,
          billingEmail,
          billingPhone,
          billingAddress,
          billingCity,
          billingState,
          billingPostalCode,
          billingCountry,
          nickname
        } = req.body;
        if (!stripe2) {
          return res.status(503).json({
            error: "Payment processing is currently unavailable"
          });
        }
        if (!paymentMethodId) {
          return res.status(400).json({
            error: "Payment method ID is required"
          });
        }
        const stripePaymentMethod = await stripe2.paymentMethods.retrieve(paymentMethodId);
        const existingPaymentMethods = await storage.getPaymentMethodsByUser(userId);
        const paymentMethodExists = existingPaymentMethods.some(
          (pm) => pm.externalId === paymentMethodId
        );
        if (paymentMethodExists) {
          return res.status(409).json({
            error: "Payment method already saved"
          });
        }
        if (isDefault) {
          for (const pm of existingPaymentMethods) {
            if (pm.isDefault) {
              await storage.updatePaymentMethod(pm.id, { isDefault: false });
            }
          }
        }
        const paymentMethodRecord = await storage.createPaymentMethod({
          userId,
          provider: "stripe",
          externalId: paymentMethodId,
          type: stripePaymentMethod.type,
          isDefault: isDefault || existingPaymentMethods.length === 0,
          // First becomes default
          metadata: JSON.stringify({
            last4: stripePaymentMethod.card?.last4,
            brand: stripePaymentMethod.card?.brand,
            expMonth: stripePaymentMethod.card?.exp_month,
            expYear: stripePaymentMethod.card?.exp_year,
            fingerprint: stripePaymentMethod.card?.fingerprint,
            country: stripePaymentMethod.card?.country,
            funding: stripePaymentMethod.card?.funding
          }),
          // Billing Address Information
          billingName: billingName || null,
          billingEmail: billingEmail || null,
          billingPhone: billingPhone || null,
          billingAddress: billingAddress || null,
          billingCity: billingCity || null,
          billingState: billingState || null,
          billingPostalCode: billingPostalCode || null,
          billingCountry: billingCountry || null,
          nickname: nickname || null
        });
        console.log(
          `[PAYMENT-METHOD] Saved payment method ${paymentMethodRecord.id} for user ${userId} with billing address`
        );
        res.json({
          success: true,
          paymentMethod: paymentMethodRecord
        });
      } catch (error) {
        console.error("[PAYMENT-METHOD] Error saving payment method:", error);
        res.status(500).json({
          error: "Failed to save payment method"
        });
      }
    }
  );
  app2.post("/api/suite/job/swipe", async (req, res) => {
    if (!req.isAuthenticated()) {
      return res.status(401).json({ message: "Unauthorized" });
    }
    try {
      const { profileId, action } = req.body;
      const currentUserId = req.user.id;
      if (!profileId || !action || !["like", "pass"].includes(action)) {
        return res.status(400).json({ message: "Invalid swipe data" });
      }
      const currentUserJobProfile = await storage.getSuiteJobProfile(currentUserId);
      if (!currentUserJobProfile) {
        return res.status(403).json({
          message: "Profile required",
          action: "create_profile",
          profileType: "jobs"
        });
      }
      const targetProfile = await storage.getSuiteJobProfileById(profileId);
      if (!targetProfile) {
        return res.status(404).json({ message: "Profile not found" });
      }
      const applicationData = {
        userId: currentUserId,
        targetProfileId: profileId,
        targetUserId: targetProfile.userId,
        action,
        applicationStatus: action === "like" ? "pending" : "rejected",
        matched: false
      };
      const existingApplication = await storage.getSuiteJobApplicationByUsers(
        currentUserId,
        targetProfile.userId
      );
      if (existingApplication) {
        return res.status(409).json({ message: "Already acted on this profile" });
      }
      const application = await storage.createSuiteJobApplication(applicationData);
      await storage.addSwipeHistory({
        userId: currentUserId,
        targetUserId: targetProfile.userId,
        action: action === "like" ? "like" : "dislike",
        appMode: "SUITE_JOBS"
      });
      console.log(
        `\u{1F4DD} [SUITE-JOBS-HISTORY] Recorded swipe history for user ${currentUserId} -> ${targetProfile.userId} (${action})`
      );
      let isMatch = false;
      if (action === "like") {
        const currentUserJobProfile2 = await storage.getSuiteJobProfile(currentUserId);
        if (currentUserJobProfile2) {
          const mutualApplication = await storage.getSuiteJobApplicationByUsers(
            targetProfile.userId,
            currentUserId
          );
          if (mutualApplication && mutualApplication.action === "like") {
            await storage.updateSuiteJobApplication(application.id, {
              matched: true,
              applicationStatus: "accepted"
            });
            await storage.updateSuiteJobApplication(mutualApplication.id, {
              matched: true,
              applicationStatus: "accepted"
            });
            const existingMatch = await storage.getMatchBetweenUsers(
              currentUserId,
              targetProfile.userId
            );
            let finalMatch;
            if (existingMatch) {
              let metadata;
              if (!existingMatch.metadata) {
                metadata = {
                  origin: "SUITE",
                  suiteType: "jobs",
                  context: "professional"
                };
              } else {
                try {
                  metadata = typeof existingMatch.metadata === "string" ? JSON.parse(existingMatch.metadata) : existingMatch.metadata;
                  if (metadata.suiteType !== "jobs") {
                    if (!metadata.additionalConnections) {
                      metadata.additionalConnections = [];
                    }
                    if (!metadata.additionalConnections.includes("jobs")) {
                      metadata.additionalConnections.push("jobs");
                      console.log(
                        `\u{1F517} Adding jobs to additionalConnections for existing match ${existingMatch.id}`
                      );
                    }
                  }
                } catch (parseError) {
                  console.error(
                    "Failed to parse existing metadata:",
                    parseError
                  );
                  metadata = {
                    origin: "SUITE",
                    suiteType: "jobs",
                    context: "professional"
                  };
                }
              }
              finalMatch = await storage.updateMatch(existingMatch.id, {
                matched: true,
                metadata: JSON.stringify(metadata)
              });
            } else {
              const matchData = {
                userId1: Math.min(currentUserId, targetProfile.userId),
                userId2: Math.max(currentUserId, targetProfile.userId),
                matched: true,
                isDislike: false,
                metadata: JSON.stringify({
                  origin: "SUITE",
                  suiteType: "jobs",
                  context: "professional"
                })
              };
              finalMatch = await storage.createMatch(matchData);
            }
            isMatch = true;
            console.log(
              `\u{1F49D} [SUITE-JOBS] Match created: ${currentUserId} \u2194 ${targetProfile.userId}`
            );
            try {
              await storage.removeMatchedUsersFromSwipeHistory(
                currentUserId,
                targetProfile.userId
              );
              console.log(
                `[JOBS-MATCH] Cleaned up swipe history for matched users: ${currentUserId} \u2194 ${targetProfile.userId}`
              );
            } catch (historyError) {
              console.error(
                "Error cleaning up jobs swipe history for matched users:",
                historyError
              );
            }
          }
        }
      }
      console.log(
        `\u{1F680} [SUITE-JOBS] User ${currentUserId} ${action}d job profile ${profileId}`
      );
      const sourceUserWs = connectedUsers4.get(currentUserId);
      const targetUserWs = connectedUsers4.get(targetProfile.userId);
      if (sourceUserWs && sourceUserWs.readyState === WebSocket4.OPEN) {
        sourceUserWs.send(
          JSON.stringify({
            type: "suite_remove_from_discover",
            suiteType: "jobs",
            removeProfileId: targetProfile.id,
            removeUserId: targetProfile.userId,
            reason: action,
            timestamp: (/* @__PURE__ */ new Date()).toISOString()
          })
        );
        console.log(
          `[REAL-TIME] Instantly removed jobs profile ${targetProfile.id} from user ${currentUserId}'s discover deck`
        );
      }
      const sourceJobProfile = await storage.getSuiteJobProfile(currentUserId);
      if (sourceJobProfile && targetUserWs && targetUserWs.readyState === WebSocket4.OPEN) {
        targetUserWs.send(
          JSON.stringify({
            type: "suite_remove_from_discover",
            suiteType: "jobs",
            removeProfileId: sourceJobProfile.id,
            removeUserId: currentUserId,
            reason: `received_jobs_${action}`,
            timestamp: (/* @__PURE__ */ new Date()).toISOString()
          })
        );
        console.log(
          `[REAL-TIME] Instantly removed jobs profile ${sourceJobProfile.id} from user ${targetProfile.userId}'s discover deck`
        );
      }
      if (isMatch) {
        [sourceUserWs, targetUserWs].forEach((ws2, index) => {
          if (ws2 && ws2.readyState === WebSocket4.OPEN) {
            ws2.send(
              JSON.stringify({
                type: "suite_connections_refresh",
                suiteType: "jobs",
                reason: "new_match",
                timestamp: (/* @__PURE__ */ new Date()).toISOString()
              })
            );
          }
        });
        console.log(
          `[CONNECTIONS-REFRESH] Sent connections refresh for new job match`
        );
      }
      res.json({
        success: true,
        action,
        profileId,
        isMatch,
        message: action === "like" ? isMatch ? "It's a match!" : "Application sent" : "Profile passed"
      });
    } catch (error) {
      console.error("Error processing job swipe:", error);
      res.status(500).json({ message: "Failed to process swipe action" });
    }
  });
  app2.get(
    "/api/payment/methods",
    requireAuth,
    async (req, res) => {
      try {
        const userId = req.user.id;
        const paymentMethods3 = await storage.getPaymentMethodsByUser(userId);
        res.json(paymentMethods3);
      } catch (error) {
        console.error(
          "[PAYMENT-METHOD] Error retrieving payment methods:",
          error
        );
        res.status(500).json({
          error: "Failed to retrieve payment methods"
        });
      }
    }
  );
  app2.delete(
    "/api/payment/methods/:id",
    requireAuth,
    async (req, res) => {
      try {
        const userId = req.user.id;
        const paymentMethodId = parseInt(req.params.id);
        const paymentMethod = await storage.getPaymentMethodById(paymentMethodId);
        if (!paymentMethod || paymentMethod.userId !== userId) {
          return res.status(404).json({
            error: "Payment method not found"
          });
        }
        await storage.deletePaymentMethod(paymentMethodId);
        console.log(
          `[PAYMENT-METHOD] Deleted payment method ${paymentMethodId} for user ${userId}`
        );
        res.json({
          success: true
        });
      } catch (error) {
        console.error("[PAYMENT-METHOD] Error deleting payment method:", error);
        res.status(500).json({
          error: "Failed to delete payment method"
        });
      }
    }
  );
  app2.get("/api/places/autocomplete", async (req, res) => {
    try {
      const { query } = req.query;
      if (!query || typeof query !== "string") {
        return res.status(400).json({
          error: "Query parameter is required"
        });
      }
      const apiKey = process.env.GOOGLE_PLACES_API_KEY || process.env.VITE_GOOGLE_PLACES_API_KEY;
      if (!apiKey) {
        console.warn("[GOOGLE-PLACES] API key not available");
        return res.status(500).json({
          error: "Google Places API not configured"
        });
      }
      const googleResponse = await fetch(
        `https://maps.googleapis.com/maps/api/place/autocomplete/json?input=${encodeURIComponent(query)}&types=(cities)&key=${apiKey}`,
        {
          method: "GET",
          headers: {
            Accept: "application/json"
          }
        }
      );
      if (!googleResponse.ok) {
        throw new Error(`Google Places API error: ${googleResponse.status}`);
      }
      const data = await googleResponse.json();
      if (data.status === "OK" && data.predictions) {
        console.log(
          `[GOOGLE-PLACES] Found ${data.predictions.length} suggestions for "${query}"`
        );
        res.json({
          predictions: data.predictions.slice(0, 5),
          // Limit to 5 suggestions
          status: "OK"
        });
      } else {
        console.log(
          `[GOOGLE-PLACES] No results found for "${query}", status: ${data.status}`
        );
        res.json({
          predictions: [],
          status: data.status || "NO_RESULTS"
        });
      }
    } catch (error) {
      console.error("[GOOGLE-PLACES] Error:", error);
      res.status(500).json({
        error: "Failed to search locations",
        details: error instanceof Error ? error.message : "Unknown error"
      });
    }
  });
  app2.get(
    "/api/professional-reviews/:userId",
    async (req, res) => {
      try {
        if (!req.isAuthenticated()) {
          return res.status(401).json({ message: "Unauthorized" });
        }
        const userId = parseInt(req.params.userId);
        const reviews = await storage.getProfessionalReviewsForUser(userId);
        const stats = await storage.getProfessionalReviewStats(userId);
        res.json({
          reviews,
          stats,
          success: true
        });
      } catch (error) {
        console.error("Error fetching professional reviews:", error);
        res.status(500).json({ message: "Internal server error" });
      }
    }
  );
  app2.post("/api/professional-reviews", async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      const { reviewedUserId, rating, reviewText, isAnonymous, category } = req.body;
      const reviewerUserId = req.user.id;
      if (!reviewedUserId || !rating || !reviewText) {
        return res.status(400).json({ message: "Missing required fields" });
      }
      if (rating < 1 || rating > 5) {
        return res.status(400).json({ message: "Rating must be between 1 and 5" });
      }
      if (reviewedUserId === reviewerUserId) {
        return res.status(400).json({ message: "Cannot review yourself" });
      }
      const existingReview = await storage.getExistingReview(
        reviewedUserId,
        reviewerUserId,
        category || "overall"
      );
      if (existingReview) {
        const updatedReview = await storage.updateProfessionalReview(
          existingReview.id,
          {
            rating,
            reviewText,
            isAnonymous: isAnonymous || false
          }
        );
        res.json({ review: updatedReview, success: true });
      } else {
        const newReview = await storage.createProfessionalReview({
          reviewedUserId,
          reviewerUserId,
          rating,
          reviewText,
          isAnonymous: isAnonymous || false,
          category: category || "overall"
        });
        res.json({ review: newReview, success: true });
      }
    } catch (error) {
      console.error("Error creating/updating professional review:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });
  app2.get(
    "/api/professional-reviews/:reviewedUserId/user/:reviewerUserId",
    async (req, res) => {
      try {
        if (!req.isAuthenticated()) {
          return res.status(401).json({ message: "Unauthorized" });
        }
        const reviewedUserId = parseInt(req.params.reviewedUserId);
        const reviewerUserId = parseInt(req.params.reviewerUserId);
        const category = req.query.category || "overall";
        const existingReview = await storage.getExistingReview(
          reviewedUserId,
          reviewerUserId,
          category
        );
        res.json({
          review: existingReview || null,
          success: true
        });
      } catch (error) {
        console.error("Error fetching existing review:", error);
        res.status(500).json({ message: "Internal server error" });
      }
    }
  );
  app2.delete(
    "/api/professional-reviews/:reviewId",
    async (req, res) => {
      try {
        if (!req.isAuthenticated()) {
          return res.status(401).json({ message: "Unauthorized" });
        }
        const reviewId = parseInt(req.params.reviewId);
        const userId = req.user.id;
        const deleted = await storage.deleteProfessionalReview(
          reviewId,
          userId
        );
        if (deleted) {
          res.json({
            success: true,
            message: "Review deleted successfully"
          });
        } else {
          res.status(404).json({
            success: false,
            message: "Review not found or you don't have permission to delete it"
          });
        }
      } catch (error) {
        console.error("Error deleting professional review:", error);
        res.status(500).json({ message: "Internal server error" });
      }
    }
  );
  const { getHomePageData: getHomePageData2, getSuitePageData: getSuitePageData2 } = await Promise.resolve().then(() => (init_unified_api(), unified_api_exports));
  app2.get("/api/home-page-data", requireAuth, getHomePageData2);
  app2.get("/api/suite-page-data", requireAuth, getSuitePageData2);
  app2.use("/api/highschool", highschool_search_default);
  app2.get("/api/university/search", searchUniversities);
  return httpServer;
}

// server/godmodel-api.ts
init_db();
import fs3 from "fs";
import path3 from "path";
import { fileURLToPath } from "url";
import { sql as sql6 } from "drizzle-orm";
function loadStatements() {
  try {
    const __filename3 = fileURLToPath(import.meta.url);
    const __dirname3 = path3.dirname(__filename3);
    const filePath = path3.resolve(
      __dirname3,
      "..",
      "client",
      "public",
      "personality_statements.txt"
    );
    const raw = fs3.readFileSync(filePath, "utf-8");
    const lines = raw.split(/\r?\n/).map((l) => l.trim()).filter((l) => l.length > 0);
    return lines.slice(0, 100);
  } catch (e) {
    console.error("[GODMODEL] Failed to load statements:", e);
    return [];
  }
}
function registerGodmodelAPI(app2) {
  const statements = loadStatements();
  app2.get("/api/godmodel/statements", (_req, res) => {
    res.json({ count: statements.length, statements });
  });
  app2.get("/api/godmodel/progress", async (req, res) => {
    if (!req.isAuthenticated()) {
      return res.status(401).json({ error: "Authentication required" });
    }
    const userId = req.user?.id;
    try {
      const result = await db.execute(
        sql6`SELECT personality_records FROM users WHERE id = ${userId} LIMIT 1;`
      );
      const value = result?.rows?.[0]?.personality_records || null;
      res.json({ records: value ? JSON.parse(value) : null });
    } catch (e) {
      console.error("[GODMODEL] Failed to get progress:", e);
      res.status(500).json({ error: "Failed to get progress" });
    }
  });
  app2.post("/api/godmodel/progress", async (req, res) => {
    if (!req.isAuthenticated()) {
      return res.status(401).json({ error: "Authentication required" });
    }
    const userId = req.user?.id;
    const { progress } = req.body || {};
    try {
      await db.execute(
        sql6`UPDATE users SET personality_records = ${JSON.stringify(progress)} WHERE id = ${userId};`
      );
      res.json({ success: true });
    } catch (e) {
      console.error("[GODMODEL] Failed to save progress:", e);
      res.status(500).json({ error: "Failed to save progress" });
    }
  });
  app2.post("/api/godmodel/complete", async (req, res) => {
    if (!req.isAuthenticated()) {
      return res.status(401).json({ error: "Authentication required" });
    }
    const userId = req.user?.id;
    const { final } = req.body || {};
    console.log(`[GODMODEL] Completing test for user ${userId}:`, final);
    try {
      const finalData = JSON.stringify(final);
      console.log(
        `[GODMODEL] Saving personality records to database for user ${userId}`
      );
      await db.execute(sql6`
        UPDATE users 
        SET personality_records = ${finalData}, 
            personality_test_completed = TRUE 
        WHERE id = ${userId};
      `);
      console.log(
        `[GODMODEL] \u2705 Successfully saved personality records and marked test as completed for user ${userId}`
      );
      try {
        console.log(`[GODMODEL-BIG5] Computing Big 5 scores for user ${userId}...`);
        const responses = final.responses || [];
        const big5Responses = responses.map((response) => {
          const answerMap = {
            "Strongly Disagree": "StronglyDisagree",
            "Disagree": "Disagree",
            "Neutral": "Neutral",
            "Agree": "Agree",
            "Strongly Agree": "StronglyAgree"
          };
          return answerMap[response.answer] || "Neutral";
        });
        if (big5Responses.length !== 100) {
          console.warn(`[GODMODEL-BIG5] Expected 100 responses, got ${big5Responses.length}. Padding with neutral responses.`);
          while (big5Responses.length < 100) {
            big5Responses.push("Neutral");
          }
        }
        console.log(`[GODMODEL-BIG5] Sample mapped responses:`, big5Responses.slice(0, 5));
        console.log(`[GODMODEL-BIG5] Total responses for Big 5:`, big5Responses.length);
        const big5Profile = big5ScoringService.generateBig5Profile(big5Responses);
        await db.execute(sql6`
          UPDATE users 
          SET big5_profile = ${JSON.stringify(big5Profile)},
              big5_computed_at = ${/* @__PURE__ */ new Date()},
              personality_model_version = 'v1.0'
          WHERE id = ${userId};
        `);
        console.log(`[GODMODEL-BIG5] \u2705 Successfully computed and saved Big 5 profile for user ${userId}`);
      } catch (big5Error) {
        console.error(`[GODMODEL-BIG5] Failed to compute Big 5 scores for user ${userId}:`, big5Error);
      }
      res.json({ success: true });
    } catch (e) {
      console.error("[GODMODEL] Failed to complete test:", e);
      res.status(500).json({ error: "Failed to complete test" });
    }
  });
}

// server/vite.ts
import express from "express";
import fs4 from "fs";
import path5, { dirname as dirname2 } from "path";
import { fileURLToPath as fileURLToPath3 } from "url";
import { createServer as createViteServer, createLogger } from "vite";

// vite.config.ts
import { defineConfig } from "vite";
import react from "@vitejs/plugin-react";
import themePlugin from "@replit/vite-plugin-shadcn-theme-json";
import path4, { dirname } from "path";
import runtimeErrorOverlay from "@replit/vite-plugin-runtime-error-modal";
import { fileURLToPath as fileURLToPath2 } from "url";
var __filename = fileURLToPath2(import.meta.url);
var __dirname = dirname(__filename);
var vite_config_default = defineConfig({
  plugins: [
    react(),
    runtimeErrorOverlay(),
    themePlugin(),
    ...process.env.NODE_ENV !== "production" && process.env.REPL_ID !== void 0 ? [
      await import("@replit/vite-plugin-cartographer").then(
        (m) => m.cartographer()
      )
    ] : []
  ],
  resolve: {
    alias: {
      "@": path4.resolve(__dirname, "client", "src"),
      "@shared": path4.resolve(__dirname, "shared"),
      "@assets": path4.resolve(__dirname, "attached_assets")
    }
  },
  root: path4.resolve(__dirname, "client"),
  build: {
    outDir: path4.resolve(__dirname, "dist/public"),
    emptyOutDir: true
  }
});

// server/vite.ts
import { nanoid } from "nanoid";
var __filename2 = fileURLToPath3(import.meta.url);
var __dirname2 = dirname2(__filename2);
var viteLogger = createLogger();
function log(message, source = "express") {
  const formattedTime = (/* @__PURE__ */ new Date()).toLocaleTimeString("en-US", {
    hour: "numeric",
    minute: "2-digit",
    second: "2-digit",
    hour12: true
  });
  console.log(`${formattedTime} [${source}] ${message}`);
}
async function setupVite(app2, server) {
  const serverOptions = {
    middlewareMode: true,
    hmr: { server },
    allowedHosts: true
  };
  const vite = await createViteServer({
    ...vite_config_default,
    configFile: false,
    customLogger: {
      ...viteLogger,
      error: (msg, options) => {
        viteLogger.error(msg, options);
        process.exit(1);
      }
    },
    server: serverOptions,
    appType: "custom"
  });
  app2.use((req, res, next) => {
    const url = req.originalUrl;
    if (url.startsWith("/api") || url.startsWith("/ws")) {
      return next();
    }
    return vite.middlewares(req, res, next);
  });
  app2.use("*", async (req, res, next) => {
    const url = req.originalUrl;
    if (url.startsWith("/api") || url.startsWith("/ws")) {
      return next();
    }
    try {
      const clientTemplate = path5.resolve(
        __dirname2,
        "..",
        "client",
        "index.html"
      );
      let template = await fs4.promises.readFile(clientTemplate, "utf-8");
      template = template.replace(
        `src="/src/main.tsx"`,
        `src="/src/main.tsx?v=${nanoid()}"`
      );
      const page = await vite.transformIndexHtml(url, template);
      res.status(200).set({ "Content-Type": "text/html" }).end(page);
    } catch (e) {
      vite.ssrFixStacktrace(e);
      next(e);
    }
  });
}
function serveStatic(app2) {
  const distPath = path5.resolve(__dirname2, "public");
  if (!fs4.existsSync(distPath)) {
    throw new Error(
      `Could not find the build directory: ${distPath}, make sure to build the client first`
    );
  }
  app2.use(express.static(distPath));
  app2.use("*", (_req, res) => {
    res.sendFile(path5.resolve(distPath, "index.html"));
  });
}

// server/index.ts
import dotenv3 from "dotenv";
dotenv3.config();
var app = express2();
app.use(express2.json({ limit: "10gb" }));
app.use(express2.urlencoded({ extended: false, limit: "10gb" }));
app.use((req, res, next) => {
  const start = Date.now();
  const path6 = req.path;
  let capturedJsonResponse = void 0;
  const originalResJson = res.json;
  res.json = function(bodyJson, ...args) {
    capturedJsonResponse = bodyJson;
    return originalResJson.apply(res, [bodyJson, ...args]);
  };
  res.on("finish", () => {
    const duration = Date.now() - start;
    if (path6.startsWith("/api")) {
      let logLine = `${req.method} ${path6} ${res.statusCode} in ${duration}ms`;
      if (capturedJsonResponse) {
        logLine += ` :: ${JSON.stringify(capturedJsonResponse)}`;
      }
      if (logLine.length > 80) {
        logLine = logLine.slice(0, 79) + "\u2026";
      }
      log(logLine);
    }
  });
  next();
});
(async () => {
  try {
    console.log("[SERVER-DEBUG] Starting server initialization...");
    console.log("[SERVER-DEBUG] Environment check:");
    console.log("  - DATABASE_URL:", process.env.DATABASE_URL ? "\u2713 Present" : "\u2717 Missing");
    console.log("  - SENDGRID_API_KEY:", process.env.SENDGRID_API_KEY ? `\u2713 Present (starts with: ${process.env.SENDGRID_API_KEY.substring(0, 3)})` : "\u2717 Missing");
    console.log("  - STRIPE_SECRET_KEY:", process.env.STRIPE_SECRET_KEY ? "\u2713 Present" : "\u2717 Missing");
    console.log("[SERVER-DEBUG] Registering main routes...");
    const server = await registerRoutes(app);
    console.log("[SERVER-DEBUG] Main routes registered successfully");
    console.log("[SERVER-DEBUG] Registering Godmodel API endpoints...");
    registerGodmodelAPI(app);
    console.log("[SERVER-DEBUG] Godmodel API registered successfully");
    app.use((err, _req, res, _next) => {
      const status = err.status || err.statusCode || 500;
      const message = err.message || "Internal Server Error";
      res.status(status).json({ message });
      throw err;
    });
    const isProduction = process.env.REPLIT_DEPLOYMENT === "1" || process.env.NODE_ENV === "production";
    if (isProduction) {
      console.log("[SERVER] Running in production mode - serving static files");
      console.log("[SERVER] API routes should be registered before static serving");
      serveStatic(app);
    } else {
      console.log("[SERVER] Running in development mode - using Vite middleware");
      await setupVite(app, server);
    }
    console.log("[SERVER-DEBUG] Starting server...");
    startServer(server, () => {
      console.log("[SERVER-DEBUG] Server startup callback executed");
      log("Server started successfully");
    });
  } catch (error) {
    console.error("[SERVER-DEBUG] Fatal error during server initialization:");
    console.error(error);
    process.exit(1);
  }
})();
function startServer(server, callback) {
  let port = parseInt(process.env.PORT || "5000");
  const host = "0.0.0.0";
  const maxAttempts = 10;
  let attempts = 0;
  function tryPort(currentPort) {
    if (attempts >= maxAttempts) {
      log(`Failed to find available port after ${maxAttempts} attempts`);
      process.exit(1);
      return;
    }
    attempts++;
    server.listen(currentPort, host, () => {
      log(`Server listening at http://${host}:${currentPort}`);
      if (callback) callback();
    }).on("error", (err) => {
      if (err.message.includes("EADDRINUSE")) {
        log(
          `Port ${currentPort} is in use, trying port ${currentPort + 1}...`
        );
        server.close(() => {
          tryPort(currentPort + 1);
        });
      } else {
        log(`Failed to start server: ${err.message}`);
        process.exit(1);
      }
    });
  }
  tryPort(port);
}
